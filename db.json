{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123095924037-1618037447.png","path":"images/1309909-20180123095924037-1618037447.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123095955350-1680422636.png","path":"images/1309909-20180123095955350-1680422636.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123101901740-2118178734.png","path":"images/1309909-20180123101901740-2118178734.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123110136115-1112016464.png","path":"images/1309909-20180123110136115-1112016464.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123110156272-1242463729.png","path":"images/1309909-20180123110156272-1242463729.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/Challestend.png","path":"images/Challestend.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123110209772-2057141058.png","path":"images/1309909-20180123110209772-2057141058.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/TIM图片20181023195537.jpg","path":"images/TIM图片20181023195537.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/TIM图片20181209192946.jpg","path":"images/TIM图片20181209192946.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/1309909-20180123110213709-49169640.png","path":"images/1309909-20180123110213709-49169640.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/TIM图片20190103092627.png","path":"images/TIM图片20190103092627.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/TIM截图20190214152934.png","path":"images/TIM截图20190214152934.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/图片1.png","path":"images/图片1.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/图片2.png","path":"images/图片2.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/TIM截图20190116111347.png","path":"images/TIM截图20190116111347.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/TIM截图20190215193107.png","path":"images/TIM截图20190215193107.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/图片3.png","path":"images/图片3.png","modified":1,"renderable":1},{"_id":"themes/next/source/fonts/ArimaMadurai-Light.ttf","path":"fonts/ArimaMadurai-Light.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"e91ccc2a50435ccc7ffc974659743c95de3131b1","modified":1550016988185},{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1550016988185},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1550016988185},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1550016988185},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1550016988185},{"_id":"themes/next/.gitignore","hash":"0378adb9c2dc4855b3198184df4863cb30e4059c","modified":1550016988185},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1550016988185},{"_id":"themes/next/.travis.yml","hash":"fb9ac54e875f6ea16d5c83db497f6bd70ae83198","modified":1550016988185},{"_id":"themes/next/README.md","hash":"460ef40953c2eccea4f87bc67043aac2eb87b1a9","modified":1550016988185},{"_id":"themes/next/LICENSE.md","hash":"f0190c7d83a98464549a6b3a51bb206148d88e1b","modified":1550016988185},{"_id":"themes/next/bower.json","hash":"960159e57be380d14aef75360412575cd8cb938f","modified":1550016988185},{"_id":"themes/next/_config.yml","hash":"177cb1dda90c1d2c15918e0ebf90742749e1a18d","modified":1550016988185},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1550016988185},{"_id":"themes/next/gulpfile.coffee","hash":"67eaf2515100971f6195b60eeebbfe5e8de895ab","modified":1550016988201},{"_id":"themes/next/package.json","hash":"d74dc584653e0bfab272de5d284d4be8a30c8e48","modified":1550016988217},{"_id":"source/about/index.md","hash":"220508533eaefef47c9df7762e07b62af3cd34e3","modified":1550016988185},{"_id":"source/_posts/0000-00-00-announcement.md","hash":"4c82213cebd110c04ae11aab65d07186d3cd553e","modified":1550016988185},{"_id":"source/_posts/2018-09-27-luogu-t47720-solution.md","hash":"5f716215ce82c57a65c9a98b65aea3e808138fd8","modified":1550016988185},{"_id":"source/_posts/2018-09-29-luogu-p3924-solution.md","hash":"a682285cddd42187942514510d03ebb918fe4efe","modified":1550016988185},{"_id":"source/_posts/2018-10-04-luogu-p4900-solution.md","hash":"0b2dbcd331f46c3c60be3383f03a880d046625a4","modified":1550016988185},{"_id":"source/_posts/2018-10-12-luogu-p2154-solution.md","hash":"45ff86c4f039067cca16b60184206cd2645d08eb","modified":1550016988185},{"_id":"source/_posts/2018-10-13-chtholly-tree-learning-notes.md","hash":"b4fdc92e1202c00b5e3a0a1719d7bb57bead7222","modified":1550016988185},{"_id":"source/_posts/2018-09-27-hello-world.md","hash":"81b6e3f4e06b7c30c06f958546aa4c6edceaa29e","modified":1550016988185},{"_id":"source/_posts/2018-10-24-status-compression-learning-notes.md","hash":"445e8cfb1a1e134cc378c5d3c8bd5c9162d1b577","modified":1550016988185},{"_id":"source/_posts/2018-11-08-luogu-p5009-solution.md","hash":"2446f3b13de782fd0923b50040ba5029c691f192","modified":1550016988185},{"_id":"source/_posts/2018-11-09-noip-2018-notes.md","hash":"b7c4bd5121883fefc6a7746b9f7ca03b145ab624","modified":1550016988185},{"_id":"source/_posts/2018-11-29-number-theory-learning-notes.md","hash":"8b7dfcb54f3ad7f7ee64b54e58c4b934273850bb","modified":1550016988185},{"_id":"source/_posts/2018-12-19-polynomial-learning-notes-pt1.md","hash":"3012ecb4ba8e3b1947baa166e4392c6f5a949dae","modified":1550016988185},{"_id":"source/_posts/2018-12-08-future-algorithm-ep1.md","hash":"acf81024ed8995cb882ccd6fae2272eaf9753469","modified":1550016988185},{"_id":"source/_posts/2018-12-19-sqrt-decomposition-complexity-optimization.md","hash":"a9df1d970c089a9c5a88ea20dc058e7b3a8b482f","modified":1550016988185},{"_id":"source/_posts/2018-12-20-polynomial-learning-notes-pt2.md","hash":"adc4d68bfd5fecd30e224b3d5c9b219cc48c320f","modified":1550016988185},{"_id":"source/_posts/2018-12-24-block-decomposition.md","hash":"f0cd05d2697db56cc7137f9ef37ffa8fb3879219","modified":1550016988185},{"_id":"source/_posts/2018-12-26-timuzu-solutions.md","hash":"421821b533d4a2cf553b721f894190609011dd9a","modified":1550016988185},{"_id":"source/_posts/2019-01-02-luogu-p5162-solution.md","hash":"c002d1e7d23e8891d39410f97a6a639ef2782abc","modified":1550016988185},{"_id":"source/_posts/2019-01-07-luogu-p4113-solution.md","hash":"d57f8cffa253488c1ede9affb00804c1116eb97a","modified":1550016988185},{"_id":"source/_posts/2019-01-10-similar-euclid-algorithm-learning-notes.md","hash":"bdae6b46c48961d01b2c583d831a3dc480ada1f3","modified":1550016988185},{"_id":"source/_posts/2019-01-14-something-about-network-flow-learning-notes.md","hash":"b9712af0962d59ba95ec90a32c0575b3e77297a1","modified":1550016988185},{"_id":"source/_posts/2019-01-04-luogu-p3723-solution.md","hash":"a318e9a875b9bb7446ea802603cf9e8b7464299a","modified":1550016988185},{"_id":"source/_posts/2019-01-17-luogu-p4091-solution.md","hash":"030b6a57e09fc34dbb9ce1c77ddd83697d05bc9a","modified":1550016988185},{"_id":"source/_posts/2019-01-20-lolioi-2019-01-20-solutions.md","hash":"54083069b3a44873e94bfce1f8a37d3dfa8b40c2","modified":1550016988185},{"_id":"source/_posts/2019-01-21-link-cut-tree-learning-notes.md","hash":"135922fdbc9fd252cfe3c637c17606aa42221d5e","modified":1550016988185},{"_id":"source/_posts/2019-02-13-min-25-sieve-learning-notes.md","hash":"053f0a74cec8b873ffc22d24157a7c2c0641bfee","modified":1550222355606},{"_id":"source/_posts/2019-02-15-luogu-p3613-solution.md","hash":"80360c64b5b4d7d4e6e12ee2e1ae1f4658a214c5","modified":1550232498442},{"_id":"source/categories/index.md","hash":"f563bb5f33c2269565e0a9b06f5d693918b721cb","modified":1550016988185},{"_id":"source/tags/index.md","hash":"619f4f22b5e5ae130f1da4e2e81dcc41287ab140","modified":1550016988185},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"40b0fd9fdb8586fab98e23f713940e7a2f80e2f9","modified":1550016988185},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"1e212fe229bd659726b4a3bcf4b5b14e0310ba3a","modified":1550016988185},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"36201119490a04107c8179b10202548a9d0e5e60","modified":1550016988185},{"_id":"themes/next/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1550016988185},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1550016988185},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1550016988185},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"1dada3c3404445a00367882b8f97cdf092b7943d","modified":1550016988185},{"_id":"themes/next/docs/AUTHORS.md","hash":"51a0a13da55ff3d596970b2f9ab4531c6b2211f2","modified":1550016988185},{"_id":"themes/next/docs/DATA-FILES.md","hash":"9a1895c0a0db705c4c48f512e86917f9af1ec3fb","modified":1550016988185},{"_id":"themes/next/docs/INSTALLATION.md","hash":"b74ef6fedf76cdb156e2265759ee0a789ddd49cc","modified":1550016988185},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"f2fd611a84dd6f9ed5395b63e187e29e9effbcd3","modified":1550016988185},{"_id":"themes/next/docs/LICENSE","hash":"5b702310012d480b40529fd10cf1872f687277a0","modified":1550016988185},{"_id":"themes/next/docs/MATH.md","hash":"34a46ca9a05b4570903beaadd4807e6759afb52e","modified":1550016988185},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"c9f2ed8e15c137b1885d9ca8b7197d9f457971e9","modified":1550016988185},{"_id":"themes/next/languages/de.yml","hash":"641e49587d41bb87e4d5932dc3d975754ded7953","modified":1550016988201},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1550016988201},{"_id":"themes/next/languages/en.yml","hash":"d66b8b48840443a4f9c72c7696a21e292f685a47","modified":1550016988201},{"_id":"themes/next/languages/it.yml","hash":"4e3adeb10c0fa627935d69ae1783ce0894f5dee5","modified":1550016988201},{"_id":"themes/next/languages/fr.yml","hash":"ebcd1f188af8c3f5ef1f0923e794c839fbfae2d4","modified":1550016988201},{"_id":"themes/next/languages/ko.yml","hash":"33e065ceb21590b8eb32430a69e76c2f057eb758","modified":1550016988201},{"_id":"themes/next/languages/ja.yml","hash":"82afb0a5637ad67065fa5b2624fa56c7c240c3c6","modified":1550016988201},{"_id":"themes/next/languages/nl.yml","hash":"060efc260c1c529469d739d97dcee79683e8f411","modified":1550016988201},{"_id":"themes/next/languages/pt-BR.yml","hash":"dc09e290e908744ca28e093dbdd859ca2a20290e","modified":1550016988201},{"_id":"themes/next/languages/pt.yml","hash":"53e2a52b9d5dc20c04080acd4f5b954e8699780f","modified":1550016988201},{"_id":"themes/next/languages/ru.yml","hash":"720b92a9ec075b68737d296b1f29ad8e01151c85","modified":1550016988201},{"_id":"themes/next/languages/tr.yml","hash":"6d2f53d3687a7a46c67c78ab47908accd8812add","modified":1550016988201},{"_id":"themes/next/languages/vi.yml","hash":"e2b3b18359ab41d58c64b2002acfedd60a7505a4","modified":1550016988201},{"_id":"themes/next/languages/zh-CN.yml","hash":"04f9376ba50e23eb08f30d6fbd98ad62dcc04fad","modified":1550016988201},{"_id":"themes/next/languages/zh-HK.yml","hash":"c22113c4a6c748c18093dae56da5a9e8c5b963cd","modified":1550016988201},{"_id":"themes/next/languages/zh-TW.yml","hash":"dbf4dd87716babb2db4f5332fae9ec190a6f636a","modified":1550016988201},{"_id":"themes/next/layout/_layout.swig","hash":"41ab1ee113e1a3ddb2aff0014445fcecb1d59c9c","modified":1550016988201},{"_id":"themes/next/layout/archive.swig","hash":"4b53070008775ecfd03953bd1b4adfcb0fabcaac","modified":1550016988217},{"_id":"themes/next/layout/index.swig","hash":"bdcc9f57adef49706b16b107791cacecbc23c1dc","modified":1550016988217},{"_id":"themes/next/layout/category.swig","hash":"f0e3338bfa5efb205d2c28e635e9611f1fff3b55","modified":1550016988217},{"_id":"themes/next/layout/page.swig","hash":"9ddf40303f82e3db76d59dc82b6d4eadfed203c6","modified":1550016988217},{"_id":"themes/next/layout/post.swig","hash":"0554f42f90f4a524666c2b520be30b689c1d6a87","modified":1550016988217},{"_id":"themes/next/layout/tag.swig","hash":"7cda2822e50b9fee9848a6b81e6c2d1aca830aeb","modified":1550016988217},{"_id":"themes/next/layout/schedule.swig","hash":"d99b9eff0cff38caf095445f27c08aaf11a5b862","modified":1550016988217},{"_id":"themes/next/scripts/fold.js","hash":"d8d2e96221479673c1e71d41d8f4b25335b01bcc","modified":1550016988217},{"_id":"themes/next/languages/id.yml","hash":"9709a4dbacc56a1571a96b139b872128d6959e90","modified":1550016988201},{"_id":"themes/next/scripts/helpers.js","hash":"7849f9b9a86fc82d6e186e32a5e26e1f27c49b47","modified":1550016988217},{"_id":"themes/next/scripts/merge-configs.js","hash":"5f96f63e86825fd7028c2522e4111103e261a758","modified":1550016988217},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1550016988217},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"22f2ccc5522563b67c8663849fc1d6cbae93a8ff","modified":1550016988185},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1550016988263},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1550016988263},{"_id":"themes/next/scripts/tags.js","hash":"7365718e38783421691ea107f525f247bf764b27","modified":1550016988217},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1550016988263},{"_id":"source/log/index.md","hash":"3d56d9587c9fc24ca75ecf5c7691f91772ab36d9","modified":1550016988185},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988248},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"7b2963daac19b0c14f98ebef375d5fbce8fc3f44","modified":1550016988201},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"a51de08657f5946f4028b11373280ddc04639525","modified":1550016988185},{"_id":"themes/next/docs/ru/README.md","hash":"caaad965f9d54f82382c934f44a507d37a863fa3","modified":1550016988201},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"1a4e41adcf5831057f3f7b3025ed4a5ef7c442b4","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"e771c5b745608c6fb5ae2fa1c06c61b3699627ec","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"9b512cb820627fcc45c9f77c7a122aa99e021bd5","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"6ea741f380dc3e90661d12db7e115a94b77643a4","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"baca12cc24be082f1db28c7f283493569666321c","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"67f4a987e7db0ab1ce1ea4c311f2961df07b6681","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"4d68054b062b3c8404b146a155d9624d2d25dd9b","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"7214fcd1b5830e62b3ac0836ad2d1b0fa391ae12","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/README.md","hash":"0e6652be1b6bca87479f2601ff89105def200b4c","modified":1550016988201},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"2095d1214a4e519a1d31b67b41c89080fa3285d3","modified":1550016988201},{"_id":"themes/next/layout/_custom/head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1550016988201},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1550016988201},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1550016988201},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1550016988201},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"8ff97c3f4eb888207bdc50066053c97d890e0202","modified":1550016988201},{"_id":"themes/next/layout/_macro/post.swig","hash":"1d2ac8fa186bd412dc3d0ed2d9f6d77aabbc09e1","modified":1550016988201},{"_id":"themes/next/layout/_macro/post-related.swig","hash":"e8dfb86eb62b9c2bc1435d6d1afa95d3b4c7b931","modified":1550016988201},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56733f92352b891b0bb1baca293f68f6c8928b0b","modified":1550016988201},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"0c8fa20e669ff206b1a405f6897b9c0e527e4d3c","modified":1550016988201},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"7a9b687087793bf5e218cbc345214f927fa5601a","modified":1550016988201},{"_id":"themes/next/layout/_partials/comments.swig","hash":"412d2a0e18a237e490e1b8bce5547558768b9da3","modified":1550016988201},{"_id":"themes/next/layout/_partials/breadcrumb.swig","hash":"4b48fdbfe3bf41ddeda4ff74c1ff17ab9f15c14e","modified":1550016988201},{"_id":"themes/next/layout/_partials/footer.swig","hash":"1e4604b62c62bcaaff39e4546acd03e4538d5464","modified":1550016988201},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"914155d5d758306cff405beefd4a07973fd8fc77","modified":1550016988201},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"206cbd6ac9ca6a219a8516f59beae25b3c770199","modified":1550016988201},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"27fb1d81151b9b79683e488579df19eee7e654d6","modified":1550016988201},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"f8c7e729ad6e72b4c705a2c5d5041589c2b4cc52","modified":1550016988201},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"f544e21883d249d5a341c684c97bd25831008f07","modified":1550016988201},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"f134aeb8d5bee351e5277edb92ac694af314b75f","modified":1550016988217},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"ed62ea83d3f2c9db2ea57bf23a7d765ed82504c2","modified":1550016988217},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"c62c37474c8de78cf34e54c6219b503ec28d9815","modified":1550016988217},{"_id":"themes/next/layout/_third-party/github-banner.swig","hash":"736cb278fa09d3b4ed6f305b56353941ea918793","modified":1550016988217},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"53861f78a1fb52e96a43cf6909e1530dcf6cbff8","modified":1550016988217},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"ccf0035086e14dcefa24c2907301edf4c37d5448","modified":1550016988217},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"debba9b7110f635204a15df148194d4c2fd2668b","modified":1550016988217},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"a174d4a0c9188f9c4a2652f49bfa7a60ad0a83e3","modified":1550016988217},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1550016988217},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1550016988217},{"_id":"themes/next/scripts/tags/exturl.js","hash":"83e48148d2f4f8543f6833effa8a26eb0b60f2f0","modified":1550016988217},{"_id":"themes/next/scripts/tags/button.js","hash":"510f3711a9c9d3e2a844250647d90e8359e7d130","modified":1550016988217},{"_id":"themes/next/scripts/tags/full-image.js","hash":"ef2c2985a3edb9f69740740c5bc42d4b692c86fd","modified":1550016988217},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"aface11629970a5c4ee38aaa15550d2caee59560","modified":1550016988217},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"ab4a82a7246265717556c7a42f897430340b88cf","modified":1550016988217},{"_id":"themes/next/scripts/tags/label.js","hash":"bb502616bfabe85de5de903074ec6afe627f8413","modified":1550016988217},{"_id":"themes/next/scripts/tags/note.js","hash":"bd3310a5890bded1bda9ba3ad6f98ee44ecb101a","modified":1550016988217},{"_id":"themes/next/scripts/tags/tabs.js","hash":"2d257e26718d4011509fd6f530d2ea37e50e3e66","modified":1550016988217},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"4519ab8e6898f2ee90d05cde060375462b937a7d","modified":1550016988217},{"_id":"themes/next/source/css/main.styl","hash":"2a62e2a11e9cdcc69e538d856d6f9ce228a07c93","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123095924037-1618037447.png","hash":"5ee810abb59e8db835b1dcfdee0ebe2af27ca798","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123095955350-1680422636.png","hash":"d2dd7a73bd28c95f817f26c85f6ffcf8530a8165","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123101901740-2118178734.png","hash":"d472e6f4f11884ed90efedfaa0e8433ee5a971b5","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123110136115-1112016464.png","hash":"e7aca1268b63998cbb3db07421ca674331381363","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123110156272-1242463729.png","hash":"937f4340c26c86f4ebad97a98af5adc69b9a9c88","modified":1550016988248},{"_id":"themes/next/source/images/Challestend.png","hash":"f77ecb69e448ec420da9cf8ca5d3f8979d4ea991","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123110209772-2057141058.png","hash":"2d9834c8e294848d304f0a57d1f4cfb8c1370de0","modified":1550016988248},{"_id":"themes/next/source/images/TIM图片20181023195537.jpg","hash":"6fb73e6c8ac291398911366bcc11d275820e866a","modified":1550016988248},{"_id":"themes/next/source/images/TIM图片20181209192946.jpg","hash":"7726adf714e53f596ce2ab149ebc5380beb5abe4","modified":1550016988248},{"_id":"themes/next/source/images/1309909-20180123110213709-49169640.png","hash":"f94a543e4d57058bd3b2a7911f05abacfe897816","modified":1550016988248},{"_id":"themes/next/source/images/TIM图片20190103092627.png","hash":"302582079f123bc1a7074bc8ae84ce027181b49a","modified":1546478656000},{"_id":"themes/next/source/images/TIM截图20190214152934.png","hash":"c3426aa6be73ef9639734f927ec5eb0a661556e6","modified":1550129393568},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1550016988248},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550016988248},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1550016988248},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1550016988248},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1550016988248},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550016988248},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1550016988248},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1550016988248},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1550016988248},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550016988248},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550016988248},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550016988248},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1550016988248},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550016988248},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1550016988248},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1550016988248},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550016988248},{"_id":"themes/next/source/images/图片1.png","hash":"1ac5f10a556ae34712e4613451839681910df009","modified":1550016988248},{"_id":"themes/next/source/images/图片2.png","hash":"30b2caa13edfc612eec7f9dcb1a83305a8e46c9f","modified":1550016988248},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1550016988248},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988201},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988201},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988232},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988232},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988232},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988248},{"_id":"themes/next/source/images/TIM截图20190116111347.png","hash":"718d56a312712097da85b4d0e286cab9bcb222be","modified":1550016988248},{"_id":"themes/next/source/images/TIM截图20190215193107.png","hash":"230f65c221d97be0a295cbe3b3efdf3d839b44c9","modified":1550230271949},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550016988248},{"_id":"themes/next/source/images/图片3.png","hash":"fa5e6fb339cddf434da3570428c5a7baac01b16f","modified":1550016988248},{"_id":"themes/next/source/fonts/ArimaMadurai-Light.ttf","hash":"4308742519f8ad4f6e546c283e1944e19653aaf2","modified":1550016988248},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"4eb8e222dc337211efb0d3bbdb5e29af3e6ecdb8","modified":1550016988201},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"aab518204d3125e948796a9ba6b56b09cade2d92","modified":1550016988201},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1550016988201},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"0b8349710caf9691741a457aa746add35245048e","modified":1550016988201},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"09109a5c5a301e7cc5e3c7aec32b0164739fc7d4","modified":1550016988201},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"f6454c452b2e90a8c760321bce7e3dc6119b71fa","modified":1550016988201},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1550016988201},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1550016988201},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1550016988201},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"c909f6e96373c151dea325bcddfdd8c9522421b6","modified":1550016988201},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"f3ae3168801304af3d80ec3b84264e1d4201cb89","modified":1550016988201},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"3f11ae8e9084f39628cd2006931d39a2069b9dd6","modified":1550016988201},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"19050627bc23b0b2c2e65e7248c0f88468eb8ea5","modified":1550016988201},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1550016988201},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1550016988201},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1550016988201},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1550016988201},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"580e9d9c4d8783ee6200d845ae16c98979bf1ea3","modified":1550016988201},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"1ce5fa218a44cf6e620583e9013e0b674dd6a989","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"8ab040fccba41675bc835973515530af8a51f8bd","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"cfc932c5db04fef64cc56d3ba0b8ddf3a15a63bd","modified":1550016988217},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"c381f638315a007b1baf5fea879161001fe50cd0","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"bd8382d4f12df207ed52f75f6e5fb06527970167","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1550016988217},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1550016988217},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"2440f1e66cb8e39cc2bacfd783fb6fe904a628e9","modified":1550016988217},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"19fd1d4d01193308a0ef530a7fc9abbae5441c34","modified":1550016988217},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"34cc66d4dbada2d561ba6f70fd9a75207c5adbd4","modified":1550016988217},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"c49a3b10b2f2f64a7ac41fa3d436fd2c8d31cca8","modified":1550016988217},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"d05e70a416963023ee1978e4168d58bcfd956ed3","modified":1550016988217},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1550016988217},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"30e9e55d9af2ced6e6b156a042026a8b480f0ab0","modified":1550016988217},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"860de4ce6fccc516d2f779a4b600a4214d8c18e2","modified":1550016988217},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"c0c2fd87e71f0beb542aa50c0bc875da5aa5c44b","modified":1550016988217},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1550016988217},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"71c897f9b107dd0de1b7f649633cf583c206a9db","modified":1550016988217},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1550016988217},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1550016988217},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"790d9d66d66c9df2948c67347d00996126450022","modified":1550016988232},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1550016988232},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"8aa98ae349908736ba43196c42498fd5bdeb780a","modified":1550016988232},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0882d76333ab409e8d3362c284b91a0f0ae761ae","modified":1550016988232},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"8d6cf29f63c90364f4d3c336f7c9bb794b4c46cc","modified":1550016988248},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1550016988248},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"72927abd51d3a607a6ba32cf882390792b34e834","modified":1550016988248},{"_id":"themes/next/source/css/_variables/base.styl","hash":"c566e9313798c3d13391c9462fe885a375856bbe","modified":1550016988248},{"_id":"themes/next/source/js/src/affix.js","hash":"ad343aa406fd8181b5f310434817ce98fc2219e3","modified":1550016988248},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"84906eeae57bd06744dd20160b93eacf658f97e2","modified":1550016988248},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"c7e2a588b679d46379124141bb2f30bc2f3210e2","modified":1550016988248},{"_id":"themes/next/source/js/src/exturl.js","hash":"c48aa4b3c0e578a807fd3661e6cd4f3890777437","modified":1550016988248},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1550016988248},{"_id":"themes/next/source/js/src/motion.js","hash":"4c7f94e499743f4cc958f6cd1260a93d765d3051","modified":1550016988248},{"_id":"themes/next/source/js/src/post-details.js","hash":"f564f54b277e98a24bfe74509001e28a4decfd0a","modified":1550016988248},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"68d3690152c89e7adb08bb35ec28dbda2bd93686","modified":1550016988248},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"c4867626afab749404daf321367f9b6b8e223f69","modified":1550016988248},{"_id":"themes/next/source/js/src/utils.js","hash":"fa3aab0ba7bc5138c6f8fac436efe5b8dcb97567","modified":1550016988248},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1550016988263},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1550016988263},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1550016988263},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1550016988263},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"6e076b5e183eedf425a445e99851f938789c3194","modified":1550016988217},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1550016988232},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"4b89f955bb92ff953fa3337546a26322de5caa01","modified":1550016988232},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1550016988232},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"ab775f23ad475efb25376b5aad752ae8b56cfd8c","modified":1550016988232},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1550016988232},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1550016988232},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"fbb6be577529c750ef7c872fe7abdc7ab0faf0f8","modified":1550016988232},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"52bc8ba71b91d954530b35dfc63b402a02b1321d","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"d0e9065b0dbbc01811259f0597d1790268b4881b","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa6c00fdaf8f0ca3b690a5a556671745fb67e2c9","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"2ccb9bdc309b7c1ef183a3dbb0a4621bec54a328","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"3cc7646583218d16925ced7b70865e63a901d4a7","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"b26f8a3394d8357a5bfd24d9f8bf62d7b4063ebb","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"cc961108b12ab97d9216606ceb1cd1cd31ab20f0","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"ccf5a4761cb0ce451b5e994cfabf8769248a45c1","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1550016988248},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"df16dc995eb9ad498df2edcfc3e20528fc9aa133","modified":1550016988248},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"f3aa863adf972569b72f2df6bc6a914e7daace99","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"be72740313a9a0477b8a22f62e4c8ffa6d23a2e5","modified":1550016988248},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"a558803ca81cceae2bdc22c18ef638fcc023681b","modified":1550016988248},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7e4e499964c2112d47e6f9d2b6e87c31ec8269e2","modified":1550016988232},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"6b37727883ab6f2a7211300d93289a337944838b","modified":1550016988248},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7dd247c8869fdefb5a007045d00f3ef8ceecf300","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"835c1340571bd6c4ec263c482cf13283fb047e49","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"3f3d2a43d1a326bad25b633c8ec9ddd87867224c","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"34f5ac3c1ed2dd31e9297cc4c0733e71bc2e252f","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1550016988217},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"630be616447a982413030e561bbd3a80ac14b120","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"ad4cae23c8e383f4fabc9a2a95bca6055020d22e","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"317c9ceda655e9dc373ce8e7b71d20b794fce9a4","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"330c8884efb5612e7eb03986d87d29e8b0651974","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"82bc7fa5d38d98e98cc25f9a73189024fda25e63","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ff50a32ae6fea5fcdf2939dc9b01e1eb76cc73f0","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"adfd6d2d3b34adc4b476a0ea91e19020456a3b1a","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"c4168c95d73b05b610d917778ad5b262cbfd424b","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5c3141d58970a0614896b6a62fd7a8a8caf4e401","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"fa57ec9a6f1943c0558856dfba2d6b8faca0cd4d","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"00a504620c454287111dc0ace64c989e1ff97f54","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"9e05a2232faabb41bcebb51d545d897a76f077da","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"94d76e6da600a36d80e2470326ebb6b3be447ccb","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"2d58ad90f148e845bc7023751a7a13260600f8d6","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"f1640253cbbf71d0c04c34c25bd61045894f98bc","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"f4d8144c22544bdb89787c14ab9d39578dae4b7c","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"acfdd76b1c90d2e384affb3d0006a39b524609d2","modified":1550016988232},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"c31fbaec7e6373ecfb8588500b972d451695a6ad","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1550016988232},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1550016988232},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1550016988263},{"_id":"public/404.html","hash":"280c1b64c61ef6bb187d7820b4527d7d494753e8","modified":1550232557883},{"_id":"public/atom.xml","hash":"f9762c42e5061440d92e1ff3dce40b0fe9118e08","modified":1550232557896},{"_id":"public/search.xml","hash":"0f2dc99276104821e0896544407ebdeab891c7aa","modified":1550232557897},{"_id":"public/content.json","hash":"b75e749365ef217121f1010fdafe88a066cb4c25","modified":1550232557919},{"_id":"public/categories/index.html","hash":"af67ac67faee43283fe9fe4eea24f5a984ec50f6","modified":1550232557927},{"_id":"public/tags/index.html","hash":"510e2f1863343b1fbb9ed1e66fca3eb8c429f17a","modified":1550232557927},{"_id":"public/about/index.html","hash":"be34ae61a75a7b34d287596c4fe71cfa3bd82ab5","modified":1550232557927},{"_id":"public/log/index.html","hash":"4b79a44f351f34475b20123f38decf06a28bc61e","modified":1550232557927},{"_id":"public/luogu-p3613-solution/index.html","hash":"0676247cafb827082af61a16dd8c1ef2631d687f","modified":1550232557927},{"_id":"public/min-25-sieve-learning-notes/index.html","hash":"d8c8a14195ab4087c77e8e9757fe2d1f8101be7b","modified":1550232557927},{"_id":"public/link-cut-tree-learning-notes/index.html","hash":"7c5ceaa3437cd2fcfb624c597a0c1448b7eefc20","modified":1550232557927},{"_id":"public/lolioi-2019-01-20-solutions/index.html","hash":"75eb38083a0fa6404254f9ecb8d733da1abf6916","modified":1550232557927},{"_id":"public/luogu-p4091-solution/index.html","hash":"33b01447e30dda8deead27a2903d3073e7438f35","modified":1550232557927},{"_id":"public/something-about-network-flow-learning-notes/index.html","hash":"dba5bde81546bdd05643a5727c04c185df311f6c","modified":1550232557928},{"_id":"public/similar-euclid-algorithm-learning-notes/index.html","hash":"650cfb8fecde2b502bb7c409664108e96b31f8af","modified":1550232557928},{"_id":"public/luogu-p4113-solution/index.html","hash":"d65f863a3ffe40891703547e2b0b5c19240dcfa8","modified":1550232557928},{"_id":"public/luogu-p3723-solution/index.html","hash":"4b314f70eee49a6c18acc6b9470510c59ec0320c","modified":1550232557928},{"_id":"public/luogu-p5162-solution/index.html","hash":"c4279cfe8b53b98762d8b7395c3ed137ce5748ac","modified":1550232557928},{"_id":"public/timuzu-solutions/index.html","hash":"d3afdf0f654a40127b65548034f2ed53c42824fb","modified":1550232557928},{"_id":"public/block-decomposition/index.html","hash":"e18e5525ea2ba1732a4005f5a1aa55d188803d98","modified":1550232557928},{"_id":"public/polynomial-learning-notes-pt2/index.html","hash":"2e286da8ed7c176fc318fb6f3e5a67df8c7d3ae9","modified":1550232557928},{"_id":"public/polynomial-learning-notes-pt1/index.html","hash":"ba4461e0e07b09c436eb6d63da34e24dc5f37978","modified":1550232557928},{"_id":"public/sqrt-decomposition-complexity-optimization/index.html","hash":"a1bc12dee7137f9473cbcacd2753042c2b353325","modified":1550232557928},{"_id":"public/future-algorithm-ep1/index.html","hash":"d2f0cec39670899d328024890a5ad095db0380cc","modified":1550232557928},{"_id":"public/number-theory-learning-notes/index.html","hash":"884d77e9678630b7854d792cd9714793eb4bce21","modified":1550232557928},{"_id":"public/noip-2018-notes/index.html","hash":"7080a2c4dceb2d9c5d3d6974bf62bf7206a7fca5","modified":1550232557928},{"_id":"public/luogu-p5009-solution/index.html","hash":"207b318ee7fb625b42b7938d7eecf35f1cd75a60","modified":1550232557928},{"_id":"public/status-compression-learning-notes/index.html","hash":"c97d115a9633b2b9781f1838ab698ab97c2bae8c","modified":1550232557928},{"_id":"public/chtholly-tree-learning-notes/index.html","hash":"4afe94ed9e6b02db56489a36d22e24d4d1069c69","modified":1550232557928},{"_id":"public/luogu-p2154-solution/index.html","hash":"3d38d0d1927819a50804d9c453aa52fa9ed04e0e","modified":1550232557928},{"_id":"public/luogu-p4900-solution/index.html","hash":"c41016b31e92f5f041f433235ec434f2f5d95dc5","modified":1550232557928},{"_id":"public/luogu-p3924-solution/index.html","hash":"5dd340af06c60a665340f29c5fb3a817188eff46","modified":1550232557929},{"_id":"public/luogu-t47720-solution/index.html","hash":"a1ec32a3c79a6dc6c32f4d17f82875b1f3f50713","modified":1550232557929},{"_id":"public/hello-world/index.html","hash":"fe6e28280f2b6c590880458785b04d2c88de266c","modified":1550232557929},{"_id":"public/announcement/index.html","hash":"ad4c99a33c72f7d8ea7117b9ae79404c0f5ee777","modified":1550232557929},{"_id":"public/archives/index.html","hash":"d129e3f9c073332984670ec3b83254b92d0d6fb9","modified":1550232557929},{"_id":"public/archives/page/2/index.html","hash":"4b3c80b9b3f3e58ad51fdbacec7313fb840df457","modified":1550232557929},{"_id":"public/archives/page/3/index.html","hash":"fa685718043e031c0e24287724a55ee028bd4b60","modified":1550232557929},{"_id":"public/archives/1899/index.html","hash":"3a8b0dccbb61a882449e7f9b71f6abc45a7e5ec4","modified":1550232557929},{"_id":"public/archives/1899/11/index.html","hash":"1b92cf4054430ddd0420633ab9a187deef466b51","modified":1550232557929},{"_id":"public/archives/2018/index.html","hash":"ddc610c494b2af48cd9a0bd5db81cf4802662533","modified":1550232557929},{"_id":"public/archives/2018/page/2/index.html","hash":"35eb5e27c7f8d2dd54e430f5d8ba45a41a2ba3b5","modified":1550232557929},{"_id":"public/archives/2018/09/index.html","hash":"76c0244be124546ceaf4848f6829052e5ecaf14e","modified":1550232557929},{"_id":"public/archives/2018/10/index.html","hash":"024765941bfb50a8f62d6df1ebd786825c9f5718","modified":1550232557929},{"_id":"public/archives/2018/11/index.html","hash":"b9b98e3e835a6bcc68882c92d71e7b6c406e5ed5","modified":1550232557929},{"_id":"public/archives/2018/12/index.html","hash":"9d27543fcb3dc51f448463707c1b9f0256afa316","modified":1550232557929},{"_id":"public/archives/2019/index.html","hash":"0db92194ec93692736803fdd1d578e24668b081b","modified":1550232557930},{"_id":"public/archives/2019/01/index.html","hash":"ee7acd4a5c7ae47dcb5bd021414f8810c53fcad9","modified":1550232557930},{"_id":"public/archives/2019/02/index.html","hash":"b541c77780353da89bd80b2ef708ebbc519fb41d","modified":1550232557930},{"_id":"public/categories/未分类/index.html","hash":"a8a30875b459a86354ca4247d11200cd4ae74585","modified":1550232557930},{"_id":"public/categories/题解/index.html","hash":"8b8bb3e9ca44680fbf4d466e2bb4bab19734f0c7","modified":1550232557930},{"_id":"public/categories/题解/page/2/index.html","hash":"dd9585f46651a34196760b247ea4a23f2821b92d","modified":1550232557930},{"_id":"public/categories/学习笔记/index.html","hash":"62cfb14a082aa82953cdbd6602c74b8fb1dc4580","modified":1550232557930},{"_id":"public/categories/游记/index.html","hash":"b590943562e5b290e49680652569c0f11a937853","modified":1550232557930},{"_id":"public/categories/研究报告/index.html","hash":"5369b9380d9a5dadd067be635511eab4c199792d","modified":1550232557930},{"_id":"public/categories/未来算法/index.html","hash":"b2c49e8fd5e7c26294432796352b0f05d53c70ea","modified":1550232557930},{"_id":"public/index.html","hash":"ac146cf8b2de7fba885e7b6efec6e6a37ab1d544","modified":1550232557930},{"_id":"public/page/2/index.html","hash":"993da933f6fcab718940f9b79fefebc559686d41","modified":1550232557930},{"_id":"public/page/3/index.html","hash":"7e1ceea20843d47ddb5b73f76c0ca626fe3b0b16","modified":1550232557930},{"_id":"public/tags/其它/index.html","hash":"3c460e3025c8969e89a293d4a5c673a3032f22e1","modified":1550232557930},{"_id":"public/tags/数论/index.html","hash":"2cd35924a7db5e79106046d20a9dba6b4cb0f44c","modified":1550232557930},{"_id":"public/tags/组合数学/index.html","hash":"1b06ee15755ed8f530350caa30922556bbd79fb5","modified":1550232557930},{"_id":"public/tags/期望/index.html","hash":"3497f930e33f4a082aa9445b8aa320feec2b0293","modified":1550232557930},{"_id":"public/tags/洛谷/index.html","hash":"ea9c4a6d348ae9c4863c77163bd45094cc18aba2","modified":1550232557930},{"_id":"public/tags/差分/index.html","hash":"2b9ba698ef7b1ca4144bcf2aaaae7d5f46e172b7","modified":1550232557930},{"_id":"public/tags/SDOI/index.html","hash":"538e43f55b5e09d9c93f6c66a64004ee5c0340ff","modified":1550232557931},{"_id":"public/tags/2009/index.html","hash":"60b25a5f05675c0325b37bbea6c3de428cd0194b","modified":1550232557931},{"_id":"public/tags/离散化/index.html","hash":"12716d1342a7c3e6f3b63a23b3eb9c2e4ef1a153","modified":1550232557931},{"_id":"public/tags/树状数组/index.html","hash":"753ba7f65c2d56176f28d777ddd5017885564c53","modified":1550232557931},{"_id":"public/tags/状态压缩/index.html","hash":"80193c702d23c2662dda6f4148e6d00ab9619b39","modified":1550232557931},{"_id":"public/tags/动态规划/index.html","hash":"fd45893894515779a9cd874f82211933b6232b78","modified":1550232557931},{"_id":"public/tags/NOIp/index.html","hash":"55f51bbd6de490599be5ae9c4037102c08f99439","modified":1550232557931},{"_id":"public/tags/2018/index.html","hash":"35c9c73992e30ca268f772dffd51cc38b2dee79b","modified":1550232557931},{"_id":"public/tags/分块/index.html","hash":"84f948e10cb72da18d62fde0a68753da7118a36b","modified":1550232557931},{"_id":"public/tags/块状分块/index.html","hash":"924e9b1241121ae7bf8c9997e813a1d53e3b503e","modified":1550232557931},{"_id":"public/tags/NTT/index.html","hash":"2896961a0f787a17658b4130eb0a50d76f695b27","modified":1550232557931},{"_id":"public/tags/HEOI/index.html","hash":"031e7bfa23fc5d038e998fe25df2de05439154cb","modified":1550232557931},{"_id":"public/tags/2012/index.html","hash":"c92c4ed90bb373ebf119153a740feff310611361","modified":1550232557931},{"_id":"public/tags/莫队/index.html","hash":"b06f7a4af1945778bf9b8ee5a4e7811be67e9746","modified":1550232557931},{"_id":"public/tags/网络流/index.html","hash":"972dffd10679487fa4641745b361f259990fbb11","modified":1550232557931},{"_id":"public/tags/最大流/index.html","hash":"a755f9f3fd60bb4fae27f1c6b171d2bf61972c0d","modified":1550232557931},{"_id":"public/tags/预留推进/index.html","hash":"a71be6d9e8e94898cc11f532d629f8471e2927c1","modified":1550232557931},{"_id":"public/tags/AHOI/index.html","hash":"1fa2597b2b0c9da7e1d284ebf211ef0acb916ed7","modified":1550232557931},{"_id":"public/tags/HNOI/index.html","hash":"88a4687fe54fa6d3c0a441921cf51fa618bafad3","modified":1550232557931},{"_id":"public/tags/2017/index.html","hash":"d68a752f777d71acc1fcfc4483e724b084ca211e","modified":1550232557931},{"_id":"public/tags/TJOI/index.html","hash":"c2913e3f99f96ae458542948d7a1392bf83fdbf4","modified":1550232557932},{"_id":"public/tags/2016/index.html","hash":"513886f88bb7e5c7eaee9b0d83a6adeaacdc6d4c","modified":1550232557932},{"_id":"public/tags/loli/index.html","hash":"965e1becc34108b0414d02915c797121dc70b01a","modified":1550232557932},{"_id":"public/tags/模拟赛/index.html","hash":"4aa31891d67dc20899ebe1b04f89e4720c3fef4d","modified":1550232557932},{"_id":"public/tags/树链剖分/index.html","hash":"4c89cf1e59c8aee572daea19c1d9aede4563bf0f","modified":1550232557932},{"_id":"public/tags/LCT/index.html","hash":"8f3a93223e264daabc3efcb2af316c08d38aaaab","modified":1550232557932},{"_id":"public/tags/珂朵莉树/index.html","hash":"250be2d98df93aef96f9513c4e805b7c3f8c05c8","modified":1550232557932},{"_id":"public/tags/线段树/index.html","hash":"3fe6541e0fae4ef300c83ff7cbf2279f2ded9e77","modified":1550232557932},{"_id":"public/tags/树套树/index.html","hash":"df42906c16198043fd19bd63107b537efc4f584c","modified":1550232557932},{"_id":"public/tags/FFT/index.html","hash":"5b6ddc5f85cedb945c18fd9c04c3365033b1d9a8","modified":1550232557932},{"_id":"public/tags/题目组/index.html","hash":"0636753d52e60985cfb5d7328c5588c87d875638","modified":1550232557932},{"_id":"public/tags/毒瘤题/index.html","hash":"f7b660ec4d0659a944226c8dbeb84a2becfaa28f","modified":1550232557932},{"_id":"public/tags/Splay/index.html","hash":"e89315733e1a2dbdf6f3d36472f7e99d154c37c2","modified":1550232557933},{"_id":"public/tags/min-25筛/index.html","hash":"af6a817dccd51a5fa694f2529c1b26ed7699a0df","modified":1550232557933},{"_id":"public/tags/杜教筛/index.html","hash":"3a088367143ee518032a1557f85769b10a0aa8a2","modified":1550232557933},{"_id":"public/tags/类欧几里得/index.html","hash":"78269035b9edb6d02ce532a533035c93983e4ccd","modified":1550232557933},{"_id":"public/images/1309909-20180123095955350-1680422636.png","hash":"d2dd7a73bd28c95f817f26c85f6ffcf8530a8165","modified":1550232558015},{"_id":"public/images/1309909-20180123110136115-1112016464.png","hash":"e7aca1268b63998cbb3db07421ca674331381363","modified":1550232558015},{"_id":"public/images/1309909-20180123101901740-2118178734.png","hash":"d472e6f4f11884ed90efedfaa0e8433ee5a971b5","modified":1550232558015},{"_id":"public/images/1309909-20180123110156272-1242463729.png","hash":"937f4340c26c86f4ebad97a98af5adc69b9a9c88","modified":1550232558015},{"_id":"public/images/1309909-20180123110209772-2057141058.png","hash":"2d9834c8e294848d304f0a57d1f4cfb8c1370de0","modified":1550232558015},{"_id":"public/images/TIM图片20181209192946.jpg","hash":"7726adf714e53f596ce2ab149ebc5380beb5abe4","modified":1550232558015},{"_id":"public/images/TIM图片20181023195537.jpg","hash":"6fb73e6c8ac291398911366bcc11d275820e866a","modified":1550232558015},{"_id":"public/images/TIM图片20190103092627.png","hash":"302582079f123bc1a7074bc8ae84ce027181b49a","modified":1550232558015},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550232558015},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1550232558016},{"_id":"public/images/TIM截图20190214152934.png","hash":"c3426aa6be73ef9639734f927ec5eb0a661556e6","modified":1550232558016},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1550232558016},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1550232558016},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1550232558016},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1550232558016},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1550232558016},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550232558016},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550232558016},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550232558016},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550232558016},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1550232558016},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1550232558016},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550232558016},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550232558016},{"_id":"public/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1550232558016},{"_id":"public/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1550232558016},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1550232558016},{"_id":"public/images/图片2.png","hash":"30b2caa13edfc612eec7f9dcb1a83305a8e46c9f","modified":1550232558016},{"_id":"public/images/图片1.png","hash":"1ac5f10a556ae34712e4613451839681910df009","modified":1550232558016},{"_id":"public/images/TIM截图20190116111347.png","hash":"718d56a312712097da85b4d0e286cab9bcb222be","modified":1550232558016},{"_id":"public/images/TIM截图20190215193107.png","hash":"230f65c221d97be0a295cbe3b3efdf3d839b44c9","modified":1550232558016},{"_id":"public/lib/blog-encrypt.js","hash":"58afe7c5f6e7e71d6b6760e1fd9f9e9d0eb962a1","modified":1550232558017},{"_id":"public/css/blog-encrypt.css","hash":"b609ba95748409b03ef3386681d43bd1739399c8","modified":1550232558017},{"_id":"public/images/1309909-20180123095924037-1618037447.png","hash":"5ee810abb59e8db835b1dcfdee0ebe2af27ca798","modified":1550232558418},{"_id":"public/images/Challestend.png","hash":"f77ecb69e448ec420da9cf8ca5d3f8979d4ea991","modified":1550232558485},{"_id":"public/images/1309909-20180123110213709-49169640.png","hash":"f94a543e4d57058bd3b2a7911f05abacfe897816","modified":1550232558486},{"_id":"public/images/图片3.png","hash":"fa5e6fb339cddf434da3570428c5a7baac01b16f","modified":1550232558486},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1550232558493},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1550232558493},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1550232558494},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1550232558494},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550232558494},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1550232558494},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1550232558494},{"_id":"public/js/src/schemes/pisces.js","hash":"58f87062210200c778eb92e20a9453bb6a5a03fa","modified":1550232558494},{"_id":"public/js/src/post-details.js","hash":"e4214e382f466e33c74c80136ec46b93445060b5","modified":1550232558494},{"_id":"public/css/main.css","hash":"595ff26c495c29caaa0ad7e76038af5c1d7d9b67","modified":1550232558494},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1550232558508},{"_id":"public/js/src/utils.js","hash":"e437eff1d3781c4a1aec9ff2060565524a37c983","modified":1550232558508},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550232558508},{"_id":"public/fonts/ArimaMadurai-Light.ttf","hash":"4308742519f8ad4f6e546c283e1944e19653aaf2","modified":1550232558512},{"_id":"public/lib/crypto-js.js","hash":"ddacd177f23f65ff97b93b0417048f51928ee17e","modified":1550232558535},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550232558588},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550232558588},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550232558717},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550232558726}],"Category":[{"name":"未分类","_id":"cjs60fpui000534cw4avfe35w"},{"name":"题解","_id":"cjs60fpuo000b34cwejv4f683"},{"name":"学习笔记","_id":"cjs60fpv2000y34cwl5jybo88"},{"name":"游记","_id":"cjs60fpv4001734cwndq75h6f"},{"name":"研究报告","_id":"cjs60fpv7001e34cw4n07i3rc"},{"name":"未来算法","_id":"cjs60fpwf003u34cwgan78t25"}],"Data":[],"Page":[{"layout":"false","comments":0,"_content":"<body>\n\t<div>\n\t\t<p style=\"text-align: center;\"><img src=\"https://i.loli.net/2018/10/27/5bd4705dd844f.jpg\"></p>\n\t\t<p style=\"text-align: center;\"><strong>您可能访问了错误的网址</strong></p>\n\t\t<p style=\"text-align: center;\"><a href=\"https://challestend.github.io\" target=\"_self\"><strong>回到博客主页</strong></a></p>\n\t</div>\n</html>\n","source":"404.html","raw":"---\nlayout: false\ncomments: false\n---\n<body>\n\t<div>\n\t\t<p style=\"text-align: center;\"><img src=\"https://i.loli.net/2018/10/27/5bd4705dd844f.jpg\"></p>\n\t\t<p style=\"text-align: center;\"><strong>您可能访问了错误的网址</strong></p>\n\t\t<p style=\"text-align: center;\"><a href=\"https://challestend.github.io\" target=\"_self\"><strong>回到博客主页</strong></a></p>\n\t</div>\n</html>\n","date":"2019-02-13T00:16:28.185Z","updated":"2019-02-13T00:16:28.185Z","path":"404.html","title":"","_id":"cjs60fpoy000034cwajqkpsqi","content":"<body>\n\t<div>\n\t\t<p style=\"text-align: center;\"><img src=\"https://i.loli.net/2018/10/27/5bd4705dd844f.jpg\"></p>\n\t\t<p style=\"text-align: center;\"><strong>您可能访问了错误的网址</strong></p>\n\t\t<p style=\"text-align: center;\"><a href=\"https://challestend.github.io\" target=\"_self\"><strong>回到博客主页</strong></a></p>\n\t</div>\n\n</body>","site":{"data":{}},"excerpt":"","more":"<body>\n\t<div>\n\t\t<p style=\"text-align: center;\"><img src=\"https://i.loli.net/2018/10/27/5bd4705dd844f.jpg\"></p>\n\t\t<p style=\"text-align: center;\"><strong>您可能访问了错误的网址</strong></p>\n\t\t<p style=\"text-align: center;\"><a href=\"https://challestend.github.io\" target=\"_self\"><strong>回到博客主页</strong></a></p>\n\t</div>\n\n</body>"},{"title":"分类","date":"2018-10-11T00:14:04.000Z","type":"categories","comments":0,"_content":"\n","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-10-11 08:14:04\ntype: \"categories\"\ncomments: false\n---\n\n","updated":"2019-02-13T00:16:28.185Z","path":"categories/index.html","layout":"page","_id":"cjs60fpuf000234cwb6uiq60k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-10-09T01:57:40.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-10-09 09:57:40\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-02-13T00:16:28.185Z","path":"tags/index.html","layout":"page","_id":"cjs60fpuh000434cwpeskhf7y","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2019-02-13T00:16:28.185Z","comments":0,"_content":"A juruo OIer from SD province.\n\nStudying in SLYZ.\n\nFind me on\n\n- [Luogu](https://www.luogu.org/space/show?uid=63352)\n- [LibreOJ](https://loj.ac/user/6666)\n- [NowCoder](https://www.nowcoder.com/profile/514705863)\n- [CodeForces](http://codeforces.com/profile/CLT)\n- [GitHub](https://github.com/Challestend)\n","source":"about/index.md","raw":"---\ntitle: 关于\ndate: Undefined\ncomments: false\n---\nA juruo OIer from SD province.\n\nStudying in SLYZ.\n\nFind me on\n\n- [Luogu](https://www.luogu.org/space/show?uid=63352)\n- [LibreOJ](https://loj.ac/user/6666)\n- [NowCoder](https://www.nowcoder.com/profile/514705863)\n- [CodeForces](http://codeforces.com/profile/CLT)\n- [GitHub](https://github.com/Challestend)\n","updated":"2019-02-13T00:16:28.185Z","path":"about/index.html","layout":"page","_id":"cjs60fpul000834cwmhb2w4d5","content":"<p>A juruo OIer from SD province.</p>\n<p>Studying in SLYZ.</p>\n<p>Find me on</p>\n<ul>\n<li><a href=\"https://www.luogu.org/space/show?uid=63352\" target=\"_blank\" rel=\"noopener\">Luogu</a></li>\n<li><a href=\"https://loj.ac/user/6666\" target=\"_blank\" rel=\"noopener\">LibreOJ</a></li>\n<li><a href=\"https://www.nowcoder.com/profile/514705863\" target=\"_blank\" rel=\"noopener\">NowCoder</a></li>\n<li><a href=\"http://codeforces.com/profile/CLT\" target=\"_blank\" rel=\"noopener\">CodeForces</a></li>\n<li><a href=\"https://github.com/Challestend\">GitHub</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>A juruo OIer from SD province.</p>\n<p>Studying in SLYZ.</p>\n<p>Find me on</p>\n<ul>\n<li><a href=\"https://www.luogu.org/space/show?uid=63352\" target=\"_blank\" rel=\"noopener\">Luogu</a></li>\n<li><a href=\"https://loj.ac/user/6666\" target=\"_blank\" rel=\"noopener\">LibreOJ</a></li>\n<li><a href=\"https://www.nowcoder.com/profile/514705863\" target=\"_blank\" rel=\"noopener\">NowCoder</a></li>\n<li><a href=\"http://codeforces.com/profile/CLT\" target=\"_blank\" rel=\"noopener\">CodeForces</a></li>\n<li><a href=\"https://github.com/Challestend\">GitHub</a></li>\n</ul>\n"},{"title":"更新日志","date":"2018-12-12T11:47:51.000Z","mathjax":true,"_content":"直角，这是这篇blog的更新日志。\n\n不过我不是一个考虑周全的人，之前9月份搭起博客时，我并没有考虑到这些。因而，之前的很多更新的具体时间已经无从知晓。\n\n- 2018-09-27\n  - 建站。\n- （略）\n- 2018-12-13\n  - 令`theme-next-pace`的加载进度条的颜色温和了一点。\n  - 将`hexo-symbols-count-time`的字数和时间统计替换成了精确数值。\n  - 减少了侧边栏和网易云外链的宽度。\n- 2018-12-14\n  - 修复了在404页面点击「回到博客主页」会打开新标签页的问题。\n- 2018-12-19\n  - 将字体改为了Arima Madurai。\n- 2018-12-28\n  - 新增了访客计数。\n- 2019-01-07\n  - 不知道什么时候字体炸了，然后xjb捣鼓了一波终于修好了。\n- 2019-01-08\n  - ~~然后一大早发现它又炸了。告辞。不修了。~~然后传上去发现又好了。\n- 2019-01-16\n  - 新增了代码折叠\n  - 新增了SnoWY的blog\n  - 更新了asuldb的blog地址\n  - 字体又炸了（\n- To Be Continued\n","source":"log/index.md","raw":"---\ntitle: 更新日志\ndate: 2018-12-12 19:47:51\nmathjax: true\n---\n直角，这是这篇blog的更新日志。\n\n不过我不是一个考虑周全的人，之前9月份搭起博客时，我并没有考虑到这些。因而，之前的很多更新的具体时间已经无从知晓。\n\n- 2018-09-27\n  - 建站。\n- （略）\n- 2018-12-13\n  - 令`theme-next-pace`的加载进度条的颜色温和了一点。\n  - 将`hexo-symbols-count-time`的字数和时间统计替换成了精确数值。\n  - 减少了侧边栏和网易云外链的宽度。\n- 2018-12-14\n  - 修复了在404页面点击「回到博客主页」会打开新标签页的问题。\n- 2018-12-19\n  - 将字体改为了Arima Madurai。\n- 2018-12-28\n  - 新增了访客计数。\n- 2019-01-07\n  - 不知道什么时候字体炸了，然后xjb捣鼓了一波终于修好了。\n- 2019-01-08\n  - ~~然后一大早发现它又炸了。告辞。不修了。~~然后传上去发现又好了。\n- 2019-01-16\n  - 新增了代码折叠\n  - 新增了SnoWY的blog\n  - 更新了asuldb的blog地址\n  - 字体又炸了（\n- To Be Continued\n","updated":"2019-02-13T00:16:28.185Z","path":"log/index.html","comments":1,"layout":"page","_id":"cjs60fpwb003o34cw9my8l8ou","content":"<p>直角，这是这篇blog的更新日志。</p>\n<p>不过我不是一个考虑周全的人，之前9月份搭起博客时，我并没有考虑到这些。因而，之前的很多更新的具体时间已经无从知晓。</p>\n<ul>\n<li>2018-09-27<ul>\n<li>建站。</li>\n</ul>\n</li>\n<li>（略）</li>\n<li>2018-12-13<ul>\n<li>令<code>theme-next-pace</code>的加载进度条的颜色温和了一点。</li>\n<li>将<code>hexo-symbols-count-time</code>的字数和时间统计替换成了精确数值。</li>\n<li>减少了侧边栏和网易云外链的宽度。</li>\n</ul>\n</li>\n<li>2018-12-14<ul>\n<li>修复了在404页面点击「回到博客主页」会打开新标签页的问题。</li>\n</ul>\n</li>\n<li>2018-12-19<ul>\n<li>将字体改为了Arima Madurai。</li>\n</ul>\n</li>\n<li>2018-12-28<ul>\n<li>新增了访客计数。</li>\n</ul>\n</li>\n<li>2019-01-07<ul>\n<li>不知道什么时候字体炸了，然后xjb捣鼓了一波终于修好了。</li>\n</ul>\n</li>\n<li>2019-01-08<ul>\n<li><del>然后一大早发现它又炸了。告辞。不修了。</del>然后传上去发现又好了。</li>\n</ul>\n</li>\n<li>2019-01-16<ul>\n<li>新增了代码折叠</li>\n<li>新增了SnoWY的blog</li>\n<li>更新了asuldb的blog地址</li>\n<li>字体又炸了（</li>\n</ul>\n</li>\n<li>To Be Continued</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>直角，这是这篇blog的更新日志。</p>\n<p>不过我不是一个考虑周全的人，之前9月份搭起博客时，我并没有考虑到这些。因而，之前的很多更新的具体时间已经无从知晓。</p>\n<ul>\n<li>2018-09-27<ul>\n<li>建站。</li>\n</ul>\n</li>\n<li>（略）</li>\n<li>2018-12-13<ul>\n<li>令<code>theme-next-pace</code>的加载进度条的颜色温和了一点。</li>\n<li>将<code>hexo-symbols-count-time</code>的字数和时间统计替换成了精确数值。</li>\n<li>减少了侧边栏和网易云外链的宽度。</li>\n</ul>\n</li>\n<li>2018-12-14<ul>\n<li>修复了在404页面点击「回到博客主页」会打开新标签页的问题。</li>\n</ul>\n</li>\n<li>2018-12-19<ul>\n<li>将字体改为了Arima Madurai。</li>\n</ul>\n</li>\n<li>2018-12-28<ul>\n<li>新增了访客计数。</li>\n</ul>\n</li>\n<li>2019-01-07<ul>\n<li>不知道什么时候字体炸了，然后xjb捣鼓了一波终于修好了。</li>\n</ul>\n</li>\n<li>2019-01-08<ul>\n<li><del>然后一大早发现它又炸了。告辞。不修了。</del>然后传上去发现又好了。</li>\n</ul>\n</li>\n<li>2019-01-16<ul>\n<li>新增了代码折叠</li>\n<li>新增了SnoWY的blog</li>\n<li>更新了asuldb的blog地址</li>\n<li>字体又炸了（</li>\n</ul>\n</li>\n<li>To Be Continued</li>\n</ul>\n"}],"Post":[{"mathjax":true,"date":"1899-11-29T16:00:00.000Z","title":"说在前面的话","top":2147483647,"_content":"在阅读这个菜鸡的blog之前，您需要知道的一些事情。\n\n<!-- more -->\n\n1. 在[有小标题的文章](/poisonous-problems/)里，侧边栏的网易云外链会出锅。原因不明。\n2. 在撰写评论时，推荐您在「邮箱」一栏如实填写自己用于注册Gravatar的邮箱，使用您Gravatar上的头像。~~当然，如果您实在是懒得搞什么G啥玩意的，~~您也可以随便填点什么，我们会基于您填写的内容生成一个随机头像。__但是无论如何不推荐留空。而且一定要保证满足邮箱的格式，即`?*@?*.com`。其中`?*`表示这里可以填任意多个字符，但不能是零个，而且不能包含一些奇怪的字符，包括但不限于`/`、`.`。__\n","source":"_posts/0000-00-00-announcement.md","raw":"---\nmathjax: true\ndate: 0000-00-00 00:00:00\ntitle: 说在前面的话\ntags:\n  - 其它\ncategories:\n  - 未分类\ntop: 2147483647\n---\n在阅读这个菜鸡的blog之前，您需要知道的一些事情。\n\n<!-- more -->\n\n1. 在[有小标题的文章](/poisonous-problems/)里，侧边栏的网易云外链会出锅。原因不明。\n2. 在撰写评论时，推荐您在「邮箱」一栏如实填写自己用于注册Gravatar的邮箱，使用您Gravatar上的头像。~~当然，如果您实在是懒得搞什么G啥玩意的，~~您也可以随便填点什么，我们会基于您填写的内容生成一个随机头像。__但是无论如何不推荐留空。而且一定要保证满足邮箱的格式，即`?*@?*.com`。其中`?*`表示这里可以填任意多个字符，但不能是零个，而且不能包含一些奇怪的字符，包括但不限于`/`、`.`。__\n","slug":"announcement","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpub000134cwnkmxkqes","content":"<p>在阅读这个菜鸡的blog之前，您需要知道的一些事情。</p>\n<a id=\"more\"></a>\n<ol>\n<li>在<a href=\"/poisonous-problems/\">有小标题的文章</a>里，侧边栏的网易云外链会出锅。原因不明。</li>\n<li>在撰写评论时，推荐您在「邮箱」一栏如实填写自己用于注册Gravatar的邮箱，使用您Gravatar上的头像。<del>当然，如果您实在是懒得搞什么G啥玩意的，</del>您也可以随便填点什么，我们会基于您填写的内容生成一个随机头像。<strong>但是无论如何不推荐留空。而且一定要保证满足邮箱的格式，即<code>?*@?*.com</code>。其中<code>?*</code>表示这里可以填任意多个字符，但不能是零个，而且不能包含一些奇怪的字符，包括但不限于<code>/</code>、<code>.</code>。</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在阅读这个菜鸡的blog之前，您需要知道的一些事情。</p>","more":"<ol>\n<li>在<a href=\"/poisonous-problems/\">有小标题的文章</a>里，侧边栏的网易云外链会出锅。原因不明。</li>\n<li>在撰写评论时，推荐您在「邮箱」一栏如实填写自己用于注册Gravatar的邮箱，使用您Gravatar上的头像。<del>当然，如果您实在是懒得搞什么G啥玩意的，</del>您也可以随便填点什么，我们会基于您填写的内容生成一个随机头像。<strong>但是无论如何不推荐留空。而且一定要保证满足邮箱的格式，即<code>?*@?*.com</code>。其中<code>?*</code>表示这里可以填任意多个字符，但不能是零个，而且不能包含一些奇怪的字符，包括但不限于<code>/</code>、<code>.</code>。</strong></li>\n</ol>"},{"title":"「Luogu-T47720」孤立元","date":"2018-09-27T06:29:56.000Z","mathjax":true,"_content":"[传送门](https://www.luogu.org/problemnew/show/T47720)\n\n<!-- more -->\n\n自己出的第一道~~毒瘤~~数论题。\n\n对于每一个$i(1<i<n)$，如果它成为了孤立元，那么一定有$i-1\\notin B$且$i+1\\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为\n\n$$\\frac{\\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}$$\n\n将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式\n\n$$\\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\\frac{m(n+1)(n-m)}{n(n-1)}$$\n\n> Updated on 2018-10-10\n>\n> 之前公式写错了，分子上的$m$全都漏掉了（\n>\n> 以及，我们还可以将上式继续整理：\n>\n> $$\\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}$$\n>\n> ~~以及，顺便测试了一下新的快读板子，然后发现`#ifdef`真没用也可能是我太菜了（~~\n>\n> > Updated on 2018-10-16\n> >\n> > 好吧我当时并不会用`#ifdef`（\n>\n> 以及，标程经过一系列~~丧心病狂的~~卡常卡到了$1861\\text{ms}$，最慢的一个点只跑了$300\\text{ms}$不到。截至本日，另外两个切掉这道题的$\\text{dalao}$最慢的一个点也只跑了$400\\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？~~所以说为什么我当初在本地测的时候平均每个点$500\\text{ms}$，是我们机房的电脑太菜了吗（~~\n\n于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。\n\n但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……\n","source":"_posts/2018-09-27-luogu-t47720-solution.md","raw":"---\ntitle: 「Luogu-T47720」孤立元\ndate: 2018-09-27 14:29:56\ntags:\n  - 数论\n  - 组合数学\n  - 期望\ncategories:\n  - 题解\nmathjax: true\n---\n[传送门](https://www.luogu.org/problemnew/show/T47720)\n\n<!-- more -->\n\n自己出的第一道~~毒瘤~~数论题。\n\n对于每一个$i(1<i<n)$，如果它成为了孤立元，那么一定有$i-1\\notin B$且$i+1\\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为\n\n$$\\frac{\\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}$$\n\n将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式\n\n$$\\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\\frac{m(n+1)(n-m)}{n(n-1)}$$\n\n> Updated on 2018-10-10\n>\n> 之前公式写错了，分子上的$m$全都漏掉了（\n>\n> 以及，我们还可以将上式继续整理：\n>\n> $$\\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}$$\n>\n> ~~以及，顺便测试了一下新的快读板子，然后发现`#ifdef`真没用也可能是我太菜了（~~\n>\n> > Updated on 2018-10-16\n> >\n> > 好吧我当时并不会用`#ifdef`（\n>\n> 以及，标程经过一系列~~丧心病狂的~~卡常卡到了$1861\\text{ms}$，最慢的一个点只跑了$300\\text{ms}$不到。截至本日，另外两个切掉这道题的$\\text{dalao}$最慢的一个点也只跑了$400\\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？~~所以说为什么我当初在本地测的时候平均每个点$500\\text{ms}$，是我们机房的电脑太菜了吗（~~\n\n于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。\n\n但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……\n","slug":"luogu-t47720-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpug000334cw8jhgtlrm","content":"<p><a href=\"https://www.luogu.org/problemnew/show/T47720\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p>自己出的第一道<del>毒瘤</del>数论题。</p>\n<p>对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\\notin B$且$i+1\\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为</p>\n<script type=\"math/tex; mode=display\">\\frac{\\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p>\n<script type=\"math/tex; mode=display\">\\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote>\n<p>Updated on 2018-10-10</p>\n<p>之前公式写错了，分子上的$m$全都漏掉了（</p>\n<p>以及，我们还可以将上式继续整理：</p>\n<script type=\"math/tex; mode=display\">\\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现<code>#ifdef</code>真没用也可能是我太菜了（</del></p>\n<blockquote>\n<p>Updated on 2018-10-16</p>\n<p>好吧我当时并不会用<code>#ifdef</code>（</p>\n</blockquote>\n<p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了$1861\\text{ms}$，最慢的一个点只跑了$300\\text{ms}$不到。截至本日，另外两个切掉这道题的$\\text{dalao}$最慢的一个点也只跑了$400\\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点$500\\text{ms}$，是我们机房的电脑太菜了吗（</del></p>\n</blockquote>\n<p>于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。</p>\n<p>但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/T47720\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p>自己出的第一道<del>毒瘤</del>数论题。</p>\n<p>对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\\notin B$且$i+1\\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为</p>\n<script type=\"math/tex; mode=display\">\\frac{\\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p>\n<script type=\"math/tex; mode=display\">\\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote>\n<p>Updated on 2018-10-10</p>\n<p>之前公式写错了，分子上的$m$全都漏掉了（</p>\n<p>以及，我们还可以将上式继续整理：</p>\n<script type=\"math/tex; mode=display\">\\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现<code>#ifdef</code>真没用也可能是我太菜了（</del></p>\n<blockquote>\n<p>Updated on 2018-10-16</p>\n<p>好吧我当时并不会用<code>#ifdef</code>（</p>\n</blockquote>\n<p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了$1861\\text{ms}$，最慢的一个点只跑了$300\\text{ms}$不到。截至本日，另外两个切掉这道题的$\\text{dalao}$最慢的一个点也只跑了$400\\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点$500\\text{ms}$，是我们机房的电脑太菜了吗（</del></p>\n</blockquote>\n<p>于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。</p>\n<p>但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……</p>"},{"title":"「Luogu-P3924」康娜的线段树","date":"2018-09-29T08:20:16.000Z","mathjax":true,"_content":"[传送门](https://www.luogu.org/problemnew/show/P3924)\n\n<!-- more -->\n\n读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：\n\n> 对于$70\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{5}$。\n>\n> 对于$100\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{6}$。\n\n~~也就是说，上述做法__最多__只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。~~\n\n> Updated on 2018-10-09\n>\n> 不好意思时间复杂度算错了我太菜了。\n>\n> 但反正线段树需要卡常才能过（\n\n我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。\n\n定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。\n\n稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。\n\n以及，最后一句话。\n\n这道题卡精度。\n","source":"_posts/2018-09-29-luogu-p3924-solution.md","raw":"---\ntitle: 「Luogu-P3924」康娜的线段树\ndate: 2018-09-29 16:20:16\ntags:\n  - 洛谷\n  - 差分\ncategories:\n  - 题解\nmathjax: true\n---\n[传送门](https://www.luogu.org/problemnew/show/P3924)\n\n<!-- more -->\n\n读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：\n\n> 对于$70\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{5}$。\n>\n> 对于$100\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{6}$。\n\n~~也就是说，上述做法__最多__只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。~~\n\n> Updated on 2018-10-09\n>\n> 不好意思时间复杂度算错了我太菜了。\n>\n> 但反正线段树需要卡常才能过（\n\n我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。\n\n定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。\n\n稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。\n\n以及，最后一句话。\n\n这道题卡精度。\n","slug":"luogu-p3924-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpuk000734cwcl9j5wjj","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P3924\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p>\n<blockquote>\n<p>对于$70\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{5}$。</p>\n<p>对于$100\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{6}$。</p>\n</blockquote>\n<p><del>也就是说，上述做法<strong>最多</strong>只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。</del></p>\n<blockquote>\n<p>Updated on 2018-10-09</p>\n<p>不好意思时间复杂度算错了我太菜了。</p>\n<p>但反正线段树需要卡常才能过（</p>\n</blockquote>\n<p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p>\n<p>定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。</p>\n<p>稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。</p>\n<p>以及，最后一句话。</p>\n<p>这道题卡精度。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P3924\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p>\n<blockquote>\n<p>对于$70\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{5}$。</p>\n<p>对于$100\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{6}$。</p>\n</blockquote>\n<p><del>也就是说，上述做法<strong>最多</strong>只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。</del></p>\n<blockquote>\n<p>Updated on 2018-10-09</p>\n<p>不好意思时间复杂度算错了我太菜了。</p>\n<p>但反正线段树需要卡常才能过（</p>\n</blockquote>\n<p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p>\n<p>定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。</p>\n<p>稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。</p>\n<p>以及，最后一句话。</p>\n<p>这道题卡精度。</p>"},{"title":"「Luogu-P4900」食堂","date":"2018-10-04T04:11:18.000Z","mathjax":true,"_content":"[传送门](https://www.luogu.org/problemnew/show/P4900)\n\n<!-- more -->\n\n~~闲着没事写篇题解（~~\n\n简单来说，就是要求\n\n$$\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\pmod{998244353}$$\n\n其中$\\lbrace x\\rbrace$表示取$x$的小数部分。\n\n稍加思索，我们不难发现\n\n$$\\begin{aligned}\n&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\\\\n\\equiv&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\\\\n\\equiv&\\sum\\limits_{i=1}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}-\\sum\\limits_{i=1}^{A-1}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\n\\pmod{998244353}\n\\end{aligned}$$\n\n因此，我们只需要关注下式的值\n\n$$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\pmod{998244353}$$\n\n我们可以参考一下[这道题](https://www.luogu.org/problemnew/show/P3708)\n\n在这道题中，我们定义了\n\n$$f(x)=\\sum\\limits_{i=1}^{n}x\\%i$$\n\n首先，如果不考虑$x\\%i=0$的情况，我们有\n\n$$x\\%i=(x-1)\\%i+1$$\n\n$$f(x)=f(x-1)+n$$\n\n如果$x\\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此\n\n$$f(x)=f(x-1)+n-\\sigma(x)$$\n\n我们可以类似地定义\n\n$$g(x)=\\sum\\limits_{i=1}^{n}x\\%i\\times i^{-1}\\pmod{998244353}$$\n\n$$h(x)=\\sum\\limits_{i\\mid x}i\\times i^{-1}\\equiv\\sum\\limits_{i\\mid x}1\\equiv d(x)\\pmod{998244353}$$\n\n从而我们有\n\n$$g(x)\\equiv g(x-1)+\\sum\\limits_{i=1}^{n}i^{-1}-d(x)\\pmod{998244353}$$\n\n然而我们需要的是\n\n$$\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}$$\n\n其中\n\n$$ans(x)=\\sum\\limits_{i=1}^{x}x\\%i\\times i^{-1}\\pmod{998244353}$$\n\n不难发现当$i<j$时$i\\%j=i$，从而\n\n$$\\begin{aligned}\n&g(x)-ans(x)\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\%i\\times i^{-1}\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\times i^{-1}\n\\pmod{998244353}\n\\end{aligned}$$\n\n最终，我们得到\n\n$$ans(x)\\equiv g(x)-x\\sum\\limits_{i=x+1}^{n}i^{-1}$$\n\n$$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\equiv\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}$$\n\n把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。\n","source":"_posts/2018-10-04-luogu-p4900-solution.md","raw":"---\ntitle: 「Luogu-P4900」食堂\ndate: 2018-10-04 12:11:18\ntags:\n  - 洛谷\n  - 数论\ncategories:\n  - 题解\nmathjax: true\n---\n[传送门](https://www.luogu.org/problemnew/show/P4900)\n\n<!-- more -->\n\n~~闲着没事写篇题解（~~\n\n简单来说，就是要求\n\n$$\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\pmod{998244353}$$\n\n其中$\\lbrace x\\rbrace$表示取$x$的小数部分。\n\n稍加思索，我们不难发现\n\n$$\\begin{aligned}\n&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\\\\n\\equiv&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\\\\n\\equiv&\\sum\\limits_{i=1}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}-\\sum\\limits_{i=1}^{A-1}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\n\\pmod{998244353}\n\\end{aligned}$$\n\n因此，我们只需要关注下式的值\n\n$$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\pmod{998244353}$$\n\n我们可以参考一下[这道题](https://www.luogu.org/problemnew/show/P3708)\n\n在这道题中，我们定义了\n\n$$f(x)=\\sum\\limits_{i=1}^{n}x\\%i$$\n\n首先，如果不考虑$x\\%i=0$的情况，我们有\n\n$$x\\%i=(x-1)\\%i+1$$\n\n$$f(x)=f(x-1)+n$$\n\n如果$x\\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此\n\n$$f(x)=f(x-1)+n-\\sigma(x)$$\n\n我们可以类似地定义\n\n$$g(x)=\\sum\\limits_{i=1}^{n}x\\%i\\times i^{-1}\\pmod{998244353}$$\n\n$$h(x)=\\sum\\limits_{i\\mid x}i\\times i^{-1}\\equiv\\sum\\limits_{i\\mid x}1\\equiv d(x)\\pmod{998244353}$$\n\n从而我们有\n\n$$g(x)\\equiv g(x-1)+\\sum\\limits_{i=1}^{n}i^{-1}-d(x)\\pmod{998244353}$$\n\n然而我们需要的是\n\n$$\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}$$\n\n其中\n\n$$ans(x)=\\sum\\limits_{i=1}^{x}x\\%i\\times i^{-1}\\pmod{998244353}$$\n\n不难发现当$i<j$时$i\\%j=i$，从而\n\n$$\\begin{aligned}\n&g(x)-ans(x)\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\%i\\times i^{-1}\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\times i^{-1}\n\\pmod{998244353}\n\\end{aligned}$$\n\n最终，我们得到\n\n$$ans(x)\\equiv g(x)-x\\sum\\limits_{i=x+1}^{n}i^{-1}$$\n\n$$\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\equiv\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}$$\n\n把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。\n","slug":"luogu-p4900-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpum000934cw3y7bb2vy","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P4900\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p><del>闲着没事写篇题解（</del></p>\n<p>简单来说，就是要求</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\pmod{998244353}</script><p>其中$\\lbrace x\\rbrace$表示取$x$的小数部分。</p>\n<p>稍加思索，我们不难发现</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\\\\n\\equiv&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\\\\n\\equiv&\\sum\\limits_{i=1}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}-\\sum\\limits_{i=1}^{A-1}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\n\\pmod{998244353}\n\\end{aligned}</script><p>因此，我们只需要关注下式的值</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\pmod{998244353}</script><p>我们可以参考一下<a href=\"https://www.luogu.org/problemnew/show/P3708\" target=\"_blank\" rel=\"noopener\">这道题</a></p>\n<p>在这道题中，我们定义了</p>\n<script type=\"math/tex; mode=display\">f(x)=\\sum\\limits_{i=1}^{n}x\\%i</script><p>首先，如果不考虑$x\\%i=0$的情况，我们有</p>\n<script type=\"math/tex; mode=display\">x\\%i=(x-1)\\%i+1</script><script type=\"math/tex; mode=display\">f(x)=f(x-1)+n</script><p>如果$x\\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此</p>\n<script type=\"math/tex; mode=display\">f(x)=f(x-1)+n-\\sigma(x)</script><p>我们可以类似地定义</p>\n<script type=\"math/tex; mode=display\">g(x)=\\sum\\limits_{i=1}^{n}x\\%i\\times i^{-1}\\pmod{998244353}</script><script type=\"math/tex; mode=display\">h(x)=\\sum\\limits_{i\\mid x}i\\times i^{-1}\\equiv\\sum\\limits_{i\\mid x}1\\equiv d(x)\\pmod{998244353}</script><p>从而我们有</p>\n<script type=\"math/tex; mode=display\">g(x)\\equiv g(x-1)+\\sum\\limits_{i=1}^{n}i^{-1}-d(x)\\pmod{998244353}</script><p>然而我们需要的是</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">ans(x)=\\sum\\limits_{i=1}^{x}x\\%i\\times i^{-1}\\pmod{998244353}</script><p>不难发现当$i&lt;j$时$i\\%j=i$，从而</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&g(x)-ans(x)\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\%i\\times i^{-1}\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\times i^{-1}\n\\pmod{998244353}\n\\end{aligned}</script><p>最终，我们得到</p>\n<script type=\"math/tex; mode=display\">ans(x)\\equiv g(x)-x\\sum\\limits_{i=x+1}^{n}i^{-1}</script><script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\equiv\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P4900\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p><del>闲着没事写篇题解（</del></p>\n<p>简单来说，就是要求</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\pmod{998244353}</script><p>其中$\\lbrace x\\rbrace$表示取$x$的小数部分。</p>\n<p>稍加思索，我们不难发现</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\\\\n\\equiv&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\\\\n\\equiv&\\sum\\limits_{i=1}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}-\\sum\\limits_{i=1}^{A-1}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\n\\pmod{998244353}\n\\end{aligned}</script><p>因此，我们只需要关注下式的值</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\pmod{998244353}</script><p>我们可以参考一下<a href=\"https://www.luogu.org/problemnew/show/P3708\" target=\"_blank\" rel=\"noopener\">这道题</a></p>\n<p>在这道题中，我们定义了</p>\n<script type=\"math/tex; mode=display\">f(x)=\\sum\\limits_{i=1}^{n}x\\%i</script><p>首先，如果不考虑$x\\%i=0$的情况，我们有</p>\n<script type=\"math/tex; mode=display\">x\\%i=(x-1)\\%i+1</script><script type=\"math/tex; mode=display\">f(x)=f(x-1)+n</script><p>如果$x\\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此</p>\n<script type=\"math/tex; mode=display\">f(x)=f(x-1)+n-\\sigma(x)</script><p>我们可以类似地定义</p>\n<script type=\"math/tex; mode=display\">g(x)=\\sum\\limits_{i=1}^{n}x\\%i\\times i^{-1}\\pmod{998244353}</script><script type=\"math/tex; mode=display\">h(x)=\\sum\\limits_{i\\mid x}i\\times i^{-1}\\equiv\\sum\\limits_{i\\mid x}1\\equiv d(x)\\pmod{998244353}</script><p>从而我们有</p>\n<script type=\"math/tex; mode=display\">g(x)\\equiv g(x-1)+\\sum\\limits_{i=1}^{n}i^{-1}-d(x)\\pmod{998244353}</script><p>然而我们需要的是</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">ans(x)=\\sum\\limits_{i=1}^{x}x\\%i\\times i^{-1}\\pmod{998244353}</script><p>不难发现当$i&lt;j$时$i\\%j=i$，从而</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&g(x)-ans(x)\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\%i\\times i^{-1}\\\\\n\\equiv&\\sum\\limits_{i=x+1}^{n}x\\times i^{-1}\n\\pmod{998244353}\n\\end{aligned}</script><p>最终，我们得到</p>\n<script type=\"math/tex; mode=display\">ans(x)\\equiv g(x)-x\\sum\\limits_{i=x+1}^{n}i^{-1}</script><script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\equiv\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。</p>"},{"title":"「SDOI2009」虔诚的墓主人","date":"2018-10-12T03:28:50.000Z","mathjax":true,"_content":"[传送门](https://www.luogu.org/problemnew/show/P2154)\n\n<!-- more -->\n\n几个月前某学姐给我推荐的~~毒瘤~~题之一。然而我直到现在也只切掉两道~~，我真是太菜了~~。\n\n首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是\n\n$$C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}$$\n\n考虑到墓地不能和常青树重合，又有$k\\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为\n\n$$C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\\sum\\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})$$\n\n怎么快速地查询与修改后面那个$\\Sigma$所涉及到的值？树状数组啊~~当然如果您非要写些乱七八糟的数据结构也没人拦着您~~。\n\n坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。\n\n```cpp\n#include<cstdio>\n\nstruct NOIp{\n    unsigned long long RP,score;\n};\nNOIp NOIp2018;\n\nint main(){\n    for(;;){\n        NOIp2018.RP++;\n        NOIp2018.score++;\n    }\n    return 0;\n}\n```\n\n以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊~~但是我实在是太菜了~~qaq。\n","source":"_posts/2018-10-12-luogu-p2154-solution.md","raw":"---\ntitle: 「SDOI2009」虔诚的墓主人\ndate: 2018-10-12 11:28:50\ntags:\n  - SDOI\n  - 2009\n  - 离散化\n  - 树状数组\n  - 组合数学\ncategories:\n  - 题解\nmathjax: true\n---\n[传送门](https://www.luogu.org/problemnew/show/P2154)\n\n<!-- more -->\n\n几个月前某学姐给我推荐的~~毒瘤~~题之一。然而我直到现在也只切掉两道~~，我真是太菜了~~。\n\n首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是\n\n$$C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}$$\n\n考虑到墓地不能和常青树重合，又有$k\\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为\n\n$$C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\\sum\\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})$$\n\n怎么快速地查询与修改后面那个$\\Sigma$所涉及到的值？树状数组啊~~当然如果您非要写些乱七八糟的数据结构也没人拦着您~~。\n\n坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。\n\n```cpp\n#include<cstdio>\n\nstruct NOIp{\n    unsigned long long RP,score;\n};\nNOIp NOIp2018;\n\nint main(){\n    for(;;){\n        NOIp2018.RP++;\n        NOIp2018.score++;\n    }\n    return 0;\n}\n```\n\n以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊~~但是我实在是太菜了~~qaq。\n","slug":"luogu-p2154-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpun000a34cwomlc1pj0","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P2154\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p>\n<p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是</p>\n<script type=\"math/tex; mode=display\">C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有$k\\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p>\n<script type=\"math/tex; mode=display\">C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\\sum\\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个$\\Sigma$所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p>\n<p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">NOIp</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> RP,score;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">NOIp NOIp2018;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;;)&#123;</span><br><span class=\"line\">        NOIp2018.RP++;</span><br><span class=\"line\">        NOIp2018.score++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P2154\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p>\n<p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是</p>\n<script type=\"math/tex; mode=display\">C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有$k\\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p>\n<script type=\"math/tex; mode=display\">C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\\sum\\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个$\\Sigma$所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p>\n<p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p>\n<!--�0-->\n<p>以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>"},{"title":"Hello World","date":"2018-09-27T05:41:19.000Z","mathjax":true,"_content":"总算是搞出来了一个自己觉得海星的blog……\n","source":"_posts/2018-09-27-hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-09-27 13:41:19\ntags:\n  - 其它\ncategories:\n  - 未分类\nmathjax: true\n---\n总算是搞出来了一个自己觉得海星的blog……\n","slug":"hello-world","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpup000e34cwrxwpd9x7","content":"<p>总算是搞出来了一个自己觉得海星的blog……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>总算是搞出来了一个自己觉得海星的blog……</p>\n"},{"title":"状态压缩动态规划学习笔记","date":"2018-10-24T13:24:05.000Z","mathjax":true,"_content":"~~把标签和分类连在一起读就是标题了（~~\n\n~~好像上一篇珂朵莉树学习笔记也是这样（~~\n\n~~马上就要复赛了，但反正我已经退役预定了来颓blog吧。~~\n\n<!-- more -->\n\n首先我们来看一道例题，[「USACO06NOV」玉米田Corn Fields](https://www.luogu.org/problemnew/show/P1879)。\n\n首先，我们想到定义`f[i][...]`表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……`f[i][0/1]...(省略10个[0/1])...[0/1]`，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。\n\n但是等等……$13$维的状态……\n\n![](https://i.loli.net/2018/10/24/5bd07656b885a.jpg)\n\n注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。\n\n于是，现在我们定义`f[i][S]`表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义`a[i]`表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。`valid[S]`表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。`a[i]`在读入时就可以处理出来，至于`valid[S]`，我们可以通过这样的一个循环处理出来：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<(1<<m);++i)\n    valid[i]=valid[i>>1]&(~(i&(i>>1)&1));\n```\n\n{% endfold %}\n\n用人话来讲就是`[S是否合法]=[S>>1是否合法]&[S与S>>1的最后一位是否不同为1]`。\n\n在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是`(S|a[i])==a[i]&&valid[S]&&(S&S')==0`。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=0;i<(1<<m);++i)\n    if((i|a[1])==a[1]&&valid[i])\n        f[1][i]=1;\nfor(re int i=2;i<=n;++i)\n    for(re int j=0;j<(1<<m);++j)\n        if((j|a[i])==a[i]&&valid[j])\n            for(re int k=0;k<(1<<m);++k)\n                if((k|a[i-1])==a[i-1]&&valid[k]&&(k&j)==0)\n                    (f[i][j]+=f[i-1][k])%=mod;\n```\n\n{% endfold %}\n\n粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个`if`剪掉，因而实际运行跑得比谁都快（\n\n为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，[「NOI2001」炮兵阵地](https://www.luogu.org/problemnew/show/P2704)。\n\n因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用`f[i][S1][S2]`表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录`a[i]`和`valid[S]`，不过，这次`valid[s]`的预处理过程差不多是这样：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<(1<<m);++i){\n    valid[i]=(i&1)?valid[i>>3]&((~i)>>2)&((~i)>>1):valid[i>>1];\n```\n\n{% endfold %}\n\n![](https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg)\n\n~~看起来~~有些~~非常~~复杂，用人话来讲就是……诶我当时是不是写错了（\n\n……不好像又没写错……\n\n好吧没写错。\n\n如果$S$的最后一位是$1$，则`[S是否合法]=[S>>3是否合法]&[S的倒数第2位和倒数第3位是否都为0]`，否则`[S是否合法]=[S>>1是否合法]`。\n\n因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<(1<<m);++i)\n    cnt[i]=cnt[i>>1]+(i&1);\n```\n\n{% endfold %}\n\n转移过程如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=0;i<(1<<m);++i)\n    if((i|a[1])==a[1]&&valid[i])\n        for(re int j=0;j<(1<<m);++j)\n            if((j|a[2])==a[2]&&valid[j]&&(i&j)==0)\n                    f[2][i][j]=cnt[i]+cnt[j];\nfor(re int i=3;i<=n;++i)\n    for(re int j=0;j<(1<<m);++j)\n        if((j|a[i-2])==a[i-2]&&valid[j])\n            for(re int k=0;k<(1<<m);++k)\n                if((k|a[i-1])==a[i-1]&&valid[k]&&(j&k)==0)\n                    for(re int l=0;l<(1<<m);++l)\n                        if((l|a[i])==a[i]&&valid[l]&&(l&j)==0&&(l&k)==0)\n                            f[i][k][l]=max(f[i][k][l],f[i-1][j][k]+cnt[l]);\n```\n\n{% endfold %}\n\n时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\\text{won't TLE})$（\n\n我们再来看一个状压的应用，[「SP3953」MMINPAID - Paid Roads](https://www.spoj.com/problems/MMINPAID/)，或者您也可以~~反正我就是~~在[洛谷](https://www.luogu.org/problemnew/show/SP3953)上提交。\n\n大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义`dis[u][S]`为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，`dis[v][S|(1<<(v-1))]=min(dis[v][S|(1<<(v-1))],dis[u][S]+cost)`，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。\n\n这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。\n\n~~我是不会说我把impossible打成Impossible然后交上去WA了一发的（~~\n\n一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\\leqslant 20$，就很有可能是状压题~~或者也有可能是神仙剪枝题~~。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。\n\n![](https://i.loli.net/2018/10/25/5bd13984b8601.jpg)\n\n以上，我觉得我的状压讲的差不多了（\n","source":"_posts/2018-10-24-status-compression-learning-notes.md","raw":"---\ntitle: 状态压缩动态规划学习笔记\ndate: 2018-10-24 21:24:05\ntags:\n  - 状态压缩\n  - 动态规划\ncategories:\n  - 学习笔记\nmathjax: true\n---\n~~把标签和分类连在一起读就是标题了（~~\n\n~~好像上一篇珂朵莉树学习笔记也是这样（~~\n\n~~马上就要复赛了，但反正我已经退役预定了来颓blog吧。~~\n\n<!-- more -->\n\n首先我们来看一道例题，[「USACO06NOV」玉米田Corn Fields](https://www.luogu.org/problemnew/show/P1879)。\n\n首先，我们想到定义`f[i][...]`表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……`f[i][0/1]...(省略10个[0/1])...[0/1]`，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。\n\n但是等等……$13$维的状态……\n\n![](https://i.loli.net/2018/10/24/5bd07656b885a.jpg)\n\n注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。\n\n于是，现在我们定义`f[i][S]`表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义`a[i]`表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。`valid[S]`表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。`a[i]`在读入时就可以处理出来，至于`valid[S]`，我们可以通过这样的一个循环处理出来：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<(1<<m);++i)\n    valid[i]=valid[i>>1]&(~(i&(i>>1)&1));\n```\n\n{% endfold %}\n\n用人话来讲就是`[S是否合法]=[S>>1是否合法]&[S与S>>1的最后一位是否不同为1]`。\n\n在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是`(S|a[i])==a[i]&&valid[S]&&(S&S')==0`。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=0;i<(1<<m);++i)\n    if((i|a[1])==a[1]&&valid[i])\n        f[1][i]=1;\nfor(re int i=2;i<=n;++i)\n    for(re int j=0;j<(1<<m);++j)\n        if((j|a[i])==a[i]&&valid[j])\n            for(re int k=0;k<(1<<m);++k)\n                if((k|a[i-1])==a[i-1]&&valid[k]&&(k&j)==0)\n                    (f[i][j]+=f[i-1][k])%=mod;\n```\n\n{% endfold %}\n\n粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个`if`剪掉，因而实际运行跑得比谁都快（\n\n为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，[「NOI2001」炮兵阵地](https://www.luogu.org/problemnew/show/P2704)。\n\n因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用`f[i][S1][S2]`表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录`a[i]`和`valid[S]`，不过，这次`valid[s]`的预处理过程差不多是这样：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<(1<<m);++i){\n    valid[i]=(i&1)?valid[i>>3]&((~i)>>2)&((~i)>>1):valid[i>>1];\n```\n\n{% endfold %}\n\n![](https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg)\n\n~~看起来~~有些~~非常~~复杂，用人话来讲就是……诶我当时是不是写错了（\n\n……不好像又没写错……\n\n好吧没写错。\n\n如果$S$的最后一位是$1$，则`[S是否合法]=[S>>3是否合法]&[S的倒数第2位和倒数第3位是否都为0]`，否则`[S是否合法]=[S>>1是否合法]`。\n\n因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<(1<<m);++i)\n    cnt[i]=cnt[i>>1]+(i&1);\n```\n\n{% endfold %}\n\n转移过程如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=0;i<(1<<m);++i)\n    if((i|a[1])==a[1]&&valid[i])\n        for(re int j=0;j<(1<<m);++j)\n            if((j|a[2])==a[2]&&valid[j]&&(i&j)==0)\n                    f[2][i][j]=cnt[i]+cnt[j];\nfor(re int i=3;i<=n;++i)\n    for(re int j=0;j<(1<<m);++j)\n        if((j|a[i-2])==a[i-2]&&valid[j])\n            for(re int k=0;k<(1<<m);++k)\n                if((k|a[i-1])==a[i-1]&&valid[k]&&(j&k)==0)\n                    for(re int l=0;l<(1<<m);++l)\n                        if((l|a[i])==a[i]&&valid[l]&&(l&j)==0&&(l&k)==0)\n                            f[i][k][l]=max(f[i][k][l],f[i-1][j][k]+cnt[l]);\n```\n\n{% endfold %}\n\n时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\\text{won't TLE})$（\n\n我们再来看一个状压的应用，[「SP3953」MMINPAID - Paid Roads](https://www.spoj.com/problems/MMINPAID/)，或者您也可以~~反正我就是~~在[洛谷](https://www.luogu.org/problemnew/show/SP3953)上提交。\n\n大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义`dis[u][S]`为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，`dis[v][S|(1<<(v-1))]=min(dis[v][S|(1<<(v-1))],dis[u][S]+cost)`，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。\n\n这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。\n\n~~我是不会说我把impossible打成Impossible然后交上去WA了一发的（~~\n\n一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\\leqslant 20$，就很有可能是状压题~~或者也有可能是神仙剪枝题~~。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。\n\n![](https://i.loli.net/2018/10/25/5bd13984b8601.jpg)\n\n以上，我觉得我的状压讲的差不多了（\n","slug":"status-compression-learning-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpus000f34cweapb71hb","content":"<p><del>把标签和分类连在一起读就是标题了（</del></p>\n<p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p>\n<p><del>马上就要复赛了，但反正我已经退役预定了来颓blog吧。</del></p>\n<a id=\"more\"></a>\n<p>首先我们来看一道例题，<a href=\"https://www.luogu.org/problemnew/show/P1879\" target=\"_blank\" rel=\"noopener\">「USACO06NOV」玉米田Corn Fields</a>。</p>\n<p>首先，我们想到定义<code>f[i][...]</code>表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...(省略10个[0/1])...[0/1]</code>，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。</p>\n<p>但是等等……$13$维的状态……</p>\n<p><img src=\"https://i.loli.net/2018/10/24/5bd07656b885a.jpg\" alt=\"\"></p>\n<p>注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。</p>\n<p>于是，现在我们定义<code>f[i][S]</code>表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义<code>a[i]</code>表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。<code>valid[S]</code>表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。<code>a[i]</code>在读入时就可以处理出来，至于<code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);++i)</span><br><span class=\"line\">    valid[i]=valid[i&gt;&gt;<span class=\"number\">1</span>]&amp;(~(i&amp;(i&gt;&gt;<span class=\"number\">1</span>)&amp;<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>用人话来讲就是<code>[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]</code>。</p>\n<p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是<code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((i|a[<span class=\"number\">1</span>])==a[<span class=\"number\">1</span>]&amp;&amp;valid[i])</span><br><span class=\"line\">        f[<span class=\"number\">1</span>][i]=<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=n;++i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;m);++j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((j|a[i])==a[i]&amp;&amp;valid[j])</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;(<span class=\"number\">1</span>&lt;&lt;m);++k)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((k|a[i<span class=\"number\">-1</span>])==a[i<span class=\"number\">-1</span>]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==<span class=\"number\">0</span>)</span><br><span class=\"line\">                    (f[i][j]+=f[i<span class=\"number\">-1</span>][k])%=mod;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个<code>if</code>剪掉，因而实际运行跑得比谁都快（</p>\n<p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href=\"https://www.luogu.org/problemnew/show/P2704\" target=\"_blank\" rel=\"noopener\">「NOI2001」炮兵阵地</a>。</p>\n<p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用<code>f[i][S1][S2]</code>表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录<code>a[i]</code>和<code>valid[S]</code>，不过，这次<code>valid[s]</code>的预处理过程差不多是这样：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);++i)&#123;</span><br><span class=\"line\">    valid[i]=(i&amp;<span class=\"number\">1</span>)?valid[i&gt;&gt;<span class=\"number\">3</span>]&amp;((~i)&gt;&gt;<span class=\"number\">2</span>)&amp;((~i)&gt;&gt;<span class=\"number\">1</span>):valid[i&gt;&gt;<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p><img src=\"https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg\" alt=\"\"></p>\n<p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p>\n<p>……不好像又没写错……</p>\n<p>好吧没写错。</p>\n<p>如果$S$的最后一位是$1$，则<code>[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]</code>，否则<code>[S是否合法]=[S&gt;&gt;1是否合法]</code>。</p>\n<p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);++i)</span><br><span class=\"line\">    cnt[i]=cnt[i&gt;&gt;<span class=\"number\">1</span>]+(i&amp;<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>转移过程如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;(<span class=\"number\">1</span>&lt;&lt;m);++i)</span><br><span class=\"line\">    <span class=\"keyword\">if</span>((i|a[<span class=\"number\">1</span>])==a[<span class=\"number\">1</span>]&amp;&amp;valid[i])</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;m);++j)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>((j|a[<span class=\"number\">2</span>])==a[<span class=\"number\">2</span>]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==<span class=\"number\">0</span>)</span><br><span class=\"line\">                    f[<span class=\"number\">2</span>][i][j]=cnt[i]+cnt[j];</span><br><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">3</span>;i&lt;=n;++i)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;(<span class=\"number\">1</span>&lt;&lt;m);++j)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>((j|a[i<span class=\"number\">-2</span>])==a[i<span class=\"number\">-2</span>]&amp;&amp;valid[j])</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;(<span class=\"number\">1</span>&lt;&lt;m);++k)</span><br><span class=\"line\">                <span class=\"keyword\">if</span>((k|a[i<span class=\"number\">-1</span>])==a[i<span class=\"number\">-1</span>]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==<span class=\"number\">0</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> l=<span class=\"number\">0</span>;l&lt;(<span class=\"number\">1</span>&lt;&lt;m);++l)</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==<span class=\"number\">0</span>&amp;&amp;(l&amp;k)==<span class=\"number\">0</span>)</span><br><span class=\"line\">                            f[i][k][l]=max(f[i][k][l],f[i<span class=\"number\">-1</span>][j][k]+cnt[l]);</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\\text{won’t TLE})$（</p>\n<p>我们再来看一个状压的应用，<a href=\"https://www.spoj.com/problems/MMINPAID/\" target=\"_blank\" rel=\"noopener\">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href=\"https://www.luogu.org/problemnew/show/SP3953\" target=\"_blank\" rel=\"noopener\">洛谷</a>上提交。</p>\n<p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义<code>dis[u][S]</code>为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。</p>\n<p>这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p>\n<p><del>我是不会说我把impossible打成Impossible然后交上去WA了一发的（</del></p>\n<p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p>\n<p><img src=\"https://i.loli.net/2018/10/25/5bd13984b8601.jpg\" alt=\"\"></p>\n<p>以上，我觉得我的状压讲的差不多了（</p>\n","site":{"data":{}},"excerpt":"<p><del>把标签和分类连在一起读就是标题了（</del></p>\n<p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p>\n<p><del>马上就要复赛了，但反正我已经退役预定了来颓blog吧。</del></p>","more":"<p>首先我们来看一道例题，<a href=\"https://www.luogu.org/problemnew/show/P1879\" target=\"_blank\" rel=\"noopener\">「USACO06NOV」玉米田Corn Fields</a>。</p>\n<p>首先，我们想到定义<code>f[i][...]</code>表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...(省略10个[0/1])...[0/1]</code>，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。</p>\n<p>但是等等……$13$维的状态……</p>\n<p><img src=\"https://i.loli.net/2018/10/24/5bd07656b885a.jpg\" alt=\"\"></p>\n<p>注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。</p>\n<p>于是，现在我们定义<code>f[i][S]</code>表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义<code>a[i]</code>表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。<code>valid[S]</code>表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。<code>a[i]</code>在读入时就可以处理出来，至于<code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�1-->\n\n</div></div>\n<p>用人话来讲就是<code>[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]</code>。</p>\n<p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是<code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�2-->\n\n</div></div>\n<p>粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个<code>if</code>剪掉，因而实际运行跑得比谁都快（</p>\n<p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href=\"https://www.luogu.org/problemnew/show/P2704\" target=\"_blank\" rel=\"noopener\">「NOI2001」炮兵阵地</a>。</p>\n<p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用<code>f[i][S1][S2]</code>表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录<code>a[i]</code>和<code>valid[S]</code>，不过，这次<code>valid[s]</code>的预处理过程差不多是这样：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�3-->\n\n</div></div>\n<p><img src=\"https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg\" alt=\"\"></p>\n<p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p>\n<p>……不好像又没写错……</p>\n<p>好吧没写错。</p>\n<p>如果$S$的最后一位是$1$，则<code>[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]</code>，否则<code>[S是否合法]=[S&gt;&gt;1是否合法]</code>。</p>\n<p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�4-->\n\n</div></div>\n<p>转移过程如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�5-->\n\n</div></div>\n<p>时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\\text{won’t TLE})$（</p>\n<p>我们再来看一个状压的应用，<a href=\"https://www.spoj.com/problems/MMINPAID/\" target=\"_blank\" rel=\"noopener\">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href=\"https://www.luogu.org/problemnew/show/SP3953\" target=\"_blank\" rel=\"noopener\">洛谷</a>上提交。</p>\n<p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义<code>dis[u][S]</code>为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。</p>\n<p>这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p>\n<p><del>我是不会说我把impossible打成Impossible然后交上去WA了一发的（</del></p>\n<p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p>\n<p><img src=\"https://i.loli.net/2018/10/25/5bd13984b8601.jpg\" alt=\"\"></p>\n<p>以上，我觉得我的状压讲的差不多了（</p>"},{"title":"「NOIp2018游记」夢の終わるところ","date":"2018-11-09T01:40:45.000Z","mathjax":true,"_content":"~~€€£：禁赛警告。~~\n\n<!-- more -->\n\n# Day 0\n\n自从一周前放假回来以后，我就开始一颓不振：\n\n![](https://i.loli.net/2018/11/09/5be4e6d8c122f.png)\n\n明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废~~，同时看着其他dalao随手切神仙题~~。然后我看到yemdalao写了一篇[NOIp2018~~禁赛记~~游记](https://www.cnblogs.com/taduro/p/9933329.html)~~，想着禁赛真有趣~~，我就写下了这篇游记。\n\n> 其他dalao都在机房补文化课而我在颓blog（\n>\n> 于是，此处以下，Updated on 2018-11-12。\n>\n> > Updated on 2018-11-14\n> >\n> > 看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。\n> >\n> > 但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃\n\n中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。\n\n然后一抽考场发现是外校，赛前先`rp--`。\n\n然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（\n\n下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（\n\n除那之外就没啥了，算是颓了一个下午。\n\n晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（\n\n试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。\n\n反正板子是不可能打炸的，这辈子都不可能的。\n\n因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。\n\n# Day 1\n\n早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。\n\n然后一打开E盘发现被清了，只有题目。\n\nDay1的解压密码是不是就我一个人不懂啊（\n\n那么于是，到了8：30，我点开今天的题目，定神一看……\n\n## [T1](https://www.luogu.org/problemnew/show/P5019)\n\n智障单调栈，有不开数组的做法，不过我懒得细想了，反正`score+=100`。\n\n## [T2](https://www.luogu.org/problemnew/show/P5020)\n\n稍微想一想不难想到完全背包，`score+=100`。\n\n## [T3](https://www.luogu.org/problemnew/show/P5021)\n\n神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。\n\n估分100+100+25=225。\n\n出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（\n\n前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（\n\n那我可真是太菜了（\n\n下午日常发呆，然后晚上是快乐的颓废时间。\n\n中午买的零食一个下午就全吃完了（\n\n# Day 2\n\n早上莫名起不来，然后就没吃早饭。\n\n这次我东西是真的带全了（\n\nDay2的解压密码依然不懂，然后是今天的题目：\n\n## [T1](https://www.luogu.org/problemnew/show/P5022)\n\nNOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。\n\n现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点`std::sort`一遍。然后维护一个邻接矩阵处理断边（\n\n为什么不直接用邻接矩阵呢（\n\n## [T2](https://www.luogu.org/problemnew/show/P5023)\n\n神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（\n\n## [T3](https://www.luogu.org/problemnew/show/P5024)\n\n究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。\n\n估分100+65+44=204（不存在的，肯定比这个低）。\n\n这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……\n\n不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（\n\n好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……\n\n下午请假回家开心地颓废。\n\n# Extra Notes\n\n果然是等到NOIp结束后才更新的。\n\n以及，我比较菜，第一次写游记，写的~~可能~~一定很菜，所以……算了，告辞。\n\n> Updated on 2018-11-26\n>\n> 好像有些晚的更新。\n>\n> 出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（\n>\n> 具体成绩差不多是100+100+20+100+65+36=421。\n>\n> 以上。\n","source":"_posts/2018-11-09-noip-2018-notes.md","raw":"---\ntitle: 「NOIp2018游记」夢の終わるところ\ndate: 2018-11-09 09:40:45\ntags:\n  - NOIp\n  - 2018\ncategories:\n  - 游记\nmathjax: true\n---\n~~€€£：禁赛警告。~~\n\n<!-- more -->\n\n# Day 0\n\n自从一周前放假回来以后，我就开始一颓不振：\n\n![](https://i.loli.net/2018/11/09/5be4e6d8c122f.png)\n\n明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废~~，同时看着其他dalao随手切神仙题~~。然后我看到yemdalao写了一篇[NOIp2018~~禁赛记~~游记](https://www.cnblogs.com/taduro/p/9933329.html)~~，想着禁赛真有趣~~，我就写下了这篇游记。\n\n> 其他dalao都在机房补文化课而我在颓blog（\n>\n> 于是，此处以下，Updated on 2018-11-12。\n>\n> > Updated on 2018-11-14\n> >\n> > 看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。\n> >\n> > 但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃\n\n中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。\n\n然后一抽考场发现是外校，赛前先`rp--`。\n\n然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（\n\n下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（\n\n除那之外就没啥了，算是颓了一个下午。\n\n晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（\n\n试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。\n\n反正板子是不可能打炸的，这辈子都不可能的。\n\n因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。\n\n# Day 1\n\n早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。\n\n然后一打开E盘发现被清了，只有题目。\n\nDay1的解压密码是不是就我一个人不懂啊（\n\n那么于是，到了8：30，我点开今天的题目，定神一看……\n\n## [T1](https://www.luogu.org/problemnew/show/P5019)\n\n智障单调栈，有不开数组的做法，不过我懒得细想了，反正`score+=100`。\n\n## [T2](https://www.luogu.org/problemnew/show/P5020)\n\n稍微想一想不难想到完全背包，`score+=100`。\n\n## [T3](https://www.luogu.org/problemnew/show/P5021)\n\n神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。\n\n估分100+100+25=225。\n\n出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（\n\n前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（\n\n那我可真是太菜了（\n\n下午日常发呆，然后晚上是快乐的颓废时间。\n\n中午买的零食一个下午就全吃完了（\n\n# Day 2\n\n早上莫名起不来，然后就没吃早饭。\n\n这次我东西是真的带全了（\n\nDay2的解压密码依然不懂，然后是今天的题目：\n\n## [T1](https://www.luogu.org/problemnew/show/P5022)\n\nNOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。\n\n现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点`std::sort`一遍。然后维护一个邻接矩阵处理断边（\n\n为什么不直接用邻接矩阵呢（\n\n## [T2](https://www.luogu.org/problemnew/show/P5023)\n\n神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（\n\n## [T3](https://www.luogu.org/problemnew/show/P5024)\n\n究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。\n\n估分100+65+44=204（不存在的，肯定比这个低）。\n\n这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……\n\n不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（\n\n好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……\n\n下午请假回家开心地颓废。\n\n# Extra Notes\n\n果然是等到NOIp结束后才更新的。\n\n以及，我比较菜，第一次写游记，写的~~可能~~一定很菜，所以……算了，告辞。\n\n> Updated on 2018-11-26\n>\n> 好像有些晚的更新。\n>\n> 出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（\n>\n> 具体成绩差不多是100+100+20+100+65+36=421。\n>\n> 以上。\n","slug":"noip-2018-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpuv000k34cwt0p6k7ii","content":"<p><del>€€£：禁赛警告。</del></p>\n<a id=\"more\"></a>\n<h1 id=\"Day-0\"><a href=\"#Day-0\" class=\"headerlink\" title=\"Day 0\"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p>\n<p><img src=\"https://i.loli.net/2018/11/09/5be4e6d8c122f.png\" alt=\"\"></p>\n<p>明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废<del>，同时看着其他dalao随手切神仙题</del>。然后我看到yemdalao写了一篇<a href=\"https://www.cnblogs.com/taduro/p/9933329.html\" target=\"_blank\" rel=\"noopener\">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p>\n<blockquote>\n<p>其他dalao都在机房补文化课而我在颓blog（</p>\n<p>于是，此处以下，Updated on 2018-11-12。</p>\n<blockquote>\n<p>Updated on 2018-11-14</p>\n<p>看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。</p>\n<p>但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p>\n</blockquote>\n</blockquote>\n<p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。</p>\n<p>然后一抽考场发现是外校，赛前先<code>rp--</code>。</p>\n<p>然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（</p>\n<p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（</p>\n<p>除那之外就没啥了，算是颓了一个下午。</p>\n<p>晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（</p>\n<p>试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。</p>\n<p>反正板子是不可能打炸的，这辈子都不可能的。</p>\n<p>因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。</p>\n<h1 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。</p>\n<p>然后一打开E盘发现被清了，只有题目。</p>\n<p>Day1的解压密码是不是就我一个人不懂啊（</p>\n<p>那么于是，到了8：30，我点开今天的题目，定神一看……</p>\n<h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a><a href=\"https://www.luogu.org/problemnew/show/P5019\" target=\"_blank\" rel=\"noopener\">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正<code>score+=100</code>。</p>\n<h2 id=\"T2\"><a href=\"#T2\" class=\"headerlink\" title=\"T2\"></a><a href=\"https://www.luogu.org/problemnew/show/P5020\" target=\"_blank\" rel=\"noopener\">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p>\n<h2 id=\"T3\"><a href=\"#T3\" class=\"headerlink\" title=\"T3\"></a><a href=\"https://www.luogu.org/problemnew/show/P5021\" target=\"_blank\" rel=\"noopener\">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。</p>\n<p>估分100+100+25=225。</p>\n<p>出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（</p>\n<p>前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（</p>\n<p>那我可真是太菜了（</p>\n<p>下午日常发呆，然后晚上是快乐的颓废时间。</p>\n<p>中午买的零食一个下午就全吃完了（</p>\n<h1 id=\"Day-2\"><a href=\"#Day-2\" class=\"headerlink\" title=\"Day 2\"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p>\n<p>这次我东西是真的带全了（</p>\n<p>Day2的解压密码依然不懂，然后是今天的题目：</p>\n<h2 id=\"T1-1\"><a href=\"#T1-1\" class=\"headerlink\" title=\"T1\"></a><a href=\"https://www.luogu.org/problemnew/show/P5022\" target=\"_blank\" rel=\"noopener\">T1</a></h2><p>NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。</p>\n<p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点<code>std::sort</code>一遍。然后维护一个邻接矩阵处理断边（</p>\n<p>为什么不直接用邻接矩阵呢（</p>\n<h2 id=\"T2-1\"><a href=\"#T2-1\" class=\"headerlink\" title=\"T2\"></a><a href=\"https://www.luogu.org/problemnew/show/P5023\" target=\"_blank\" rel=\"noopener\">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（</p>\n<h2 id=\"T3-1\"><a href=\"#T3-1\" class=\"headerlink\" title=\"T3\"></a><a href=\"https://www.luogu.org/problemnew/show/P5024\" target=\"_blank\" rel=\"noopener\">T3</a></h2><p>究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。</p>\n<p>估分100+65+44=204（不存在的，肯定比这个低）。</p>\n<p>这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……</p>\n<p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p>\n<p>好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……</p>\n<p>下午请假回家开心地颓废。</p>\n<h1 id=\"Extra-Notes\"><a href=\"#Extra-Notes\" class=\"headerlink\" title=\"Extra Notes\"></a>Extra Notes</h1><p>果然是等到NOIp结束后才更新的。</p>\n<p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p>\n<blockquote>\n<p>Updated on 2018-11-26</p>\n<p>好像有些晚的更新。</p>\n<p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p>\n<p>具体成绩差不多是100+100+20+100+65+36=421。</p>\n<p>以上。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><del>€€£：禁赛警告。</del></p>","more":"<h1 id=\"Day-0\"><a href=\"#Day-0\" class=\"headerlink\" title=\"Day 0\"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p>\n<p><img src=\"https://i.loli.net/2018/11/09/5be4e6d8c122f.png\" alt=\"\"></p>\n<p>明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废<del>，同时看着其他dalao随手切神仙题</del>。然后我看到yemdalao写了一篇<a href=\"https://www.cnblogs.com/taduro/p/9933329.html\" target=\"_blank\" rel=\"noopener\">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p>\n<blockquote>\n<p>其他dalao都在机房补文化课而我在颓blog（</p>\n<p>于是，此处以下，Updated on 2018-11-12。</p>\n<blockquote>\n<p>Updated on 2018-11-14</p>\n<p>看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。</p>\n<p>但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p>\n</blockquote>\n</blockquote>\n<p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。</p>\n<p>然后一抽考场发现是外校，赛前先<code>rp--</code>。</p>\n<p>然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（</p>\n<p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（</p>\n<p>除那之外就没啥了，算是颓了一个下午。</p>\n<p>晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（</p>\n<p>试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。</p>\n<p>反正板子是不可能打炸的，这辈子都不可能的。</p>\n<p>因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。</p>\n<h1 id=\"Day-1\"><a href=\"#Day-1\" class=\"headerlink\" title=\"Day 1\"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。</p>\n<p>然后一打开E盘发现被清了，只有题目。</p>\n<p>Day1的解压密码是不是就我一个人不懂啊（</p>\n<p>那么于是，到了8：30，我点开今天的题目，定神一看……</p>\n<h2 id=\"T1\"><a href=\"#T1\" class=\"headerlink\" title=\"T1\"></a><a href=\"https://www.luogu.org/problemnew/show/P5019\" target=\"_blank\" rel=\"noopener\">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正<code>score+=100</code>。</p>\n<h2 id=\"T2\"><a href=\"#T2\" class=\"headerlink\" title=\"T2\"></a><a href=\"https://www.luogu.org/problemnew/show/P5020\" target=\"_blank\" rel=\"noopener\">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p>\n<h2 id=\"T3\"><a href=\"#T3\" class=\"headerlink\" title=\"T3\"></a><a href=\"https://www.luogu.org/problemnew/show/P5021\" target=\"_blank\" rel=\"noopener\">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。</p>\n<p>估分100+100+25=225。</p>\n<p>出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（</p>\n<p>前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（</p>\n<p>那我可真是太菜了（</p>\n<p>下午日常发呆，然后晚上是快乐的颓废时间。</p>\n<p>中午买的零食一个下午就全吃完了（</p>\n<h1 id=\"Day-2\"><a href=\"#Day-2\" class=\"headerlink\" title=\"Day 2\"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p>\n<p>这次我东西是真的带全了（</p>\n<p>Day2的解压密码依然不懂，然后是今天的题目：</p>\n<h2 id=\"T1-1\"><a href=\"#T1-1\" class=\"headerlink\" title=\"T1\"></a><a href=\"https://www.luogu.org/problemnew/show/P5022\" target=\"_blank\" rel=\"noopener\">T1</a></h2><p>NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。</p>\n<p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点<code>std::sort</code>一遍。然后维护一个邻接矩阵处理断边（</p>\n<p>为什么不直接用邻接矩阵呢（</p>\n<h2 id=\"T2-1\"><a href=\"#T2-1\" class=\"headerlink\" title=\"T2\"></a><a href=\"https://www.luogu.org/problemnew/show/P5023\" target=\"_blank\" rel=\"noopener\">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（</p>\n<h2 id=\"T3-1\"><a href=\"#T3-1\" class=\"headerlink\" title=\"T3\"></a><a href=\"https://www.luogu.org/problemnew/show/P5024\" target=\"_blank\" rel=\"noopener\">T3</a></h2><p>究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。</p>\n<p>估分100+65+44=204（不存在的，肯定比这个低）。</p>\n<p>这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……</p>\n<p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p>\n<p>好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……</p>\n<p>下午请假回家开心地颓废。</p>\n<h1 id=\"Extra-Notes\"><a href=\"#Extra-Notes\" class=\"headerlink\" title=\"Extra Notes\"></a>Extra Notes</h1><p>果然是等到NOIp结束后才更新的。</p>\n<p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p>\n<blockquote>\n<p>Updated on 2018-11-26</p>\n<p>好像有些晚的更新。</p>\n<p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p>\n<p>具体成绩差不多是100+100+20+100+65+36=421。</p>\n<p>以上。</p>\n</blockquote>"},{"title":"关于最优化分块时间复杂度的研究报告","date":"2018-12-19T12:19:18.000Z","mathjax":true,"_content":"最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。\n\n<!-- more -->\n\n假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\\text{A}x+\\text{B}y$。根据均值不等式\n\n$$\\cfrac{1}{2}(x+y)\\geqslant\\sqrt{xy}$$\n\n我们有\n\n$$\\text{A}x+\\text{B}y\\geqslant2\\sqrt{\\text{AB}n}$$\n\n当且仅当$x=\\sqrt{\\cfrac{\\text{B}}{\\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\\sqrt{\\text{AB}n})$。\n\n以上。\n","source":"_posts/2018-12-19-sqrt-decomposition-complexity-optimization.md","raw":"---\ntitle: 关于最优化分块时间复杂度的研究报告\ndate: 2018-12-19 20:19:18\ntags:\n  - 分块\ncategories:\n  - 研究报告\nmathjax: true\n---\n最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。\n\n<!-- more -->\n\n假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\\text{A}x+\\text{B}y$。根据均值不等式\n\n$$\\cfrac{1}{2}(x+y)\\geqslant\\sqrt{xy}$$\n\n我们有\n\n$$\\text{A}x+\\text{B}y\\geqslant2\\sqrt{\\text{AB}n}$$\n\n当且仅当$x=\\sqrt{\\cfrac{\\text{B}}{\\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\\sqrt{\\text{AB}n})$。\n\n以上。\n","slug":"sqrt-decomposition-complexity-optimization","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpuw000l34cw8xrxmsfo","content":"<p>最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。</p>\n<a id=\"more\"></a>\n<p>假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\\text{A}x+\\text{B}y$。根据均值不等式</p>\n<script type=\"math/tex; mode=display\">\\cfrac{1}{2}(x+y)\\geqslant\\sqrt{xy}</script><p>我们有</p>\n<script type=\"math/tex; mode=display\">\\text{A}x+\\text{B}y\\geqslant2\\sqrt{\\text{AB}n}</script><p>当且仅当$x=\\sqrt{\\cfrac{\\text{B}}{\\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\\sqrt{\\text{AB}n})$。</p>\n<p>以上。</p>\n","site":{"data":{}},"excerpt":"<p>最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。</p>","more":"<p>假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\\text{A}x+\\text{B}y$。根据均值不等式</p>\n<script type=\"math/tex; mode=display\">\\cfrac{1}{2}(x+y)\\geqslant\\sqrt{xy}</script><p>我们有</p>\n<script type=\"math/tex; mode=display\">\\text{A}x+\\text{B}y\\geqslant2\\sqrt{\\text{AB}n}</script><p>当且仅当$x=\\sqrt{\\cfrac{\\text{B}}{\\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\\sqrt{\\text{AB}n})$。</p>\n<p>以上。</p>"},{"mathjax":true,"date":"2018-12-24T02:27:06.000Z","title":"关于块状分块的研究报告","password":"qwijfpw49qg][pl}_,rp","abstract":"该文章已被加密","message":"输入密码继续阅读","_content":"之前的机房珂学家发明的船新的数据结构。\n\nsto __Juan\\_feng__ orz\n\n<!-- more -->\n\n[模板题](https://www.luogu.org/problemnew/show/T64137)\n\n那么这道题怎么做呢？\n\n- 线段树！不好意思卡空间，只给了⑨分。\n- 树状数组！不好意思不保证乘的数有逆元，只给了59分。\n- 分块！不好意思复杂度太大，只给了3分~~，和暴力一个分~~。\n\n那么这道题怎么做呢？如标题所示，块状分块。\n\n就是说，我们先把原序列分成很多小块，然后再将这些小块分成大块。每次操作时分为大整块、小整块、小散块三部分考虑。\n\n假设说我们一个大块$\\text{A}$个数，一个小块$\\text{B}$个数，每次查询的时间复杂度就是\n\n$$O(\\cfrac{n}{\\text{A}}+\\cfrac{\\text{A}}{\\text{B}}+\\text{B})$$\n\n我们令\n\n$$x=\\cfrac{n}{\\text{A}}\\;\\;y=\\cfrac{\\text{A}}{\\text{B}}\\;\\;z=\\text{B}$$\n\n$$xyz=n$$\n\n$$\\begin{cases}\n&x+y\\geqslant 2\\sqrt{xy}\\\\\n&y+z\\geqslant 2\\sqrt{yz}\\\\\n&x+z\\geqslant 2\\sqrt{xz}\n\\end{cases}$$\n\n当\n\n$$x=y=z=n^{\\frac{1}{3}}$$\n\n时，以上三式均取等号，此时\n\n$$\\text{A}=n^{\\frac{2}{3}}\\;\\;\\text{B}=n^{\\frac{1}{3}}$$\n\n$$O(\\cfrac{n}{\\text{A}}+\\cfrac{\\text{A}}{\\text{B}}+\\text{B})=O(n^{\\frac{1}{3}})$$\n\n就是这样的一个神奇的数据结构。\n\n---\n\n胡扯开始。\n\n以上，我们通过套两层分块的方式将单次询问的时间复杂度从$O(\\sqrt{n})$砍到了$O(n^{\\frac{1}{3}})$也就是$O(\\sqrt[3]{n})$。我们猜想，如果说我们套$k$层分块，单次询问的时间复杂度就是$O(n^{\\frac{1}{k+1}})$，当$k$趋向于正无穷大时（？？？），我们就得到了一个单次询问$O(1)$的优秀数据结构（光速逃\n\n胡扯结束。\n\n---\n\n代码先不贴（\n","source":"_posts/2018-12-24-block-decomposition.md","raw":"---\nmathjax: true\ndate: 2018-12-24 10:27:06\ntitle: 关于块状分块的研究报告\ntags:\n  - 分块\n  - 块状分块\ncategories:\n  - 研究报告\npassword: qwijfpw49qg][pl}_,rp\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\n---\n之前的机房珂学家发明的船新的数据结构。\n\nsto __Juan\\_feng__ orz\n\n<!-- more -->\n\n[模板题](https://www.luogu.org/problemnew/show/T64137)\n\n那么这道题怎么做呢？\n\n- 线段树！不好意思卡空间，只给了⑨分。\n- 树状数组！不好意思不保证乘的数有逆元，只给了59分。\n- 分块！不好意思复杂度太大，只给了3分~~，和暴力一个分~~。\n\n那么这道题怎么做呢？如标题所示，块状分块。\n\n就是说，我们先把原序列分成很多小块，然后再将这些小块分成大块。每次操作时分为大整块、小整块、小散块三部分考虑。\n\n假设说我们一个大块$\\text{A}$个数，一个小块$\\text{B}$个数，每次查询的时间复杂度就是\n\n$$O(\\cfrac{n}{\\text{A}}+\\cfrac{\\text{A}}{\\text{B}}+\\text{B})$$\n\n我们令\n\n$$x=\\cfrac{n}{\\text{A}}\\;\\;y=\\cfrac{\\text{A}}{\\text{B}}\\;\\;z=\\text{B}$$\n\n$$xyz=n$$\n\n$$\\begin{cases}\n&x+y\\geqslant 2\\sqrt{xy}\\\\\n&y+z\\geqslant 2\\sqrt{yz}\\\\\n&x+z\\geqslant 2\\sqrt{xz}\n\\end{cases}$$\n\n当\n\n$$x=y=z=n^{\\frac{1}{3}}$$\n\n时，以上三式均取等号，此时\n\n$$\\text{A}=n^{\\frac{2}{3}}\\;\\;\\text{B}=n^{\\frac{1}{3}}$$\n\n$$O(\\cfrac{n}{\\text{A}}+\\cfrac{\\text{A}}{\\text{B}}+\\text{B})=O(n^{\\frac{1}{3}})$$\n\n就是这样的一个神奇的数据结构。\n\n---\n\n胡扯开始。\n\n以上，我们通过套两层分块的方式将单次询问的时间复杂度从$O(\\sqrt{n})$砍到了$O(n^{\\frac{1}{3}})$也就是$O(\\sqrt[3]{n})$。我们猜想，如果说我们套$k$层分块，单次询问的时间复杂度就是$O(n^{\\frac{1}{k+1}})$，当$k$趋向于正无穷大时（？？？），我们就得到了一个单次询问$O(1)$的优秀数据结构（光速逃\n\n胡扯结束。\n\n---\n\n代码先不贴（\n","slug":"block-decomposition","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpux000p34cw5l27g9bw","content":"<script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script>\n<div id=\"hbe-security\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" class=\"hbe-form-control\" id=\"pass\" placeholder=\"输入密码继续阅读\" />\n    <label for=\"pass\">输入密码继续阅读</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n</div>\n<div id=\"decryptionError\" style=\"display: none;\">Incorrect Password!</div>\n<div id=\"noContentError\" style=\"display: none;\">No content to display!</div>\n<div id=\"encrypt-blog\" style=\"display:none\">\n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\n</div>\n<script src=\"/lib/crypto-js.js\"></script><script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"该文章已被加密","more":"该文章已被加密","origin":"<p>之前的机房珂学家发明的船新的数据结构。</p>\n<p>sto <strong>Juan_feng</strong> orz</p>\n<a id=\"more\"></a>\n<p><a href=\"https://www.luogu.org/problemnew/show/T64137\" target=\"_blank\" rel=\"noopener\">模板题</a></p>\n<p>那么这道题怎么做呢？</p>\n<ul>\n<li>线段树！不好意思卡空间，只给了⑨分。</li>\n<li>树状数组！不好意思不保证乘的数有逆元，只给了59分。</li>\n<li>分块！不好意思复杂度太大，只给了3分<del>，和暴力一个分</del>。</li>\n</ul>\n<p>那么这道题怎么做呢？如标题所示，块状分块。</p>\n<p>就是说，我们先把原序列分成很多小块，然后再将这些小块分成大块。每次操作时分为大整块、小整块、小散块三部分考虑。</p>\n<p>假设说我们一个大块$\\text{A}$个数，一个小块$\\text{B}$个数，每次查询的时间复杂度就是</p>\n<script type=\"math/tex; mode=display\">O(\\cfrac{n}{\\text{A}}+\\cfrac{\\text{A}}{\\text{B}}+\\text{B})</script><p>我们令</p>\n<script type=\"math/tex; mode=display\">x=\\cfrac{n}{\\text{A}}\\;\\;y=\\cfrac{\\text{A}}{\\text{B}}\\;\\;z=\\text{B}</script><script type=\"math/tex; mode=display\">xyz=n</script><script type=\"math/tex; mode=display\">\\begin{cases}\n&x+y\\geqslant 2\\sqrt{xy}\\\\\n&y+z\\geqslant 2\\sqrt{yz}\\\\\n&x+z\\geqslant 2\\sqrt{xz}\n\\end{cases}</script><p>当</p>\n<script type=\"math/tex; mode=display\">x=y=z=n^{\\frac{1}{3}}</script><p>时，以上三式均取等号，此时</p>\n<script type=\"math/tex; mode=display\">\\text{A}=n^{\\frac{2}{3}}\\;\\;\\text{B}=n^{\\frac{1}{3}}</script><script type=\"math/tex; mode=display\">O(\\cfrac{n}{\\text{A}}+\\cfrac{\\text{A}}{\\text{B}}+\\text{B})=O(n^{\\frac{1}{3}})</script><p>就是这样的一个神奇的数据结构。</p>\n<hr>\n<p>胡扯开始。</p>\n<p>以上，我们通过套两层分块的方式将单次询问的时间复杂度从$O(\\sqrt{n})$砍到了$O(n^{\\frac{1}{3}})$也就是$O(\\sqrt[3]{n})$。我们猜想，如果说我们套$k$层分块，单次询问的时间复杂度就是$O(n^{\\frac{1}{k+1}})$，当$k$趋向于正无穷大时（？？？），我们就得到了一个单次询问$O(1)$的优秀数据结构（光速逃</p>\n<p>胡扯结束。</p>\n<hr>\n<p>代码先不贴（</p>\n","encrypt":true,"template":"<script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script>\n<div id=\"hbe-security\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" class=\"hbe-form-control\" id=\"pass\" placeholder=\"输入密码继续阅读\" />\n    <label for=\"pass\">输入密码继续阅读</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n</div>\n<div id=\"decryptionError\" style=\"display: none;\">Incorrect Password!</div>\n<div id=\"noContentError\" style=\"display: none;\">No content to display!</div>\n<div id=\"encrypt-blog\" style=\"display:none\">\n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\n</div>\n","decryptionError":"Incorrect Password!","noContentError":"No content to display!"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-02T08:43:53.000Z","title":"「Luogu-P5162」WD与积木","password":null,"_content":"9102年的第一篇blog。\n\n[传送门](https://www.luogu.org/problemnew/show/P5162)\n\n<!-- more -->\n\n大概算是我用NTT切的第一道非模板题。\n\n其实本来应该是[这道](http://codeforces.com/contest/438/problem/E)。不过调不出来了弃了。\n\n首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。\n\n首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程：\n\n$$G[n]=\\sum\\limits_{i=0}^{n}C_{n}^{i}G[n-i]$$\n\n但是这样对吗？\n\n代入$n=0$我们发现\n\n$$G[0]=C_{0}^{0}G[0]=G[0]$$\n\n![](https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg)\n\n注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。\n\n那然后$G[0]$应该等于几？\n\n$$G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1$$\n\n所以说$G[0]=1$。\n\n如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。\n\n再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开\n\n$$G[n]=n!\\sum\\limits_{i=0}^{n}\\cfrac{1}{i!}\\times\\cfrac{G[n-i]}{(n-i)!}$$\n\n定义\n\n$$H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}$$\n\n$$G[n]=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{G[n-i]}{(n-i)!}$$\n\n注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义\n\n$$G^{\\prime}[n]=\\cfrac{G[n]}{n!}$$\n\n就可以得到\n\n$$\\begin{aligned}\nG^{\\prime}[n]&=\\sum\\limits_{i=0}^{n}H[i]\\times G^{\\prime}[n-i]\\\\\nG^{\\prime}&=G^{\\prime}H+1\n\\end{aligned}$$\n\n注意不要忘了$+1$。因为很明显地$G^{\\prime}H[0]=0$，而$G^{\\prime}[0]=1$。\n\n然后我们就有\n\n$$G^{\\prime}=\\cfrac{1}{1-H}$$\n\n然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。\n\n首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此\n\n$$F[n]=G[n]+\\sum\\limits_{i=0}^{n}C_{n}^{i}F[n-i]$$\n\n然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（\n\n$$\n\\begin{aligned}\nF[n]&=G[n]+n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]}{(n-i)!}\\\\\n&=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\\\\nF^{\\prime}[n]&=\\cfrac{F[n]}{n!}\\\\\n&=\\sum\\limits_{i=0}^{n}H[i]\\times(F^{\\prime}[n-i]+G^{\\prime}[n-i])\\\\\nF^{\\prime}&=H(F^{\\prime}+G^{\\prime})\n\\end{aligned}$$\n\n不过这次我们就不需要$+1$了。\n\n解上面的方程，我们得到\n\n$$F^{\\prime}=\\cfrac{HG^{\\prime}}{1-H}=\\cfrac{G^{\\prime}}{(1-H)^{2}}$$\n\n然后我们总结一下\n\n$$H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}$$\n\n$$G^{\\prime}=\\cfrac{1}{1-H}$$\n\n$$F^{\\prime}=\\cfrac{G^{\\prime}}{(1-H)^{2}}$$\n\n最后的答案，也就是$n$块积木的期望层数，就是$\\cfrac{F[n]}{G[n]}$。然后不难发现$\\cfrac{F^{\\prime}[n]}{G^{\\prime}[n]}=\\cfrac{F[n]}{G[n]}$。\n\n我就是不贴代码（\n\n~~反正会的应该都能写出来了吧（~~\n","source":"_posts/2019-01-02-luogu-p5162-solution.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-02 16:43:53\ntitle: 「Luogu-P5162」WD与积木\ntags:\n  - NTT\ncategories:\n  - 题解\npassword:\n---\n9102年的第一篇blog。\n\n[传送门](https://www.luogu.org/problemnew/show/P5162)\n\n<!-- more -->\n\n大概算是我用NTT切的第一道非模板题。\n\n其实本来应该是[这道](http://codeforces.com/contest/438/problem/E)。不过调不出来了弃了。\n\n首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。\n\n首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程：\n\n$$G[n]=\\sum\\limits_{i=0}^{n}C_{n}^{i}G[n-i]$$\n\n但是这样对吗？\n\n代入$n=0$我们发现\n\n$$G[0]=C_{0}^{0}G[0]=G[0]$$\n\n![](https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg)\n\n注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。\n\n那然后$G[0]$应该等于几？\n\n$$G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1$$\n\n所以说$G[0]=1$。\n\n如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。\n\n再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开\n\n$$G[n]=n!\\sum\\limits_{i=0}^{n}\\cfrac{1}{i!}\\times\\cfrac{G[n-i]}{(n-i)!}$$\n\n定义\n\n$$H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}$$\n\n$$G[n]=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{G[n-i]}{(n-i)!}$$\n\n注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义\n\n$$G^{\\prime}[n]=\\cfrac{G[n]}{n!}$$\n\n就可以得到\n\n$$\\begin{aligned}\nG^{\\prime}[n]&=\\sum\\limits_{i=0}^{n}H[i]\\times G^{\\prime}[n-i]\\\\\nG^{\\prime}&=G^{\\prime}H+1\n\\end{aligned}$$\n\n注意不要忘了$+1$。因为很明显地$G^{\\prime}H[0]=0$，而$G^{\\prime}[0]=1$。\n\n然后我们就有\n\n$$G^{\\prime}=\\cfrac{1}{1-H}$$\n\n然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。\n\n首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此\n\n$$F[n]=G[n]+\\sum\\limits_{i=0}^{n}C_{n}^{i}F[n-i]$$\n\n然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（\n\n$$\n\\begin{aligned}\nF[n]&=G[n]+n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]}{(n-i)!}\\\\\n&=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\\\\nF^{\\prime}[n]&=\\cfrac{F[n]}{n!}\\\\\n&=\\sum\\limits_{i=0}^{n}H[i]\\times(F^{\\prime}[n-i]+G^{\\prime}[n-i])\\\\\nF^{\\prime}&=H(F^{\\prime}+G^{\\prime})\n\\end{aligned}$$\n\n不过这次我们就不需要$+1$了。\n\n解上面的方程，我们得到\n\n$$F^{\\prime}=\\cfrac{HG^{\\prime}}{1-H}=\\cfrac{G^{\\prime}}{(1-H)^{2}}$$\n\n然后我们总结一下\n\n$$H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}$$\n\n$$G^{\\prime}=\\cfrac{1}{1-H}$$\n\n$$F^{\\prime}=\\cfrac{G^{\\prime}}{(1-H)^{2}}$$\n\n最后的答案，也就是$n$块积木的期望层数，就是$\\cfrac{F[n]}{G[n]}$。然后不难发现$\\cfrac{F^{\\prime}[n]}{G^{\\prime}[n]}=\\cfrac{F[n]}{G[n]}$。\n\n我就是不贴代码（\n\n~~反正会的应该都能写出来了吧（~~\n","slug":"luogu-p5162-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpuy000r34cwhp29c9mp","content":"<p>9102年的第一篇blog。</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P5162\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p>大概算是我用NTT切的第一道非模板题。</p>\n<p>其实本来应该是<a href=\"http://codeforces.com/contest/438/problem/E\" target=\"_blank\" rel=\"noopener\">这道</a>。不过调不出来了弃了。</p>\n<p>首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。</p>\n<p>首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程：</p>\n<script type=\"math/tex; mode=display\">G[n]=\\sum\\limits_{i=0}^{n}C_{n}^{i}G[n-i]</script><p>但是这样对吗？</p>\n<p>代入$n=0$我们发现</p>\n<script type=\"math/tex; mode=display\">G[0]=C_{0}^{0}G[0]=G[0]</script><p><img src=\"https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg\" alt=\"\"></p>\n<p>注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。</p>\n<p>那然后$G[0]$应该等于几？</p>\n<script type=\"math/tex; mode=display\">G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1</script><p>所以说$G[0]=1$。</p>\n<p>如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。</p>\n<p>再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开</p>\n<script type=\"math/tex; mode=display\">G[n]=n!\\sum\\limits_{i=0}^{n}\\cfrac{1}{i!}\\times\\cfrac{G[n-i]}{(n-i)!}</script><p>定义</p>\n<script type=\"math/tex; mode=display\">H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}</script><script type=\"math/tex; mode=display\">G[n]=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{G[n-i]}{(n-i)!}</script><p>注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}[n]=\\cfrac{G[n]}{n!}</script><p>就可以得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nG^{\\prime}[n]&=\\sum\\limits_{i=0}^{n}H[i]\\times G^{\\prime}[n-i]\\\\\nG^{\\prime}&=G^{\\prime}H+1\n\\end{aligned}</script><p>注意不要忘了$+1$。因为很明显地$G^{\\prime}H[0]=0$，而$G^{\\prime}[0]=1$。</p>\n<p>然后我们就有</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}=\\cfrac{1}{1-H}</script><p>然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。</p>\n<p>首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此</p>\n<script type=\"math/tex; mode=display\">F[n]=G[n]+\\sum\\limits_{i=0}^{n}C_{n}^{i}F[n-i]</script><p>然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nF[n]&=G[n]+n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]}{(n-i)!}\\\\\n&=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\\\\nF^{\\prime}[n]&=\\cfrac{F[n]}{n!}\\\\\n&=\\sum\\limits_{i=0}^{n}H[i]\\times(F^{\\prime}[n-i]+G^{\\prime}[n-i])\\\\\nF^{\\prime}&=H(F^{\\prime}+G^{\\prime})\n\\end{aligned}</script><p>不过这次我们就不需要$+1$了。</p>\n<p>解上面的方程，我们得到</p>\n<script type=\"math/tex; mode=display\">F^{\\prime}=\\cfrac{HG^{\\prime}}{1-H}=\\cfrac{G^{\\prime}}{(1-H)^{2}}</script><p>然后我们总结一下</p>\n<script type=\"math/tex; mode=display\">H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}</script><script type=\"math/tex; mode=display\">G^{\\prime}=\\cfrac{1}{1-H}</script><script type=\"math/tex; mode=display\">F^{\\prime}=\\cfrac{G^{\\prime}}{(1-H)^{2}}</script><p>最后的答案，也就是$n$块积木的期望层数，就是$\\cfrac{F[n]}{G[n]}$。然后不难发现$\\cfrac{F^{\\prime}[n]}{G^{\\prime}[n]}=\\cfrac{F[n]}{G[n]}$。</p>\n<p>我就是不贴代码（</p>\n<p><del>反正会的应该都能写出来了吧（</del></p>\n","site":{"data":{}},"excerpt":"<p>9102年的第一篇blog。</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P5162\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p>大概算是我用NTT切的第一道非模板题。</p>\n<p>其实本来应该是<a href=\"http://codeforces.com/contest/438/problem/E\" target=\"_blank\" rel=\"noopener\">这道</a>。不过调不出来了弃了。</p>\n<p>首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。</p>\n<p>首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程：</p>\n<script type=\"math/tex; mode=display\">G[n]=\\sum\\limits_{i=0}^{n}C_{n}^{i}G[n-i]</script><p>但是这样对吗？</p>\n<p>代入$n=0$我们发现</p>\n<script type=\"math/tex; mode=display\">G[0]=C_{0}^{0}G[0]=G[0]</script><p><img src=\"https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg\" alt=\"\"></p>\n<p>注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。</p>\n<p>那然后$G[0]$应该等于几？</p>\n<script type=\"math/tex; mode=display\">G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1</script><p>所以说$G[0]=1$。</p>\n<p>如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。</p>\n<p>再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开</p>\n<script type=\"math/tex; mode=display\">G[n]=n!\\sum\\limits_{i=0}^{n}\\cfrac{1}{i!}\\times\\cfrac{G[n-i]}{(n-i)!}</script><p>定义</p>\n<script type=\"math/tex; mode=display\">H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}</script><script type=\"math/tex; mode=display\">G[n]=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{G[n-i]}{(n-i)!}</script><p>注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}[n]=\\cfrac{G[n]}{n!}</script><p>就可以得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nG^{\\prime}[n]&=\\sum\\limits_{i=0}^{n}H[i]\\times G^{\\prime}[n-i]\\\\\nG^{\\prime}&=G^{\\prime}H+1\n\\end{aligned}</script><p>注意不要忘了$+1$。因为很明显地$G^{\\prime}H[0]=0$，而$G^{\\prime}[0]=1$。</p>\n<p>然后我们就有</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}=\\cfrac{1}{1-H}</script><p>然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。</p>\n<p>首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此</p>\n<script type=\"math/tex; mode=display\">F[n]=G[n]+\\sum\\limits_{i=0}^{n}C_{n}^{i}F[n-i]</script><p>然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\nF[n]&=G[n]+n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]}{(n-i)!}\\\\\n&=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\\\\nF^{\\prime}[n]&=\\cfrac{F[n]}{n!}\\\\\n&=\\sum\\limits_{i=0}^{n}H[i]\\times(F^{\\prime}[n-i]+G^{\\prime}[n-i])\\\\\nF^{\\prime}&=H(F^{\\prime}+G^{\\prime})\n\\end{aligned}</script><p>不过这次我们就不需要$+1$了。</p>\n<p>解上面的方程，我们得到</p>\n<script type=\"math/tex; mode=display\">F^{\\prime}=\\cfrac{HG^{\\prime}}{1-H}=\\cfrac{G^{\\prime}}{(1-H)^{2}}</script><p>然后我们总结一下</p>\n<script type=\"math/tex; mode=display\">H[n]=\\begin{cases}\n&0&(n=0)\\\\\n&\\cfrac{1}{n!}\\;\\;&(n>1)\n\\end{cases}</script><script type=\"math/tex; mode=display\">G^{\\prime}=\\cfrac{1}{1-H}</script><script type=\"math/tex; mode=display\">F^{\\prime}=\\cfrac{G^{\\prime}}{(1-H)^{2}}</script><p>最后的答案，也就是$n$块积木的期望层数，就是$\\cfrac{F[n]}{G[n]}$。然后不难发现$\\cfrac{F^{\\prime}[n]}{G^{\\prime}[n]}=\\cfrac{F[n]}{G[n]}$。</p>\n<p>我就是不贴代码（</p>\n<p><del>反正会的应该都能写出来了吧（</del></p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-07T11:05:03.000Z","title":"「HEOI2012」采花","password":null,"_content":"[传送门](https://www.luogu.org/problemnew/show/P4113)\n\n[Taduro的题解](https://dftyem.github.io/2019/01/07/HEOI2012-采花/)\n\nsto __Taduro__ orz\n\n<!-- more -->\n\n首先，读完题一定有人要跳出来喊「莫队！」。\n\n~~莫队！~~\n\n然后再一看数据范围\n\n> 对于$100\\%$的数据，$1\\leqslant c\\leqslant n,m\\leqslant 2\\times 10^{6}$。\n\n~~笑容逐渐消失。~~\n\n然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了~~，树状数组什么时候有这种操作了~~。\n\n首先这个样例比较菜，我们手造一个：\n\n```plain\n1 6 2 4 2 3 6 2\n```\n\n首先我们维护一个`nxt`数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的`nxt`差不多长这样：\n\n| `i` | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `nxt[i]` | $0$ | $7$ | $5$ | $0$ | $8$ | $0$ | $0$ | $0$ |\n\n然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。\n\n然后我们还需要一个数组`ans`，对于每一种颜色，我们令__其在指针所在位置及其之后的部分中第二次出现的位置__的`ans`为$1$。\n\n| `i` | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ |\n\n因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。\n\n不难发现，此时$\\sum_{i=1}^{x}ans[i]$就是询问`1 x`的答案。\n\n需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的`ans`置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。\n\n这个时候`nxt`数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。\n\n让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：\n\n| `i` | $\\underline{1}$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ |\n\n| `i` | $1$ | $\\underline{2}$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ |\n\n| `i` | $1$ | $2$ | $\\underline{3}$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | ${\\color{red}6}$ | $2$ | $4$ | $2$ | $3$ | ${\\color{red}6}$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | ${\\color{red}0}$ | $0$ |\n\n| `i` | $1$ | $2$ | $3$ | $\\underline{4}$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | ${\\color{red}2}$ | $4$ | ${\\color{red}2}$ | $3$ | $6$ | ${\\color{red}2}$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | ${\\color{red}0}$ | $0$ | $0$ | ${\\color{red}1}$ |\n\n对于一次询问`l r`，我们将指针移动到`l`这个位置之后查询$\\sum_{i=l}^{r}ans[i]$即可。\n\n代码就不贴了~~，其实我还没写（~~\n","source":"_posts/2019-01-07-luogu-p4113-solution.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-07 19:05:03\ntitle: 「HEOI2012」采花\ntags:\n  - HEOI\n  - 2012\n  - 分块\n  - 莫队\n  - 树状数组\ncategories:\n  - 题解\npassword:\n---\n[传送门](https://www.luogu.org/problemnew/show/P4113)\n\n[Taduro的题解](https://dftyem.github.io/2019/01/07/HEOI2012-采花/)\n\nsto __Taduro__ orz\n\n<!-- more -->\n\n首先，读完题一定有人要跳出来喊「莫队！」。\n\n~~莫队！~~\n\n然后再一看数据范围\n\n> 对于$100\\%$的数据，$1\\leqslant c\\leqslant n,m\\leqslant 2\\times 10^{6}$。\n\n~~笑容逐渐消失。~~\n\n然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了~~，树状数组什么时候有这种操作了~~。\n\n首先这个样例比较菜，我们手造一个：\n\n```plain\n1 6 2 4 2 3 6 2\n```\n\n首先我们维护一个`nxt`数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的`nxt`差不多长这样：\n\n| `i` | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `nxt[i]` | $0$ | $7$ | $5$ | $0$ | $8$ | $0$ | $0$ | $0$ |\n\n然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。\n\n然后我们还需要一个数组`ans`，对于每一种颜色，我们令__其在指针所在位置及其之后的部分中第二次出现的位置__的`ans`为$1$。\n\n| `i` | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ |\n\n因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。\n\n不难发现，此时$\\sum_{i=1}^{x}ans[i]$就是询问`1 x`的答案。\n\n需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的`ans`置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。\n\n这个时候`nxt`数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。\n\n让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：\n\n| `i` | $\\underline{1}$ | $2$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ |\n\n| `i` | $1$ | $\\underline{2}$ | $3$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | $2$ | $4$ | $2$ | $3$ | $6$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | $1$ | $0$ |\n\n| `i` | $1$ | $2$ | $\\underline{3}$ | $4$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | ${\\color{red}6}$ | $2$ | $4$ | $2$ | $3$ | ${\\color{red}6}$ | $2$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | $1$ | $0$ | ${\\color{red}0}$ | $0$ |\n\n| `i` | $1$ | $2$ | $3$ | $\\underline{4}$ | $5$ | $6$ | $7$ | $8$ |\n| :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: | :-: |\n| `c[i]` | $1$ | $6$ | ${\\color{red}2}$ | $4$ | ${\\color{red}2}$ | $3$ | $6$ | ${\\color{red}2}$ |\n| `ans[i]` | $0$ | $0$ | $0$ | $0$ | ${\\color{red}0}$ | $0$ | $0$ | ${\\color{red}1}$ |\n\n对于一次询问`l r`，我们将指针移动到`l`这个位置之后查询$\\sum_{i=l}^{r}ans[i]$即可。\n\n代码就不贴了~~，其实我还没写（~~\n","slug":"luogu-p4113-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpv0000v34cw2rzerami","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P4113\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p><a href=\"https://dftyem.github.io/2019/01/07/HEOI2012-采花/\" target=\"_blank\" rel=\"noopener\">Taduro的题解</a></p>\n<p>sto <strong>Taduro</strong> orz</p>\n<a id=\"more\"></a>\n<p>首先，读完题一定有人要跳出来喊「莫队！」。</p>\n<p><del>莫队！</del></p>\n<p>然后再一看数据范围</p>\n<blockquote>\n<p>对于$100\\%$的数据，$1\\leqslant c\\leqslant n,m\\leqslant 2\\times 10^{6}$。</p>\n</blockquote>\n<p><del>笑容逐渐消失。</del></p>\n<p>然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了<del>，树状数组什么时候有这种操作了</del>。</p>\n<p>首先这个样例比较菜，我们手造一个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1 6 2 4 2 3 6 2</span><br></pre></td></tr></table></figure>\n<p>首先我们维护一个<code>nxt</code>数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的<code>nxt</code>差不多长这样：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>nxt[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$7$</td>\n<td style=\"text-align:center\">$5$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$8$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。</p>\n<p>然后我们还需要一个数组<code>ans</code>，对于每一种颜色，我们令<strong>其在指针所在位置及其之后的部分中第二次出现的位置</strong>的<code>ans</code>为$1$。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。</p>\n<p>不难发现，此时$\\sum_{i=1}^{x}ans[i]$就是询问<code>1 x</code>的答案。</p>\n<p>需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的<code>ans</code>置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。</p>\n<p>这个时候<code>nxt</code>数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。</p>\n<p>让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$\\underline{1}$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$\\underline{2}$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$\\underline{3}$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">${\\color{red}6}$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">${\\color{red}6}$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">${\\color{red}0}$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$\\underline{4}$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">${\\color{red}2}$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">${\\color{red}2}$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">${\\color{red}2}$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">${\\color{red}0}$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">${\\color{red}1}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对于一次询问<code>l r</code>，我们将指针移动到<code>l</code>这个位置之后查询$\\sum_{i=l}^{r}ans[i]$即可。</p>\n<p>代码就不贴了<del>，其实我还没写（</del></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P4113\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p><a href=\"https://dftyem.github.io/2019/01/07/HEOI2012-采花/\" target=\"_blank\" rel=\"noopener\">Taduro的题解</a></p>\n<p>sto <strong>Taduro</strong> orz</p>","more":"<p>首先，读完题一定有人要跳出来喊「莫队！」。</p>\n<p><del>莫队！</del></p>\n<p>然后再一看数据范围</p>\n<blockquote>\n<p>对于$100\\%$的数据，$1\\leqslant c\\leqslant n,m\\leqslant 2\\times 10^{6}$。</p>\n</blockquote>\n<p><del>笑容逐渐消失。</del></p>\n<p>然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了<del>，树状数组什么时候有这种操作了</del>。</p>\n<p>首先这个样例比较菜，我们手造一个：</p>\n<!--�6-->\n<p>首先我们维护一个<code>nxt</code>数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的<code>nxt</code>差不多长这样：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>nxt[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$7$</td>\n<td style=\"text-align:center\">$5$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$8$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。</p>\n<p>然后我们还需要一个数组<code>ans</code>，对于每一种颜色，我们令<strong>其在指针所在位置及其之后的部分中第二次出现的位置</strong>的<code>ans</code>为$1$。</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。</p>\n<p>不难发现，此时$\\sum_{i=1}^{x}ans[i]$就是询问<code>1 x</code>的答案。</p>\n<p>需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的<code>ans</code>置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。</p>\n<p>这个时候<code>nxt</code>数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。</p>\n<p>让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$\\underline{1}$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$\\underline{2}$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$\\underline{3}$</th>\n<th style=\"text-align:center\">$4$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">${\\color{red}6}$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">${\\color{red}6}$</td>\n<td style=\"text-align:center\">$2$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">${\\color{red}0}$</td>\n<td style=\"text-align:center\">$0$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\"><code>i</code></th>\n<th style=\"text-align:center\">$1$</th>\n<th style=\"text-align:center\">$2$</th>\n<th style=\"text-align:center\">$3$</th>\n<th style=\"text-align:center\">$\\underline{4}$</th>\n<th style=\"text-align:center\">$5$</th>\n<th style=\"text-align:center\">$6$</th>\n<th style=\"text-align:center\">$7$</th>\n<th style=\"text-align:center\">$8$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>c[i]</code></td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">${\\color{red}2}$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">${\\color{red}2}$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">${\\color{red}2}$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>ans[i]</code></td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">${\\color{red}0}$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">${\\color{red}1}$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>对于一次询问<code>l r</code>，我们将指针移动到<code>l</code>这个位置之后查询$\\sum_{i=l}^{r}ans[i]$即可。</p>\n<p>代码就不贴了<del>，其实我还没写（</del></p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-14T13:18:08.000Z","title":"有上下界的网络流问题与预留推进学习笔记","password":null,"_content":"感觉最近好颓啊（\n\n这是一篇正在咕咕咕的blog。\n<!-- more -->\n\n### [无源汇有上下界可行流](https://loj.ac/problem/115)\n\n我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\\text{upper}(e)-\\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令\n\n$$w(u)=\\sum_{v\\in V,(v,u)\\in E}\\text{lower}((v,u))-\\sum_{v\\in V,(u,v)\\in E}\\text{lower}((u,v))$$\n\n- 如果$w(u)=0$，说明我们不需要对点$u$做出调整。\n- 如果$w(u)\\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。\n- 如果$w(u)\\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。\n\n然后直接跑一边从源点到汇点的最大流即可。\n\n需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。\n\n否则，我们就已经构造出了一组可行解。\n\n### [有源汇有上下界最大流](https://loj.ac/problem/116)\n\n这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。\n\n我们可以从汇点到源点连一条流量上界为$+\\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。\n\n需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。\n\n当然，求解可行流时无解的话，整个问题无解。\n\n### [有源汇有上下界最小流](https://loj.ac/problem/117)\n\n还没看懂，先咕着。\n\n### [最高标号预流推进（HLPP-Highest Label Preflow Pushing？）](https://loj.ac/problem/127)\n\n还没看懂，先咕着。\n","source":"_posts/2019-01-14-something-about-network-flow-learning-notes.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-14 21:18:08\ntitle: 有上下界的网络流问题与预留推进学习笔记\ntags:\n  - 网络流\n  - 最大流\n  - 预留推进\ncategories:\n  - 学习笔记\npassword:\n---\n感觉最近好颓啊（\n\n这是一篇正在咕咕咕的blog。\n<!-- more -->\n\n### [无源汇有上下界可行流](https://loj.ac/problem/115)\n\n我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\\text{upper}(e)-\\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令\n\n$$w(u)=\\sum_{v\\in V,(v,u)\\in E}\\text{lower}((v,u))-\\sum_{v\\in V,(u,v)\\in E}\\text{lower}((u,v))$$\n\n- 如果$w(u)=0$，说明我们不需要对点$u$做出调整。\n- 如果$w(u)\\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。\n- 如果$w(u)\\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。\n\n然后直接跑一边从源点到汇点的最大流即可。\n\n需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。\n\n否则，我们就已经构造出了一组可行解。\n\n### [有源汇有上下界最大流](https://loj.ac/problem/116)\n\n这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。\n\n我们可以从汇点到源点连一条流量上界为$+\\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。\n\n需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。\n\n当然，求解可行流时无解的话，整个问题无解。\n\n### [有源汇有上下界最小流](https://loj.ac/problem/117)\n\n还没看懂，先咕着。\n\n### [最高标号预流推进（HLPP-Highest Label Preflow Pushing？）](https://loj.ac/problem/127)\n\n还没看懂，先咕着。\n","slug":"something-about-network-flow-learning-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpv1000x34cw4mgah8uy","content":"<p>感觉最近好颓啊（</p>\n<p>这是一篇正在咕咕咕的blog。<br><a id=\"more\"></a></p>\n<h3 id=\"无源汇有上下界可行流\"><a href=\"#无源汇有上下界可行流\" class=\"headerlink\" title=\"无源汇有上下界可行流\"></a><a href=\"https://loj.ac/problem/115\" target=\"_blank\" rel=\"noopener\">无源汇有上下界可行流</a></h3><p>我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\\text{upper}(e)-\\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令</p>\n<script type=\"math/tex; mode=display\">w(u)=\\sum_{v\\in V,(v,u)\\in E}\\text{lower}((v,u))-\\sum_{v\\in V,(u,v)\\in E}\\text{lower}((u,v))</script><ul>\n<li>如果$w(u)=0$，说明我们不需要对点$u$做出调整。</li>\n<li>如果$w(u)\\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。</li>\n<li>如果$w(u)\\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。</li>\n</ul>\n<p>然后直接跑一边从源点到汇点的最大流即可。</p>\n<p>需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。</p>\n<p>否则，我们就已经构造出了一组可行解。</p>\n<h3 id=\"有源汇有上下界最大流\"><a href=\"#有源汇有上下界最大流\" class=\"headerlink\" title=\"有源汇有上下界最大流\"></a><a href=\"https://loj.ac/problem/116\" target=\"_blank\" rel=\"noopener\">有源汇有上下界最大流</a></h3><p>这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。</p>\n<p>我们可以从汇点到源点连一条流量上界为$+\\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。</p>\n<p>需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。</p>\n<p>当然，求解可行流时无解的话，整个问题无解。</p>\n<h3 id=\"有源汇有上下界最小流\"><a href=\"#有源汇有上下界最小流\" class=\"headerlink\" title=\"有源汇有上下界最小流\"></a><a href=\"https://loj.ac/problem/117\" target=\"_blank\" rel=\"noopener\">有源汇有上下界最小流</a></h3><p>还没看懂，先咕着。</p>\n<h3 id=\"最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）\"><a href=\"#最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）\" class=\"headerlink\" title=\"最高标号预流推进（HLPP-Highest Label Preflow Pushing？）\"></a><a href=\"https://loj.ac/problem/127\" target=\"_blank\" rel=\"noopener\">最高标号预流推进（HLPP-Highest Label Preflow Pushing？）</a></h3><p>还没看懂，先咕着。</p>\n","site":{"data":{}},"excerpt":"<p>感觉最近好颓啊（</p>\n<p>这是一篇正在咕咕咕的blog。<br>","more":"</p>\n<h3 id=\"无源汇有上下界可行流\"><a href=\"#无源汇有上下界可行流\" class=\"headerlink\" title=\"无源汇有上下界可行流\"></a><a href=\"https://loj.ac/problem/115\" target=\"_blank\" rel=\"noopener\">无源汇有上下界可行流</a></h3><p>我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\\text{upper}(e)-\\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令</p>\n<script type=\"math/tex; mode=display\">w(u)=\\sum_{v\\in V,(v,u)\\in E}\\text{lower}((v,u))-\\sum_{v\\in V,(u,v)\\in E}\\text{lower}((u,v))</script><ul>\n<li>如果$w(u)=0$，说明我们不需要对点$u$做出调整。</li>\n<li>如果$w(u)\\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。</li>\n<li>如果$w(u)\\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。</li>\n</ul>\n<p>然后直接跑一边从源点到汇点的最大流即可。</p>\n<p>需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。</p>\n<p>否则，我们就已经构造出了一组可行解。</p>\n<h3 id=\"有源汇有上下界最大流\"><a href=\"#有源汇有上下界最大流\" class=\"headerlink\" title=\"有源汇有上下界最大流\"></a><a href=\"https://loj.ac/problem/116\" target=\"_blank\" rel=\"noopener\">有源汇有上下界最大流</a></h3><p>这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。</p>\n<p>我们可以从汇点到源点连一条流量上界为$+\\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。</p>\n<p>需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。</p>\n<p>当然，求解可行流时无解的话，整个问题无解。</p>\n<h3 id=\"有源汇有上下界最小流\"><a href=\"#有源汇有上下界最小流\" class=\"headerlink\" title=\"有源汇有上下界最小流\"></a><a href=\"https://loj.ac/problem/117\" target=\"_blank\" rel=\"noopener\">有源汇有上下界最小流</a></h3><p>还没看懂，先咕着。</p>\n<h3 id=\"最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）\"><a href=\"#最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）\" class=\"headerlink\" title=\"最高标号预流推进（HLPP-Highest Label Preflow Pushing？）\"></a><a href=\"https://loj.ac/problem/127\" target=\"_blank\" rel=\"noopener\">最高标号预流推进（HLPP-Highest Label Preflow Pushing？）</a></h3><p>还没看懂，先咕着。</p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-04T03:14:12.000Z","title":"「AHOI2017/HNOI2017」礼物","password":null,"_content":"[传送门](https://www.luogu.org/problemnew/show/P3723)\n\n<!-- more -->\n\n首先我们要有一个简单粗暴的暴力。\n\n$$\\min\\limits_{x=0}^{n-1}\\min\\limits_{c_{1}=0,c_{2}=0}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\\%n}-c_{2})^{2}$$\n\n因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。\n\n$$\\min\\limits_{x=0}^{n-1}\\min\\limits_{c=-m}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}$$\n\n我们仔细观察一下那个$\\Sigma$。\n\n$$\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}\\\\\n=&\\sum\\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\\%n}+2cA_{i}-2cB_{(i+x)\\%n})\\\\\n=&\\sum\\limits_{i=0}^{n-1}A_{i}^{2}+\\sum\\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\\sum\\limits_{i=0}^{n-1}A_{i}-\\sum\\limits_{i=0}^{n-1}B_{i})-2\\sum\\limits_{i=0}^{n-1}A_{i}B_{(i+x)\\%n}\n\\end{aligned}$$\n\n首先$\\Sigma A_{i}^{2}$和$\\Sigma B_{i}^{2}$可以看成是常数项。\n\n$nc^{2}+2c(\\Sigma A_{i}-\\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\\Sigma A_{i}-\\Sigma B_{i})$，我们知道它在$c=-\\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\\lfloor -\\cfrac{k}{n}\\rfloor$和$c=\\lceil -\\cfrac{k}{n}\\rceil$两者都代入原式，然后取较小值。\n\n然后我们想要求出$\\Sigma A_{i}B_{(i+x)\\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。\n\n$$\\sum\\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\\sum\\limits_{i=0}^{x-1}A_{i-x+n}B_{i}$$\n\n然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。\n\n然后一想，我们可以倒过来搞啊。\n\n定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成\n\n$$\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\\sum\\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\\\\n=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\n\\end{aligned}$$\n\n然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。\n\n以下是代码：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#define re register\n#define maxn 131072\n#define mod 998244353\n#define max(a,b) ((a)>=(b)?(a):(b))\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define swap(a,b) a^=b,b^=a,a^=b\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m,ans,k,mx;\nint unit[2][24],rev[maxn+1],A[maxn+1],B[maxn+1],C[maxn+1],D[maxn+1];\n\ninline int cltpow(re int x,re int y){\n\tre int res=1;\n\tfor(;y;){\n\t\tif(y&1)\n\t\t\tres=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\ninline void NTT(re int* F,re int n,re int tp){\n\tfor(re int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(re int k=1,p=1;p<n;++k,p<<=1)\n\t\tfor(re int i=0;i<n;i+=p<<1)\n\t\t\tfor(re int j=i,tmp=1;j<i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod){\n\t\t\t\tre int x=F[j],y=1LL*F[j+p]*tmp%mod;\n\t\t\t\tF[j]=(x+y)%mod;\n\t\t\t\tF[j+p]=(x-y+mod)%mod;\n\t\t\t}\n\tre int v=cltpow(n,tp*(mod-2));\n\tfor(re int i=0;i<n;++i)\n\t\tF[i]=1LL*F[i]*v%mod;\n}\n\nint main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tfor(re int i=0;i<n;++i){\n\t\tcltstream::read(A[i]);\n\t\tans+=A[i]*A[i];\n\t\tk+=A[i];\n\t\tC[n-1-i]=A[i];\n\t}\n\tfor(re int i=0;i<n;++i){\n\t\tcltstream::read(B[i]);\n\t\tans+=B[i]*B[i];\n\t\tk-=B[i];\n\t\tD[n-1-i]=B[i];\n\t}\n\tans+=min(n*floor(1.0*k/n)*floor(1.0*k/n)-2*k*floor(1.0*k/n),n*ceil(1.0*k/n)*ceil(1.0*k/n)-2*k*ceil(1.0*k/n));\n\tunit[0][23]=cltpow(3,119);\n\tunit[1][23]=cltpow(332748118,119);\n\tfor(re int i=0;i<2;++i)\n\t\tfor(re int j=22;j>=0;--j)\n\t\t\tunit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod;\n\tfor(m=1;m<n;m<<=1);\n\tm<<=1;\n\tfor(re int i=0;i<m;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(m>>1):0);\n\tNTT(A,m,0);\n\tNTT(B,m,0);\n\tNTT(C,m,0);\n\tNTT(D,m,0);\n\tfor(re int i=0;i<m;++i){\n\t\tA[i]=1LL*A[i]*D[i]%mod;\n\t\tB[i]=1LL*B[i]*C[i]%mod;\n\t}\n\tNTT(A,m,1);\n\tNTT(B,m,1);\n\tmx=A[n-1];\n\tfor(re int i=1;i<n;++i)\n\t\tmx=max(mx,A[n-1-i]+B[i-1]);\n\tcltstream::write(ans-=2*mx);\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/2019-01-04-luogu-p3723-solution.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-04 11:14:12\ntitle: 「AHOI2017/HNOI2017」礼物\ntags:\n  - AHOI\n  - HNOI\n  - 2017\n  - NTT\ncategories:\n  - 题解\npassword:\n---\n[传送门](https://www.luogu.org/problemnew/show/P3723)\n\n<!-- more -->\n\n首先我们要有一个简单粗暴的暴力。\n\n$$\\min\\limits_{x=0}^{n-1}\\min\\limits_{c_{1}=0,c_{2}=0}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\\%n}-c_{2})^{2}$$\n\n因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。\n\n$$\\min\\limits_{x=0}^{n-1}\\min\\limits_{c=-m}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}$$\n\n我们仔细观察一下那个$\\Sigma$。\n\n$$\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}\\\\\n=&\\sum\\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\\%n}+2cA_{i}-2cB_{(i+x)\\%n})\\\\\n=&\\sum\\limits_{i=0}^{n-1}A_{i}^{2}+\\sum\\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\\sum\\limits_{i=0}^{n-1}A_{i}-\\sum\\limits_{i=0}^{n-1}B_{i})-2\\sum\\limits_{i=0}^{n-1}A_{i}B_{(i+x)\\%n}\n\\end{aligned}$$\n\n首先$\\Sigma A_{i}^{2}$和$\\Sigma B_{i}^{2}$可以看成是常数项。\n\n$nc^{2}+2c(\\Sigma A_{i}-\\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\\Sigma A_{i}-\\Sigma B_{i})$，我们知道它在$c=-\\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\\lfloor -\\cfrac{k}{n}\\rfloor$和$c=\\lceil -\\cfrac{k}{n}\\rceil$两者都代入原式，然后取较小值。\n\n然后我们想要求出$\\Sigma A_{i}B_{(i+x)\\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。\n\n$$\\sum\\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\\sum\\limits_{i=0}^{x-1}A_{i-x+n}B_{i}$$\n\n然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。\n\n然后一想，我们可以倒过来搞啊。\n\n定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成\n\n$$\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\\sum\\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\\\\n=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\n\\end{aligned}$$\n\n然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。\n\n以下是代码：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#define re register\n#define maxn 131072\n#define mod 998244353\n#define max(a,b) ((a)>=(b)?(a):(b))\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define swap(a,b) a^=b,b^=a,a^=b\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m,ans,k,mx;\nint unit[2][24],rev[maxn+1],A[maxn+1],B[maxn+1],C[maxn+1],D[maxn+1];\n\ninline int cltpow(re int x,re int y){\n\tre int res=1;\n\tfor(;y;){\n\t\tif(y&1)\n\t\t\tres=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\ninline void NTT(re int* F,re int n,re int tp){\n\tfor(re int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(re int k=1,p=1;p<n;++k,p<<=1)\n\t\tfor(re int i=0;i<n;i+=p<<1)\n\t\t\tfor(re int j=i,tmp=1;j<i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod){\n\t\t\t\tre int x=F[j],y=1LL*F[j+p]*tmp%mod;\n\t\t\t\tF[j]=(x+y)%mod;\n\t\t\t\tF[j+p]=(x-y+mod)%mod;\n\t\t\t}\n\tre int v=cltpow(n,tp*(mod-2));\n\tfor(re int i=0;i<n;++i)\n\t\tF[i]=1LL*F[i]*v%mod;\n}\n\nint main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tfor(re int i=0;i<n;++i){\n\t\tcltstream::read(A[i]);\n\t\tans+=A[i]*A[i];\n\t\tk+=A[i];\n\t\tC[n-1-i]=A[i];\n\t}\n\tfor(re int i=0;i<n;++i){\n\t\tcltstream::read(B[i]);\n\t\tans+=B[i]*B[i];\n\t\tk-=B[i];\n\t\tD[n-1-i]=B[i];\n\t}\n\tans+=min(n*floor(1.0*k/n)*floor(1.0*k/n)-2*k*floor(1.0*k/n),n*ceil(1.0*k/n)*ceil(1.0*k/n)-2*k*ceil(1.0*k/n));\n\tunit[0][23]=cltpow(3,119);\n\tunit[1][23]=cltpow(332748118,119);\n\tfor(re int i=0;i<2;++i)\n\t\tfor(re int j=22;j>=0;--j)\n\t\t\tunit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod;\n\tfor(m=1;m<n;m<<=1);\n\tm<<=1;\n\tfor(re int i=0;i<m;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(m>>1):0);\n\tNTT(A,m,0);\n\tNTT(B,m,0);\n\tNTT(C,m,0);\n\tNTT(D,m,0);\n\tfor(re int i=0;i<m;++i){\n\t\tA[i]=1LL*A[i]*D[i]%mod;\n\t\tB[i]=1LL*B[i]*C[i]%mod;\n\t}\n\tNTT(A,m,1);\n\tNTT(B,m,1);\n\tmx=A[n-1];\n\tfor(re int i=1;i<n;++i)\n\t\tmx=max(mx,A[n-1-i]+B[i-1]);\n\tcltstream::write(ans-=2*mx);\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n","slug":"luogu-p3723-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpv2001134cwtdeuovpm","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P3723\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p>首先我们要有一个简单粗暴的暴力。</p>\n<script type=\"math/tex; mode=display\">\\min\\limits_{x=0}^{n-1}\\min\\limits_{c_{1}=0,c_{2}=0}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\\%n}-c_{2})^{2}</script><p>因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。</p>\n<script type=\"math/tex; mode=display\">\\min\\limits_{x=0}^{n-1}\\min\\limits_{c=-m}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}</script><p>我们仔细观察一下那个$\\Sigma$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}\\\\\n=&\\sum\\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\\%n}+2cA_{i}-2cB_{(i+x)\\%n})\\\\\n=&\\sum\\limits_{i=0}^{n-1}A_{i}^{2}+\\sum\\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\\sum\\limits_{i=0}^{n-1}A_{i}-\\sum\\limits_{i=0}^{n-1}B_{i})-2\\sum\\limits_{i=0}^{n-1}A_{i}B_{(i+x)\\%n}\n\\end{aligned}</script><p>首先$\\Sigma A_{i}^{2}$和$\\Sigma B_{i}^{2}$可以看成是常数项。</p>\n<p>$nc^{2}+2c(\\Sigma A_{i}-\\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\\Sigma A_{i}-\\Sigma B_{i})$，我们知道它在$c=-\\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\\lfloor -\\cfrac{k}{n}\\rfloor$和$c=\\lceil -\\cfrac{k}{n}\\rceil$两者都代入原式，然后取较小值。</p>\n<p>然后我们想要求出$\\Sigma A_{i}B_{(i+x)\\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\\sum\\limits_{i=0}^{x-1}A_{i-x+n}B_{i}</script><p>然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。</p>\n<p>然后一想，我们可以倒过来搞啊。</p>\n<p>定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\\sum\\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\\\\n=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\n\\end{aligned}</script><p>然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。</p>\n<p>以下是代码：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 131072</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 998244353</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,ans,k,mx;</span><br><span class=\"line\"><span class=\"keyword\">int</span> unit[<span class=\"number\">2</span>][<span class=\"number\">24</span>],rev[maxn+<span class=\"number\">1</span>],A[maxn+<span class=\"number\">1</span>],B[maxn+<span class=\"number\">1</span>],C[maxn+<span class=\"number\">1</span>],D[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">cltpow</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> res=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;y;)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tres=<span class=\"number\">1L</span>L*res*x%mod;</span><br><span class=\"line\">\t\tx=<span class=\"number\">1L</span>L*x*x%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">NTT</span><span class=\"params\">(re <span class=\"keyword\">int</span>* F,re <span class=\"keyword\">int</span> n,re <span class=\"keyword\">int</span> tp)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&lt;rev[i])</span><br><span class=\"line\">\t\t\tswap(F[i],F[rev[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">1</span>,p=<span class=\"number\">1</span>;p&lt;n;++k,p&lt;&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=p&lt;&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=i,tmp=<span class=\"number\">1</span>;j&lt;i+p;++j,tmp=<span class=\"number\">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class=\"line\">\t\t\t\tre <span class=\"keyword\">int</span> x=F[j],y=<span class=\"number\">1L</span>L*F[j+p]*tmp%mod;</span><br><span class=\"line\">\t\t\t\tF[j]=(x+y)%mod;</span><br><span class=\"line\">\t\t\t\tF[j+p]=(x-y+mod)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> v=cltpow(n,tp*(mod<span class=\"number\">-2</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tF[i]=<span class=\"number\">1L</span>L*F[i]*v%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\tcltstream::read(m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tcltstream::read(A[i]);</span><br><span class=\"line\">\t\tans+=A[i]*A[i];</span><br><span class=\"line\">\t\tk+=A[i];</span><br><span class=\"line\">\t\tC[n<span class=\"number\">-1</span>-i]=A[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\tcltstream::read(B[i]);</span><br><span class=\"line\">\t\tans+=B[i]*B[i];</span><br><span class=\"line\">\t\tk-=B[i];</span><br><span class=\"line\">\t\tD[n<span class=\"number\">-1</span>-i]=B[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tans+=min(n*<span class=\"built_in\">floor</span>(<span class=\"number\">1.0</span>*k/n)*<span class=\"built_in\">floor</span>(<span class=\"number\">1.0</span>*k/n)<span class=\"number\">-2</span>*k*<span class=\"built_in\">floor</span>(<span class=\"number\">1.0</span>*k/n),n*<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*k/n)*<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*k/n)<span class=\"number\">-2</span>*k*<span class=\"built_in\">ceil</span>(<span class=\"number\">1.0</span>*k/n));</span><br><span class=\"line\">\tunit[<span class=\"number\">0</span>][<span class=\"number\">23</span>]=cltpow(<span class=\"number\">3</span>,<span class=\"number\">119</span>);</span><br><span class=\"line\">\tunit[<span class=\"number\">1</span>][<span class=\"number\">23</span>]=cltpow(<span class=\"number\">332748118</span>,<span class=\"number\">119</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">22</span>;j&gt;=<span class=\"number\">0</span>;--j)</span><br><span class=\"line\">\t\t\tunit[i][j]=<span class=\"number\">1L</span>L*unit[i][j+<span class=\"number\">1</span>]*unit[i][j+<span class=\"number\">1</span>]%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(m=<span class=\"number\">1</span>;m&lt;n;m&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">\tm&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)</span><br><span class=\"line\">\t\trev[i]=(rev[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|((i&amp;<span class=\"number\">1</span>)?(m&gt;&gt;<span class=\"number\">1</span>):<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(A,m,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(B,m,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(C,m,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(D,m,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)&#123;</span><br><span class=\"line\">\t\tA[i]=<span class=\"number\">1L</span>L*A[i]*D[i]%mod;</span><br><span class=\"line\">\t\tB[i]=<span class=\"number\">1L</span>L*B[i]*C[i]%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tNTT(A,m,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tNTT(B,m,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tmx=A[n<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tmx=max(mx,A[n<span class=\"number\">-1</span>-i]+B[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\tcltstream::write(ans-=<span class=\"number\">2</span>*mx);</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P3723\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p>首先我们要有一个简单粗暴的暴力。</p>\n<script type=\"math/tex; mode=display\">\\min\\limits_{x=0}^{n-1}\\min\\limits_{c_{1}=0,c_{2}=0}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\\%n}-c_{2})^{2}</script><p>因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。</p>\n<script type=\"math/tex; mode=display\">\\min\\limits_{x=0}^{n-1}\\min\\limits_{c=-m}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}</script><p>我们仔细观察一下那个$\\Sigma$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}\\\\\n=&\\sum\\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\\%n}+2cA_{i}-2cB_{(i+x)\\%n})\\\\\n=&\\sum\\limits_{i=0}^{n-1}A_{i}^{2}+\\sum\\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\\sum\\limits_{i=0}^{n-1}A_{i}-\\sum\\limits_{i=0}^{n-1}B_{i})-2\\sum\\limits_{i=0}^{n-1}A_{i}B_{(i+x)\\%n}\n\\end{aligned}</script><p>首先$\\Sigma A_{i}^{2}$和$\\Sigma B_{i}^{2}$可以看成是常数项。</p>\n<p>$nc^{2}+2c(\\Sigma A_{i}-\\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\\Sigma A_{i}-\\Sigma B_{i})$，我们知道它在$c=-\\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\\lfloor -\\cfrac{k}{n}\\rfloor$和$c=\\lceil -\\cfrac{k}{n}\\rceil$两者都代入原式，然后取较小值。</p>\n<p>然后我们想要求出$\\Sigma A_{i}B_{(i+x)\\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\\sum\\limits_{i=0}^{x-1}A_{i-x+n}B_{i}</script><p>然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。</p>\n<p>然后一想，我们可以倒过来搞啊。</p>\n<p>定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n&\\sum\\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\\sum\\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\\\\n=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\n\\end{aligned}</script><p>然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。</p>\n<p>以下是代码：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�7-->\n\n</div></div>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-17T03:28:06.000Z","title":"「HEOI2016/TJOI2016」求和","password":null,"_content":"[传送门](https://www.luogu.org/problemnew/show/P4091)\n\n感觉最近意志消沉啥也不想干，于是继续来颓blog（\n\n<!-- more -->\n\n仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（\n\n首先我们知道如果$n\\gt m$，$S(n,m)=0$。于是我们将原式写成\n\n$$\\sum_{i=0}^{n}\\sum_{j=0}^{n}2^{j}j!S(i,j)=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)$$\n\n第二类斯特林数有一个通项公式，它长这样\n\n$$S(n,m)=\\cfrac{1}{m!}\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}$$\n\n直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现\n\n$$F(n,m,k)=C(m,k)(m-k)^{n}$$\n\n然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现\n\n$$G(n,m)=\\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}$$\n\n因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。\n\n然后我们继续推式子\n\n$$\\begin{aligned}\n\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}\\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}\n\\end{aligned}$$\n\n我们看到右边就是一个等比数列求和，于是\n\n$$\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}$$\n\n定义\n\n$$F[i]=\\cfrac{(-1)^{i}}{i!}$$\n\n右边的等比数列求和比较麻烦，我们需要一些特判。\n\n$$G[i]=\\begin{cases}\n&1&(i=0)\\\\\n&n+1&(i=1)\\\\\n&\\cfrac{i^{n+1}-1}{i!(i-1)}\\;\\;&(i>1)\n\\end{cases}$$\n\n然后我们就有\n\n$$\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\\sum_{j=0}^{n}2^{j}j!(F\\times G)[j]$$\n\n这么一想前几天的我还只会暴力二项式定理展开（\n\n![](/images/TIM图片20181209192946.jpg)\n","source":"_posts/2019-01-17-luogu-p4091-solution.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-17 11:28:06\ntitle: 「HEOI2016/TJOI2016」求和\ntags:\n  - HEOI\n  - TJOI\n  - 2016\n  - NTT\ncategories:\n  - 题解\npassword:\n---\n[传送门](https://www.luogu.org/problemnew/show/P4091)\n\n感觉最近意志消沉啥也不想干，于是继续来颓blog（\n\n<!-- more -->\n\n仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（\n\n首先我们知道如果$n\\gt m$，$S(n,m)=0$。于是我们将原式写成\n\n$$\\sum_{i=0}^{n}\\sum_{j=0}^{n}2^{j}j!S(i,j)=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)$$\n\n第二类斯特林数有一个通项公式，它长这样\n\n$$S(n,m)=\\cfrac{1}{m!}\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}$$\n\n直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现\n\n$$F(n,m,k)=C(m,k)(m-k)^{n}$$\n\n然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现\n\n$$G(n,m)=\\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}$$\n\n因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。\n\n然后我们继续推式子\n\n$$\\begin{aligned}\n\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}\\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}\n\\end{aligned}$$\n\n我们看到右边就是一个等比数列求和，于是\n\n$$\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}$$\n\n定义\n\n$$F[i]=\\cfrac{(-1)^{i}}{i!}$$\n\n右边的等比数列求和比较麻烦，我们需要一些特判。\n\n$$G[i]=\\begin{cases}\n&1&(i=0)\\\\\n&n+1&(i=1)\\\\\n&\\cfrac{i^{n+1}-1}{i!(i-1)}\\;\\;&(i>1)\n\\end{cases}$$\n\n然后我们就有\n\n$$\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\\sum_{j=0}^{n}2^{j}j!(F\\times G)[j]$$\n\n这么一想前几天的我还只会暴力二项式定理展开（\n\n![](/images/TIM图片20181209192946.jpg)\n","slug":"luogu-p4091-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpv3001534cwejpe4f07","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P4091\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p>感觉最近意志消沉啥也不想干，于是继续来颓blog（</p>\n<a id=\"more\"></a>\n<p>仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（</p>\n<p>首先我们知道如果$n\\gt m$，$S(n,m)=0$。于是我们将原式写成</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=0}^{n}\\sum_{j=0}^{n}2^{j}j!S(i,j)=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)</script><p>第二类斯特林数有一个通项公式，它长这样</p>\n<script type=\"math/tex; mode=display\">S(n,m)=\\cfrac{1}{m!}\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现</p>\n<script type=\"math/tex; mode=display\">F(n,m,k)=C(m,k)(m-k)^{n}</script><p>然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现</p>\n<script type=\"math/tex; mode=display\">G(n,m)=\\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。</p>\n<p>然后我们继续推式子</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}\\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}\n\\end{aligned}</script><p>我们看到右边就是一个等比数列求和，于是</p>\n<script type=\"math/tex; mode=display\">\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}</script><p>定义</p>\n<script type=\"math/tex; mode=display\">F[i]=\\cfrac{(-1)^{i}}{i!}</script><p>右边的等比数列求和比较麻烦，我们需要一些特判。</p>\n<script type=\"math/tex; mode=display\">G[i]=\\begin{cases}\n&1&(i=0)\\\\\n&n+1&(i=1)\\\\\n&\\cfrac{i^{n+1}-1}{i!(i-1)}\\;\\;&(i>1)\n\\end{cases}</script><p>然后我们就有</p>\n<script type=\"math/tex; mode=display\">\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\\sum_{j=0}^{n}2^{j}j!(F\\times G)[j]</script><p>这么一想前几天的我还只会暴力二项式定理展开（</p>\n<p><img src=\"/images/TIM图片20181209192946.jpg\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P4091\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p>感觉最近意志消沉啥也不想干，于是继续来颓blog（</p>","more":"<p>仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（</p>\n<p>首先我们知道如果$n\\gt m$，$S(n,m)=0$。于是我们将原式写成</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=0}^{n}\\sum_{j=0}^{n}2^{j}j!S(i,j)=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)</script><p>第二类斯特林数有一个通项公式，它长这样</p>\n<script type=\"math/tex; mode=display\">S(n,m)=\\cfrac{1}{m!}\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现</p>\n<script type=\"math/tex; mode=display\">F(n,m,k)=C(m,k)(m-k)^{n}</script><p>然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现</p>\n<script type=\"math/tex; mode=display\">G(n,m)=\\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。</p>\n<p>然后我们继续推式子</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}\\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\\\\n&=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}\n\\end{aligned}</script><p>我们看到右边就是一个等比数列求和，于是</p>\n<script type=\"math/tex; mode=display\">\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}</script><p>定义</p>\n<script type=\"math/tex; mode=display\">F[i]=\\cfrac{(-1)^{i}}{i!}</script><p>右边的等比数列求和比较麻烦，我们需要一些特判。</p>\n<script type=\"math/tex; mode=display\">G[i]=\\begin{cases}\n&1&(i=0)\\\\\n&n+1&(i=1)\\\\\n&\\cfrac{i^{n+1}-1}{i!(i-1)}\\;\\;&(i>1)\n\\end{cases}</script><p>然后我们就有</p>\n<script type=\"math/tex; mode=display\">\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\\sum_{j=0}^{n}2^{j}j!(F\\times G)[j]</script><p>这么一想前几天的我还只会暴力二项式定理展开（</p>\n<p><img src=\"/images/TIM图片20181209192946.jpg\" alt=\"\"></p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-20T09:43:14.000Z","title":"2019-01-20：loli的两场模拟赛的题解","password":null,"_content":"今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。\n\n上午记为D1，下午记为D2。\n\n<!-- more -->\n\n### D1\n\n#### T1 简 - simple\n\n给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。\n\n$n\\leqslant 100000$。\n\n不予置评。\n\n#### T2 单 - single\n\n给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义\n\n$$b_{u}=\\sum_{i=1}^{n}dist(u,i)a_{i}$$\n\n还会给你一个$\\text{tp}$，$\\text{tp}=0$时给你$\\{a_{n}\\}$让你求$\\{b_{n}\\}$，$\\text{tp}=1$时给你$\\{b_{n}\\}$让你求$\\{a_{n}\\}$。多组数据。\n\n$n\\leqslant 100000,T\\leqslant 5$。\n\n$\\text{tp}=0$时就是一个简单的树形DP。\n\n$\\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（\n\n他给的题解我也没看懂（\n\n我就打了$\\text{tp}=0$的$30$分。\n\n#### T3 题 - problem\n\n有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。\n\n关于$S$，首先会给你一个$\\text{tp}$，然后$S$如下定义\n\n$$S=\\begin{cases}\n&\\{(x,y)\\mid x,y\\in\\mathbb{Z}\\}\\;\\;&(\\text{tp}=0)\\\\\n&\\{(x,y)\\mid x\\in\\mathbb{N},y=0\\}&(\\text{tp}=1)\\\\\n&\\{(x,y)\\mid xy=0\\}&(\\text{tp}=2)\\\\\n&\\{(x,y)\\mid x,y\\in\\mathbb{N}\\}&(\\text{tp}=3)\n\\end{cases}$$\n\n$n\\leqslant 100000$，$n\\equiv 0\\pmod{2}$，$\\text{tp}\\in\\{0,1,2,3\\}$。特殊地，当$\\text{tp}=2$时$n\\leqslant 1000$。\n\n四合一数论提答（\n\n很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。\n\n$\\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。\n我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此\n\n$$\\text{Ans}=(2n)!\\sum_{i=0}^{n}\\cfrac{1}{i!i!(n-i)!(n-i)!}$$\n\n$\\text{tp}=1$直接卡特兰数。\n\n$\\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。\n\n如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP\n\n$$f[x]=\\sum_{i=1}^{x}f[x-i]\\cfrac{(2i)!}{i!i!}$$\n\n其实如果改一下模数的话这个东西可以用NTT优化到$O(n\\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（\n\n$\\text{tp}=3$大概是$\\text{tp}=0$与$\\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是\n\n$$\\begin{aligned}\n\\text{Ans}&=\\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\\\\n&=\\sum_{i=0}^{n}\\cfrac{(2n)!}{(2i)!(2(n-i))!}\\left(\\cfrac{(2i)!}{i!i!}-\\cfrac{(2i)!}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\\right)\\\\\n&=(2n)!\\sum_{i=0}^{n}\\left(\\cfrac{1}{i!i!}-\\cfrac{1}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{1}{(n-i)!(n-i)!}-\\cfrac{1}{(n-i+1)!(n-i-1)!}\\right)\n\\end{aligned}$$\n\n于是愉快地$230$直接rank1（\n\n话说wzx打了$240$分的啊……然而炸成$210$（\n\n### D2\n\n#### T1 印章 - seal\n\n给你一张$n\\times m$的纸，上面有些格子要印墨水。你有一个$r\\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。\n\n$n,m,r,c\\leqslant 1000,T\\leqslant 10$。\n\n首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个`bitset`瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（\n\n拿了$60$就跑（\n\n#### T2 多边形 - polygon\n\n一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。\n\n这是一个$0-4$边形\n\n![](/images/图片1.png)\n\n\n这是一个$1-4$边形\n\n![](/images/图片2.png)\n\n这是一个$2-4$边形\n\n![](/images/图片3.png)\n\n给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。\n\n$0\\leqslant k\\leqslant 10^{6},3\\leqslant n\\leqslant 10^{9}$。\n\n![](/images/TIM图片20181023195537.jpg)\n\n告辞（\n\n彻底放弃治疗（\n\n#### T3 扔球 - ball\n\n给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。\n\n所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\\{a_{n}\\}$的期望逆序对数量。四舍五入保留两位小数。\n\n如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。\n\n$n\\leqslant 500000,0.4\\leqslant p\\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\\Sigma|S_{i}|\\leqslant 500000$。\n\n从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。\n\n套个树状数组就行。\n\n但是等会，$a_{x}=y$的概率怎么算啊。\n\n首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是\n\n$$\n\\begin{aligned}\n\\lim_{n\\rightarrow+\\infty}\\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\\\\n&=\\cfrac{p}{1-(1-p)^{|S_{x}|}}\n\\end{aligned}$$\n\n那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为\n\n$$\\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}$$\n\n最后总分只有$160$，被$190$分的wzx吊着打（\n","source":"_posts/2019-01-20-lolioi-2019-01-20-solutions.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-20 17:43:14\ntitle: 2019-01-20：loli的两场模拟赛的题解\ntags:\n  - loli\n  - 模拟赛\ncategories:\n  - 题解\npassword:\n---\n今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。\n\n上午记为D1，下午记为D2。\n\n<!-- more -->\n\n### D1\n\n#### T1 简 - simple\n\n给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。\n\n$n\\leqslant 100000$。\n\n不予置评。\n\n#### T2 单 - single\n\n给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义\n\n$$b_{u}=\\sum_{i=1}^{n}dist(u,i)a_{i}$$\n\n还会给你一个$\\text{tp}$，$\\text{tp}=0$时给你$\\{a_{n}\\}$让你求$\\{b_{n}\\}$，$\\text{tp}=1$时给你$\\{b_{n}\\}$让你求$\\{a_{n}\\}$。多组数据。\n\n$n\\leqslant 100000,T\\leqslant 5$。\n\n$\\text{tp}=0$时就是一个简单的树形DP。\n\n$\\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（\n\n他给的题解我也没看懂（\n\n我就打了$\\text{tp}=0$的$30$分。\n\n#### T3 题 - problem\n\n有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。\n\n关于$S$，首先会给你一个$\\text{tp}$，然后$S$如下定义\n\n$$S=\\begin{cases}\n&\\{(x,y)\\mid x,y\\in\\mathbb{Z}\\}\\;\\;&(\\text{tp}=0)\\\\\n&\\{(x,y)\\mid x\\in\\mathbb{N},y=0\\}&(\\text{tp}=1)\\\\\n&\\{(x,y)\\mid xy=0\\}&(\\text{tp}=2)\\\\\n&\\{(x,y)\\mid x,y\\in\\mathbb{N}\\}&(\\text{tp}=3)\n\\end{cases}$$\n\n$n\\leqslant 100000$，$n\\equiv 0\\pmod{2}$，$\\text{tp}\\in\\{0,1,2,3\\}$。特殊地，当$\\text{tp}=2$时$n\\leqslant 1000$。\n\n四合一数论提答（\n\n很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。\n\n$\\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。\n我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此\n\n$$\\text{Ans}=(2n)!\\sum_{i=0}^{n}\\cfrac{1}{i!i!(n-i)!(n-i)!}$$\n\n$\\text{tp}=1$直接卡特兰数。\n\n$\\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。\n\n如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP\n\n$$f[x]=\\sum_{i=1}^{x}f[x-i]\\cfrac{(2i)!}{i!i!}$$\n\n其实如果改一下模数的话这个东西可以用NTT优化到$O(n\\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（\n\n$\\text{tp}=3$大概是$\\text{tp}=0$与$\\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是\n\n$$\\begin{aligned}\n\\text{Ans}&=\\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\\\\n&=\\sum_{i=0}^{n}\\cfrac{(2n)!}{(2i)!(2(n-i))!}\\left(\\cfrac{(2i)!}{i!i!}-\\cfrac{(2i)!}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\\right)\\\\\n&=(2n)!\\sum_{i=0}^{n}\\left(\\cfrac{1}{i!i!}-\\cfrac{1}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{1}{(n-i)!(n-i)!}-\\cfrac{1}{(n-i+1)!(n-i-1)!}\\right)\n\\end{aligned}$$\n\n于是愉快地$230$直接rank1（\n\n话说wzx打了$240$分的啊……然而炸成$210$（\n\n### D2\n\n#### T1 印章 - seal\n\n给你一张$n\\times m$的纸，上面有些格子要印墨水。你有一个$r\\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。\n\n$n,m,r,c\\leqslant 1000,T\\leqslant 10$。\n\n首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个`bitset`瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（\n\n拿了$60$就跑（\n\n#### T2 多边形 - polygon\n\n一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。\n\n这是一个$0-4$边形\n\n![](/images/图片1.png)\n\n\n这是一个$1-4$边形\n\n![](/images/图片2.png)\n\n这是一个$2-4$边形\n\n![](/images/图片3.png)\n\n给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。\n\n$0\\leqslant k\\leqslant 10^{6},3\\leqslant n\\leqslant 10^{9}$。\n\n![](/images/TIM图片20181023195537.jpg)\n\n告辞（\n\n彻底放弃治疗（\n\n#### T3 扔球 - ball\n\n给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。\n\n所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\\{a_{n}\\}$的期望逆序对数量。四舍五入保留两位小数。\n\n如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。\n\n$n\\leqslant 500000,0.4\\leqslant p\\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\\Sigma|S_{i}|\\leqslant 500000$。\n\n从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。\n\n套个树状数组就行。\n\n但是等会，$a_{x}=y$的概率怎么算啊。\n\n首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是\n\n$$\n\\begin{aligned}\n\\lim_{n\\rightarrow+\\infty}\\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\\\\n&=\\cfrac{p}{1-(1-p)^{|S_{x}|}}\n\\end{aligned}$$\n\n那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为\n\n$$\\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}$$\n\n最后总分只有$160$，被$190$分的wzx吊着打（\n","slug":"lolioi-2019-01-20-solutions","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpv5001834cw0f77bbg9","content":"<p>今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。</p>\n<p>上午记为D1，下午记为D2。</p>\n<a id=\"more\"></a>\n<h3 id=\"D1\"><a href=\"#D1\" class=\"headerlink\" title=\"D1\"></a>D1</h3><h4 id=\"T1-简-simple\"><a href=\"#T1-简-simple\" class=\"headerlink\" title=\"T1 简 - simple\"></a>T1 简 - simple</h4><p>给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。</p>\n<p>$n\\leqslant 100000$。</p>\n<p>不予置评。</p>\n<h4 id=\"T2-单-single\"><a href=\"#T2-单-single\" class=\"headerlink\" title=\"T2 单 - single\"></a>T2 单 - single</h4><p>给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义</p>\n<script type=\"math/tex; mode=display\">b_{u}=\\sum_{i=1}^{n}dist(u,i)a_{i}</script><p>还会给你一个$\\text{tp}$，$\\text{tp}=0$时给你$\\{a_{n}\\}$让你求$\\{b_{n}\\}$，$\\text{tp}=1$时给你$\\{b_{n}\\}$让你求$\\{a_{n}\\}$。多组数据。</p>\n<p>$n\\leqslant 100000,T\\leqslant 5$。</p>\n<p>$\\text{tp}=0$时就是一个简单的树形DP。</p>\n<p>$\\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（</p>\n<p>他给的题解我也没看懂（</p>\n<p>我就打了$\\text{tp}=0$的$30$分。</p>\n<h4 id=\"T3-题-problem\"><a href=\"#T3-题-problem\" class=\"headerlink\" title=\"T3 题 - problem\"></a>T3 题 - problem</h4><p>有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。</p>\n<p>关于$S$，首先会给你一个$\\text{tp}$，然后$S$如下定义</p>\n<script type=\"math/tex; mode=display\">S=\\begin{cases}\n&\\{(x,y)\\mid x,y\\in\\mathbb{Z}\\}\\;\\;&(\\text{tp}=0)\\\\\n&\\{(x,y)\\mid x\\in\\mathbb{N},y=0\\}&(\\text{tp}=1)\\\\\n&\\{(x,y)\\mid xy=0\\}&(\\text{tp}=2)\\\\\n&\\{(x,y)\\mid x,y\\in\\mathbb{N}\\}&(\\text{tp}=3)\n\\end{cases}</script><p>$n\\leqslant 100000$，$n\\equiv 0\\pmod{2}$，$\\text{tp}\\in\\{0,1,2,3\\}$。特殊地，当$\\text{tp}=2$时$n\\leqslant 1000$。</p>\n<p>四合一数论提答（</p>\n<p>很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。</p>\n<p>$\\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。<br>我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此</p>\n<script type=\"math/tex; mode=display\">\\text{Ans}=(2n)!\\sum_{i=0}^{n}\\cfrac{1}{i!i!(n-i)!(n-i)!}</script><p>$\\text{tp}=1$直接卡特兰数。</p>\n<p>$\\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。</p>\n<p>如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP</p>\n<script type=\"math/tex; mode=display\">f[x]=\\sum_{i=1}^{x}f[x-i]\\cfrac{(2i)!}{i!i!}</script><p>其实如果改一下模数的话这个东西可以用NTT优化到$O(n\\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（</p>\n<p>$\\text{tp}=3$大概是$\\text{tp}=0$与$\\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\text{Ans}&=\\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\\\\n&=\\sum_{i=0}^{n}\\cfrac{(2n)!}{(2i)!(2(n-i))!}\\left(\\cfrac{(2i)!}{i!i!}-\\cfrac{(2i)!}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\\right)\\\\\n&=(2n)!\\sum_{i=0}^{n}\\left(\\cfrac{1}{i!i!}-\\cfrac{1}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{1}{(n-i)!(n-i)!}-\\cfrac{1}{(n-i+1)!(n-i-1)!}\\right)\n\\end{aligned}</script><p>于是愉快地$230$直接rank1（</p>\n<p>话说wzx打了$240$分的啊……然而炸成$210$（</p>\n<h3 id=\"D2\"><a href=\"#D2\" class=\"headerlink\" title=\"D2\"></a>D2</h3><h4 id=\"T1-印章-seal\"><a href=\"#T1-印章-seal\" class=\"headerlink\" title=\"T1 印章 - seal\"></a>T1 印章 - seal</h4><p>给你一张$n\\times m$的纸，上面有些格子要印墨水。你有一个$r\\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。</p>\n<p>$n,m,r,c\\leqslant 1000,T\\leqslant 10$。</p>\n<p>首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个<code>bitset</code>瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（</p>\n<p>拿了$60$就跑（</p>\n<h4 id=\"T2-多边形-polygon\"><a href=\"#T2-多边形-polygon\" class=\"headerlink\" title=\"T2 多边形 - polygon\"></a>T2 多边形 - polygon</h4><p>一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。</p>\n<p>这是一个$0-4$边形</p>\n<p><img src=\"/images/图片1.png\" alt=\"\"></p>\n<p>这是一个$1-4$边形</p>\n<p><img src=\"/images/图片2.png\" alt=\"\"></p>\n<p>这是一个$2-4$边形</p>\n<p><img src=\"/images/图片3.png\" alt=\"\"></p>\n<p>给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。</p>\n<p>$0\\leqslant k\\leqslant 10^{6},3\\leqslant n\\leqslant 10^{9}$。</p>\n<p><img src=\"/images/TIM图片20181023195537.jpg\" alt=\"\"></p>\n<p>告辞（</p>\n<p>彻底放弃治疗（</p>\n<h4 id=\"T3-扔球-ball\"><a href=\"#T3-扔球-ball\" class=\"headerlink\" title=\"T3 扔球 - ball\"></a>T3 扔球 - ball</h4><p>给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。</p>\n<p>所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\\{a_{n}\\}$的期望逆序对数量。四舍五入保留两位小数。</p>\n<p>如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。</p>\n<p>$n\\leqslant 500000,0.4\\leqslant p\\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\\Sigma|S_{i}|\\leqslant 500000$。</p>\n<p>从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。</p>\n<p>套个树状数组就行。</p>\n<p>但是等会，$a_{x}=y$的概率怎么算啊。</p>\n<p>首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\lim_{n\\rightarrow+\\infty}\\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\\\\n&=\\cfrac{p}{1-(1-p)^{|S_{x}|}}\n\\end{aligned}</script><p>那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为</p>\n<script type=\"math/tex; mode=display\">\\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}</script><p>最后总分只有$160$，被$190$分的wzx吊着打（</p>\n","site":{"data":{}},"excerpt":"<p>今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。</p>\n<p>上午记为D1，下午记为D2。</p>","more":"<h3 id=\"D1\"><a href=\"#D1\" class=\"headerlink\" title=\"D1\"></a>D1</h3><h4 id=\"T1-简-simple\"><a href=\"#T1-简-simple\" class=\"headerlink\" title=\"T1 简 - simple\"></a>T1 简 - simple</h4><p>给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。</p>\n<p>$n\\leqslant 100000$。</p>\n<p>不予置评。</p>\n<h4 id=\"T2-单-single\"><a href=\"#T2-单-single\" class=\"headerlink\" title=\"T2 单 - single\"></a>T2 单 - single</h4><p>给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义</p>\n<script type=\"math/tex; mode=display\">b_{u}=\\sum_{i=1}^{n}dist(u,i)a_{i}</script><p>还会给你一个$\\text{tp}$，$\\text{tp}=0$时给你$\\{a_{n}\\}$让你求$\\{b_{n}\\}$，$\\text{tp}=1$时给你$\\{b_{n}\\}$让你求$\\{a_{n}\\}$。多组数据。</p>\n<p>$n\\leqslant 100000,T\\leqslant 5$。</p>\n<p>$\\text{tp}=0$时就是一个简单的树形DP。</p>\n<p>$\\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（</p>\n<p>他给的题解我也没看懂（</p>\n<p>我就打了$\\text{tp}=0$的$30$分。</p>\n<h4 id=\"T3-题-problem\"><a href=\"#T3-题-problem\" class=\"headerlink\" title=\"T3 题 - problem\"></a>T3 题 - problem</h4><p>有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。</p>\n<p>关于$S$，首先会给你一个$\\text{tp}$，然后$S$如下定义</p>\n<script type=\"math/tex; mode=display\">S=\\begin{cases}\n&\\{(x,y)\\mid x,y\\in\\mathbb{Z}\\}\\;\\;&(\\text{tp}=0)\\\\\n&\\{(x,y)\\mid x\\in\\mathbb{N},y=0\\}&(\\text{tp}=1)\\\\\n&\\{(x,y)\\mid xy=0\\}&(\\text{tp}=2)\\\\\n&\\{(x,y)\\mid x,y\\in\\mathbb{N}\\}&(\\text{tp}=3)\n\\end{cases}</script><p>$n\\leqslant 100000$，$n\\equiv 0\\pmod{2}$，$\\text{tp}\\in\\{0,1,2,3\\}$。特殊地，当$\\text{tp}=2$时$n\\leqslant 1000$。</p>\n<p>四合一数论提答（</p>\n<p>很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。</p>\n<p>$\\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。<br>我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此</p>\n<script type=\"math/tex; mode=display\">\\text{Ans}=(2n)!\\sum_{i=0}^{n}\\cfrac{1}{i!i!(n-i)!(n-i)!}</script><p>$\\text{tp}=1$直接卡特兰数。</p>\n<p>$\\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。</p>\n<p>如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP</p>\n<script type=\"math/tex; mode=display\">f[x]=\\sum_{i=1}^{x}f[x-i]\\cfrac{(2i)!}{i!i!}</script><p>其实如果改一下模数的话这个东西可以用NTT优化到$O(n\\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（</p>\n<p>$\\text{tp}=3$大概是$\\text{tp}=0$与$\\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\text{Ans}&=\\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\\\\n&=\\sum_{i=0}^{n}\\cfrac{(2n)!}{(2i)!(2(n-i))!}\\left(\\cfrac{(2i)!}{i!i!}-\\cfrac{(2i)!}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\\right)\\\\\n&=(2n)!\\sum_{i=0}^{n}\\left(\\cfrac{1}{i!i!}-\\cfrac{1}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{1}{(n-i)!(n-i)!}-\\cfrac{1}{(n-i+1)!(n-i-1)!}\\right)\n\\end{aligned}</script><p>于是愉快地$230$直接rank1（</p>\n<p>话说wzx打了$240$分的啊……然而炸成$210$（</p>\n<h3 id=\"D2\"><a href=\"#D2\" class=\"headerlink\" title=\"D2\"></a>D2</h3><h4 id=\"T1-印章-seal\"><a href=\"#T1-印章-seal\" class=\"headerlink\" title=\"T1 印章 - seal\"></a>T1 印章 - seal</h4><p>给你一张$n\\times m$的纸，上面有些格子要印墨水。你有一个$r\\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。</p>\n<p>$n,m,r,c\\leqslant 1000,T\\leqslant 10$。</p>\n<p>首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个<code>bitset</code>瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（</p>\n<p>拿了$60$就跑（</p>\n<h4 id=\"T2-多边形-polygon\"><a href=\"#T2-多边形-polygon\" class=\"headerlink\" title=\"T2 多边形 - polygon\"></a>T2 多边形 - polygon</h4><p>一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。</p>\n<p>这是一个$0-4$边形</p>\n<p><img src=\"/images/图片1.png\" alt=\"\"></p>\n<p>这是一个$1-4$边形</p>\n<p><img src=\"/images/图片2.png\" alt=\"\"></p>\n<p>这是一个$2-4$边形</p>\n<p><img src=\"/images/图片3.png\" alt=\"\"></p>\n<p>给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。</p>\n<p>$0\\leqslant k\\leqslant 10^{6},3\\leqslant n\\leqslant 10^{9}$。</p>\n<p><img src=\"/images/TIM图片20181023195537.jpg\" alt=\"\"></p>\n<p>告辞（</p>\n<p>彻底放弃治疗（</p>\n<h4 id=\"T3-扔球-ball\"><a href=\"#T3-扔球-ball\" class=\"headerlink\" title=\"T3 扔球 - ball\"></a>T3 扔球 - ball</h4><p>给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。</p>\n<p>所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\\{a_{n}\\}$的期望逆序对数量。四舍五入保留两位小数。</p>\n<p>如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。</p>\n<p>$n\\leqslant 500000,0.4\\leqslant p\\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\\Sigma|S_{i}|\\leqslant 500000$。</p>\n<p>从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。</p>\n<p>套个树状数组就行。</p>\n<p>但是等会，$a_{x}=y$的概率怎么算啊。</p>\n<p>首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是</p>\n<script type=\"math/tex; mode=display\">\n\\begin{aligned}\n\\lim_{n\\rightarrow+\\infty}\\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\\\\n&=\\cfrac{p}{1-(1-p)^{|S_{x}|}}\n\\end{aligned}</script><p>那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为</p>\n<script type=\"math/tex; mode=display\">\\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}</script><p>最后总分只有$160$，被$190$分的wzx吊着打（</p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-02-15T11:25:37.000Z","title":"「Luogu-P3613」睡觉困难综合征","password":null,"_content":"[传送门](https://www.luogu.org/problemnew/show/P3613)\n\n<!-- more -->\n\n### xjb扯\n\n以前刚学树剖时看到这题感觉好神仙啊没法做啊。\n\n然后现在学了LCT过来一看~~，这不就一水题（~~\n\nxjb写了棵LCT一交。\n\n![](/images/TIM截图20190215193107.png)\n\nemmmmmm……\n\n然后改的时候才发现全是细节错误，LCT的部分动都没动一下（\n\n就比如说，下面是我第一次交的程序的主程序部分。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<=m;++i){\n\tint opt,x,y;\n\tcltstream::read(opt);\n\tcltstream::read(x);\n\tcltstream::read(y);\n\tif(opt==1){\n\t\tint z;\n\t\t//我都不知道我当时是怎么想的（\n\t\tcltstream::read(z);\n\t\tsplit(mempool+x,mempool+y);\n\t\tre unsigned long long ans0=(mempool+y)->ans0,ans1=(mempool+y)->ans1,ans=0;\n\t\tfor(re int j=k-1;j>=0;--j)\n\t\t\tif(((ans0>>j)&1)>=((ans1>>j)&1)||z<(1<<j))\n\t\t\t//甚至忘了用1ULL（\n\t\t\t\tans^=ans0&(1<<j);\n\t\t\telse{\n\t\t\t\tz-=1<<j;\n\t\t\t\tans^=ans1&(1<<j);\n\t\t\t}\n\t\tcltstream::write(ans,10);\n\t}\n\telse{\n\t\tunsigned long long z;\n\t\tcltstream::read(z);\n\t\taccess(mempool+x);\n\t\t(mempool+x)->tp=y;\n\t\t(mempool+x)->val=z;\n\t\t(mempool+y)->pushUp();\n\t\t//？？？\n\t}\n}\n```\n\n{% endfold %}\n\n然后我Splay节点的内部信息甚至开成了`unsigned`，excuse me？？？\n\n~~不这个东西这不是我写的（~~\n\n### 真正的题解\n\n首先LCT。\n\n不过首先的首先您还是要先做了[这道题](https://www.luogu.org/problemnew/show/P2114)。\n\n每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。\n\n我们记这两个值为`ans0`和`ans1`。\n\n左子树和节点本身的信息很好维护。\n\n而关于右子树，看上去我们没办法迅速求出把到现在为止的`ans0`和`ans1`扔进去跑一遍的结果。\n\n但是注意到这些都是按位运算，位与位之间不互相影响。\n\n我们可以对于`ans0`中是$1$的那些位，提取出`rc->ans1`的对应位，对于`ans0`中是$0$的那些位，提取出`rc->ans0`的对应位。\n\n然后`ans1`也类似处理就行了。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nstruct SplayNode{\n\tSplayNode *ftr,*lc,*rc;\n\tint tp,rev;\n\tunsigned val,ans0,ans1;\n\n\tinline unsigned long long apply(unsigned long long x){\n\t\treturn tp==1?(x&val):tp==2?(x|val):(x^val);\n\t}\n\n\t/*...*/\n\n\tinline void pushUp(){\n\t\tans0=0,ans1=-1;\n\t\tif(lc!=NULL){\n\t\t\tans0=lc->ans0;\n\t\t\tans1=lc->ans1;\n\t\t}\n\t\tans0=apply(ans0),ans1=apply(ans1);\n\t\tif(rc!=NULL){\n\t\t\tans0=(ans0&rc->ans1)|((~ans0)&rc->ans0);\n\t\t\tans1=(ans1&rc->ans1)|((~ans1)&rc->ans0);\n\t\t}\n\t}\n};\n```\n\n{% endfold %}\n\n但是还有一个问题是，LCT在连边和提取路径时需要`makeRoot`，也就是说需要区间翻转。\n\n但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。\n\n那么提前维护好就行了。提前维护好`sna0`和`sna1`，表示把$0$和$-1$反过来跑一遍的结果。\n\n然后就没了。\n","source":"_posts/2019-02-15-luogu-p3613-solution.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-02-15 19:25:37\ntitle: 「Luogu-P3613」睡觉困难综合征\ntags:\n  - 树链剖分\n  - LCT\ncategories:\n  - 题解\npassword:\n---\n[传送门](https://www.luogu.org/problemnew/show/P3613)\n\n<!-- more -->\n\n### xjb扯\n\n以前刚学树剖时看到这题感觉好神仙啊没法做啊。\n\n然后现在学了LCT过来一看~~，这不就一水题（~~\n\nxjb写了棵LCT一交。\n\n![](/images/TIM截图20190215193107.png)\n\nemmmmmm……\n\n然后改的时候才发现全是细节错误，LCT的部分动都没动一下（\n\n就比如说，下面是我第一次交的程序的主程序部分。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<=m;++i){\n\tint opt,x,y;\n\tcltstream::read(opt);\n\tcltstream::read(x);\n\tcltstream::read(y);\n\tif(opt==1){\n\t\tint z;\n\t\t//我都不知道我当时是怎么想的（\n\t\tcltstream::read(z);\n\t\tsplit(mempool+x,mempool+y);\n\t\tre unsigned long long ans0=(mempool+y)->ans0,ans1=(mempool+y)->ans1,ans=0;\n\t\tfor(re int j=k-1;j>=0;--j)\n\t\t\tif(((ans0>>j)&1)>=((ans1>>j)&1)||z<(1<<j))\n\t\t\t//甚至忘了用1ULL（\n\t\t\t\tans^=ans0&(1<<j);\n\t\t\telse{\n\t\t\t\tz-=1<<j;\n\t\t\t\tans^=ans1&(1<<j);\n\t\t\t}\n\t\tcltstream::write(ans,10);\n\t}\n\telse{\n\t\tunsigned long long z;\n\t\tcltstream::read(z);\n\t\taccess(mempool+x);\n\t\t(mempool+x)->tp=y;\n\t\t(mempool+x)->val=z;\n\t\t(mempool+y)->pushUp();\n\t\t//？？？\n\t}\n}\n```\n\n{% endfold %}\n\n然后我Splay节点的内部信息甚至开成了`unsigned`，excuse me？？？\n\n~~不这个东西这不是我写的（~~\n\n### 真正的题解\n\n首先LCT。\n\n不过首先的首先您还是要先做了[这道题](https://www.luogu.org/problemnew/show/P2114)。\n\n每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。\n\n我们记这两个值为`ans0`和`ans1`。\n\n左子树和节点本身的信息很好维护。\n\n而关于右子树，看上去我们没办法迅速求出把到现在为止的`ans0`和`ans1`扔进去跑一遍的结果。\n\n但是注意到这些都是按位运算，位与位之间不互相影响。\n\n我们可以对于`ans0`中是$1$的那些位，提取出`rc->ans1`的对应位，对于`ans0`中是$0$的那些位，提取出`rc->ans0`的对应位。\n\n然后`ans1`也类似处理就行了。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nstruct SplayNode{\n\tSplayNode *ftr,*lc,*rc;\n\tint tp,rev;\n\tunsigned val,ans0,ans1;\n\n\tinline unsigned long long apply(unsigned long long x){\n\t\treturn tp==1?(x&val):tp==2?(x|val):(x^val);\n\t}\n\n\t/*...*/\n\n\tinline void pushUp(){\n\t\tans0=0,ans1=-1;\n\t\tif(lc!=NULL){\n\t\t\tans0=lc->ans0;\n\t\t\tans1=lc->ans1;\n\t\t}\n\t\tans0=apply(ans0),ans1=apply(ans1);\n\t\tif(rc!=NULL){\n\t\t\tans0=(ans0&rc->ans1)|((~ans0)&rc->ans0);\n\t\t\tans1=(ans1&rc->ans1)|((~ans1)&rc->ans0);\n\t\t}\n\t}\n};\n```\n\n{% endfold %}\n\n但是还有一个问题是，LCT在连边和提取路径时需要`makeRoot`，也就是说需要区间翻转。\n\n但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。\n\n那么提前维护好就行了。提前维护好`sna0`和`sna1`，表示把$0$和$-1$反过来跑一遍的结果。\n\n然后就没了。\n","slug":"luogu-p3613-solution","published":1,"updated":"2019-02-15T12:08:18.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpv6001b34cwbyiu0gnp","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P3613\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<h3 id=\"xjb扯\"><a href=\"#xjb扯\" class=\"headerlink\" title=\"xjb扯\"></a>xjb扯</h3><p>以前刚学树剖时看到这题感觉好神仙啊没法做啊。</p>\n<p>然后现在学了LCT过来一看<del>，这不就一水题（</del></p>\n<p>xjb写了棵LCT一交。</p>\n<p><img src=\"/images/TIM截图20190215193107.png\" alt=\"\"></p>\n<p>emmmmmm……</p>\n<p>然后改的时候才发现全是细节错误，LCT的部分动都没动一下（</p>\n<p>就比如说，下面是我第一次交的程序的主程序部分。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> opt,x,y;</span><br><span class=\"line\">\tcltstream::read(opt);</span><br><span class=\"line\">\tcltstream::read(x);</span><br><span class=\"line\">\tcltstream::read(y);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(opt==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> z;</span><br><span class=\"line\">\t\t<span class=\"comment\">//我都不知道我当时是怎么想的（</span></span><br><span class=\"line\">\t\tcltstream::read(z);</span><br><span class=\"line\">\t\tsplit(mempool+x,mempool+y);</span><br><span class=\"line\">\t\tre <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> ans0=(mempool+y)-&gt;ans0,ans1=(mempool+y)-&gt;ans1,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=k<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">0</span>;--j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(((ans0&gt;&gt;j)&amp;<span class=\"number\">1</span>)&gt;=((ans1&gt;&gt;j)&amp;<span class=\"number\">1</span>)||z&lt;(<span class=\"number\">1</span>&lt;&lt;j))</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//甚至忘了用1ULL（</span></span><br><span class=\"line\">\t\t\t\tans^=ans0&amp;(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\tz-=<span class=\"number\">1</span>&lt;&lt;j;</span><br><span class=\"line\">\t\t\t\tans^=ans1&amp;(<span class=\"number\">1</span>&lt;&lt;j);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcltstream::write(ans,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> z;</span><br><span class=\"line\">\t\tcltstream::read(z);</span><br><span class=\"line\">\t\taccess(mempool+x);</span><br><span class=\"line\">\t\t(mempool+x)-&gt;tp=y;</span><br><span class=\"line\">\t\t(mempool+x)-&gt;val=z;</span><br><span class=\"line\">\t\t(mempool+y)-&gt;pushUp();</span><br><span class=\"line\">\t\t<span class=\"comment\">//？？？</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>然后我Splay节点的内部信息甚至开成了<code>unsigned</code>，excuse me？？？</p>\n<p><del>不这个东西这不是我写的（</del></p>\n<h3 id=\"真正的题解\"><a href=\"#真正的题解\" class=\"headerlink\" title=\"真正的题解\"></a>真正的题解</h3><p>首先LCT。</p>\n<p>不过首先的首先您还是要先做了<a href=\"https://www.luogu.org/problemnew/show/P2114\" target=\"_blank\" rel=\"noopener\">这道题</a>。</p>\n<p>每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。</p>\n<p>我们记这两个值为<code>ans0</code>和<code>ans1</code>。</p>\n<p>左子树和节点本身的信息很好维护。</p>\n<p>而关于右子树，看上去我们没办法迅速求出把到现在为止的<code>ans0</code>和<code>ans1</code>扔进去跑一遍的结果。</p>\n<p>但是注意到这些都是按位运算，位与位之间不互相影响。</p>\n<p>我们可以对于<code>ans0</code>中是$1$的那些位，提取出<code>rc-&gt;ans1</code>的对应位，对于<code>ans0</code>中是$0$的那些位，提取出<code>rc-&gt;ans0</code>的对应位。</p>\n<p>然后<code>ans1</code>也类似处理就行了。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SplayNode</span>&#123;</span></span><br><span class=\"line\">\tSplayNode *ftr,*lc,*rc;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> tp,rev;</span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> val,ans0,ans1;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">apply</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> tp==<span class=\"number\">1</span>?(x&amp;val):tp==<span class=\"number\">2</span>?(x|val):(x^val);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/*...*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tans0=<span class=\"number\">0</span>,ans1=<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(lc!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t\tans0=lc-&gt;ans0;</span><br><span class=\"line\">\t\t\tans1=lc-&gt;ans1;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tans0=apply(ans0),ans1=apply(ans1);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(rc!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t\tans0=(ans0&amp;rc-&gt;ans1)|((~ans0)&amp;rc-&gt;ans0);</span><br><span class=\"line\">\t\t\tans1=(ans1&amp;rc-&gt;ans1)|((~ans1)&amp;rc-&gt;ans0);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>但是还有一个问题是，LCT在连边和提取路径时需要<code>makeRoot</code>，也就是说需要区间翻转。</p>\n<p>但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。</p>\n<p>那么提前维护好就行了。提前维护好<code>sna0</code>和<code>sna1</code>，表示把$0$和$-1$反过来跑一遍的结果。</p>\n<p>然后就没了。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P3613\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<h3 id=\"xjb扯\"><a href=\"#xjb扯\" class=\"headerlink\" title=\"xjb扯\"></a>xjb扯</h3><p>以前刚学树剖时看到这题感觉好神仙啊没法做啊。</p>\n<p>然后现在学了LCT过来一看<del>，这不就一水题（</del></p>\n<p>xjb写了棵LCT一交。</p>\n<p><img src=\"/images/TIM截图20190215193107.png\" alt=\"\"></p>\n<p>emmmmmm……</p>\n<p>然后改的时候才发现全是细节错误，LCT的部分动都没动一下（</p>\n<p>就比如说，下面是我第一次交的程序的主程序部分。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�8-->\n\n</div></div>\n<p>然后我Splay节点的内部信息甚至开成了<code>unsigned</code>，excuse me？？？</p>\n<p><del>不这个东西这不是我写的（</del></p>\n<h3 id=\"真正的题解\"><a href=\"#真正的题解\" class=\"headerlink\" title=\"真正的题解\"></a>真正的题解</h3><p>首先LCT。</p>\n<p>不过首先的首先您还是要先做了<a href=\"https://www.luogu.org/problemnew/show/P2114\" target=\"_blank\" rel=\"noopener\">这道题</a>。</p>\n<p>每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。</p>\n<p>我们记这两个值为<code>ans0</code>和<code>ans1</code>。</p>\n<p>左子树和节点本身的信息很好维护。</p>\n<p>而关于右子树，看上去我们没办法迅速求出把到现在为止的<code>ans0</code>和<code>ans1</code>扔进去跑一遍的结果。</p>\n<p>但是注意到这些都是按位运算，位与位之间不互相影响。</p>\n<p>我们可以对于<code>ans0</code>中是$1$的那些位，提取出<code>rc-&gt;ans1</code>的对应位，对于<code>ans0</code>中是$0$的那些位，提取出<code>rc-&gt;ans0</code>的对应位。</p>\n<p>然后<code>ans1</code>也类似处理就行了。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�9-->\n\n</div></div>\n<p>但是还有一个问题是，LCT在连边和提取路径时需要<code>makeRoot</code>，也就是说需要区间翻转。</p>\n<p>但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。</p>\n<p>那么提前维护好就行了。提前维护好<code>sna0</code>和<code>sna1</code>，表示把$0$和$-1$反过来跑一遍的结果。</p>\n<p>然后就没了。</p>"},{"title":"珂朵莉树学习笔记","date":"2018-10-13T13:13:09.000Z","mathjax":true,"_content":"~~还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。~~\n\n~~话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。~~\n\n总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。\n\n<!--more -->\n\n我们先来看一道~~毒瘤~~例题，[「CF896C」Willem, Chtholly and Seniorious](http://codeforces.com/contest/896/problem/C)。\n\n如果只看前三个操作的话~~，虽然我不会写也没写过~~，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？\n\n这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于`std::set`的暴力数据结构~~，虽然您也可以手写一颗平衡树~~，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：\n\n> 珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。\n\n那么怎么推平呢？不急，我们慢慢讲。\n\n珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nstruct node{\n    int l,r;\n    mutable long long val;\n    //这里的mutable是为了让我们在之后的修改过程中可以修改val的值\n\n    node(int _l,int _r=-1,long long _val=-1){\n    //调用时_r或_val不填的话默认-1，为了后面split时方便\n        l=_l;\n        r=_r;\n        val=_val;\n    }\n};\nstd::set<node> s;\n\ninline bool operator<(node p,node q){\n    return p.l<q.l;\n}\n```\n\n{% endfold %}\n\n然后我们就可以初始化了。对于这道题，我们可以像这样初始化：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<=n;++i)\n    s.insert(node(i,i,rnd()%maxval+1));\n```\n\n{% endfold %}\n\n初始化完了？\n\n初始化完了。\n\n然后就是珂朵莉树的核心操作~~之一~~，\n\n```cpp\nstd::<set>::iterator split(int pos)\n```\n\n作用是分离出一个左端点为`pos`的区间并返回它的迭代器。它的具体实现如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#define _it std::set<node>::iterator\n//上面这句手打非常麻烦，建议宏定义\ninline _it split(int pos){\n    _it it=std::lower_bound(s.begin(),s.end(),node(pos));\n    //找第一个左端点大于等于pos的区间\n    if(it!=s.end()&&it->l==pos)\n        return it;\n    //如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器\n    --it;\n    //否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内\n    int l=it->l,r=it->r;\n    long long val=it->val;\n    s.erase(it);\n    s.insert(node(l,pos-1,val));\n    return s.insert(node(pos,r,val)).first;\n    //将区间[l,r]删除，并插入区间[l,pos)和[pos,r]\n}\n```\n\n{% endfold %}\n\n虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。\n\n`insert`函数的返回值类型是`std::pair<std::_Rb_tree_const_iterator<node>,bool>`~~，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了~~，因此我们需要加个`.first`。\n\n`std::set`内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\\operatorname{log}n)$的。\n\n然后是一个同样很核心的操作，\n\n```cpp\nvoid assign(int l,int r,int x)\n```\n\n将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void assign(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    //注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内\n    //后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器\n    s.erase(itl,itr);\n    //将[itl,itr)内所有区间删除\n    s.insert(node(l,r,x));\n    //用一个大区间取代它们\n}\n```\n\n{% endfold %}\n\n这就完了？\n\n这就完了。\n\n`assign`操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得`set`的大小迅速减小，并最终趋于$\\operatorname{log}n$。本题的操作二就只需调用一次`assign(l,r,x)`即可。\n\n然后是剩下的三个操作~~，一个比一个暴力~~。\n\n操作一，一个一个区间地拿出来加。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void IntervalAdd(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    for(re _it p=itl;p!=itr;++p)\n        p->val+=x;\n}\n```\n\n{% endfold %}\n\n就这么几行？\n\n就这么几行。\n\n操作三，把所有区间取出来，然后直接调用`std::sort`。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline long long IntervalXth(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    vec.clear();\n    for(re _it p=itl;p!=itr;++p)\n        vec.push_back(std::make_pair(p->val,p->r-p->l+1));\n    std::sort(vec.begin(),vec.end());\n    for(re unsigned i=0;i<vec.size();++i){\n        x-=vec[i].second;\n        if(x<=0)\n            return vec[i].first;\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n\n操作四，暴力快速幂。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline int IntervalXpow(int l,int r,int x,int y){\n    _it itr=split(r+1),itl=split(l);\n    int res=0;\n    for(re _it p=itl;p!=itr;++p)\n        res=(1LL*res+1LL*(p->r-p->l+1)*cltpow(p->val%y,x,y)%y)%y;\n    return res;\n}\n```\n\n{% endfold %}\n\n您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？\n\n这是我在CodeForces上的提交记录：\n\n![](https://i.loli.net/2018/10/14/5bc28b1443ea5.png)\n\n这是我之前提到的那位~~不愿意透露姓名的~~珂学家的跑得最快的一次提交记录：\n\n![](https://i.loli.net/2018/10/14/5bc28c7ecfe96.png)\n\n![](https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg)\n\n珂幻.jpg\n\n因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了[「CF915E」Physical Education Lessons](http://codeforces.com/contest/915/problem/E)，然而……\n\n![](https://i.loli.net/2018/10/14/5bc297890bbc6.png)\n\n> Updated on 2018-11-01\n>\n> 后来我卡了卡常数过了……\n>\n> 以及，删掉了某些内容（\n\n于是，接下来是珂朵莉树的完整板子。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#define re register\n#define maxn 100000\n#define _it std::set<node>::iterator\n\nnamespace cltstream{\n    #ifdef ONLINE_JUDGE\n        #define size 1048576\n        char str[size+1],*head=str,*tail=str;\n        inline char gc(){\n            if(head==tail){\n                tail=(head=str)+fread(str,1,size,stdin);\n                if(head==tail)\n                    return EOF;\n            }\n            return *head++;\n        }\n        #undef size\n    #else\n        #define gc getchar\n    #endif\n\n    template <typename _tp>\n    inline void read(_tp& x){\n        int sn=1;\n        char c=gc();\n        for(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n        if(c==45&&c!=EOF)\n            sn=-1,c=gc();\n        for(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n        x*=sn;\n    }\n\n    template <typename _tp>\n    inline void write(_tp x,char text=' '){\n        if(x<0)\n            putchar(45),x=-x;\n        if(!x)\n            putchar(48);\n        else{\n            int digit[20];\n            for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n            for(;digit[0];putchar(digit[digit[0]--]^48));\n        }\n        putchar(text);\n    }\n}\n\nint n,m,seed,maxval;\nstruct node{\n    int l,r;\n    mutable long long val;\n\n    node(int _l,int _r=-1,long long _val=-1){\n        l=_l;\n        r=_r;\n        val=_val;\n    }\n};\nstd::set<node> s;\nstd::vector<std::pair<long long,int> > vec;\n\ninline int rnd(){\n    int res=seed;\n    seed=(7LL*seed+13)%1000000007;\n    return res;\n}\n\ninline void swap(int& l,int& r){\n    int tmp=l;\n    l=r;\n    r=tmp;\n}\n\nint cltpow(int x,int y,int mod){\n    if(y==1)\n        return x;\n    int res=cltpow(x,y>>1,mod);\n    res=1LL*res*res%mod;\n    if(y&1)\n        res=1LL*res*x%mod;\n    return res;\n}\n\ninline bool operator<(node p,node q){\n    return p.l<q.l;\n}\n\ninline _it split(int pos){\n    _it it=std::lower_bound(s.begin(),s.end(),node(pos));\n    if(it!=s.end()&&it->l==pos)\n        return it;\n    --it;\n    int l=it->l,r=it->r;\n    long long val=it->val;\n    s.erase(it);\n    s.insert(node(l,pos-1,val));\n    return s.insert(node(pos,r,val)).first;\n}\n\ninline void IntervalAdd(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    for(re _it p=itl;p!=itr;++p)\n        p->val+=x;\n}\n\ninline void IntervalAssign(int l,int r,int x){\n//就是之前提到的assign\n    _it itr=split(r+1),itl=split(l);\n    s.erase(itl,itr);\n    s.insert(node(l,r,x));\n}\n\ninline long long IntervalXth(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    vec.clear();\n    for(re _it p=itl;p!=itr;++p)\n        vec.push_back(std::make_pair(p->val,p->r-p->l+1));\n    std::sort(vec.begin(),vec.end());\n    for(re unsigned i=0;i<vec.size();++i){\n        x-=vec[i].second;\n        if(x<=0)\n            return vec[i].first;\n    }\n    return 0;\n}\n\ninline int IntervalXpow(int l,int r,int x,int y){\n    _it itr=split(r+1),itl=split(l);\n    int res=0;\n    for(re _it p=itl;p!=itr;++p)\n        res=(1LL*res+1LL*(p->r-p->l+1)*cltpow(p->val%y,x,y)%y)%y;\n    return res;\n}\n\nint main(){\n    cltstream::read(n);\n    cltstream::read(m);\n    cltstream::read(seed);\n    cltstream::read(maxval);\n    for(re int i=1;i<=n;++i)\n        s.insert(node(i,i,rnd()%maxval+1));\n    for(re int i=1;i<=m;++i){\n        int opt=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1,x,y;\n        if(l>r)\n            swap(l,r);\n        switch(opt){\n            case 1:\n                x=rnd()%maxval+1;\n                IntervalAdd(l,r,x);\n                break;\n            case 2:\n                x=rnd()%maxval+1;\n                IntervalAssign(l,r,x);\n                break;\n            case 3:\n                x=rnd()%(r-l+1)+1;\n                cltstream::write(IntervalXth(l,r,x),'\\n');\n                break;\n            case 4:\n                x=rnd()%maxval+1;\n                y=rnd()%maxval+1;\n                cltstream::write(IntervalXpow(l,r,x,y),'\\n');\n                break;\n        }\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n\n以上。\n","source":"_posts/2018-10-13-chtholly-tree-learning-notes.md","raw":"---\ntitle: 珂朵莉树学习笔记\ndate: 2018-10-13 21:13:09\ntags:\n  - 珂朵莉树\ncategories:\n  - 学习笔记\nmathjax: true\n---\n~~还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。~~\n\n~~话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。~~\n\n总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。\n\n<!--more -->\n\n我们先来看一道~~毒瘤~~例题，[「CF896C」Willem, Chtholly and Seniorious](http://codeforces.com/contest/896/problem/C)。\n\n如果只看前三个操作的话~~，虽然我不会写也没写过~~，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？\n\n这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于`std::set`的暴力数据结构~~，虽然您也可以手写一颗平衡树~~，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：\n\n> 珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。\n\n那么怎么推平呢？不急，我们慢慢讲。\n\n珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nstruct node{\n    int l,r;\n    mutable long long val;\n    //这里的mutable是为了让我们在之后的修改过程中可以修改val的值\n\n    node(int _l,int _r=-1,long long _val=-1){\n    //调用时_r或_val不填的话默认-1，为了后面split时方便\n        l=_l;\n        r=_r;\n        val=_val;\n    }\n};\nstd::set<node> s;\n\ninline bool operator<(node p,node q){\n    return p.l<q.l;\n}\n```\n\n{% endfold %}\n\n然后我们就可以初始化了。对于这道题，我们可以像这样初始化：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int i=1;i<=n;++i)\n    s.insert(node(i,i,rnd()%maxval+1));\n```\n\n{% endfold %}\n\n初始化完了？\n\n初始化完了。\n\n然后就是珂朵莉树的核心操作~~之一~~，\n\n```cpp\nstd::<set>::iterator split(int pos)\n```\n\n作用是分离出一个左端点为`pos`的区间并返回它的迭代器。它的具体实现如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#define _it std::set<node>::iterator\n//上面这句手打非常麻烦，建议宏定义\ninline _it split(int pos){\n    _it it=std::lower_bound(s.begin(),s.end(),node(pos));\n    //找第一个左端点大于等于pos的区间\n    if(it!=s.end()&&it->l==pos)\n        return it;\n    //如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器\n    --it;\n    //否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内\n    int l=it->l,r=it->r;\n    long long val=it->val;\n    s.erase(it);\n    s.insert(node(l,pos-1,val));\n    return s.insert(node(pos,r,val)).first;\n    //将区间[l,r]删除，并插入区间[l,pos)和[pos,r]\n}\n```\n\n{% endfold %}\n\n虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。\n\n`insert`函数的返回值类型是`std::pair<std::_Rb_tree_const_iterator<node>,bool>`~~，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了~~，因此我们需要加个`.first`。\n\n`std::set`内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\\operatorname{log}n)$的。\n\n然后是一个同样很核心的操作，\n\n```cpp\nvoid assign(int l,int r,int x)\n```\n\n将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void assign(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    //注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内\n    //后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器\n    s.erase(itl,itr);\n    //将[itl,itr)内所有区间删除\n    s.insert(node(l,r,x));\n    //用一个大区间取代它们\n}\n```\n\n{% endfold %}\n\n这就完了？\n\n这就完了。\n\n`assign`操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得`set`的大小迅速减小，并最终趋于$\\operatorname{log}n$。本题的操作二就只需调用一次`assign(l,r,x)`即可。\n\n然后是剩下的三个操作~~，一个比一个暴力~~。\n\n操作一，一个一个区间地拿出来加。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void IntervalAdd(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    for(re _it p=itl;p!=itr;++p)\n        p->val+=x;\n}\n```\n\n{% endfold %}\n\n就这么几行？\n\n就这么几行。\n\n操作三，把所有区间取出来，然后直接调用`std::sort`。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline long long IntervalXth(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    vec.clear();\n    for(re _it p=itl;p!=itr;++p)\n        vec.push_back(std::make_pair(p->val,p->r-p->l+1));\n    std::sort(vec.begin(),vec.end());\n    for(re unsigned i=0;i<vec.size();++i){\n        x-=vec[i].second;\n        if(x<=0)\n            return vec[i].first;\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n\n操作四，暴力快速幂。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline int IntervalXpow(int l,int r,int x,int y){\n    _it itr=split(r+1),itl=split(l);\n    int res=0;\n    for(re _it p=itl;p!=itr;++p)\n        res=(1LL*res+1LL*(p->r-p->l+1)*cltpow(p->val%y,x,y)%y)%y;\n    return res;\n}\n```\n\n{% endfold %}\n\n您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？\n\n这是我在CodeForces上的提交记录：\n\n![](https://i.loli.net/2018/10/14/5bc28b1443ea5.png)\n\n这是我之前提到的那位~~不愿意透露姓名的~~珂学家的跑得最快的一次提交记录：\n\n![](https://i.loli.net/2018/10/14/5bc28c7ecfe96.png)\n\n![](https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg)\n\n珂幻.jpg\n\n因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了[「CF915E」Physical Education Lessons](http://codeforces.com/contest/915/problem/E)，然而……\n\n![](https://i.loli.net/2018/10/14/5bc297890bbc6.png)\n\n> Updated on 2018-11-01\n>\n> 后来我卡了卡常数过了……\n>\n> 以及，删掉了某些内容（\n\n于是，接下来是珂朵莉树的完整板子。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#define re register\n#define maxn 100000\n#define _it std::set<node>::iterator\n\nnamespace cltstream{\n    #ifdef ONLINE_JUDGE\n        #define size 1048576\n        char str[size+1],*head=str,*tail=str;\n        inline char gc(){\n            if(head==tail){\n                tail=(head=str)+fread(str,1,size,stdin);\n                if(head==tail)\n                    return EOF;\n            }\n            return *head++;\n        }\n        #undef size\n    #else\n        #define gc getchar\n    #endif\n\n    template <typename _tp>\n    inline void read(_tp& x){\n        int sn=1;\n        char c=gc();\n        for(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n        if(c==45&&c!=EOF)\n            sn=-1,c=gc();\n        for(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n        x*=sn;\n    }\n\n    template <typename _tp>\n    inline void write(_tp x,char text=' '){\n        if(x<0)\n            putchar(45),x=-x;\n        if(!x)\n            putchar(48);\n        else{\n            int digit[20];\n            for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n            for(;digit[0];putchar(digit[digit[0]--]^48));\n        }\n        putchar(text);\n    }\n}\n\nint n,m,seed,maxval;\nstruct node{\n    int l,r;\n    mutable long long val;\n\n    node(int _l,int _r=-1,long long _val=-1){\n        l=_l;\n        r=_r;\n        val=_val;\n    }\n};\nstd::set<node> s;\nstd::vector<std::pair<long long,int> > vec;\n\ninline int rnd(){\n    int res=seed;\n    seed=(7LL*seed+13)%1000000007;\n    return res;\n}\n\ninline void swap(int& l,int& r){\n    int tmp=l;\n    l=r;\n    r=tmp;\n}\n\nint cltpow(int x,int y,int mod){\n    if(y==1)\n        return x;\n    int res=cltpow(x,y>>1,mod);\n    res=1LL*res*res%mod;\n    if(y&1)\n        res=1LL*res*x%mod;\n    return res;\n}\n\ninline bool operator<(node p,node q){\n    return p.l<q.l;\n}\n\ninline _it split(int pos){\n    _it it=std::lower_bound(s.begin(),s.end(),node(pos));\n    if(it!=s.end()&&it->l==pos)\n        return it;\n    --it;\n    int l=it->l,r=it->r;\n    long long val=it->val;\n    s.erase(it);\n    s.insert(node(l,pos-1,val));\n    return s.insert(node(pos,r,val)).first;\n}\n\ninline void IntervalAdd(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    for(re _it p=itl;p!=itr;++p)\n        p->val+=x;\n}\n\ninline void IntervalAssign(int l,int r,int x){\n//就是之前提到的assign\n    _it itr=split(r+1),itl=split(l);\n    s.erase(itl,itr);\n    s.insert(node(l,r,x));\n}\n\ninline long long IntervalXth(int l,int r,int x){\n    _it itr=split(r+1),itl=split(l);\n    vec.clear();\n    for(re _it p=itl;p!=itr;++p)\n        vec.push_back(std::make_pair(p->val,p->r-p->l+1));\n    std::sort(vec.begin(),vec.end());\n    for(re unsigned i=0;i<vec.size();++i){\n        x-=vec[i].second;\n        if(x<=0)\n            return vec[i].first;\n    }\n    return 0;\n}\n\ninline int IntervalXpow(int l,int r,int x,int y){\n    _it itr=split(r+1),itl=split(l);\n    int res=0;\n    for(re _it p=itl;p!=itr;++p)\n        res=(1LL*res+1LL*(p->r-p->l+1)*cltpow(p->val%y,x,y)%y)%y;\n    return res;\n}\n\nint main(){\n    cltstream::read(n);\n    cltstream::read(m);\n    cltstream::read(seed);\n    cltstream::read(maxval);\n    for(re int i=1;i<=n;++i)\n        s.insert(node(i,i,rnd()%maxval+1));\n    for(re int i=1;i<=m;++i){\n        int opt=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1,x,y;\n        if(l>r)\n            swap(l,r);\n        switch(opt){\n            case 1:\n                x=rnd()%maxval+1;\n                IntervalAdd(l,r,x);\n                break;\n            case 2:\n                x=rnd()%maxval+1;\n                IntervalAssign(l,r,x);\n                break;\n            case 3:\n                x=rnd()%(r-l+1)+1;\n                cltstream::write(IntervalXth(l,r,x),'\\n');\n                break;\n            case 4:\n                x=rnd()%maxval+1;\n                y=rnd()%maxval+1;\n                cltstream::write(IntervalXpow(l,r,x,y),'\\n');\n                break;\n        }\n    }\n    return 0;\n}\n```\n\n{% endfold %}\n\n以上。\n","slug":"chtholly-tree-learning-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwb003n34cw2u7epae1","content":"<p><del>还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p>\n<p><del>话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。</del></p>\n<p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p>\n<a id=\"more\"></a>\n<p>我们先来看一道<del>毒瘤</del>例题，<a href=\"http://codeforces.com/contest/896/problem/C\" target=\"_blank\" rel=\"noopener\">「CF896C」Willem, Chtholly and Seniorious</a>。</p>\n<p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？</p>\n<p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于<code>std::set</code>的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p>\n<blockquote>\n<p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p>\n</blockquote>\n<p>那么怎么推平呢？不急，我们慢慢讲。</p>\n<p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l,r;</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val;</span><br><span class=\"line\">    <span class=\"comment\">//这里的mutable是为了让我们在之后的修改过程中可以修改val的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">    node(<span class=\"keyword\">int</span> _l,<span class=\"keyword\">int</span> _r=<span class=\"number\">-1</span>,<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> _val=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//调用时_r或_val不填的话默认-1，为了后面split时方便</span></span><br><span class=\"line\">        l=_l;</span><br><span class=\"line\">        r=_r;</span><br><span class=\"line\">        val=_val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;node&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(node p,node q)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.l&lt;q.l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">    s.insert(node(i,i,rnd()%maxval+<span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>初始化完了？</p>\n<p>初始化完了。</p>\n<p>然后就是珂朵莉树的核心操作<del>之一</del>，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">std</span>::&lt;<span class=\"built_in\">set</span>&gt;::<span class=\"function\">iterator <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span></span><br></pre></td></tr></table></figure>\n<p>作用是分离出一个左端点为<code>pos</code>的区间并返回它的迭代器。它的具体实现如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _it std::set<span class=\"meta-string\">&lt;node&gt;::iterator</span></span></span><br><span class=\"line\"><span class=\"comment\">//上面这句手打非常麻烦，建议宏定义</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> _<span class=\"function\">it <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">    _it it=<span class=\"built_in\">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class=\"line\">    <span class=\"comment\">//找第一个左端点大于等于pos的区间</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> it;</span><br><span class=\"line\">    <span class=\"comment\">//如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器</span></span><br><span class=\"line\">    --it;</span><br><span class=\"line\">    <span class=\"comment\">//否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val=it-&gt;val;</span><br><span class=\"line\">    s.erase(it);</span><br><span class=\"line\">    s.insert(node(l,pos<span class=\"number\">-1</span>,val));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.insert(node(pos,r,val)).first;</span><br><span class=\"line\">    <span class=\"comment\">//将区间[l,r]删除，并插入区间[l,pos)和[pos,r]</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p>\n<p><code>insert</code>函数的返回值类型是<code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个<code>.first</code>。</p>\n<p><code>std::set</code>内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\\operatorname{log}n)$的。</p>\n<p>然后是一个同样很核心的操作，</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span></span><br></pre></td></tr></table></figure>\n<p>将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">assign</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    <span class=\"comment\">//注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内</span></span><br><span class=\"line\">    <span class=\"comment\">//后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器</span></span><br><span class=\"line\">    s.erase(itl,itr);</span><br><span class=\"line\">    <span class=\"comment\">//将[itl,itr)内所有区间删除</span></span><br><span class=\"line\">    s.insert(node(l,r,x));</span><br><span class=\"line\">    <span class=\"comment\">//用一个大区间取代它们</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>这就完了？</p>\n<p>这就完了。</p>\n<p><code>assign</code>操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得<code>set</code>的大小迅速减小，并最终趋于$\\operatorname{log}n$。本题的操作二就只需调用一次<code>assign(l,r,x)</code>即可。</p>\n<p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p>\n<p>操作一，一个一个区间地拿出来加。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">IntervalAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class=\"line\">        p-&gt;val+=x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>就这么几行？</p>\n<p>就这么几行。</p>\n<p>操作三，把所有区间取出来，然后直接调用<code>std::sort</code>。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">IntervalXth</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    vec.clear();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class=\"line\">        vec.push_back(<span class=\"built_in\">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::sort(vec.begin(),vec.end());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re <span class=\"keyword\">unsigned</span> i=<span class=\"number\">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class=\"line\">        x-=vec[i].second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> vec[i].first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>操作四，暴力快速幂。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">IntervalXpow</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class=\"line\">        res=(<span class=\"number\">1L</span>L*res+<span class=\"number\">1L</span>L*(p-&gt;r-p-&gt;l+<span class=\"number\">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p>\n<p>这是我在CodeForces上的提交记录：</p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc28b1443ea5.png\" alt=\"\"></p>\n<p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc28c7ecfe96.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg\" alt=\"\"></p>\n<p>珂幻.jpg</p>\n<p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href=\"http://codeforces.com/contest/915/problem/E\" target=\"_blank\" rel=\"noopener\">「CF915E」Physical Education Lessons</a>，然而……</p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc297890bbc6.png\" alt=\"\"></p>\n<blockquote>\n<p>Updated on 2018-11-01</p>\n<p>后来我卡了卡常数过了……</p>\n<p>以及，删掉了某些内容（</p>\n</blockquote>\n<p>于是，接下来是珂朵莉树的完整板子。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 100000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _it std::set<span class=\"meta-string\">&lt;node&gt;::iterator</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">        <span class=\"keyword\">char</span> str[size+<span class=\"number\">1</span>],*head=str,*tail=str;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(head==tail)&#123;</span><br><span class=\"line\">                tail=(head=str)+fread(str,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(head==tail)</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> *head++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">        <span class=\"meta\">#<span class=\"meta-keyword\">define</span> gc getchar</span></span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">            sn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">        x*=sn;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"string\">' '</span>)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">            <span class=\"built_in\">putchar</span>(<span class=\"number\">48</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> digit[<span class=\"number\">20</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];<span class=\"built_in\">putchar</span>(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(text);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,seed,maxval;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> l,r;</span><br><span class=\"line\">    <span class=\"keyword\">mutable</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val;</span><br><span class=\"line\"></span><br><span class=\"line\">    node(<span class=\"keyword\">int</span> _l,<span class=\"keyword\">int</span> _r=<span class=\"number\">-1</span>,<span class=\"keyword\">long</span> <span class=\"keyword\">long</span> _val=<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">        l=_l;</span><br><span class=\"line\">        r=_r;</span><br><span class=\"line\">        val=_val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;node&gt; s;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::pair&lt;<span class=\"keyword\">long</span> <span class=\"keyword\">long</span>,<span class=\"keyword\">int</span>&gt; &gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">rnd</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res=seed;</span><br><span class=\"line\">    seed=(<span class=\"number\">7L</span>L*seed+<span class=\"number\">13</span>)%<span class=\"number\">1000000007</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>&amp; l,<span class=\"keyword\">int</span>&amp; r)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tmp=l;</span><br><span class=\"line\">    l=r;</span><br><span class=\"line\">    r=tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cltpow</span><span class=\"params\">(<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y,<span class=\"keyword\">int</span> mod)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y==<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res=cltpow(x,y&gt;&gt;<span class=\"number\">1</span>,mod);</span><br><span class=\"line\">    res=<span class=\"number\">1L</span>L*res*res%mod;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">        res=<span class=\"number\">1L</span>L*res*x%mod;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(node p,node q)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> p.l&lt;q.l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> _<span class=\"function\">it <span class=\"title\">split</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">    _it it=<span class=\"built_in\">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> it;</span><br><span class=\"line\">    --it;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> val=it-&gt;val;</span><br><span class=\"line\">    s.erase(it);</span><br><span class=\"line\">    s.insert(node(l,pos<span class=\"number\">-1</span>,val));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> s.insert(node(pos,r,val)).first;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">IntervalAdd</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class=\"line\">        p-&gt;val+=x;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">IntervalAssign</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//就是之前提到的assign</span></span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    s.erase(itl,itr);</span><br><span class=\"line\">    s.insert(node(l,r,x));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">IntervalXth</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    vec.clear();</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class=\"line\">        vec.push_back(<span class=\"built_in\">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::sort(vec.begin(),vec.end());</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re <span class=\"keyword\">unsigned</span> i=<span class=\"number\">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class=\"line\">        x-=vec[i].second;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> vec[i].first;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">IntervalXpow</span><span class=\"params\">(<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">    _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class=\"line\">        res=(<span class=\"number\">1L</span>L*res+<span class=\"number\">1L</span>L*(p-&gt;r-p-&gt;l+<span class=\"number\">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    cltstream::read(n);</span><br><span class=\"line\">    cltstream::read(m);</span><br><span class=\"line\">    cltstream::read(seed);</span><br><span class=\"line\">    cltstream::read(maxval);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">        s.insert(node(i,i,rnd()%maxval+<span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> opt=rnd()%<span class=\"number\">4</span>+<span class=\"number\">1</span>,l=rnd()%n+<span class=\"number\">1</span>,r=rnd()%n+<span class=\"number\">1</span>,x,y;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(l&gt;r)</span><br><span class=\"line\">            swap(l,r);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(opt)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                x=rnd()%maxval+<span class=\"number\">1</span>;</span><br><span class=\"line\">                IntervalAdd(l,r,x);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                x=rnd()%maxval+<span class=\"number\">1</span>;</span><br><span class=\"line\">                IntervalAssign(l,r,x);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                x=rnd()%(r-l+<span class=\"number\">1</span>)+<span class=\"number\">1</span>;</span><br><span class=\"line\">                cltstream::write(IntervalXth(l,r,x),<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                x=rnd()%maxval+<span class=\"number\">1</span>;</span><br><span class=\"line\">                y=rnd()%maxval+<span class=\"number\">1</span>;</span><br><span class=\"line\">                cltstream::write(IntervalXpow(l,r,x,y),<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>以上。</p>\n","site":{"data":{}},"excerpt":"<p><del>还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p>\n<p><del>话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。</del></p>\n<p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p>","more":"<p>我们先来看一道<del>毒瘤</del>例题，<a href=\"http://codeforces.com/contest/896/problem/C\" target=\"_blank\" rel=\"noopener\">「CF896C」Willem, Chtholly and Seniorious</a>。</p>\n<p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？</p>\n<p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于<code>std::set</code>的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p>\n<blockquote>\n<p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p>\n</blockquote>\n<p>那么怎么推平呢？不急，我们慢慢讲。</p>\n<p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�10-->\n\n</div></div>\n<p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�11-->\n\n</div></div>\n<p>初始化完了？</p>\n<p>初始化完了。</p>\n<p>然后就是珂朵莉树的核心操作<del>之一</del>，</p>\n<!--�12-->\n<p>作用是分离出一个左端点为<code>pos</code>的区间并返回它的迭代器。它的具体实现如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�13-->\n\n</div></div>\n<p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p>\n<p><code>insert</code>函数的返回值类型是<code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个<code>.first</code>。</p>\n<p><code>std::set</code>内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\\operatorname{log}n)$的。</p>\n<p>然后是一个同样很核心的操作，</p>\n<!--�14-->\n<p>将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�15-->\n\n</div></div>\n<p>这就完了？</p>\n<p>这就完了。</p>\n<p><code>assign</code>操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得<code>set</code>的大小迅速减小，并最终趋于$\\operatorname{log}n$。本题的操作二就只需调用一次<code>assign(l,r,x)</code>即可。</p>\n<p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p>\n<p>操作一，一个一个区间地拿出来加。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�16-->\n\n</div></div>\n<p>就这么几行？</p>\n<p>就这么几行。</p>\n<p>操作三，把所有区间取出来，然后直接调用<code>std::sort</code>。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�17-->\n\n</div></div>\n<p>操作四，暴力快速幂。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�18-->\n\n</div></div>\n<p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p>\n<p>这是我在CodeForces上的提交记录：</p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc28b1443ea5.png\" alt=\"\"></p>\n<p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc28c7ecfe96.png\" alt=\"\"></p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg\" alt=\"\"></p>\n<p>珂幻.jpg</p>\n<p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href=\"http://codeforces.com/contest/915/problem/E\" target=\"_blank\" rel=\"noopener\">「CF915E」Physical Education Lessons</a>，然而……</p>\n<p><img src=\"https://i.loli.net/2018/10/14/5bc297890bbc6.png\" alt=\"\"></p>\n<blockquote>\n<p>Updated on 2018-11-01</p>\n<p>后来我卡了卡常数过了……</p>\n<p>以及，删掉了某些内容（</p>\n</blockquote>\n<p>于是，接下来是珂朵莉树的完整板子。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�19-->\n\n</div></div>\n<p>以上。</p>"},{"title":"「Luogu-P5009」毒瘤分块题","date":"2018-11-08T00:04:22.000Z","mathjax":true,"_content":"[传送门](https://www.luogu.org/problemnew/show/P5009)\n\n<!-- more -->\n\n从来没做过这么毒瘤的题qaq\n\n就算看了题解现在还是一脸懵逼qaq\n\n首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq\n\n对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2>t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\\prime$使得$v_i^\\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\\prime$，然后查询的时候我们就可以直接返回$v_i^\\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\\prime=v_i-t_1xb_i$。\n\n需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\\Sigma v_i^\\prime+t\\Sigma (a_i+x+z)(b_i+y)=\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$，即$\\Sigma v_i^\\prime=\\Sigma v_i-tz\\Sigma (b_i+y)$。\n\n不过，上式中$tz\\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\\Sigma b_i$，考虑到每层节点的$\\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\\Sigma v_i+=B\\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。\n\n然后是毒瘤的下推标记。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\naddv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];\n//就是上面这句qaq现在还是一脸懵逼qaq\nA[son]+=A[father];\nB[son]+=B[father];\nadda[son]+=adda[father];\naddb[son]+=addf[father];\n```\n\n{% endfold %}\n\n其实我也不知道我上面在扯些啥，所以以下是代码~~，反正应该没人能看懂我的清奇写法（~~\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#define re register\n#define maxn 200005\n#define maxm 200005\n#define mod 100000007\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m;\nint sumv[(maxn<<2)+1],suma[(maxn<<2)+1],sumb[(maxn<<2)+1],sump[(maxn<<2)+1];\nint A[(maxn<<2)+1],B[(maxn<<2)+1];\nint addv[(maxn<<2)+1],adda[(maxn<<2)+1],addb[(maxn<<2)+1];\n\ninline void pushDown(int cur,int ln,int rn){\n\tsumv[cur<<1]=(sumv[cur<<1]+1LL*A[cur]*suma[cur<<1]%mod)%mod;\n\tsumv[cur<<1]=(sumv[cur<<1]+1LL*B[cur]*sumb[cur<<1]%mod)%mod;\n\tsumv[cur<<1]=(sumv[cur<<1]+1LL*ln*addv[cur]%mod)%mod;\n\tsump[cur<<1]=(sump[cur<<1]+1LL*adda[cur]*sumb[cur<<1]%mod)%mod;\n\tsump[cur<<1]=(sump[cur<<1]+1LL*addb[cur]*suma[cur<<1]%mod)%mod;\n\tsump[cur<<1]=(sump[cur<<1]+1LL*adda[cur]*addb[cur]%mod*ln%mod)%mod;\n\tsuma[cur<<1]=(suma[cur<<1]+1LL*ln*adda[cur]%mod)%mod;\n\tsumb[cur<<1]=(sumb[cur<<1]+1LL*ln*addb[cur]%mod)%mod;\n\taddv[cur<<1]=(addv[cur<<1]+1LL*A[cur]*adda[cur<<1]%mod)%mod;\n\taddv[cur<<1]=(addv[cur<<1]+1LL*B[cur]*addb[cur<<1]%mod)%mod;\n\taddv[cur<<1]=(addv[cur<<1]+addv[cur])%mod;\n\tA[cur<<1]=(A[cur<<1]+A[cur])%mod;\n\tB[cur<<1]=(B[cur<<1]+B[cur])%mod;\n\tadda[cur<<1]=(adda[cur<<1]+adda[cur])%mod;\n\taddb[cur<<1]=(addb[cur<<1]+addb[cur])%mod;\n\tsumv[cur<<1|1]=(sumv[cur<<1|1]+1LL*A[cur]*suma[cur<<1|1]%mod)%mod;\n\tsumv[cur<<1|1]=(sumv[cur<<1|1]+1LL*B[cur]*sumb[cur<<1|1]%mod)%mod;\n\tsumv[cur<<1|1]=(sumv[cur<<1|1]+1LL*rn*addv[cur]%mod)%mod;\n\tsump[cur<<1|1]=(sump[cur<<1|1]+1LL*adda[cur]*sumb[cur<<1|1]%mod)%mod;\n\tsump[cur<<1|1]=(sump[cur<<1|1]+1LL*addb[cur]*suma[cur<<1|1]%mod)%mod;\n\tsump[cur<<1|1]=(sump[cur<<1|1]+1LL*adda[cur]*addb[cur]%mod*rn%mod)%mod;\n\tsuma[cur<<1|1]=(suma[cur<<1|1]+1LL*rn*adda[cur]%mod)%mod;\n\tsumb[cur<<1|1]=(sumb[cur<<1|1]+1LL*rn*addb[cur]%mod)%mod;\n\taddv[cur<<1|1]=(addv[cur<<1|1]+1LL*A[cur]*adda[cur<<1|1]%mod)%mod;\n\taddv[cur<<1|1]=(addv[cur<<1|1]+1LL*B[cur]*addb[cur<<1|1]%mod)%mod;\n\taddv[cur<<1|1]=(addv[cur<<1|1]+addv[cur])%mod;\n\tA[cur<<1|1]=(A[cur<<1|1]+A[cur])%mod;\n\tB[cur<<1|1]=(B[cur<<1|1]+B[cur])%mod;\n\tadda[cur<<1|1]=(adda[cur<<1|1]+adda[cur])%mod;\n\taddb[cur<<1|1]=(addb[cur<<1|1]+addb[cur])%mod;\n\tA[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=0;\n}\n\ninline void pushUp(int cur){\n\tsumv[cur]=(sumv[cur<<1]+sumv[cur<<1|1])%mod;\n\tsuma[cur]=(suma[cur<<1]+suma[cur<<1|1])%mod;\n\tsumb[cur]=(sumb[cur<<1]+sumb[cur<<1|1])%mod;\n\tsump[cur]=(sump[cur<<1]+sump[cur<<1|1])%mod;\n}\n\nvoid build(int cur,int l,int r){\n\tif(l==r){\n\t\tcltstream::read(sumv[cur]);\n\t\tcltstream::read(suma[cur]);\n\t\tcltstream::read(sumb[cur]);\n\t\tsumv[cur]=(sumv[cur]%mod+mod)%mod;\n\t\tsuma[cur]=(suma[cur]%mod+mod)%mod;\n\t\tsumb[cur]=(sumb[cur]%mod+mod)%mod;\n\t\tsump[cur]=1LL*suma[cur]*sumb[cur]%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tbuild(cur<<1,l,mid);\n\t\tbuild(cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nint query(int L,int R,int t,int cur,int l,int r){\n\tif(l>=L&&r<=R)\n\t\treturn (sumv[cur]+1LL*t*sump[cur]%mod)%mod;\n\telse{\n\t\tint mid=(l+r)>>1,res=0;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tres=(res+query(L,R,t,cur<<1,l,mid))%mod;\n\t\tif(R>mid)\n\t\t\tres=(res+query(L,R,t,cur<<1|1,mid+1,r))%mod;\n\t\treturn res;\n\t}\n}\n\nvoid modifyV(int L,int R,int x,int cur,int l,int r){\n\tif(l>=L&&r<=R){\n\t\tsumv[cur]=(sumv[cur]+1LL*(r-l+1)*x%mod)%mod;\n\t\taddv[cur]=(addv[cur]+x)%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tmodifyV(L,R,x,cur<<1,l,mid);\n\t\tif(R>mid)\n\t\t\tmodifyV(L,R,x,cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nvoid modifyA(int L,int R,int t,int x,int cur,int l,int r){\n\tif(l>=L&&r<=R){\n\t\tsumv[cur]=(sumv[cur]+(-1LL*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;\n\t\tsuma[cur]=(suma[cur]+1LL*(r-l+1)*x%mod)%mod;\n\t\tsump[cur]=(sump[cur]+1LL*sumb[cur]*x%mod)%mod;\n\t\tB[cur]=(B[cur]+(-1LL*x*t%mod+mod)%mod)%mod;\n\t\taddv[cur]=(addv[cur]+(-1LL*x*t%mod*addb[cur]%mod+mod)%mod)%mod;\n\t\tadda[cur]=(adda[cur]+x)%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tmodifyA(L,R,t,x,cur<<1,l,mid);\n\t\tif(R>mid)\n\t\t\tmodifyA(L,R,t,x,cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nvoid modifyB(int L,int R,int t,int x,int cur,int l,int r){\n\tif(l>=L&&r<=R){\n\t\tsumv[cur]=(sumv[cur]+(-1LL*x*t%mod*suma[cur]%mod+mod)%mod)%mod;\n\t\tsumb[cur]=(sumb[cur]+1LL*(r-l+1)*x%mod)%mod;\n\t\tsump[cur]=(sump[cur]+1LL*suma[cur]*x%mod)%mod;\n\t\tA[cur]=(A[cur]+(-1LL*x*t%mod+mod)%mod)%mod;\n\t\taddv[cur]=(addv[cur]+(-1LL*x*t%mod*adda[cur]%mod+mod)%mod)%mod;\n\t\taddb[cur]=(addb[cur]+x)%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tmodifyB(L,R,t,x,cur<<1,l,mid);\n\t\tif(R>mid)\n\t\t\tmodifyB(L,R,t,x,cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nint main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tbuild(1,1,n);\n\tfor(re int i=1;i<=m;++i){\n\t\tint opt,t,l,r,x;\n\t\tcltstream::read(opt);\n\t\tcltstream::read(t);\n\t\tcltstream::read(l);\n\t\tcltstream::read(r);\n\t\tswitch(opt){\n\t\t\tcase 1:\n\t\t\t\tcltstream::write(query(l,r,t,1,1,n),10);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcltstream::read(x);\n\t\t\t\tmodifyA(l,r,t,(x%mod+mod)%mod,1,1,n);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcltstream::read(x);\n\t\t\t\tmodifyB(l,r,t,(x%mod+mod)%mod,1,1,n);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcltstream::read(x);\n\t\t\t\tmodifyV(l,r,(x%mod+mod)%mod,1,1,n);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n大概是我太菜了不适合做这种毒瘤题吧qaq\n\n![](https://i.loli.net/2018/11/08/5be38edf529ca.jpg)\n\n距 __在NOIp2018爆零__ 还剩 __1 天__。\n","source":"_posts/2018-11-08-luogu-p5009-solution.md","raw":"---\ntitle: 「Luogu-P5009」毒瘤分块题\ndate: 2018-11-08 08:04:22\ntags:\n  - 洛谷\n  - 线段树\ncategories:\n  - 题解\nmathjax: true\n---\n[传送门](https://www.luogu.org/problemnew/show/P5009)\n\n<!-- more -->\n\n从来没做过这么毒瘤的题qaq\n\n就算看了题解现在还是一脸懵逼qaq\n\n首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq\n\n对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2>t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\\prime$使得$v_i^\\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\\prime$，然后查询的时候我们就可以直接返回$v_i^\\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\\prime=v_i-t_1xb_i$。\n\n需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\\Sigma v_i^\\prime+t\\Sigma (a_i+x+z)(b_i+y)=\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$，即$\\Sigma v_i^\\prime=\\Sigma v_i-tz\\Sigma (b_i+y)$。\n\n不过，上式中$tz\\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\\Sigma b_i$，考虑到每层节点的$\\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\\Sigma v_i+=B\\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。\n\n然后是毒瘤的下推标记。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\naddv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];\n//就是上面这句qaq现在还是一脸懵逼qaq\nA[son]+=A[father];\nB[son]+=B[father];\nadda[son]+=adda[father];\naddb[son]+=addf[father];\n```\n\n{% endfold %}\n\n其实我也不知道我上面在扯些啥，所以以下是代码~~，反正应该没人能看懂我的清奇写法（~~\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#define re register\n#define maxn 200005\n#define maxm 200005\n#define mod 100000007\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m;\nint sumv[(maxn<<2)+1],suma[(maxn<<2)+1],sumb[(maxn<<2)+1],sump[(maxn<<2)+1];\nint A[(maxn<<2)+1],B[(maxn<<2)+1];\nint addv[(maxn<<2)+1],adda[(maxn<<2)+1],addb[(maxn<<2)+1];\n\ninline void pushDown(int cur,int ln,int rn){\n\tsumv[cur<<1]=(sumv[cur<<1]+1LL*A[cur]*suma[cur<<1]%mod)%mod;\n\tsumv[cur<<1]=(sumv[cur<<1]+1LL*B[cur]*sumb[cur<<1]%mod)%mod;\n\tsumv[cur<<1]=(sumv[cur<<1]+1LL*ln*addv[cur]%mod)%mod;\n\tsump[cur<<1]=(sump[cur<<1]+1LL*adda[cur]*sumb[cur<<1]%mod)%mod;\n\tsump[cur<<1]=(sump[cur<<1]+1LL*addb[cur]*suma[cur<<1]%mod)%mod;\n\tsump[cur<<1]=(sump[cur<<1]+1LL*adda[cur]*addb[cur]%mod*ln%mod)%mod;\n\tsuma[cur<<1]=(suma[cur<<1]+1LL*ln*adda[cur]%mod)%mod;\n\tsumb[cur<<1]=(sumb[cur<<1]+1LL*ln*addb[cur]%mod)%mod;\n\taddv[cur<<1]=(addv[cur<<1]+1LL*A[cur]*adda[cur<<1]%mod)%mod;\n\taddv[cur<<1]=(addv[cur<<1]+1LL*B[cur]*addb[cur<<1]%mod)%mod;\n\taddv[cur<<1]=(addv[cur<<1]+addv[cur])%mod;\n\tA[cur<<1]=(A[cur<<1]+A[cur])%mod;\n\tB[cur<<1]=(B[cur<<1]+B[cur])%mod;\n\tadda[cur<<1]=(adda[cur<<1]+adda[cur])%mod;\n\taddb[cur<<1]=(addb[cur<<1]+addb[cur])%mod;\n\tsumv[cur<<1|1]=(sumv[cur<<1|1]+1LL*A[cur]*suma[cur<<1|1]%mod)%mod;\n\tsumv[cur<<1|1]=(sumv[cur<<1|1]+1LL*B[cur]*sumb[cur<<1|1]%mod)%mod;\n\tsumv[cur<<1|1]=(sumv[cur<<1|1]+1LL*rn*addv[cur]%mod)%mod;\n\tsump[cur<<1|1]=(sump[cur<<1|1]+1LL*adda[cur]*sumb[cur<<1|1]%mod)%mod;\n\tsump[cur<<1|1]=(sump[cur<<1|1]+1LL*addb[cur]*suma[cur<<1|1]%mod)%mod;\n\tsump[cur<<1|1]=(sump[cur<<1|1]+1LL*adda[cur]*addb[cur]%mod*rn%mod)%mod;\n\tsuma[cur<<1|1]=(suma[cur<<1|1]+1LL*rn*adda[cur]%mod)%mod;\n\tsumb[cur<<1|1]=(sumb[cur<<1|1]+1LL*rn*addb[cur]%mod)%mod;\n\taddv[cur<<1|1]=(addv[cur<<1|1]+1LL*A[cur]*adda[cur<<1|1]%mod)%mod;\n\taddv[cur<<1|1]=(addv[cur<<1|1]+1LL*B[cur]*addb[cur<<1|1]%mod)%mod;\n\taddv[cur<<1|1]=(addv[cur<<1|1]+addv[cur])%mod;\n\tA[cur<<1|1]=(A[cur<<1|1]+A[cur])%mod;\n\tB[cur<<1|1]=(B[cur<<1|1]+B[cur])%mod;\n\tadda[cur<<1|1]=(adda[cur<<1|1]+adda[cur])%mod;\n\taddb[cur<<1|1]=(addb[cur<<1|1]+addb[cur])%mod;\n\tA[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=0;\n}\n\ninline void pushUp(int cur){\n\tsumv[cur]=(sumv[cur<<1]+sumv[cur<<1|1])%mod;\n\tsuma[cur]=(suma[cur<<1]+suma[cur<<1|1])%mod;\n\tsumb[cur]=(sumb[cur<<1]+sumb[cur<<1|1])%mod;\n\tsump[cur]=(sump[cur<<1]+sump[cur<<1|1])%mod;\n}\n\nvoid build(int cur,int l,int r){\n\tif(l==r){\n\t\tcltstream::read(sumv[cur]);\n\t\tcltstream::read(suma[cur]);\n\t\tcltstream::read(sumb[cur]);\n\t\tsumv[cur]=(sumv[cur]%mod+mod)%mod;\n\t\tsuma[cur]=(suma[cur]%mod+mod)%mod;\n\t\tsumb[cur]=(sumb[cur]%mod+mod)%mod;\n\t\tsump[cur]=1LL*suma[cur]*sumb[cur]%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tbuild(cur<<1,l,mid);\n\t\tbuild(cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nint query(int L,int R,int t,int cur,int l,int r){\n\tif(l>=L&&r<=R)\n\t\treturn (sumv[cur]+1LL*t*sump[cur]%mod)%mod;\n\telse{\n\t\tint mid=(l+r)>>1,res=0;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tres=(res+query(L,R,t,cur<<1,l,mid))%mod;\n\t\tif(R>mid)\n\t\t\tres=(res+query(L,R,t,cur<<1|1,mid+1,r))%mod;\n\t\treturn res;\n\t}\n}\n\nvoid modifyV(int L,int R,int x,int cur,int l,int r){\n\tif(l>=L&&r<=R){\n\t\tsumv[cur]=(sumv[cur]+1LL*(r-l+1)*x%mod)%mod;\n\t\taddv[cur]=(addv[cur]+x)%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tmodifyV(L,R,x,cur<<1,l,mid);\n\t\tif(R>mid)\n\t\t\tmodifyV(L,R,x,cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nvoid modifyA(int L,int R,int t,int x,int cur,int l,int r){\n\tif(l>=L&&r<=R){\n\t\tsumv[cur]=(sumv[cur]+(-1LL*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;\n\t\tsuma[cur]=(suma[cur]+1LL*(r-l+1)*x%mod)%mod;\n\t\tsump[cur]=(sump[cur]+1LL*sumb[cur]*x%mod)%mod;\n\t\tB[cur]=(B[cur]+(-1LL*x*t%mod+mod)%mod)%mod;\n\t\taddv[cur]=(addv[cur]+(-1LL*x*t%mod*addb[cur]%mod+mod)%mod)%mod;\n\t\tadda[cur]=(adda[cur]+x)%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tmodifyA(L,R,t,x,cur<<1,l,mid);\n\t\tif(R>mid)\n\t\t\tmodifyA(L,R,t,x,cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nvoid modifyB(int L,int R,int t,int x,int cur,int l,int r){\n\tif(l>=L&&r<=R){\n\t\tsumv[cur]=(sumv[cur]+(-1LL*x*t%mod*suma[cur]%mod+mod)%mod)%mod;\n\t\tsumb[cur]=(sumb[cur]+1LL*(r-l+1)*x%mod)%mod;\n\t\tsump[cur]=(sump[cur]+1LL*suma[cur]*x%mod)%mod;\n\t\tA[cur]=(A[cur]+(-1LL*x*t%mod+mod)%mod)%mod;\n\t\taddv[cur]=(addv[cur]+(-1LL*x*t%mod*adda[cur]%mod+mod)%mod)%mod;\n\t\taddb[cur]=(addb[cur]+x)%mod;\n\t}\n\telse{\n\t\tint mid=(l+r)>>1;\n\t\tpushDown(cur,mid-l+1,r-mid);\n\t\tif(L<=mid)\n\t\t\tmodifyB(L,R,t,x,cur<<1,l,mid);\n\t\tif(R>mid)\n\t\t\tmodifyB(L,R,t,x,cur<<1|1,mid+1,r);\n\t\tpushUp(cur);\n\t}\n}\n\nint main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tbuild(1,1,n);\n\tfor(re int i=1;i<=m;++i){\n\t\tint opt,t,l,r,x;\n\t\tcltstream::read(opt);\n\t\tcltstream::read(t);\n\t\tcltstream::read(l);\n\t\tcltstream::read(r);\n\t\tswitch(opt){\n\t\t\tcase 1:\n\t\t\t\tcltstream::write(query(l,r,t,1,1,n),10);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tcltstream::read(x);\n\t\t\t\tmodifyA(l,r,t,(x%mod+mod)%mod,1,1,n);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tcltstream::read(x);\n\t\t\t\tmodifyB(l,r,t,(x%mod+mod)%mod,1,1,n);\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tcltstream::read(x);\n\t\t\t\tmodifyV(l,r,(x%mod+mod)%mod,1,1,n);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n大概是我太菜了不适合做这种毒瘤题吧qaq\n\n![](https://i.loli.net/2018/11/08/5be38edf529ca.jpg)\n\n距 __在NOIp2018爆零__ 还剩 __1 天__。\n","slug":"luogu-p5009-solution","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwc003p34cwjf55ld5o","content":"<p><a href=\"https://www.luogu.org/problemnew/show/P5009\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<a id=\"more\"></a>\n<p>从来没做过这么毒瘤的题qaq</p>\n<p>就算看了题解现在还是一脸懵逼qaq</p>\n<p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq</p>\n<p>对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\\prime$使得$v_i^\\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\\prime$，然后查询的时候我们就可以直接返回$v_i^\\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\\prime=v_i-t_1xb_i$。</p>\n<p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\\Sigma v_i^\\prime+t\\Sigma (a_i+x+z)(b_i+y)=\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$，即$\\Sigma v_i^\\prime=\\Sigma v_i-tz\\Sigma (b_i+y)$。</p>\n<p>不过，上式中$tz\\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\\Sigma b_i$，考虑到每层节点的$\\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\\Sigma v_i+=B\\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。</p>\n<p>然后是毒瘤的下推标记。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];</span><br><span class=\"line\"><span class=\"comment\">//就是上面这句qaq现在还是一脸懵逼qaq</span></span><br><span class=\"line\">A[son]+=A[father];</span><br><span class=\"line\">B[son]+=B[father];</span><br><span class=\"line\">adda[son]+=adda[father];</span><br><span class=\"line\">addb[son]+=addf[father];</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 200005</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxm 200005</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 100000007</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> sumv[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>],suma[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>],sumb[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>],sump[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> A[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>],B[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> addv[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>],adda[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>],addb[(maxn&lt;&lt;<span class=\"number\">2</span>)+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushDown</span><span class=\"params\">(<span class=\"keyword\">int</span> cur,<span class=\"keyword\">int</span> ln,<span class=\"keyword\">int</span> rn)</span></span>&#123;</span><br><span class=\"line\">\tsumv[cur&lt;&lt;<span class=\"number\">1</span>]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsumv[cur&lt;&lt;<span class=\"number\">1</span>]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsumv[cur&lt;&lt;<span class=\"number\">1</span>]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*ln*addv[cur]%mod)%mod;</span><br><span class=\"line\">\tsump[cur&lt;&lt;<span class=\"number\">1</span>]=(sump[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsump[cur&lt;&lt;<span class=\"number\">1</span>]=(sump[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsump[cur&lt;&lt;<span class=\"number\">1</span>]=(sump[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*adda[cur]*addb[cur]%mod*ln%mod)%mod;</span><br><span class=\"line\">\tsuma[cur&lt;&lt;<span class=\"number\">1</span>]=(suma[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*ln*adda[cur]%mod)%mod;</span><br><span class=\"line\">\tsumb[cur&lt;&lt;<span class=\"number\">1</span>]=(sumb[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*ln*addb[cur]%mod)%mod;</span><br><span class=\"line\">\taddv[cur&lt;&lt;<span class=\"number\">1</span>]=(addv[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\taddv[cur&lt;&lt;<span class=\"number\">1</span>]=(addv[cur&lt;&lt;<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\taddv[cur&lt;&lt;<span class=\"number\">1</span>]=(addv[cur&lt;&lt;<span class=\"number\">1</span>]+addv[cur])%mod;</span><br><span class=\"line\">\tA[cur&lt;&lt;<span class=\"number\">1</span>]=(A[cur&lt;&lt;<span class=\"number\">1</span>]+A[cur])%mod;</span><br><span class=\"line\">\tB[cur&lt;&lt;<span class=\"number\">1</span>]=(B[cur&lt;&lt;<span class=\"number\">1</span>]+B[cur])%mod;</span><br><span class=\"line\">\tadda[cur&lt;&lt;<span class=\"number\">1</span>]=(adda[cur&lt;&lt;<span class=\"number\">1</span>]+adda[cur])%mod;</span><br><span class=\"line\">\taddb[cur&lt;&lt;<span class=\"number\">1</span>]=(addb[cur&lt;&lt;<span class=\"number\">1</span>]+addb[cur])%mod;</span><br><span class=\"line\">\tsumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*rn*addv[cur]%mod)%mod;</span><br><span class=\"line\">\tsump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\tsump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*adda[cur]*addb[cur]%mod*rn%mod)%mod;</span><br><span class=\"line\">\tsuma[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(suma[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*rn*adda[cur]%mod)%mod;</span><br><span class=\"line\">\tsumb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(sumb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*rn*addb[cur]%mod)%mod;</span><br><span class=\"line\">\taddv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(addv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\taddv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(addv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+<span class=\"number\">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]%mod)%mod;</span><br><span class=\"line\">\taddv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(addv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+addv[cur])%mod;</span><br><span class=\"line\">\tA[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(A[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+A[cur])%mod;</span><br><span class=\"line\">\tB[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(B[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+B[cur])%mod;</span><br><span class=\"line\">\tadda[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(adda[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+adda[cur])%mod;</span><br><span class=\"line\">\taddb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]=(addb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>]+addb[cur])%mod;</span><br><span class=\"line\">\tA[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushUp</span><span class=\"params\">(<span class=\"keyword\">int</span> cur)</span></span>&#123;</span><br><span class=\"line\">\tsumv[cur]=(sumv[cur&lt;&lt;<span class=\"number\">1</span>]+sumv[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\tsuma[cur]=(suma[cur&lt;&lt;<span class=\"number\">1</span>]+suma[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\tsumb[cur]=(sumb[cur&lt;&lt;<span class=\"number\">1</span>]+sumb[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">\tsump[cur]=(sump[cur&lt;&lt;<span class=\"number\">1</span>]+sump[cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>])%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(<span class=\"keyword\">int</span> cur,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l==r)&#123;</span><br><span class=\"line\">\t\tcltstream::read(sumv[cur]);</span><br><span class=\"line\">\t\tcltstream::read(suma[cur]);</span><br><span class=\"line\">\t\tcltstream::read(sumb[cur]);</span><br><span class=\"line\">\t\tsumv[cur]=(sumv[cur]%mod+mod)%mod;</span><br><span class=\"line\">\t\tsuma[cur]=(suma[cur]%mod+mod)%mod;</span><br><span class=\"line\">\t\tsumb[cur]=(sumb[cur]%mod+mod)%mod;</span><br><span class=\"line\">\t\tsump[cur]=<span class=\"number\">1L</span>L*suma[cur]*sumb[cur]%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tbuild(cur&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t\tbuild(cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\tpushUp(cur);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">query</span><span class=\"params\">(<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> cur,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (sumv[cur]+<span class=\"number\">1L</span>L*t*sump[cur]%mod)%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>,res=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tpushDown(cur,mid-l+<span class=\"number\">1</span>,r-mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L&lt;=mid)</span><br><span class=\"line\">\t\t\tres=(res+query(L,R,t,cur&lt;&lt;<span class=\"number\">1</span>,l,mid))%mod;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(R&gt;mid)</span><br><span class=\"line\">\t\t\tres=(res+query(L,R,t,cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r))%mod;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modifyV</span><span class=\"params\">(<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> cur,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class=\"line\">\t\tsumv[cur]=(sumv[cur]+<span class=\"number\">1L</span>L*(r-l+<span class=\"number\">1</span>)*x%mod)%mod;</span><br><span class=\"line\">\t\taddv[cur]=(addv[cur]+x)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tpushDown(cur,mid-l+<span class=\"number\">1</span>,r-mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L&lt;=mid)</span><br><span class=\"line\">\t\t\tmodifyV(L,R,x,cur&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(R&gt;mid)</span><br><span class=\"line\">\t\t\tmodifyV(L,R,x,cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\tpushUp(cur);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modifyA</span><span class=\"params\">(<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> cur,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class=\"line\">\t\tsumv[cur]=(sumv[cur]+(<span class=\"number\">-1L</span>L*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;</span><br><span class=\"line\">\t\tsuma[cur]=(suma[cur]+<span class=\"number\">1L</span>L*(r-l+<span class=\"number\">1</span>)*x%mod)%mod;</span><br><span class=\"line\">\t\tsump[cur]=(sump[cur]+<span class=\"number\">1L</span>L*sumb[cur]*x%mod)%mod;</span><br><span class=\"line\">\t\tB[cur]=(B[cur]+(<span class=\"number\">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class=\"line\">\t\taddv[cur]=(addv[cur]+(<span class=\"number\">-1L</span>L*x*t%mod*addb[cur]%mod+mod)%mod)%mod;</span><br><span class=\"line\">\t\tadda[cur]=(adda[cur]+x)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tpushDown(cur,mid-l+<span class=\"number\">1</span>,r-mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L&lt;=mid)</span><br><span class=\"line\">\t\t\tmodifyA(L,R,t,x,cur&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(R&gt;mid)</span><br><span class=\"line\">\t\t\tmodifyA(L,R,t,x,cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\tpushUp(cur);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">modifyB</span><span class=\"params\">(<span class=\"keyword\">int</span> L,<span class=\"keyword\">int</span> R,<span class=\"keyword\">int</span> t,<span class=\"keyword\">int</span> x,<span class=\"keyword\">int</span> cur,<span class=\"keyword\">int</span> l,<span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class=\"line\">\t\tsumv[cur]=(sumv[cur]+(<span class=\"number\">-1L</span>L*x*t%mod*suma[cur]%mod+mod)%mod)%mod;</span><br><span class=\"line\">\t\tsumb[cur]=(sumb[cur]+<span class=\"number\">1L</span>L*(r-l+<span class=\"number\">1</span>)*x%mod)%mod;</span><br><span class=\"line\">\t\tsump[cur]=(sump[cur]+<span class=\"number\">1L</span>L*suma[cur]*x%mod)%mod;</span><br><span class=\"line\">\t\tA[cur]=(A[cur]+(<span class=\"number\">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class=\"line\">\t\taddv[cur]=(addv[cur]+(<span class=\"number\">-1L</span>L*x*t%mod*adda[cur]%mod+mod)%mod)%mod;</span><br><span class=\"line\">\t\taddb[cur]=(addb[cur]+x)%mod;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> mid=(l+r)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tpushDown(cur,mid-l+<span class=\"number\">1</span>,r-mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(L&lt;=mid)</span><br><span class=\"line\">\t\t\tmodifyB(L,R,t,x,cur&lt;&lt;<span class=\"number\">1</span>,l,mid);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(R&gt;mid)</span><br><span class=\"line\">\t\t\tmodifyB(L,R,t,x,cur&lt;&lt;<span class=\"number\">1</span>|<span class=\"number\">1</span>,mid+<span class=\"number\">1</span>,r);</span><br><span class=\"line\">\t\tpushUp(cur);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\tcltstream::read(m);</span><br><span class=\"line\">\tbuild(<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> opt,t,l,r,x;</span><br><span class=\"line\">\t\tcltstream::read(opt);</span><br><span class=\"line\">\t\tcltstream::read(t);</span><br><span class=\"line\">\t\tcltstream::read(l);</span><br><span class=\"line\">\t\tcltstream::read(r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(opt)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\tcltstream::write(query(l,r,t,<span class=\"number\">1</span>,<span class=\"number\">1</span>,n),<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t\tcltstream::read(x);</span><br><span class=\"line\">\t\t\t\tmodifyA(l,r,t,(x%mod+mod)%mod,<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t\tcltstream::read(x);</span><br><span class=\"line\">\t\t\t\tmodifyB(l,r,t,(x%mod+mod)%mod,<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t\tcltstream::read(x);</span><br><span class=\"line\">\t\t\t\tmodifyV(l,r,(x%mod+mod)%mod,<span class=\"number\">1</span>,<span class=\"number\">1</span>,n);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>大概是我太菜了不适合做这种毒瘤题吧qaq</p>\n<p><img src=\"https://i.loli.net/2018/11/08/5be38edf529ca.jpg\" alt=\"\"></p>\n<p>距 <strong>在NOIp2018爆零</strong> 还剩 <strong>1 天</strong>。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.luogu.org/problemnew/show/P5009\" target=\"_blank\" rel=\"noopener\">传送门</a></p>","more":"<p>从来没做过这么毒瘤的题qaq</p>\n<p>就算看了题解现在还是一脸懵逼qaq</p>\n<p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq</p>\n<p>对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\\prime$使得$v_i^\\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\\prime$，然后查询的时候我们就可以直接返回$v_i^\\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\\prime=v_i-t_1xb_i$。</p>\n<p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\\Sigma v_i^\\prime+t\\Sigma (a_i+x+z)(b_i+y)=\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$，即$\\Sigma v_i^\\prime=\\Sigma v_i-tz\\Sigma (b_i+y)$。</p>\n<p>不过，上式中$tz\\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\\Sigma b_i$，考虑到每层节点的$\\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\\Sigma v_i+=B\\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。</p>\n<p>然后是毒瘤的下推标记。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�20-->\n\n</div></div>\n<p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�21-->\n\n</div></div>\n<p>大概是我太菜了不适合做这种毒瘤题吧qaq</p>\n<p><img src=\"https://i.loli.net/2018/11/08/5be38edf529ca.jpg\" alt=\"\"></p>\n<p>距 <strong>在NOIp2018爆零</strong> 还剩 <strong>1 天</strong>。</p>"},{"title":"「未来算法Episode I」严格根号分块实现树套树","date":"2018-12-08T11:55:00.000Z","mathjax":true,"_content":"分块天下第一！！！！！！！！！\n\n<!-- more -->\n\n我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。\n\n[![](https://i.loli.net/2018/12/08/5c0bb272768cf.png)](https://www.luogu.org/record/show?rid=14518116)\n\n![](https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg)\n\n我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。\n\n先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。\n\n然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\\operatorname{log}n)$的。\n\n那我们就在外层套个树状数组，把修改$O(n\\operatorname{log}n)$查询$O(\\operatorname{log}n)$均摊成全部$O(\\operatorname{log}^{2}n)$。\n\n然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。\n\n考虑~~无敌的~~分块。\n\n一般我们想到的分块就是在块内维护`std::set`。这样操作$3$可以做到$O(\\operatorname{log}\\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\\sqrt{n}\\operatorname{log}\\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\\operatorname{log}10^{9}\\sqrt{n}\\operatorname{log}\\sqrt{n})$。\n\n然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。\n\n我们来看一下[__Shadowice1984__](https://www.luogu.org/space/show?uid=56384)dalao在他的[另一篇题解](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119)中做出的评价：\n\n> 这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\\text{log}$之内。\n>\n> 但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\\sqrt{n})$而不是$O(\\operatorname{log}n)$，这意味着分块其实和$\\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\\text{log}$来，这在强调常数的根号算法中绝对是致命的。\n\n我也是从这位dalao的[blog](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380)里看到了严格根号分块实现树套树这种未来算法。\n\n主要思想其实不难理解，既然分块和$\\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。\n\n定义`cnt1[i][j]`表示前$i$个块内有多少个元素的值在第$j$个块内，`cnt2[i][j]`表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\\sqrt{n})$的。\n\n然后我们来分析每个操作该怎么实现：\n\n1. 首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。\n2. 还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组`tmp1`和`tmp2`来保存边角块的信息。\n3. 直接$O(\\sqrt{n})$暴力重构两个`cnt`就好。\n4. 需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内__从后往前扫__，找到答案直接退出。否则还是__从后往前扫所有值域块__，找到第一个非空的块然后进去找。\n5. 操作$4$换个方向即可。\n\n综上所述，该算法的时间复杂度为$O((n+m)\\sqrt{n}+m\\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\\operatorname{log}^{2}n)\\approx 12183043$。看起来好像比不过树套树，实际上开个$\\text{O}2$跑得比谁都快，正如一开始那张图所示。\n\n不过代码写出来有点长的：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define re register\n#define maxn 50000\n#define maxm 50000\n#define maxs 230\n#define max(a,b) ((a)>=(b)?(a):(b))\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define lowbit(a) ((a)&(-(a)))\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m,sq1,sq2;\nint id1[maxn+1],id2[maxn+maxm+1],p[maxn+maxm+1];\nint a[maxn+1],opt[maxm+1][4];\nint cnt1[maxs+1][(maxs<<1)+1],cnt2[maxs+1][maxn+maxm+1],tmp1[(maxs<<1)+1],tmp2[maxn+maxm+1];\n\nint main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tfor(;(sq1+1)*(sq1+1)<=n;++sq1);\n\tfor(re int i=1;i<=n;++i){\n\t\tid1[i]=(i-1)/sq1+1;\n\t\tcltstream::read(a[i]);\n\t\tp[++p[0]]=a[i];\n\t}\n\tfor(re int i=1;i<=m;++i){\n\t\tcltstream::read(opt[i][0]);\n\t\tcltstream::read(opt[i][1]);\n\t\tcltstream::read(opt[i][2]);\n\t\tif(opt[i][0]!=3)\n\t\t\tcltstream::read(opt[i][3]);\n\t\telse\n\t\t\tp[++p[0]]=opt[i][2];\n\t}\n\tstd::sort(p+1,p+p[0]+1);\n\tp[0]=std::unique(p+1,p+p[0]+1)-p-1;\n\tfor(;(sq2+1)*(sq2+1)<=p[0];++sq2);\n\tfor(re int i=1;i<=p[0];++i)\n\t\tid2[i]=(i-1)/sq2+1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=std::lower_bound(p+1,p+p[0]+1,a[i])-p;\n\t\t++cnt1[id1[i]][id2[a[i]]];\n\t\t++cnt2[id1[i]][a[i]];\n\t}\n\tfor(re int i=1;i<=id1[n];++i){\n\t\tfor(re int j=1;j<=id2[p[0]];++j)\n\t\t\tcnt1[i][j]+=cnt1[i-1][j];\n\t\tfor(re int j=1;j<=p[0];++j)\n\t\t\tcnt2[i][j]+=cnt2[i-1][j];\n\t}\n\tfor(re int i=1;i<=m;++i){\n\t\tre int l,r,x,ans=0;\n\t\tswitch(opt[i][0]){\n\t\t\tcase 1:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p;\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j)\n\t\t\t\t\t\tans+=(a[j]<x);\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j)\n\t\t\t\t\t\tans+=(a[j]<x);\n\t\t\t\t\tfor(re int j=1;j<id2[x];++j)\n\t\t\t\t\t\tans+=cnt1[id1[r]-1][j]-cnt1[id1[l]][j];\n\t\t\t\t\tfor(re int j=(id2[x]-1)*sq2+1;j<x;++j)\n\t\t\t\t\t\tans+=cnt2[id1[r]-1][j]-cnt2[id1[l]][j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfor(re int j=l;j<=r;++j)\n\t\t\t\t\t\tans+=(a[j]<x);\n\t\t\t\tcltstream::write(ans+1,10);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=opt[i][3];\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=1;;++j)\n\t\t\t\t\t\tif(x>cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j])\n\t\t\t\t\t\t\tx-=cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j];\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2;++k)\n\t\t\t\t\t\t\t\tif(x>cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k])\n\t\t\t\t\t\t\t\t\tx-=cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k];\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcltstream::write(p[k],10);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=1;;++j)\n\t\t\t\t\t\tif(x>tmp1[j])\n\t\t\t\t\t\t\tx-=tmp1[j];\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2;++k)\n\t\t\t\t\t\t\t\tif(x>tmp2[k])\n\t\t\t\t\t\t\t\t\tx-=tmp2[k];\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcltstream::write(p[k],10);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tl=opt[i][1],x=std::lower_bound(p+1,p+p[0]+1,opt[i][2])-p;\n\t\t\t\tfor(re int j=id1[l];j<=id1[n];++j){\n\t\t\t\t\t--cnt1[j][id2[a[l]]];\n\t\t\t\t\t++cnt1[j][id2[x]];\n\t\t\t\t\t--cnt2[j][a[l]];\n\t\t\t\t\t++cnt2[j][x];\n\t\t\t\t}\n\t\t\t\ta[l]=x;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p;\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x-1;j>=(id2[x]-1)*sq2+1&&!ans;--j)\n\t\t\t\t\t\tif(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]-1;j>=1&&!ans;--j)\n\t\t\t\t\t\tif(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=j*sq2;k>=(j-1)*sq2+1&&!ans;--k)\n\t\t\t\t\t\t\t\tif(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x-1;j>=(id2[x]-1)*sq2+1&&!ans;--j)\n\t\t\t\t\t\tif(tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]-1;j>=1&&!ans;--j)\n\t\t\t\t\t\tif(tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=j*sq2;k>=(j-1)*sq2+1&&!ans;--k)\n\t\t\t\t\t\t\t\tif(tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcltstream::write(ans?p[ans]:-2147483647,10);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=std::upper_bound(p+1,p+p[0]+1,opt[i][3])-p-1;\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x+1;j<=id2[x]*sq2&&!ans;++j)\n\t\t\t\t\t\tif(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]+1;j<=id2[p[0]]&&!ans;++j)\n\t\t\t\t\t\tif(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2&&!ans;++k)\n\t\t\t\t\t\t\t\tif(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x+1;j<=id2[x]*sq2&&!ans;++j)\n\t\t\t\t\t\tif(tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]+1;j<=id2[p[0]]&&!ans;++j)\n\t\t\t\t\t\tif(tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2&&!ans;++k)\n\t\t\t\t\t\t\t\tif(tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcltstream::write(ans?p[ans]:2147483647,10);\n\t\t}\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n我还没写啥呢咋就$12\\text{KB}$了（\n\n这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（\n","source":"_posts/2018-12-08-future-algorithm-ep1.md","raw":"---\ntitle: 「未来算法Episode I」严格根号分块实现树套树\ndate: 2018-12-08 19:55:00\ntags:\n  - 树套树\n  - 分块\ncategories:\n  - 未来算法\nmathjax: true\n---\n分块天下第一！！！！！！！！！\n\n<!-- more -->\n\n我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。\n\n[![](https://i.loli.net/2018/12/08/5c0bb272768cf.png)](https://www.luogu.org/record/show?rid=14518116)\n\n![](https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg)\n\n我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。\n\n先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。\n\n然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\\operatorname{log}n)$的。\n\n那我们就在外层套个树状数组，把修改$O(n\\operatorname{log}n)$查询$O(\\operatorname{log}n)$均摊成全部$O(\\operatorname{log}^{2}n)$。\n\n然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。\n\n考虑~~无敌的~~分块。\n\n一般我们想到的分块就是在块内维护`std::set`。这样操作$3$可以做到$O(\\operatorname{log}\\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\\sqrt{n}\\operatorname{log}\\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\\operatorname{log}10^{9}\\sqrt{n}\\operatorname{log}\\sqrt{n})$。\n\n然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。\n\n我们来看一下[__Shadowice1984__](https://www.luogu.org/space/show?uid=56384)dalao在他的[另一篇题解](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119)中做出的评价：\n\n> 这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\\text{log}$之内。\n>\n> 但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\\sqrt{n})$而不是$O(\\operatorname{log}n)$，这意味着分块其实和$\\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\\text{log}$来，这在强调常数的根号算法中绝对是致命的。\n\n我也是从这位dalao的[blog](https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380)里看到了严格根号分块实现树套树这种未来算法。\n\n主要思想其实不难理解，既然分块和$\\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。\n\n定义`cnt1[i][j]`表示前$i$个块内有多少个元素的值在第$j$个块内，`cnt2[i][j]`表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\\sqrt{n})$的。\n\n然后我们来分析每个操作该怎么实现：\n\n1. 首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。\n2. 还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组`tmp1`和`tmp2`来保存边角块的信息。\n3. 直接$O(\\sqrt{n})$暴力重构两个`cnt`就好。\n4. 需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内__从后往前扫__，找到答案直接退出。否则还是__从后往前扫所有值域块__，找到第一个非空的块然后进去找。\n5. 操作$4$换个方向即可。\n\n综上所述，该算法的时间复杂度为$O((n+m)\\sqrt{n}+m\\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\\operatorname{log}^{2}n)\\approx 12183043$。看起来好像比不过树套树，实际上开个$\\text{O}2$跑得比谁都快，正如一开始那张图所示。\n\n不过代码写出来有点长的：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define re register\n#define maxn 50000\n#define maxm 50000\n#define maxs 230\n#define max(a,b) ((a)>=(b)?(a):(b))\n#define min(a,b) ((a)<=(b)?(a):(b))\n#define lowbit(a) ((a)&(-(a)))\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m,sq1,sq2;\nint id1[maxn+1],id2[maxn+maxm+1],p[maxn+maxm+1];\nint a[maxn+1],opt[maxm+1][4];\nint cnt1[maxs+1][(maxs<<1)+1],cnt2[maxs+1][maxn+maxm+1],tmp1[(maxs<<1)+1],tmp2[maxn+maxm+1];\n\nint main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tfor(;(sq1+1)*(sq1+1)<=n;++sq1);\n\tfor(re int i=1;i<=n;++i){\n\t\tid1[i]=(i-1)/sq1+1;\n\t\tcltstream::read(a[i]);\n\t\tp[++p[0]]=a[i];\n\t}\n\tfor(re int i=1;i<=m;++i){\n\t\tcltstream::read(opt[i][0]);\n\t\tcltstream::read(opt[i][1]);\n\t\tcltstream::read(opt[i][2]);\n\t\tif(opt[i][0]!=3)\n\t\t\tcltstream::read(opt[i][3]);\n\t\telse\n\t\t\tp[++p[0]]=opt[i][2];\n\t}\n\tstd::sort(p+1,p+p[0]+1);\n\tp[0]=std::unique(p+1,p+p[0]+1)-p-1;\n\tfor(;(sq2+1)*(sq2+1)<=p[0];++sq2);\n\tfor(re int i=1;i<=p[0];++i)\n\t\tid2[i]=(i-1)/sq2+1;\n\tfor(re int i=1;i<=n;++i){\n\t\ta[i]=std::lower_bound(p+1,p+p[0]+1,a[i])-p;\n\t\t++cnt1[id1[i]][id2[a[i]]];\n\t\t++cnt2[id1[i]][a[i]];\n\t}\n\tfor(re int i=1;i<=id1[n];++i){\n\t\tfor(re int j=1;j<=id2[p[0]];++j)\n\t\t\tcnt1[i][j]+=cnt1[i-1][j];\n\t\tfor(re int j=1;j<=p[0];++j)\n\t\t\tcnt2[i][j]+=cnt2[i-1][j];\n\t}\n\tfor(re int i=1;i<=m;++i){\n\t\tre int l,r,x,ans=0;\n\t\tswitch(opt[i][0]){\n\t\t\tcase 1:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p;\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j)\n\t\t\t\t\t\tans+=(a[j]<x);\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j)\n\t\t\t\t\t\tans+=(a[j]<x);\n\t\t\t\t\tfor(re int j=1;j<id2[x];++j)\n\t\t\t\t\t\tans+=cnt1[id1[r]-1][j]-cnt1[id1[l]][j];\n\t\t\t\t\tfor(re int j=(id2[x]-1)*sq2+1;j<x;++j)\n\t\t\t\t\t\tans+=cnt2[id1[r]-1][j]-cnt2[id1[l]][j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfor(re int j=l;j<=r;++j)\n\t\t\t\t\t\tans+=(a[j]<x);\n\t\t\t\tcltstream::write(ans+1,10);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=opt[i][3];\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=1;;++j)\n\t\t\t\t\t\tif(x>cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j])\n\t\t\t\t\t\t\tx-=cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j];\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2;++k)\n\t\t\t\t\t\t\t\tif(x>cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k])\n\t\t\t\t\t\t\t\t\tx-=cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k];\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcltstream::write(p[k],10);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=1;;++j)\n\t\t\t\t\t\tif(x>tmp1[j])\n\t\t\t\t\t\t\tx-=tmp1[j];\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2;++k)\n\t\t\t\t\t\t\t\tif(x>tmp2[k])\n\t\t\t\t\t\t\t\t\tx-=tmp2[k];\n\t\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\t\tcltstream::write(p[k],10);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tl=opt[i][1],x=std::lower_bound(p+1,p+p[0]+1,opt[i][2])-p;\n\t\t\t\tfor(re int j=id1[l];j<=id1[n];++j){\n\t\t\t\t\t--cnt1[j][id2[a[l]]];\n\t\t\t\t\t++cnt1[j][id2[x]];\n\t\t\t\t\t--cnt2[j][a[l]];\n\t\t\t\t\t++cnt2[j][x];\n\t\t\t\t}\n\t\t\t\ta[l]=x;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p;\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x-1;j>=(id2[x]-1)*sq2+1&&!ans;--j)\n\t\t\t\t\t\tif(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]-1;j>=1&&!ans;--j)\n\t\t\t\t\t\tif(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=j*sq2;k>=(j-1)*sq2+1&&!ans;--k)\n\t\t\t\t\t\t\t\tif(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x-1;j>=(id2[x]-1)*sq2+1&&!ans;--j)\n\t\t\t\t\t\tif(tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]-1;j>=1&&!ans;--j)\n\t\t\t\t\t\tif(tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=j*sq2;k>=(j-1)*sq2+1&&!ans;--k)\n\t\t\t\t\t\t\t\tif(tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcltstream::write(ans?p[ans]:-2147483647,10);\n\t\t\t\tbreak;\n\t\t\tcase 5:\n\t\t\t\tl=opt[i][1],r=opt[i][2],x=std::upper_bound(p+1,p+p[0]+1,opt[i][3])-p-1;\n\t\t\t\tif(id1[l]<id1[r]){\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x+1;j<=id2[x]*sq2&&!ans;++j)\n\t\t\t\t\t\tif(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]+1;j<=id2[p[0]]&&!ans;++j)\n\t\t\t\t\t\tif(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2&&!ans;++k)\n\t\t\t\t\t\t\t\tif(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=id1[l]*sq1;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=(id1[r]-1)*sq1+1;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t++tmp1[id2[a[j]]];\n\t\t\t\t\t\t++tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t\tfor(re int j=x+1;j<=id2[x]*sq2&&!ans;++j)\n\t\t\t\t\t\tif(tmp2[j])\n\t\t\t\t\t\t\tans=j;\n\t\t\t\t\tfor(re int j=id2[x]+1;j<=id2[p[0]]&&!ans;++j)\n\t\t\t\t\t\tif(tmp1[j])\n\t\t\t\t\t\t\tfor(re int k=(j-1)*sq2+1;k<=j*sq2&&!ans;++k)\n\t\t\t\t\t\t\t\tif(tmp2[k])\n\t\t\t\t\t\t\t\t\tans=k;\n\t\t\t\t\tfor(re int j=l;j<=r;++j){\n\t\t\t\t\t\t--tmp1[id2[a[j]]];\n\t\t\t\t\t\t--tmp2[a[j]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcltstream::write(ans?p[ans]:2147483647,10);\n\t\t}\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n我还没写啥呢咋就$12\\text{KB}$了（\n\n这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（\n","slug":"future-algorithm-ep1","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwd003r34cwinxi624m","content":"<p>分块天下第一！！！！！！！！！</p>\n<a id=\"more\"></a>\n<p>我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。</p>\n<p><a href=\"https://www.luogu.org/record/show?rid=14518116\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2018/12/08/5c0bb272768cf.png\" alt=\"\"></a></p>\n<p><img src=\"https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg\" alt=\"\"></p>\n<p>我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。</p>\n<p>先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。</p>\n<p>然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\\operatorname{log}n)$的。</p>\n<p>那我们就在外层套个树状数组，把修改$O(n\\operatorname{log}n)$查询$O(\\operatorname{log}n)$均摊成全部$O(\\operatorname{log}^{2}n)$。</p>\n<p>然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。</p>\n<p>考虑<del>无敌的</del>分块。</p>\n<p>一般我们想到的分块就是在块内维护<code>std::set</code>。这样操作$3$可以做到$O(\\operatorname{log}\\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\\sqrt{n}\\operatorname{log}\\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\\operatorname{log}10^{9}\\sqrt{n}\\operatorname{log}\\sqrt{n})$。</p>\n<p>然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。</p>\n<p>我们来看一下<a href=\"https://www.luogu.org/space/show?uid=56384\" target=\"_blank\" rel=\"noopener\"><strong>Shadowice1984</strong></a>dalao在他的<a href=\"https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119\" target=\"_blank\" rel=\"noopener\">另一篇题解</a>中做出的评价：</p>\n<blockquote>\n<p>这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\\text{log}$之内。</p>\n<p>但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\\sqrt{n})$而不是$O(\\operatorname{log}n)$，这意味着分块其实和$\\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\\text{log}$来，这在强调常数的根号算法中绝对是致命的。</p>\n</blockquote>\n<p>我也是从这位dalao的<a href=\"https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380\" target=\"_blank\" rel=\"noopener\">blog</a>里看到了严格根号分块实现树套树这种未来算法。</p>\n<p>主要思想其实不难理解，既然分块和$\\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。</p>\n<p>定义<code>cnt1[i][j]</code>表示前$i$个块内有多少个元素的值在第$j$个块内，<code>cnt2[i][j]</code>表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\\sqrt{n})$的。</p>\n<p>然后我们来分析每个操作该怎么实现：</p>\n<ol>\n<li>首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。</li>\n<li>还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组<code>tmp1</code>和<code>tmp2</code>来保存边角块的信息。</li>\n<li>直接$O(\\sqrt{n})$暴力重构两个<code>cnt</code>就好。</li>\n<li>需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内<strong>从后往前扫</strong>，找到答案直接退出。否则还是<strong>从后往前扫所有值域块</strong>，找到第一个非空的块然后进去找。</li>\n<li>操作$4$换个方向即可。</li>\n</ol>\n<p>综上所述，该算法的时间复杂度为$O((n+m)\\sqrt{n}+m\\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\\operatorname{log}^{2}n)\\approx 12183043$。看起来好像比不过树套树，实际上开个$\\text{O}2$跑得比谁都快，正如一开始那张图所示。</p>\n<p>不过代码写出来有点长的：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 50000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxm 50000</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxs 230</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> lowbit(a) ((a)&amp;(-(a)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m,sq1,sq2;</span><br><span class=\"line\"><span class=\"keyword\">int</span> id1[maxn+<span class=\"number\">1</span>],id2[maxn+maxm+<span class=\"number\">1</span>],p[maxn+maxm+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> a[maxn+<span class=\"number\">1</span>],opt[maxm+<span class=\"number\">1</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> cnt1[maxs+<span class=\"number\">1</span>][(maxs&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>],cnt2[maxs+<span class=\"number\">1</span>][maxn+maxm+<span class=\"number\">1</span>],tmp1[(maxs&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>],tmp2[maxn+maxm+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\tcltstream::read(m);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;(sq1+<span class=\"number\">1</span>)*(sq1+<span class=\"number\">1</span>)&lt;=n;++sq1);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\tid1[i]=(i<span class=\"number\">-1</span>)/sq1+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\tcltstream::read(a[i]);</span><br><span class=\"line\">\t\tp[++p[<span class=\"number\">0</span>]]=a[i];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">\t\tcltstream::read(opt[i][<span class=\"number\">0</span>]);</span><br><span class=\"line\">\t\tcltstream::read(opt[i][<span class=\"number\">1</span>]);</span><br><span class=\"line\">\t\tcltstream::read(opt[i][<span class=\"number\">2</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(opt[i][<span class=\"number\">0</span>]!=<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t\tcltstream::read(opt[i][<span class=\"number\">3</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tp[++p[<span class=\"number\">0</span>]]=opt[i][<span class=\"number\">2</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">std</span>::sort(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>);</span><br><span class=\"line\">\tp[<span class=\"number\">0</span>]=<span class=\"built_in\">std</span>::unique(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>)-p<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;(sq2+<span class=\"number\">1</span>)*(sq2+<span class=\"number\">1</span>)&lt;=p[<span class=\"number\">0</span>];++sq2);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=p[<span class=\"number\">0</span>];++i)</span><br><span class=\"line\">\t\tid2[i]=(i<span class=\"number\">-1</span>)/sq2+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\ta[i]=<span class=\"built_in\">std</span>::lower_bound(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>,a[i])-p;</span><br><span class=\"line\">\t\t++cnt1[id1[i]][id2[a[i]]];</span><br><span class=\"line\">\t\t++cnt2[id1[i]][a[i]];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=id1[n];++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=id2[p[<span class=\"number\">0</span>]];++j)</span><br><span class=\"line\">\t\t\tcnt1[i][j]+=cnt1[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=p[<span class=\"number\">0</span>];++j)</span><br><span class=\"line\">\t\t\tcnt2[i][j]+=cnt2[i<span class=\"number\">-1</span>][j];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> l,r,x,ans=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(opt[i][<span class=\"number\">0</span>])&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\tl=opt[i][<span class=\"number\">1</span>],r=opt[i][<span class=\"number\">2</span>],x=<span class=\"built_in\">std</span>::lower_bound(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>,opt[i][<span class=\"number\">3</span>])-p;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)</span><br><span class=\"line\">\t\t\t\t\t\tans+=(a[j]&lt;x);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)</span><br><span class=\"line\">\t\t\t\t\t\tans+=(a[j]&lt;x);</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;id2[x];++j)</span><br><span class=\"line\">\t\t\t\t\t\tans+=cnt1[id1[r]<span class=\"number\">-1</span>][j]-cnt1[id1[l]][j];</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id2[x]<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>;j&lt;x;++j)</span><br><span class=\"line\">\t\t\t\t\t\tans+=cnt2[id1[r]<span class=\"number\">-1</span>][j]-cnt2[id1[l]][j];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)</span><br><span class=\"line\">\t\t\t\t\t\tans+=(a[j]&lt;x);</span><br><span class=\"line\">\t\t\t\tcltstream::write(ans+<span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t\tl=opt[i][<span class=\"number\">1</span>],r=opt[i][<span class=\"number\">2</span>],x=opt[i][<span class=\"number\">3</span>];</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;;++j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(x&gt;cnt1[id1[r]<span class=\"number\">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class=\"line\">\t\t\t\t\t\t\tx-=cnt1[id1[r]<span class=\"number\">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j];</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=(j<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>;k&lt;=j*sq2;++k)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(x&gt;cnt2[id1[r]<span class=\"number\">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tx-=cnt2[id1[r]<span class=\"number\">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k];</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tcltstream::write(p[k],<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;;++j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(x&gt;tmp1[j])</span><br><span class=\"line\">\t\t\t\t\t\t\tx-=tmp1[j];</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=(j<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>;k&lt;=j*sq2;++k)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(x&gt;tmp2[k])</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tx-=tmp2[k];</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tcltstream::write(p[k],<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t\tl=opt[i][<span class=\"number\">1</span>],x=<span class=\"built_in\">std</span>::lower_bound(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>,opt[i][<span class=\"number\">2</span>])-p;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=id1[l];j&lt;=id1[n];++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t--cnt1[j][id2[a[l]]];</span><br><span class=\"line\">\t\t\t\t\t++cnt1[j][id2[x]];</span><br><span class=\"line\">\t\t\t\t\t--cnt2[j][a[l]];</span><br><span class=\"line\">\t\t\t\t\t++cnt2[j][x];</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\ta[l]=x;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">\t\t\t\tl=opt[i][<span class=\"number\">1</span>],r=opt[i][<span class=\"number\">2</span>],x=<span class=\"built_in\">std</span>::lower_bound(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>,opt[i][<span class=\"number\">3</span>])-p;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=x<span class=\"number\">-1</span>;j&gt;=(id2[x]<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>&amp;&amp;!ans;--j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(cnt2[id1[r]<span class=\"number\">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class=\"line\">\t\t\t\t\t\t\tans=j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=id2[x]<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">1</span>&amp;&amp;!ans;--j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(cnt1[id1[r]<span class=\"number\">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=j*sq2;k&gt;=(j<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>&amp;&amp;!ans;--k)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(cnt2[id1[r]<span class=\"number\">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tans=k;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=x<span class=\"number\">-1</span>;j&gt;=(id2[x]<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>&amp;&amp;!ans;--j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(tmp2[j])</span><br><span class=\"line\">\t\t\t\t\t\t\tans=j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=id2[x]<span class=\"number\">-1</span>;j&gt;=<span class=\"number\">1</span>&amp;&amp;!ans;--j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(tmp1[j])</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=j*sq2;k&gt;=(j<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>&amp;&amp;!ans;--k)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(tmp2[k])</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tans=k;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tcltstream::write(ans?p[ans]:<span class=\"number\">-2147483647</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">\t\t\t\tl=opt[i][<span class=\"number\">1</span>],r=opt[i][<span class=\"number\">2</span>],x=<span class=\"built_in\">std</span>::upper_bound(p+<span class=\"number\">1</span>,p+p[<span class=\"number\">0</span>]+<span class=\"number\">1</span>,opt[i][<span class=\"number\">3</span>])-p<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=x+<span class=\"number\">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(cnt2[id1[r]<span class=\"number\">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class=\"line\">\t\t\t\t\t\t\tans=j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=id2[x]+<span class=\"number\">1</span>;j&lt;=id2[p[<span class=\"number\">0</span>]]&amp;&amp;!ans;++j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(cnt1[id1[r]<span class=\"number\">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=(j<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(cnt2[id1[r]<span class=\"number\">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tans=k;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=(id1[r]<span class=\"number\">-1</span>)*sq1+<span class=\"number\">1</span>;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t++tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t++tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=x+<span class=\"number\">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(tmp2[j])</span><br><span class=\"line\">\t\t\t\t\t\t\tans=j;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=id2[x]+<span class=\"number\">1</span>;j&lt;=id2[p[<span class=\"number\">0</span>]]&amp;&amp;!ans;++j)</span><br><span class=\"line\">\t\t\t\t\t\t<span class=\"keyword\">if</span>(tmp1[j])</span><br><span class=\"line\">\t\t\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=(j<span class=\"number\">-1</span>)*sq2+<span class=\"number\">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class=\"line\">\t\t\t\t\t\t\t\t<span class=\"keyword\">if</span>(tmp2[k])</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\tans=k;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class=\"line\">\t\t\t\t\t\t--tmp1[id2[a[j]]];</span><br><span class=\"line\">\t\t\t\t\t\t--tmp2[a[j]];</span><br><span class=\"line\">\t\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\t&#125;</span><br><span class=\"line\">\t\t\t\tcltstream::write(ans?p[ans]:<span class=\"number\">2147483647</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>我还没写啥呢咋就$12\\text{KB}$了（</p>\n<p>这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（</p>\n","site":{"data":{}},"excerpt":"<p>分块天下第一！！！！！！！！！</p>","more":"<p>我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。</p>\n<p><a href=\"https://www.luogu.org/record/show?rid=14518116\" target=\"_blank\" rel=\"noopener\"><img src=\"https://i.loli.net/2018/12/08/5c0bb272768cf.png\" alt=\"\"></a></p>\n<p><img src=\"https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg\" alt=\"\"></p>\n<p>我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。</p>\n<p>先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。</p>\n<p>然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\\operatorname{log}n)$的。</p>\n<p>那我们就在外层套个树状数组，把修改$O(n\\operatorname{log}n)$查询$O(\\operatorname{log}n)$均摊成全部$O(\\operatorname{log}^{2}n)$。</p>\n<p>然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。</p>\n<p>考虑<del>无敌的</del>分块。</p>\n<p>一般我们想到的分块就是在块内维护<code>std::set</code>。这样操作$3$可以做到$O(\\operatorname{log}\\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\\sqrt{n}\\operatorname{log}\\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\\operatorname{log}10^{9}\\sqrt{n}\\operatorname{log}\\sqrt{n})$。</p>\n<p>然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。</p>\n<p>我们来看一下<a href=\"https://www.luogu.org/space/show?uid=56384\" target=\"_blank\" rel=\"noopener\"><strong>Shadowice1984</strong></a>dalao在他的<a href=\"https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119\" target=\"_blank\" rel=\"noopener\">另一篇题解</a>中做出的评价：</p>\n<blockquote>\n<p>这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\\text{log}$之内。</p>\n<p>但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\\sqrt{n})$而不是$O(\\operatorname{log}n)$，这意味着分块其实和$\\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\\text{log}$来，这在强调常数的根号算法中绝对是致命的。</p>\n</blockquote>\n<p>我也是从这位dalao的<a href=\"https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380\" target=\"_blank\" rel=\"noopener\">blog</a>里看到了严格根号分块实现树套树这种未来算法。</p>\n<p>主要思想其实不难理解，既然分块和$\\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。</p>\n<p>定义<code>cnt1[i][j]</code>表示前$i$个块内有多少个元素的值在第$j$个块内，<code>cnt2[i][j]</code>表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\\sqrt{n})$的。</p>\n<p>然后我们来分析每个操作该怎么实现：</p>\n<ol>\n<li>首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。</li>\n<li>还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组<code>tmp1</code>和<code>tmp2</code>来保存边角块的信息。</li>\n<li>直接$O(\\sqrt{n})$暴力重构两个<code>cnt</code>就好。</li>\n<li>需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内<strong>从后往前扫</strong>，找到答案直接退出。否则还是<strong>从后往前扫所有值域块</strong>，找到第一个非空的块然后进去找。</li>\n<li>操作$4$换个方向即可。</li>\n</ol>\n<p>综上所述，该算法的时间复杂度为$O((n+m)\\sqrt{n}+m\\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\\operatorname{log}^{2}n)\\approx 12183043$。看起来好像比不过树套树，实际上开个$\\text{O}2$跑得比谁都快，正如一开始那张图所示。</p>\n<p>不过代码写出来有点长的：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�22-->\n\n</div></div>\n<p>我还没写啥呢咋就$12\\text{KB}$了（</p>\n<p>这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（</p>"},{"mathjax":true,"date":"2018-12-20T08:58:39.000Z","title":"「多项式学习笔记Part II」多项式的进阶操作","_content":"以下，如果不特别声明，则所有运算在模$998244353$意义下进行。\n\n<!-- more -->\n\n### 接下来的前置知识\n\n#### 泰勒展开\n\n说实话，其实我也不是很能理解这个东西（\n\n我就凭感觉xjb扯了（\n\n现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。\n\n我们令\n\n$$g(x)=\\sum\\limits_{i=0}^{n}g[i](x-x_{0})^{i}$$\n\n我们想要让$x\\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。\n\n我们先考虑$0$阶，也就是原函数。因为$x\\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有\n\n$$g[0]=f(x_{0})$$\n\n然后是$1$阶\n\n$$g^{\\prime}(x)=\\sum\\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\\prime}(x_{0})$$\n\n再然后是$2$阶\n\n$$g^{\\prime\\prime}(x)=\\sum\\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\\prime\\prime}(x_{0})$$\n\n最后是$3$阶\n\n$$g^{\\prime\\prime\\prime}(x)=\\sum\\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\\prime\\prime\\prime}(x_{0})$$\n\n我们发现$g[n]$有如下的规律\n\n$$g[n]=\\cfrac{f^{(n)}(x_{0})}{n!}$$\n\n综上所述\n\n$$g(x)=\\sum\\limits_{i=0}^{n}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i$$\n\n~~应该吧（~~\n\n#### 多项式牛顿迭代\n\n考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得\n\n$$F(G(x))\\equiv 0\\pmod{x^{n}}$$\n\n我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得\n\n$$F(G_{0})\\equiv 0\\pmod{x^{t}}$$\n\n我们希望求出一个$G$使得\n\n$$F(G)\\equiv 0\\pmod{x^{2t}}$$\n\n我们将$F$在$G_{0}$这里进行泰勒展开：\n\n$$\\begin{aligned}\nF(G)&=F(G_{0})\\\\\n&+F^{\\prime}(G_{0})(G-G_{0})\\\\\n&+\\cfrac{F^{\\prime\\prime}(G_{0})}{2}(G-G_{0})^{2}\\\\\n&+\\cdots\\end{aligned}$$\n\n注意到\n\n$$\\begin{aligned}\nF(G)-F(G_{0})&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\n\\end{aligned}$$\n\n也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有\n\n$$\\begin{aligned}\nF(G)&\\equiv F(G_{0})+F^{\\prime}(G_{0})(G-G_{0})\\pmod{x^{2t}}\\\\\nF^{\\prime}(G_{0})G&\\equiv F^{\\prime}(G_{0})G_{0}-F(G_{0})\\pmod{x^{2t}}\\\\\nG&\\equiv G_{0}-\\cfrac{F(G_{0})}{F^{\\prime}(G_{0})}\\pmod{x^{2t}}\n\\end{aligned}$$\n\n然后我们就一直倍增，倍增到$t\\geqslant n$为止，此时$G_{0}$即为所求多项式。\n\n### [多项式求逆](https://www.luogu.org/problemnew/show/P4238)\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$F(x)\\times G(x)\\equiv 1\\pmod{x^{n}}$$\n\n假设我们已经求出了$G_{0}$使得\n\n$$F\\times G_{0}\\equiv 1\\pmod{x^{t}}$$\n\n我们希望找到一个$G$使得\n\n$$F\\times G\\equiv 1\\pmod{x^{2t}}$$\n\n据说能用牛顿迭代推，然而我不会（\n\n考虑正常一点的方式~~，虽然说还是倍增~~。\n\n$$\\begin{aligned}\nF\\times G-F\\times G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\n(G-G_{0})^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG^{2}-2GG_{0}+G_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\n\\end{aligned}$$\n\n两边同时乘$F$\n\n$$\\begin{aligned}\nG-2G_{0}+FG_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG&\\equiv 2G_{0}-FG_{0}^{2}\\pmod{x^{2t}}\n\\end{aligned}$$\n\n边界条件也很明显，就是当$t=1$时，$G[0]\\equiv F[0]^{-1}$。\n\n说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（\n\n关于代码……现在还不是时候（\n\n后面有一道超级综合题在等着我们（\n\n### [多项式对数函数](https://www.luogu.org/problemnew/show/P4725)\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$G(x)\\equiv\\ln F(x)\\pmod{x^{n}}$$\n\n对上式两边求导\n\n$$G^{\\prime}\\equiv F^{\\prime}\\ln^{\\prime}F\\pmod{x^{n}}$$\n\n又因为\n\n$$\\ln^{\\prime}x=\\frac{1}{x}$$\n\n我们就得到\n\n$$G^{\\prime}\\equiv\\cfrac{F^{\\prime}}{F}\\pmod{x^{n}}$$\n\n求导+求逆+不定积分即可。\n\n### [多项式指数函数](https://www.luogu.org/problemnew/show/P4726)\n\n超级综合题来了。\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$G(x)\\equiv e^{F(x)}\\pmod{x^{n}}$$\n\n首先\n\n$$\\ln G-F\\equiv 0\\pmod{x^{n}}$$\n\n我们把$F$看成是常数项，定义函数\n\n$$A(G)=\\ln G-F$$\n\n$$A^{\\prime}(G)=\\ln^{\\prime}G=\\cfrac{1}{G}$$\n\n套牛顿迭代\n\n$$\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}(1-\\ln G_{0}+F)\\pmod{x^{2t}}\n\\end{aligned}$$\n\n然后把以上提到的所有板子全都复制过来就行了（\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#define re register\n#define maxn 524288\n#define mod 998244353\n#define swap(a,b) a^=b,b^=a,a^=b\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n;\nint unit[2][24],rev[maxn+1],inv[maxn+1]={0,1},F[maxn+1],G[maxn+1],tmp1[maxn+1],tmp2[maxn+1],tmp3[maxn+1],tmp4[maxn+1];\n\ninline int cltpow(re int x,re int y){\n\tre int res=1;\n\tfor(;y;){\n\t\tif(y&1)\n\t\t\tres=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\ninline void NTT(re int* F,re int n,re int tp){\n\tfor(re int i=0;i<n;++i)\n\t\tif(i<(rev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0)))\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(re int k=1,p=1;p<n;++k,p<<=1)\n\t\tfor(re int i=0;i<n;i+=p<<1)\n\t\t\tfor(re int j=i,tmp=1;j<i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod){\n\t\t\t\tre int x=F[j],y=1LL*F[j+p]*tmp%mod;\n\t\t\t\tF[j]=(x+y)%mod;\n\t\t\t\tF[j+p]=(x-y+mod)%mod;\n\t\t\t}\n\tre int v=cltpow(n,tp*(mod-2));\n\tfor(re int i=0;i<n;++i)\n\t\tF[i]=1LL*F[i]*v%mod;\n}\n\ninline void Inv(re int* F,re int* G,re int n){\n\tG[0]=cltpow(F[0],mod-2);\n\tfor(re int i=1,j=4;i<n;i<<=1,j<<=1){\n\t\tfor(re int k=0;k<(i<<1);++k)\n\t\t\ttmp1[k]=F[k];\n\t\tNTT(tmp1,j,0);\n\t\tNTT(G,j,0);\n\t\tfor(re int k=0;k<j;++k)\n\t\t\tG[k]=(2-1LL*tmp1[k]*G[k]%mod+mod)*G[k]%mod;\n\t\tNTT(G,j,1);\n\t\tfor(re int k=(i<<1);k<j;++k)\n\t\t\tG[k]=0;\n\t\tfor(re int k=0;k<j;++k)\n\t\t\ttmp1[k]=0;\n\t}\n}\n\ninline void Ln(re int* F,re int* G,re int n){\n\tfor(re int i=1;i<n;++i)\n\t\tG[i-1]=1LL*F[i]*i%mod;\n\tInv(F,tmp2,n);\n\tre int N=1;\n\tfor(;N<n;N<<=1);\n\tN<<=1;\n\tNTT(G,N,0);\n\tNTT(tmp2,N,0);\n\tfor(re int i=0;i<N;++i)\n\t\tG[i]=1LL*G[i]*tmp2[i]%mod;\n\tNTT(G,N,1);\n\tfor(re int i=n-1;i>=1;--i)\n\t\tG[i]=1LL*G[i-1]*inv[i]%mod;\n\tG[0]=0;\n\tfor(re int i=n;i<N;++i)\n\t\tG[i]=0;\n\tfor(re int i=0;i<N;++i)\n\t\ttmp2[i]=0;\n}\n\ninline void Exp(re int* F,re int* G,re int n){\n\tG[0]=1;\n\tfor(re int i=1,j=2;i<(n<<1);i<<=1,j<<=1){\n\t\tLn(G,tmp3,i);\n\t\tfor(re int k=0;k<i;++k)\n\t\t\ttmp4[k]=F[k];\n\t\tNTT(tmp3,j,0);\n\t\tNTT(tmp4,j,0);\n\t\tNTT(G,j,0);\n\t\tfor(re int k=0;k<j;++k)\n\t\t\tG[k]=((1LL-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;\n\t\tNTT(G,j,1);\n\t\tfor(re int k=0;k<j;++k)\n\t\t\ttmp3[k]=tmp4[k]=0;\n\t}\n}\n\nint main(){\n\tunit[0][23]=cltpow(3,119);\n\tunit[1][23]=cltpow(332748118,119);\n\tfor(re int i=0;i<2;++i)\n\t\tfor(re int j=22;j>=0;--j)\n\t\t\tunit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod;\n\tfor(re int i=2;i<=maxn;++i)\n\t\tinv[i]=(mod-1LL*mod/i*inv[mod%i]%mod)%mod;\n\tcltstream::read(n);\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::read(F[i]);\n\tExp(F,G,n);\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::write(G[i],i<n-1?32:-1);\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n### 多项式开平方根\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$G^{2}(x)\\equiv F(x)\\pmod{x^{n}}$$\n\n牛顿迭代吼啊！\n\n$$A(G)=G^{2}-F$$\n\n$$A^{\\prime}(G)=2G$$\n\n$$\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}-\\cfrac{G_{0}^{2}-F}{2G_{0}}\\\\\n&\\equiv\\cfrac{G_{0}^{2}+F}{2G_{0}}\\\\\n&=\\cfrac{1}{2}(G_{0}+\\cfrac{F}{G_{0}})\\pmod{x^{2t}}\n\\end{aligned}$$\n\n~~复制粘贴吼啊！~~\n\n### 我刚才都学了些啥破玩意\n\n[一道例题](http://codeforces.com/contest/438/problem/E)。\n\n[Remote Judge](https://www.luogu.org/problemnew/show/CF438E)。\n\n这是读题前的我：\n\n![](https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif)\n\n这是读题后的我：\n\n![](https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg)\n\n这是知道了这题正解是多项式开平方根后的我：\n\n![](https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg)\n\n我……我怕不是学了个假的多项式哦（\n\n厚颜无耻地抄题解（\n\n首先我们搞出生成函数（然而并不是很懂）\n\n$$G(x)=\\sum\\limits_{i=0}^{m}G[i]x^{i}$$\n\n其中\n\n$$G[i]=[i\\in\\{c_{1},c_{2},\\cdots,c_{n}\\}]$$\n\n定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有\n\n$$F[0]=1$$\n\n$$F[x]=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]$$\n\n就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。\n\n然后是一些神仙操作\n\n$$\\begin{aligned}\nF[x]&=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]\\\\\n&=\\sum\\limits_{i=0}^{x}G[i]F^{2}[x-i]\\\\\n&=(GF^{2})[x]\n\\end{aligned}$$\n\n令人窒息（\n\n然后我们就有\n\n$$GF^{2}+1=F$$\n\n但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。\n\n于是解上面这个一元二次方程，我们得到\n\n$$F=\\cfrac{1\\pm\\sqrt{1-4G}}{2G}$$\n\n但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\\mp\\sqrt{1-4G})$，然后化简一波\n\n$$F=\\cfrac{2}{1\\mp\\sqrt{1-4G}}$$\n\n如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\\cfrac{2}{2}=1$。综上所述\n\n$$F=\\cfrac{2}{1+\\sqrt{1-4G}}$$\n\n本来接下来应该有代码实现的，但是~~我拒绝~~咕咕咕。\n\n~~其实是调不出来了（~~\n","source":"_posts/2018-12-20-polynomial-learning-notes-pt2.md","raw":"---\nmathjax: true\ndate: 2018-12-20 16:58:39\ntitle: 「多项式学习笔记Part II」多项式的进阶操作\ntags:\n  - FFT\n  - NTT\ncategories:\n  - 学习笔记\n---\n以下，如果不特别声明，则所有运算在模$998244353$意义下进行。\n\n<!-- more -->\n\n### 接下来的前置知识\n\n#### 泰勒展开\n\n说实话，其实我也不是很能理解这个东西（\n\n我就凭感觉xjb扯了（\n\n现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。\n\n我们令\n\n$$g(x)=\\sum\\limits_{i=0}^{n}g[i](x-x_{0})^{i}$$\n\n我们想要让$x\\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。\n\n我们先考虑$0$阶，也就是原函数。因为$x\\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有\n\n$$g[0]=f(x_{0})$$\n\n然后是$1$阶\n\n$$g^{\\prime}(x)=\\sum\\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\\prime}(x_{0})$$\n\n再然后是$2$阶\n\n$$g^{\\prime\\prime}(x)=\\sum\\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\\prime\\prime}(x_{0})$$\n\n最后是$3$阶\n\n$$g^{\\prime\\prime\\prime}(x)=\\sum\\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\\prime\\prime\\prime}(x_{0})$$\n\n我们发现$g[n]$有如下的规律\n\n$$g[n]=\\cfrac{f^{(n)}(x_{0})}{n!}$$\n\n综上所述\n\n$$g(x)=\\sum\\limits_{i=0}^{n}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i$$\n\n~~应该吧（~~\n\n#### 多项式牛顿迭代\n\n考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得\n\n$$F(G(x))\\equiv 0\\pmod{x^{n}}$$\n\n我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得\n\n$$F(G_{0})\\equiv 0\\pmod{x^{t}}$$\n\n我们希望求出一个$G$使得\n\n$$F(G)\\equiv 0\\pmod{x^{2t}}$$\n\n我们将$F$在$G_{0}$这里进行泰勒展开：\n\n$$\\begin{aligned}\nF(G)&=F(G_{0})\\\\\n&+F^{\\prime}(G_{0})(G-G_{0})\\\\\n&+\\cfrac{F^{\\prime\\prime}(G_{0})}{2}(G-G_{0})^{2}\\\\\n&+\\cdots\\end{aligned}$$\n\n注意到\n\n$$\\begin{aligned}\nF(G)-F(G_{0})&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\n\\end{aligned}$$\n\n也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有\n\n$$\\begin{aligned}\nF(G)&\\equiv F(G_{0})+F^{\\prime}(G_{0})(G-G_{0})\\pmod{x^{2t}}\\\\\nF^{\\prime}(G_{0})G&\\equiv F^{\\prime}(G_{0})G_{0}-F(G_{0})\\pmod{x^{2t}}\\\\\nG&\\equiv G_{0}-\\cfrac{F(G_{0})}{F^{\\prime}(G_{0})}\\pmod{x^{2t}}\n\\end{aligned}$$\n\n然后我们就一直倍增，倍增到$t\\geqslant n$为止，此时$G_{0}$即为所求多项式。\n\n### [多项式求逆](https://www.luogu.org/problemnew/show/P4238)\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$F(x)\\times G(x)\\equiv 1\\pmod{x^{n}}$$\n\n假设我们已经求出了$G_{0}$使得\n\n$$F\\times G_{0}\\equiv 1\\pmod{x^{t}}$$\n\n我们希望找到一个$G$使得\n\n$$F\\times G\\equiv 1\\pmod{x^{2t}}$$\n\n据说能用牛顿迭代推，然而我不会（\n\n考虑正常一点的方式~~，虽然说还是倍增~~。\n\n$$\\begin{aligned}\nF\\times G-F\\times G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\n(G-G_{0})^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG^{2}-2GG_{0}+G_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\n\\end{aligned}$$\n\n两边同时乘$F$\n\n$$\\begin{aligned}\nG-2G_{0}+FG_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG&\\equiv 2G_{0}-FG_{0}^{2}\\pmod{x^{2t}}\n\\end{aligned}$$\n\n边界条件也很明显，就是当$t=1$时，$G[0]\\equiv F[0]^{-1}$。\n\n说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（\n\n关于代码……现在还不是时候（\n\n后面有一道超级综合题在等着我们（\n\n### [多项式对数函数](https://www.luogu.org/problemnew/show/P4725)\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$G(x)\\equiv\\ln F(x)\\pmod{x^{n}}$$\n\n对上式两边求导\n\n$$G^{\\prime}\\equiv F^{\\prime}\\ln^{\\prime}F\\pmod{x^{n}}$$\n\n又因为\n\n$$\\ln^{\\prime}x=\\frac{1}{x}$$\n\n我们就得到\n\n$$G^{\\prime}\\equiv\\cfrac{F^{\\prime}}{F}\\pmod{x^{n}}$$\n\n求导+求逆+不定积分即可。\n\n### [多项式指数函数](https://www.luogu.org/problemnew/show/P4726)\n\n超级综合题来了。\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$G(x)\\equiv e^{F(x)}\\pmod{x^{n}}$$\n\n首先\n\n$$\\ln G-F\\equiv 0\\pmod{x^{n}}$$\n\n我们把$F$看成是常数项，定义函数\n\n$$A(G)=\\ln G-F$$\n\n$$A^{\\prime}(G)=\\ln^{\\prime}G=\\cfrac{1}{G}$$\n\n套牛顿迭代\n\n$$\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}(1-\\ln G_{0}+F)\\pmod{x^{2t}}\n\\end{aligned}$$\n\n然后把以上提到的所有板子全都复制过来就行了（\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cstring>\n#define re register\n#define maxn 524288\n#define mod 998244353\n#define swap(a,b) a^=b,b^=a,a^=b\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n;\nint unit[2][24],rev[maxn+1],inv[maxn+1]={0,1},F[maxn+1],G[maxn+1],tmp1[maxn+1],tmp2[maxn+1],tmp3[maxn+1],tmp4[maxn+1];\n\ninline int cltpow(re int x,re int y){\n\tre int res=1;\n\tfor(;y;){\n\t\tif(y&1)\n\t\t\tres=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\ninline void NTT(re int* F,re int n,re int tp){\n\tfor(re int i=0;i<n;++i)\n\t\tif(i<(rev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0)))\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(re int k=1,p=1;p<n;++k,p<<=1)\n\t\tfor(re int i=0;i<n;i+=p<<1)\n\t\t\tfor(re int j=i,tmp=1;j<i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod){\n\t\t\t\tre int x=F[j],y=1LL*F[j+p]*tmp%mod;\n\t\t\t\tF[j]=(x+y)%mod;\n\t\t\t\tF[j+p]=(x-y+mod)%mod;\n\t\t\t}\n\tre int v=cltpow(n,tp*(mod-2));\n\tfor(re int i=0;i<n;++i)\n\t\tF[i]=1LL*F[i]*v%mod;\n}\n\ninline void Inv(re int* F,re int* G,re int n){\n\tG[0]=cltpow(F[0],mod-2);\n\tfor(re int i=1,j=4;i<n;i<<=1,j<<=1){\n\t\tfor(re int k=0;k<(i<<1);++k)\n\t\t\ttmp1[k]=F[k];\n\t\tNTT(tmp1,j,0);\n\t\tNTT(G,j,0);\n\t\tfor(re int k=0;k<j;++k)\n\t\t\tG[k]=(2-1LL*tmp1[k]*G[k]%mod+mod)*G[k]%mod;\n\t\tNTT(G,j,1);\n\t\tfor(re int k=(i<<1);k<j;++k)\n\t\t\tG[k]=0;\n\t\tfor(re int k=0;k<j;++k)\n\t\t\ttmp1[k]=0;\n\t}\n}\n\ninline void Ln(re int* F,re int* G,re int n){\n\tfor(re int i=1;i<n;++i)\n\t\tG[i-1]=1LL*F[i]*i%mod;\n\tInv(F,tmp2,n);\n\tre int N=1;\n\tfor(;N<n;N<<=1);\n\tN<<=1;\n\tNTT(G,N,0);\n\tNTT(tmp2,N,0);\n\tfor(re int i=0;i<N;++i)\n\t\tG[i]=1LL*G[i]*tmp2[i]%mod;\n\tNTT(G,N,1);\n\tfor(re int i=n-1;i>=1;--i)\n\t\tG[i]=1LL*G[i-1]*inv[i]%mod;\n\tG[0]=0;\n\tfor(re int i=n;i<N;++i)\n\t\tG[i]=0;\n\tfor(re int i=0;i<N;++i)\n\t\ttmp2[i]=0;\n}\n\ninline void Exp(re int* F,re int* G,re int n){\n\tG[0]=1;\n\tfor(re int i=1,j=2;i<(n<<1);i<<=1,j<<=1){\n\t\tLn(G,tmp3,i);\n\t\tfor(re int k=0;k<i;++k)\n\t\t\ttmp4[k]=F[k];\n\t\tNTT(tmp3,j,0);\n\t\tNTT(tmp4,j,0);\n\t\tNTT(G,j,0);\n\t\tfor(re int k=0;k<j;++k)\n\t\t\tG[k]=((1LL-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;\n\t\tNTT(G,j,1);\n\t\tfor(re int k=0;k<j;++k)\n\t\t\ttmp3[k]=tmp4[k]=0;\n\t}\n}\n\nint main(){\n\tunit[0][23]=cltpow(3,119);\n\tunit[1][23]=cltpow(332748118,119);\n\tfor(re int i=0;i<2;++i)\n\t\tfor(re int j=22;j>=0;--j)\n\t\t\tunit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod;\n\tfor(re int i=2;i<=maxn;++i)\n\t\tinv[i]=(mod-1LL*mod/i*inv[mod%i]%mod)%mod;\n\tcltstream::read(n);\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::read(F[i]);\n\tExp(F,G,n);\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::write(G[i],i<n-1?32:-1);\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n### 多项式开平方根\n\n给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得\n\n$$G^{2}(x)\\equiv F(x)\\pmod{x^{n}}$$\n\n牛顿迭代吼啊！\n\n$$A(G)=G^{2}-F$$\n\n$$A^{\\prime}(G)=2G$$\n\n$$\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}-\\cfrac{G_{0}^{2}-F}{2G_{0}}\\\\\n&\\equiv\\cfrac{G_{0}^{2}+F}{2G_{0}}\\\\\n&=\\cfrac{1}{2}(G_{0}+\\cfrac{F}{G_{0}})\\pmod{x^{2t}}\n\\end{aligned}$$\n\n~~复制粘贴吼啊！~~\n\n### 我刚才都学了些啥破玩意\n\n[一道例题](http://codeforces.com/contest/438/problem/E)。\n\n[Remote Judge](https://www.luogu.org/problemnew/show/CF438E)。\n\n这是读题前的我：\n\n![](https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif)\n\n这是读题后的我：\n\n![](https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg)\n\n这是知道了这题正解是多项式开平方根后的我：\n\n![](https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg)\n\n我……我怕不是学了个假的多项式哦（\n\n厚颜无耻地抄题解（\n\n首先我们搞出生成函数（然而并不是很懂）\n\n$$G(x)=\\sum\\limits_{i=0}^{m}G[i]x^{i}$$\n\n其中\n\n$$G[i]=[i\\in\\{c_{1},c_{2},\\cdots,c_{n}\\}]$$\n\n定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有\n\n$$F[0]=1$$\n\n$$F[x]=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]$$\n\n就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。\n\n然后是一些神仙操作\n\n$$\\begin{aligned}\nF[x]&=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]\\\\\n&=\\sum\\limits_{i=0}^{x}G[i]F^{2}[x-i]\\\\\n&=(GF^{2})[x]\n\\end{aligned}$$\n\n令人窒息（\n\n然后我们就有\n\n$$GF^{2}+1=F$$\n\n但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。\n\n于是解上面这个一元二次方程，我们得到\n\n$$F=\\cfrac{1\\pm\\sqrt{1-4G}}{2G}$$\n\n但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\\mp\\sqrt{1-4G})$，然后化简一波\n\n$$F=\\cfrac{2}{1\\mp\\sqrt{1-4G}}$$\n\n如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\\cfrac{2}{2}=1$。综上所述\n\n$$F=\\cfrac{2}{1+\\sqrt{1-4G}}$$\n\n本来接下来应该有代码实现的，但是~~我拒绝~~咕咕咕。\n\n~~其实是调不出来了（~~\n","slug":"polynomial-learning-notes-pt2","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwe003s34cwaiu5jtjy","content":"<p>以下，如果不特别声明，则所有运算在模$998244353$意义下进行。</p>\n<a id=\"more\"></a>\n<h3 id=\"接下来的前置知识\"><a href=\"#接下来的前置知识\" class=\"headerlink\" title=\"接下来的前置知识\"></a>接下来的前置知识</h3><h4 id=\"泰勒展开\"><a href=\"#泰勒展开\" class=\"headerlink\" title=\"泰勒展开\"></a>泰勒展开</h4><p>说实话，其实我也不是很能理解这个东西（</p>\n<p>我就凭感觉xjb扯了（</p>\n<p>现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。</p>\n<p>我们令</p>\n<script type=\"math/tex; mode=display\">g(x)=\\sum\\limits_{i=0}^{n}g[i](x-x_{0})^{i}</script><p>我们想要让$x\\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。</p>\n<p>我们先考虑$0$阶，也就是原函数。因为$x\\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有</p>\n<script type=\"math/tex; mode=display\">g[0]=f(x_{0})</script><p>然后是$1$阶</p>\n<script type=\"math/tex; mode=display\">g^{\\prime}(x)=\\sum\\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\\prime}(x_{0})</script><p>再然后是$2$阶</p>\n<script type=\"math/tex; mode=display\">g^{\\prime\\prime}(x)=\\sum\\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\\prime\\prime}(x_{0})</script><p>最后是$3$阶</p>\n<script type=\"math/tex; mode=display\">g^{\\prime\\prime\\prime}(x)=\\sum\\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\\prime\\prime\\prime}(x_{0})</script><p>我们发现$g[n]$有如下的规律</p>\n<script type=\"math/tex; mode=display\">g[n]=\\cfrac{f^{(n)}(x_{0})}{n!}</script><p>综上所述</p>\n<script type=\"math/tex; mode=display\">g(x)=\\sum\\limits_{i=0}^{n}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><p><del>应该吧（</del></p>\n<h4 id=\"多项式牛顿迭代\"><a href=\"#多项式牛顿迭代\" class=\"headerlink\" title=\"多项式牛顿迭代\"></a>多项式牛顿迭代</h4><p>考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">F(G(x))\\equiv 0\\pmod{x^{n}}</script><p>我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得</p>\n<script type=\"math/tex; mode=display\">F(G_{0})\\equiv 0\\pmod{x^{t}}</script><p>我们希望求出一个$G$使得</p>\n<script type=\"math/tex; mode=display\">F(G)\\equiv 0\\pmod{x^{2t}}</script><p>我们将$F$在$G_{0}$这里进行泰勒展开：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(G)&=F(G_{0})\\\\\n&+F^{\\prime}(G_{0})(G-G_{0})\\\\\n&+\\cfrac{F^{\\prime\\prime}(G_{0})}{2}(G-G_{0})^{2}\\\\\n&+\\cdots\\end{aligned}</script><p>注意到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(G)-F(G_{0})&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\n\\end{aligned}</script><p>也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(G)&\\equiv F(G_{0})+F^{\\prime}(G_{0})(G-G_{0})\\pmod{x^{2t}}\\\\\nF^{\\prime}(G_{0})G&\\equiv F^{\\prime}(G_{0})G_{0}-F(G_{0})\\pmod{x^{2t}}\\\\\nG&\\equiv G_{0}-\\cfrac{F(G_{0})}{F^{\\prime}(G_{0})}\\pmod{x^{2t}}\n\\end{aligned}</script><p>然后我们就一直倍增，倍增到$t\\geqslant n$为止，此时$G_{0}$即为所求多项式。</p>\n<h3 id=\"多项式求逆\"><a href=\"#多项式求逆\" class=\"headerlink\" title=\"多项式求逆\"></a><a href=\"https://www.luogu.org/problemnew/show/P4238\" target=\"_blank\" rel=\"noopener\">多项式求逆</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">F(x)\\times G(x)\\equiv 1\\pmod{x^{n}}</script><p>假设我们已经求出了$G_{0}$使得</p>\n<script type=\"math/tex; mode=display\">F\\times G_{0}\\equiv 1\\pmod{x^{t}}</script><p>我们希望找到一个$G$使得</p>\n<script type=\"math/tex; mode=display\">F\\times G\\equiv 1\\pmod{x^{2t}}</script><p>据说能用牛顿迭代推，然而我不会（</p>\n<p>考虑正常一点的方式<del>，虽然说还是倍增</del>。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF\\times G-F\\times G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\n(G-G_{0})^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG^{2}-2GG_{0}+G_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\n\\end{aligned}</script><p>两边同时乘$F$</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nG-2G_{0}+FG_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG&\\equiv 2G_{0}-FG_{0}^{2}\\pmod{x^{2t}}\n\\end{aligned}</script><p>边界条件也很明显，就是当$t=1$时，$G[0]\\equiv F[0]^{-1}$。</p>\n<p>说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（</p>\n<p>关于代码……现在还不是时候（</p>\n<p>后面有一道超级综合题在等着我们（</p>\n<h3 id=\"多项式对数函数\"><a href=\"#多项式对数函数\" class=\"headerlink\" title=\"多项式对数函数\"></a><a href=\"https://www.luogu.org/problemnew/show/P4725\" target=\"_blank\" rel=\"noopener\">多项式对数函数</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">G(x)\\equiv\\ln F(x)\\pmod{x^{n}}</script><p>对上式两边求导</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}\\equiv F^{\\prime}\\ln^{\\prime}F\\pmod{x^{n}}</script><p>又因为</p>\n<script type=\"math/tex; mode=display\">\\ln^{\\prime}x=\\frac{1}{x}</script><p>我们就得到</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}\\equiv\\cfrac{F^{\\prime}}{F}\\pmod{x^{n}}</script><p>求导+求逆+不定积分即可。</p>\n<h3 id=\"多项式指数函数\"><a href=\"#多项式指数函数\" class=\"headerlink\" title=\"多项式指数函数\"></a><a href=\"https://www.luogu.org/problemnew/show/P4726\" target=\"_blank\" rel=\"noopener\">多项式指数函数</a></h3><p>超级综合题来了。</p>\n<p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">G(x)\\equiv e^{F(x)}\\pmod{x^{n}}</script><p>首先</p>\n<script type=\"math/tex; mode=display\">\\ln G-F\\equiv 0\\pmod{x^{n}}</script><p>我们把$F$看成是常数项，定义函数</p>\n<script type=\"math/tex; mode=display\">A(G)=\\ln G-F</script><script type=\"math/tex; mode=display\">A^{\\prime}(G)=\\ln^{\\prime}G=\\cfrac{1}{G}</script><p>套牛顿迭代</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}(1-\\ln G_{0}+F)\\pmod{x^{2t}}\n\\end{aligned}</script><p>然后把以上提到的所有板子全都复制过来就行了（</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 524288</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 998244353</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n;</span><br><span class=\"line\"><span class=\"keyword\">int</span> unit[<span class=\"number\">2</span>][<span class=\"number\">24</span>],rev[maxn+<span class=\"number\">1</span>],inv[maxn+<span class=\"number\">1</span>]=&#123;<span class=\"number\">0</span>,<span class=\"number\">1</span>&#125;,F[maxn+<span class=\"number\">1</span>],G[maxn+<span class=\"number\">1</span>],tmp1[maxn+<span class=\"number\">1</span>],tmp2[maxn+<span class=\"number\">1</span>],tmp3[maxn+<span class=\"number\">1</span>],tmp4[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">cltpow</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> res=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;y;)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tres=<span class=\"number\">1L</span>L*res*x%mod;</span><br><span class=\"line\">\t\tx=<span class=\"number\">1L</span>L*x*x%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">NTT</span><span class=\"params\">(re <span class=\"keyword\">int</span>* F,re <span class=\"keyword\">int</span> n,re <span class=\"keyword\">int</span> tp)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|((i&amp;<span class=\"number\">1</span>)?(n&gt;&gt;<span class=\"number\">1</span>):<span class=\"number\">0</span>)))</span><br><span class=\"line\">\t\t\tswap(F[i],F[rev[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">1</span>,p=<span class=\"number\">1</span>;p&lt;n;++k,p&lt;&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=p&lt;&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=i,tmp=<span class=\"number\">1</span>;j&lt;i+p;++j,tmp=<span class=\"number\">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class=\"line\">\t\t\t\tre <span class=\"keyword\">int</span> x=F[j],y=<span class=\"number\">1L</span>L*F[j+p]*tmp%mod;</span><br><span class=\"line\">\t\t\t\tF[j]=(x+y)%mod;</span><br><span class=\"line\">\t\t\t\tF[j+p]=(x-y+mod)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> v=cltpow(n,tp*(mod<span class=\"number\">-2</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tF[i]=<span class=\"number\">1L</span>L*F[i]*v%mod;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Inv</span><span class=\"params\">(re <span class=\"keyword\">int</span>* F,re <span class=\"keyword\">int</span>* G,re <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\tG[<span class=\"number\">0</span>]=cltpow(F[<span class=\"number\">0</span>],mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">4</span>;i&lt;n;i&lt;&lt;=<span class=\"number\">1</span>,j&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;(i&lt;&lt;<span class=\"number\">1</span>);++k)</span><br><span class=\"line\">\t\t\ttmp1[k]=F[k];</span><br><span class=\"line\">\t\tNTT(tmp1,j,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tNTT(G,j,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;j;++k)</span><br><span class=\"line\">\t\t\tG[k]=(<span class=\"number\">2</span><span class=\"number\">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class=\"line\">\t\tNTT(G,j,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=(i&lt;&lt;<span class=\"number\">1</span>);k&lt;j;++k)</span><br><span class=\"line\">\t\t\tG[k]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;j;++k)</span><br><span class=\"line\">\t\t\ttmp1[k]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Ln</span><span class=\"params\">(re <span class=\"keyword\">int</span>* F,re <span class=\"keyword\">int</span>* G,re <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tG[i<span class=\"number\">-1</span>]=<span class=\"number\">1L</span>L*F[i]*i%mod;</span><br><span class=\"line\">\tInv(F,tmp2,n);</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> N=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;N&lt;n;N&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">\tN&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\tNTT(G,N,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(tmp2,N,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;++i)</span><br><span class=\"line\">\t\tG[i]=<span class=\"number\">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class=\"line\">\tNTT(G,N,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=n<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">1</span>;--i)</span><br><span class=\"line\">\t\tG[i]=<span class=\"number\">1L</span>L*G[i<span class=\"number\">-1</span>]*inv[i]%mod;</span><br><span class=\"line\">\tG[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=n;i&lt;N;++i)</span><br><span class=\"line\">\t\tG[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;N;++i)</span><br><span class=\"line\">\t\ttmp2[i]=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">Exp</span><span class=\"params\">(re <span class=\"keyword\">int</span>* F,re <span class=\"keyword\">int</span>* G,re <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\tG[<span class=\"number\">0</span>]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>,j=<span class=\"number\">2</span>;i&lt;(n&lt;&lt;<span class=\"number\">1</span>);i&lt;&lt;=<span class=\"number\">1</span>,j&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tLn(G,tmp3,i);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;i;++k)</span><br><span class=\"line\">\t\t\ttmp4[k]=F[k];</span><br><span class=\"line\">\t\tNTT(tmp3,j,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tNTT(tmp4,j,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\tNTT(G,j,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;j;++k)</span><br><span class=\"line\">\t\t\tG[k]=((<span class=\"number\">1L</span>L-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;</span><br><span class=\"line\">\t\tNTT(G,j,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;k&lt;j;++k)</span><br><span class=\"line\">\t\t\ttmp3[k]=tmp4[k]=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tunit[<span class=\"number\">0</span>][<span class=\"number\">23</span>]=cltpow(<span class=\"number\">3</span>,<span class=\"number\">119</span>);</span><br><span class=\"line\">\tunit[<span class=\"number\">1</span>][<span class=\"number\">23</span>]=cltpow(<span class=\"number\">332748118</span>,<span class=\"number\">119</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">22</span>;j&gt;=<span class=\"number\">0</span>;--j)</span><br><span class=\"line\">\t\t\tunit[i][j]=<span class=\"number\">1L</span>L*unit[i][j+<span class=\"number\">1</span>]*unit[i][j+<span class=\"number\">1</span>]%mod;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=maxn;++i)</span><br><span class=\"line\">\t\tinv[i]=(mod<span class=\"number\">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tcltstream::read(F[i]);</span><br><span class=\"line\">\tExp(F,G,n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tcltstream::write(G[i],i&lt;n<span class=\"number\">-1</span>?<span class=\"number\">32</span>:<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"多项式开平方根\"><a href=\"#多项式开平方根\" class=\"headerlink\" title=\"多项式开平方根\"></a>多项式开平方根</h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">G^{2}(x)\\equiv F(x)\\pmod{x^{n}}</script><p>牛顿迭代吼啊！</p>\n<script type=\"math/tex; mode=display\">A(G)=G^{2}-F</script><script type=\"math/tex; mode=display\">A^{\\prime}(G)=2G</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}-\\cfrac{G_{0}^{2}-F}{2G_{0}}\\\\\n&\\equiv\\cfrac{G_{0}^{2}+F}{2G_{0}}\\\\\n&=\\cfrac{1}{2}(G_{0}+\\cfrac{F}{G_{0}})\\pmod{x^{2t}}\n\\end{aligned}</script><p><del>复制粘贴吼啊！</del></p>\n<h3 id=\"我刚才都学了些啥破玩意\"><a href=\"#我刚才都学了些啥破玩意\" class=\"headerlink\" title=\"我刚才都学了些啥破玩意\"></a>我刚才都学了些啥破玩意</h3><p><a href=\"http://codeforces.com/contest/438/problem/E\" target=\"_blank\" rel=\"noopener\">一道例题</a>。</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/CF438E\" target=\"_blank\" rel=\"noopener\">Remote Judge</a>。</p>\n<p>这是读题前的我：</p>\n<p><img src=\"https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif\" alt=\"\"></p>\n<p>这是读题后的我：</p>\n<p><img src=\"https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg\" alt=\"\"></p>\n<p>这是知道了这题正解是多项式开平方根后的我：</p>\n<p><img src=\"https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg\" alt=\"\"></p>\n<p>我……我怕不是学了个假的多项式哦（</p>\n<p>厚颜无耻地抄题解（</p>\n<p>首先我们搞出生成函数（然而并不是很懂）</p>\n<script type=\"math/tex; mode=display\">G(x)=\\sum\\limits_{i=0}^{m}G[i]x^{i}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">G[i]=[i\\in\\{c_{1},c_{2},\\cdots,c_{n}\\}]</script><p>定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有</p>\n<script type=\"math/tex; mode=display\">F[0]=1</script><script type=\"math/tex; mode=display\">F[x]=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]</script><p>就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。</p>\n<p>然后是一些神仙操作</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF[x]&=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]\\\\\n&=\\sum\\limits_{i=0}^{x}G[i]F^{2}[x-i]\\\\\n&=(GF^{2})[x]\n\\end{aligned}</script><p>令人窒息（</p>\n<p>然后我们就有</p>\n<script type=\"math/tex; mode=display\">GF^{2}+1=F</script><p>但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。</p>\n<p>于是解上面这个一元二次方程，我们得到</p>\n<script type=\"math/tex; mode=display\">F=\\cfrac{1\\pm\\sqrt{1-4G}}{2G}</script><p>但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\\mp\\sqrt{1-4G})$，然后化简一波</p>\n<script type=\"math/tex; mode=display\">F=\\cfrac{2}{1\\mp\\sqrt{1-4G}}</script><p>如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\\cfrac{2}{2}=1$。综上所述</p>\n<script type=\"math/tex; mode=display\">F=\\cfrac{2}{1+\\sqrt{1-4G}}</script><p>本来接下来应该有代码实现的，但是<del>我拒绝</del>咕咕咕。</p>\n<p><del>其实是调不出来了（</del></p>\n","site":{"data":{}},"excerpt":"<p>以下，如果不特别声明，则所有运算在模$998244353$意义下进行。</p>","more":"<h3 id=\"接下来的前置知识\"><a href=\"#接下来的前置知识\" class=\"headerlink\" title=\"接下来的前置知识\"></a>接下来的前置知识</h3><h4 id=\"泰勒展开\"><a href=\"#泰勒展开\" class=\"headerlink\" title=\"泰勒展开\"></a>泰勒展开</h4><p>说实话，其实我也不是很能理解这个东西（</p>\n<p>我就凭感觉xjb扯了（</p>\n<p>现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。</p>\n<p>我们令</p>\n<script type=\"math/tex; mode=display\">g(x)=\\sum\\limits_{i=0}^{n}g[i](x-x_{0})^{i}</script><p>我们想要让$x\\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。</p>\n<p>我们先考虑$0$阶，也就是原函数。因为$x\\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有</p>\n<script type=\"math/tex; mode=display\">g[0]=f(x_{0})</script><p>然后是$1$阶</p>\n<script type=\"math/tex; mode=display\">g^{\\prime}(x)=\\sum\\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\\prime}(x_{0})</script><p>再然后是$2$阶</p>\n<script type=\"math/tex; mode=display\">g^{\\prime\\prime}(x)=\\sum\\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\\prime\\prime}(x_{0})</script><p>最后是$3$阶</p>\n<script type=\"math/tex; mode=display\">g^{\\prime\\prime\\prime}(x)=\\sum\\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\\prime\\prime\\prime}(x_{0})</script><p>我们发现$g[n]$有如下的规律</p>\n<script type=\"math/tex; mode=display\">g[n]=\\cfrac{f^{(n)}(x_{0})}{n!}</script><p>综上所述</p>\n<script type=\"math/tex; mode=display\">g(x)=\\sum\\limits_{i=0}^{n}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><p><del>应该吧（</del></p>\n<h4 id=\"多项式牛顿迭代\"><a href=\"#多项式牛顿迭代\" class=\"headerlink\" title=\"多项式牛顿迭代\"></a>多项式牛顿迭代</h4><p>考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">F(G(x))\\equiv 0\\pmod{x^{n}}</script><p>我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得</p>\n<script type=\"math/tex; mode=display\">F(G_{0})\\equiv 0\\pmod{x^{t}}</script><p>我们希望求出一个$G$使得</p>\n<script type=\"math/tex; mode=display\">F(G)\\equiv 0\\pmod{x^{2t}}</script><p>我们将$F$在$G_{0}$这里进行泰勒展开：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(G)&=F(G_{0})\\\\\n&+F^{\\prime}(G_{0})(G-G_{0})\\\\\n&+\\cfrac{F^{\\prime\\prime}(G_{0})}{2}(G-G_{0})^{2}\\\\\n&+\\cdots\\end{aligned}</script><p>注意到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(G)-F(G_{0})&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\n\\end{aligned}</script><p>也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(G)&\\equiv F(G_{0})+F^{\\prime}(G_{0})(G-G_{0})\\pmod{x^{2t}}\\\\\nF^{\\prime}(G_{0})G&\\equiv F^{\\prime}(G_{0})G_{0}-F(G_{0})\\pmod{x^{2t}}\\\\\nG&\\equiv G_{0}-\\cfrac{F(G_{0})}{F^{\\prime}(G_{0})}\\pmod{x^{2t}}\n\\end{aligned}</script><p>然后我们就一直倍增，倍增到$t\\geqslant n$为止，此时$G_{0}$即为所求多项式。</p>\n<h3 id=\"多项式求逆\"><a href=\"#多项式求逆\" class=\"headerlink\" title=\"多项式求逆\"></a><a href=\"https://www.luogu.org/problemnew/show/P4238\" target=\"_blank\" rel=\"noopener\">多项式求逆</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">F(x)\\times G(x)\\equiv 1\\pmod{x^{n}}</script><p>假设我们已经求出了$G_{0}$使得</p>\n<script type=\"math/tex; mode=display\">F\\times G_{0}\\equiv 1\\pmod{x^{t}}</script><p>我们希望找到一个$G$使得</p>\n<script type=\"math/tex; mode=display\">F\\times G\\equiv 1\\pmod{x^{2t}}</script><p>据说能用牛顿迭代推，然而我不会（</p>\n<p>考虑正常一点的方式<del>，虽然说还是倍增</del>。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF\\times G-F\\times G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\nG-G_{0}&\\equiv 0\\pmod{x^{t}}\\\\\n(G-G_{0})^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG^{2}-2GG_{0}+G_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\n\\end{aligned}</script><p>两边同时乘$F$</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nG-2G_{0}+FG_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\\\\\nG&\\equiv 2G_{0}-FG_{0}^{2}\\pmod{x^{2t}}\n\\end{aligned}</script><p>边界条件也很明显，就是当$t=1$时，$G[0]\\equiv F[0]^{-1}$。</p>\n<p>说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（</p>\n<p>关于代码……现在还不是时候（</p>\n<p>后面有一道超级综合题在等着我们（</p>\n<h3 id=\"多项式对数函数\"><a href=\"#多项式对数函数\" class=\"headerlink\" title=\"多项式对数函数\"></a><a href=\"https://www.luogu.org/problemnew/show/P4725\" target=\"_blank\" rel=\"noopener\">多项式对数函数</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">G(x)\\equiv\\ln F(x)\\pmod{x^{n}}</script><p>对上式两边求导</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}\\equiv F^{\\prime}\\ln^{\\prime}F\\pmod{x^{n}}</script><p>又因为</p>\n<script type=\"math/tex; mode=display\">\\ln^{\\prime}x=\\frac{1}{x}</script><p>我们就得到</p>\n<script type=\"math/tex; mode=display\">G^{\\prime}\\equiv\\cfrac{F^{\\prime}}{F}\\pmod{x^{n}}</script><p>求导+求逆+不定积分即可。</p>\n<h3 id=\"多项式指数函数\"><a href=\"#多项式指数函数\" class=\"headerlink\" title=\"多项式指数函数\"></a><a href=\"https://www.luogu.org/problemnew/show/P4726\" target=\"_blank\" rel=\"noopener\">多项式指数函数</a></h3><p>超级综合题来了。</p>\n<p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">G(x)\\equiv e^{F(x)}\\pmod{x^{n}}</script><p>首先</p>\n<script type=\"math/tex; mode=display\">\\ln G-F\\equiv 0\\pmod{x^{n}}</script><p>我们把$F$看成是常数项，定义函数</p>\n<script type=\"math/tex; mode=display\">A(G)=\\ln G-F</script><script type=\"math/tex; mode=display\">A^{\\prime}(G)=\\ln^{\\prime}G=\\cfrac{1}{G}</script><p>套牛顿迭代</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}(1-\\ln G_{0}+F)\\pmod{x^{2t}}\n\\end{aligned}</script><p>然后把以上提到的所有板子全都复制过来就行了（</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�23-->\n\n</div></div>\n<h3 id=\"多项式开平方根\"><a href=\"#多项式开平方根\" class=\"headerlink\" title=\"多项式开平方根\"></a>多项式开平方根</h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p>\n<script type=\"math/tex; mode=display\">G^{2}(x)\\equiv F(x)\\pmod{x^{n}}</script><p>牛顿迭代吼啊！</p>\n<script type=\"math/tex; mode=display\">A(G)=G^{2}-F</script><script type=\"math/tex; mode=display\">A^{\\prime}(G)=2G</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nG&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\\n&\\equiv G_{0}-\\cfrac{G_{0}^{2}-F}{2G_{0}}\\\\\n&\\equiv\\cfrac{G_{0}^{2}+F}{2G_{0}}\\\\\n&=\\cfrac{1}{2}(G_{0}+\\cfrac{F}{G_{0}})\\pmod{x^{2t}}\n\\end{aligned}</script><p><del>复制粘贴吼啊！</del></p>\n<h3 id=\"我刚才都学了些啥破玩意\"><a href=\"#我刚才都学了些啥破玩意\" class=\"headerlink\" title=\"我刚才都学了些啥破玩意\"></a>我刚才都学了些啥破玩意</h3><p><a href=\"http://codeforces.com/contest/438/problem/E\" target=\"_blank\" rel=\"noopener\">一道例题</a>。</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/CF438E\" target=\"_blank\" rel=\"noopener\">Remote Judge</a>。</p>\n<p>这是读题前的我：</p>\n<p><img src=\"https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif\" alt=\"\"></p>\n<p>这是读题后的我：</p>\n<p><img src=\"https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg\" alt=\"\"></p>\n<p>这是知道了这题正解是多项式开平方根后的我：</p>\n<p><img src=\"https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg\" alt=\"\"></p>\n<p>我……我怕不是学了个假的多项式哦（</p>\n<p>厚颜无耻地抄题解（</p>\n<p>首先我们搞出生成函数（然而并不是很懂）</p>\n<script type=\"math/tex; mode=display\">G(x)=\\sum\\limits_{i=0}^{m}G[i]x^{i}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">G[i]=[i\\in\\{c_{1},c_{2},\\cdots,c_{n}\\}]</script><p>定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有</p>\n<script type=\"math/tex; mode=display\">F[0]=1</script><script type=\"math/tex; mode=display\">F[x]=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]</script><p>就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。</p>\n<p>然后是一些神仙操作</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF[x]&=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]\\\\\n&=\\sum\\limits_{i=0}^{x}G[i]F^{2}[x-i]\\\\\n&=(GF^{2})[x]\n\\end{aligned}</script><p>令人窒息（</p>\n<p>然后我们就有</p>\n<script type=\"math/tex; mode=display\">GF^{2}+1=F</script><p>但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。</p>\n<p>于是解上面这个一元二次方程，我们得到</p>\n<script type=\"math/tex; mode=display\">F=\\cfrac{1\\pm\\sqrt{1-4G}}{2G}</script><p>但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\\mp\\sqrt{1-4G})$，然后化简一波</p>\n<script type=\"math/tex; mode=display\">F=\\cfrac{2}{1\\mp\\sqrt{1-4G}}</script><p>如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\\cfrac{2}{2}=1$。综上所述</p>\n<script type=\"math/tex; mode=display\">F=\\cfrac{2}{1+\\sqrt{1-4G}}</script><p>本来接下来应该有代码实现的，但是<del>我拒绝</del>咕咕咕。</p>\n<p><del>其实是调不出来了（</del></p>"},{"mathjax":true,"date":"2018-12-26T12:17:22.000Z","title":"题目组试题选讲","password":"FLS&&8]T:$f3[yrtt!osE+K&3\"`?IlA{","abstract":"该文章已被加密","message":"输入密码继续阅读","_content":"先宣传一波[团队](https://www.luogu.org/team/show?teamid=11367)。\n\n<!-- more -->\n\n### [「T47720」孤立元](https://www.luogu.org/problemnew/show/T47720)\n\n[已有题解](/luogu-t47720-solution/)。\n\n### [「T53537」营救元首](https://www.luogu.org/problemnew/show/T53537)\n\n能看出[五彩斑斓的世界](https://www.luogu.org/problemnew/show/P4117)来吗？\n\n没错就是JF切了这道题以后~~根号上脑~~搞了这么一个东西。\n\n不过这道题相对之下有点麻烦的，因为你需要维护两个tag，一个处理减，一个处理推平。而且求前驱的时候不能值域分块，然后就只能套`set`。\n\n详细点说的话，就是每个块维护最大值和最小值。操作$1$可以选择枚举所有大于$k$的数，然后减去$k$；也可以枚举所有小于等于$k$的数，加上$k$之后整个块打上一个减$k$的标记，标记这个块内的所有数都被减去了$k$。哪个运算量少就选哪个。\n\n操作$2$就先查询最小值~~（这个都会吧）~~，然后散块直接改，整块打个标记就好，标记这个块内的所有数都被改成了另一个数。\n\n操作$3$就不必多说了，散块暴力找，整块`lower_bound`。\n\n不过说实话，写起来挺麻烦的。也懒得看以前我写的代码了，直接贴出来吧。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<set>\n#define re register\n#define maxn 100000\n#define maxm 100000\n#define maxblock 320\n#define maxval 200000\n#define mod 998244353\n#define max(a,b) ((a)>=(b)?(a):(b))\n#define min(a,b) ((a)<=(b)?(a):(b))\n\nnamespace cltstream{\n    #define size 1048576\n    char cltin[size+1],*ih=cltin,*it=cltin;\n    inline char gc(){\n        #ifdef ONLINE_JUDGE\n            if(ih==it){\n                it=(ih=cltin)+fread(cltin,1,size,stdin);\n                if(ih==it)\n                    return EOF;\n            }\n            return *ih++;\n        #else\n            return getchar();\n        #endif\n    }\n\n    char cltout[size+1],*oh=cltout;\n    int outcnt=0;\n    inline void pc(char c){\n        if(c==-1)\n            fwrite(cltout,1,outcnt,stdout);\n        else{\n            if(outcnt==size){\n                fwrite(cltout,1,size,stdout);\n                oh=cltout;\n                outcnt=0;\n            }\n            *oh++=c;\n            ++outcnt;\n        }\n    }\n    #undef size\n\n    template <typename _tp>\n    inline void read(_tp& x){\n        int sn=1;\n        char c=gc();\n        for(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n        if(c==45&&c!=EOF)\n            sn=-1,c=gc();\n        for(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n        x*=sn;\n    }\n\n    template <typename _tp>\n    inline void write(_tp x,char text=' '){\n        if(x<0)\n            pc(45),x=-x;\n        if(!x)\n            pc(48);\n        else{\n            int digit[22];\n            for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n            for(;digit[0];pc(digit[digit[0]--]^48));\n        }\n        pc(text);\n    }\n}\n\nint n,m,size;\nint a[maxn+1],id[maxn+1];\nint val[maxn+1],f[maxn+1];\nint pos[maxblock+1][maxval+1];\nint maxv[maxblock+1],minv[maxblock+1],tag[maxblock+1],sam[maxblock+1];\nstd::set<int> s[maxblock+1];\n\nint find(int x){\n    return f[x]==x?x:f[x]=find(f[x]);\n}\n\ninline void init(int x){\n    maxv[x]=-2e9;\n    minv[x]=2e9;\n    for(re int i=(x-1)*size+1;i<=x*size&&i<=n;++i)\n        if(!pos[x][a[i]]){\n            val[i]=a[i];\n            f[i]=i;\n            pos[x][a[i]]=i;\n            maxv[x]=max(maxv[x],a[i]);\n            minv[x]=min(minv[x],a[i]);\n            s[x].insert(a[i]);\n        }\n        else\n            f[i]=pos[x][a[i]];\n}\n\ninline void destory(int x){\n    for(re int i=(x-1)*size+1;i<=x*size&&i<=n;++i){\n        a[i]=sam[x]?sam[x]:val[find(i)]+tag[x];\n        pos[x][val[i]]=0;\n    }\n    tag[x]=sam[x]=0;\n    s[x].clear();\n}\n\ninline void solve(int x,int y){\n    if(sam[x]){\n        if(sam[x]>y)\n            sam[x]-=y;\n        return;\n    }\n    if(maxv[x]-(y-tag[x])<=(y-tag[x])-minv[x]+1){\n        for(re int i=(y-tag[x])+1;i<=maxv[x];++i)\n            if(pos[x][i]){\n                s[x].erase(i);\n                if(!pos[x][i-y]){\n                    val[pos[x][i]]-=y;\n                    pos[x][i-y]=pos[x][i];\n                    s[x].insert(i-y);\n                }\n                else\n                    if(pos[x][i]>pos[x][i-y])\n                        f[pos[x][i]]=pos[x][i-y];\n                    else{\n                        f[pos[x][i-y]]=pos[x][i];\n                        pos[x][i-y]=pos[x][i];\n                        val[pos[x][i-y]]-=y;\n                    }\n                pos[x][i]=0;\n            }\n    }\n    else{\n        for(re int i=(y-tag[x]);i>=minv[x];--i)\n            if(pos[x][i]){\n                s[x].erase(i);\n                if(!pos[x][i+y]){\n                    val[pos[x][i]]+=y;\n                    pos[x][i+y]=pos[x][i];\n                    s[x].insert(i+y);\n                }\n                else\n                    if(pos[x][i]>pos[x][i+y])\n                        f[pos[x][i]]=pos[x][i+y];\n                    else{\n                        f[pos[x][i+y]]=pos[x][i];\n                        pos[x][i+y]=pos[x][i];\n                        val[pos[x][i+y]]+=y;\n                    }\n                pos[x][i]=0;\n            }\n        tag[x]-=y;\n    }\n    minv[x]=*s[x].begin();\n    std::set<int>::iterator it=s[x].end();\n    --it;\n    maxv[x]=*it;\n}\n\ninline void IntervalCut(int l,int r,int x){\n    int L=id[l],R=id[r];\n    destory(L);\n    for(re int i=l;i<=L*size&&i<=r;++i)\n        if(a[i]>x)\n            a[i]-=x;\n    init(L);\n    for(re int i=L+1;i<=R-1;++i)\n        solve(i,x);\n    if(L<R){\n        destory(R);\n        for(re int i=(R-1)*size+1;i<=r;++i)\n            if(a[i]>x)\n                a[i]-=x;\n        init(R);\n    }\n}\n\ninline void IntervalAssignToMin(int l,int r){\n    int L=id[l],R=id[r],res=2e9;\n    destory(L);\n    for(re int i=l;i<=L*size&&i<=r;++i)\n        res=min(res,a[i]);\n    for(re int i=L+1;i<=R-1;++i)\n        res=min(res,sam[i]?sam[i]:minv[i]+tag[i]);\n    if(L<R){\n        destory(R);\n        for(re int i=(R-1)*size+1;i<=r;++i)\n            res=min(res,a[i]);\n    }\n    for(re int i=l;i<=L*size&&i<=r;++i)\n        a[i]=res;\n    init(L);\n    for(re int i=L+1;i<=R-1;++i)\n        sam[i]=res;\n    if(L<R){\n        for(re int i=(R-1)*size+1;i<=r;++i)\n            a[i]=res;\n        init(R);\n    }\n}\n\ninline void IntervalPre(int l,int r,int x){\n    int L=id[l],R=id[r],p=0,res=-2e9;\n    if(sam[L]){\n        if(sam[L]<x&&sam[L]>res){\n            p=l;\n            res=sam[L];\n        }\n    }\n    else\n        for(re int i=l;i<=L*size&&i<=r;++i)\n            if(val[find(i)]+tag[L]<x&&val[find(i)]+tag[L]>res){\n                p=i;\n                res=val[f[i]]+tag[L];\n            }\n    for(re int i=L+1;i<=R-1;++i)\n        if(sam[i]){\n            if(sam[i]<x&&sam[i]>res){\n                p=(i-1)*size+1;\n                res=sam[i];\n            }\n        }\n        else{\n            std::set<int>::iterator it=s[i].lower_bound(x-tag[i]);\n            if(it!=s[i].begin()){\n                --it;\n                if(*it+tag[i]<x&&*it+tag[i]>res){\n                    p=pos[i][*it];\n                    res=*it+tag[i];\n                }\n            }\n        }\n    if(L<R){\n        if(sam[R]){\n            if(sam[R]<x&&sam[R]>res){\n                p=(R-1)*size+1;\n                res=sam[R];\n            }\n        }\n        else\n            for(re int i=(R-1)*size+1;i<=r;++i)\n                if(val[find(i)]+tag[R]<x&&val[find(i)]+tag[R]>res){\n                    p=i;\n                    res=val[f[i]]+tag[R];\n                }\n    }\n    if(p)\n        cltstream::write(p,'\\n');\n    else{\n        cltstream::pc('G');\n        cltstream::pc('R');\n        cltstream::pc('E');\n        cltstream::pc('A');\n        cltstream::pc('T');\n        cltstream::pc(10);\n    }\n}\n\nint main(){\n    cltstream::read(n);\n    cltstream::read(m);\n    for(re int i=1;i<=n;++i)\n        cltstream::read(a[i]);\n    for(;(size+1)*(size+1)<=n;++size);\n    for(re int i=1;(i-1)*size+1<=n;++i){\n        init(i);\n        for(re int j=(i-1)*size+1;j<=i*size&&j<=n;++j)\n            id[j]=i;\n    }\n    for(re int i=1;i<=m;++i){\n        int opt,l,r,x;\n        cltstream::read(opt);\n        cltstream::read(l);\n        cltstream::read(r);\n        switch(opt){\n            case 1:\n                cltstream::read(x);\n                IntervalCut(l,r,x);\n                break;\n            case 2:\n                IntervalAssignToMin(l,r);\n                break;\n            case 3:\n                cltstream::read(x);\n                IntervalPre(l,r,x);\n                break;\n        }\n    }\n    for(re int i=1;i<=n;++i)\n        (a[0]+=sam[id[i]]?sam[id[i]]:val[find(i)]+tag[id[i]])%=mod;\n    cltstream::write(a[0],'\\n');\n    cltstream::pc(-1);\n    return 0;\n}\n```\n\n{% endfold %}\n\n### [「T53987」ZJF日记](https://www.luogu.org/problemnew/show/T53987)\n\n最短路计数+次短路求解。\n\n其实这才应该是签到题啊，然而当初却被排到了T3。不是很懂（\n\n不过话说回来其实题面写的很好啊。\n\nsto __多弗桃__ orz\n\n#### 关于SPFA\n\n他死了。\n\n### [「T56269」选择性失忆](https://www.luogu.org/problemnew/show/T56269)\n\nsto __SnoWY__ orz\n\n才刚学了几个月就出这种神仙题，把我这种从初中就开始学OI的菜鸡吊起来打（\n\n首先我们看到要最小化第$k+1$大的边权。二分？那么问题就转化成了找一条路径，使得其中恰有$k$条边的边权小于某个给定数值。\n\nemmmmmm……这是什么鬼（\n\n总之二分大概不大可行。然后我觉得我扯不下去了，直接讲正解吧（\n\n构造一张$k+1$层的分层图。如果说我们在某一层有一条边从$u$到$v$，边权是$w$，我们就从这一层的$u$，向下一层的$v$连一条$0$权边。然后从最上层的$1$开始跑最短路，路径长度定义为边权最大值，跑到最下层的$n$。然后`dis[最下层的n]`就是答案。\n\n那么为什么这样做可行？假设说我们现在跑出了最上层的$n$的`dis`。现在我们将$n$下压一层，我们肯定会在之前边权最大的那一条边处跨越至下层。这样这条边的边权减为$0$，相当于是说被过滤掉了。不难想象出，如果我们下压$k$层到最底层，边权前$k$大的边就都被过滤掉了，这时路径上的边权最大值就是一开始的$k+1$大。\n\n相信各位应该都会了，我就不贴代码了。\n\n然后还是要%SnoWY。\n\n[](https://i.loli.net/2018/12/26/5c237e1c077b4.jpg)\n\n### [「T62117」复习](https://www.luogu.org/problemnew/show/T62117)\n\n这是一道被线段树踩爆了的分块题。\n\n每个块内维护总和、正数数量和绝对值最小的负数的绝对值。\n\n每次加的时候，散块还是暴力重构，整块就判断一下绝对值最小的负数加完会不会变号，会就重构。\n\n因为保证$k$非负，每个数最多变号一次，也就是说最多重构$n$次，时间复杂度$O(n\\sqrt{n})$。\n\n代码太丢人了不贴了。\n\n### [「T64137」「魔板」线段树 2](https://www.luogu.org/problemnew/show/T64137)\n\n这是一道~~丧心病狂的~~卡时空块状分块题。\n\n关于块状分块请看[这里](/block-decomposition/)。\n\n反正也没啥可说的，就是写起来麻烦，我就简单讲一下这题背后的故事吧。\n\n首先一开始我们定的时空限制是$1\\text{s}/4\\text{MB}$。然而还是放跑了空间复杂度足够优秀的线段树。然后一气之下删了`fread`，把空间限制改到$2\\text{MB}$，并把时间限制改到$850\\text{ms}$。然后有神仙通过将线段树的多个叶子结点合并起来的方法又水过去了。最后空间直接卡到了现在的$1.5\\text{MB}$。然后最后两个点询问加到$2\\times 10^{6}$，并塞入大量单点操作，才算把该卡的都卡掉了。\n\n顺便第一次写计分脚本祭。\n\n### [「T65749」斩整「土偶剪定」](https://www.luogu.org/problemnew/show/T65749)\n\n首先高维这种东西我们肯定不能硬想。\n\n首先假设$a_{i}\\gt 1$。如果说一个小土块恰有$k$面有颜色，这也就意味着，它恰有$k$个维度的坐标是$1$或$a_{i}$，剩下$n-k$个维度除了$1$和$a_{i}$以外随便选。那么我们的总方案数就是\n\n$$2^{k}\\sum_{\\mid S\\mid=n-k\\wedge\\forall i\\in S,i\\in[1,n]\\cap\\mathbb{Z}}\\prod_{i\\in S}(a_{i}-2)$$\n\n下文为了方便，我们定义$Q_{k}$为\n\n$$\\sum_{\\mid S\\mid=k\\wedge\\forall i\\in S,i\\in[1,n]\\cap\\mathbb{Z}}\\prod_{i\\in S}(a_{i}-2)$$\n\n也就是从所有的$a_{i}-2$中选$k$个相乘的所有方案的结果的总和。同时$Q_{0}=1$。\n\n没错就是[这道题](https://www.luogu.org/problemnew/show/P4247)。\n\n现在我们想要对于$[0,n]$内的每一个$i$求出$Q_{i}$。在上面那道题中我们采用的办法是分治。具体来说就是，如果说我们要在$[l,r]$内选$k$个数相乘，我们可以先在$[l,mid]$内选$x$个数相乘，再在$[mid+1,r]$内选$k-x$个数相乘，然后把结果相乘并累加。\n\n形式化地讲的话\n\n$$Q_{k}=\\sum_{i=0}^{k}Q_{l,i}Q_{r,k-i}$$\n\n然后我们直接$O(n^{2})$暴力算就好。但是我们发现如果说我们直接分治，我们会得到这么一个关于时间复杂度的递推式\n\n$$T(n)=2T(\\cfrac{n}{2})+O(n^{2})$$\n\n根据主定理，我们有$T(n)=O(n^{2})$。\n\n其实我一开始以为它是$O(n^{2}\\log n)$的，仔细一算才发现不对（\n\n不过我的标算并不是这么写的。我的做法是从头扫到尾，将前$k$个与第$k+1$个合并。这样的时间复杂度是\n\n$$T(n)=T(n-1)+O(n)$$\n\n很明显也是$O(n^{2})$的。不过好像常数相对较大？\n\n~~然而对比了一下发现常数小了不少（~~\n\n那么问题来了，如果说存在$a_{i}=1$怎么办？\n\n存在$a_{i}=1$就说明，这一维的坐标一定会同时碰到两个边界。那么我们就可以扔掉这个$1$，把它当成$n-1$维处理，然后在最左边添上两个$0$就行了。\n\n同理，如果存在$m$个$a_{i}=1$，我们就扔掉它们并当成$n-m$维处理，然后在最左边添上$2m$个$0$。\n\n其实这道题还可以优化。仔细观察这个式子\n\n$$Q_{k}=\\sum_{i=0}^{k}Q_{l,i}Q_{r,k-i}$$\n\n我们看到这其实就是一个卷积，我们套一波FFT/NTT就能把时间复杂度优化到\n\n$$T(n)=2T(\\cfrac{n}{2})+O(n\\log n)$$\n\n根据主定理，我们有$T(n)=O(n\\log^{2}n)$。一写发现跑得飞快。\n\n当然这是仅限于分治做法的，像我标算这种做法上了FFT/NTT也优化不了（\n\n![](/images/TIM截图20190116111347.png)\n\n上面这三个评测记录，最下面的是真正的标算，中间的是分治，上面的是NTT优化分治。\n\n#### 论如何用最简短的语言描述主定理\n\n$$T(n)=aT(\\cfrac{n}{b})+O(n^{c}\\log^{k}n)$$\n\n$$T(n)=\\begin{cases}\n&O(n^{c})\\;\\;&(c>\\log_{b}a\\wedge k=0)\\\\\n&O(n^{\\log_{b}a})&(c<\\log_{b}a\\wedge k=0)\\\\\n&O(n^{c}\\log^{k+1}n)&(c=\\log_{b}a)\n\\end{cases}$$\n","source":"_posts/2018-12-26-timuzu-solutions.md","raw":"---\nmathjax: true\ndate: 2018-12-26 20:17:22\ntitle: 题目组试题选讲\ntags:\n  - 洛谷\n  - 题目组\n  - 毒瘤题\ncategories:\n  - 题解\npassword: FLS&&8]T:$f3[yrtt!osE+K&3\"`?IlA{\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\n---\n先宣传一波[团队](https://www.luogu.org/team/show?teamid=11367)。\n\n<!-- more -->\n\n### [「T47720」孤立元](https://www.luogu.org/problemnew/show/T47720)\n\n[已有题解](/luogu-t47720-solution/)。\n\n### [「T53537」营救元首](https://www.luogu.org/problemnew/show/T53537)\n\n能看出[五彩斑斓的世界](https://www.luogu.org/problemnew/show/P4117)来吗？\n\n没错就是JF切了这道题以后~~根号上脑~~搞了这么一个东西。\n\n不过这道题相对之下有点麻烦的，因为你需要维护两个tag，一个处理减，一个处理推平。而且求前驱的时候不能值域分块，然后就只能套`set`。\n\n详细点说的话，就是每个块维护最大值和最小值。操作$1$可以选择枚举所有大于$k$的数，然后减去$k$；也可以枚举所有小于等于$k$的数，加上$k$之后整个块打上一个减$k$的标记，标记这个块内的所有数都被减去了$k$。哪个运算量少就选哪个。\n\n操作$2$就先查询最小值~~（这个都会吧）~~，然后散块直接改，整块打个标记就好，标记这个块内的所有数都被改成了另一个数。\n\n操作$3$就不必多说了，散块暴力找，整块`lower_bound`。\n\n不过说实话，写起来挺麻烦的。也懒得看以前我写的代码了，直接贴出来吧。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<set>\n#define re register\n#define maxn 100000\n#define maxm 100000\n#define maxblock 320\n#define maxval 200000\n#define mod 998244353\n#define max(a,b) ((a)>=(b)?(a):(b))\n#define min(a,b) ((a)<=(b)?(a):(b))\n\nnamespace cltstream{\n    #define size 1048576\n    char cltin[size+1],*ih=cltin,*it=cltin;\n    inline char gc(){\n        #ifdef ONLINE_JUDGE\n            if(ih==it){\n                it=(ih=cltin)+fread(cltin,1,size,stdin);\n                if(ih==it)\n                    return EOF;\n            }\n            return *ih++;\n        #else\n            return getchar();\n        #endif\n    }\n\n    char cltout[size+1],*oh=cltout;\n    int outcnt=0;\n    inline void pc(char c){\n        if(c==-1)\n            fwrite(cltout,1,outcnt,stdout);\n        else{\n            if(outcnt==size){\n                fwrite(cltout,1,size,stdout);\n                oh=cltout;\n                outcnt=0;\n            }\n            *oh++=c;\n            ++outcnt;\n        }\n    }\n    #undef size\n\n    template <typename _tp>\n    inline void read(_tp& x){\n        int sn=1;\n        char c=gc();\n        for(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n        if(c==45&&c!=EOF)\n            sn=-1,c=gc();\n        for(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n        x*=sn;\n    }\n\n    template <typename _tp>\n    inline void write(_tp x,char text=' '){\n        if(x<0)\n            pc(45),x=-x;\n        if(!x)\n            pc(48);\n        else{\n            int digit[22];\n            for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n            for(;digit[0];pc(digit[digit[0]--]^48));\n        }\n        pc(text);\n    }\n}\n\nint n,m,size;\nint a[maxn+1],id[maxn+1];\nint val[maxn+1],f[maxn+1];\nint pos[maxblock+1][maxval+1];\nint maxv[maxblock+1],minv[maxblock+1],tag[maxblock+1],sam[maxblock+1];\nstd::set<int> s[maxblock+1];\n\nint find(int x){\n    return f[x]==x?x:f[x]=find(f[x]);\n}\n\ninline void init(int x){\n    maxv[x]=-2e9;\n    minv[x]=2e9;\n    for(re int i=(x-1)*size+1;i<=x*size&&i<=n;++i)\n        if(!pos[x][a[i]]){\n            val[i]=a[i];\n            f[i]=i;\n            pos[x][a[i]]=i;\n            maxv[x]=max(maxv[x],a[i]);\n            minv[x]=min(minv[x],a[i]);\n            s[x].insert(a[i]);\n        }\n        else\n            f[i]=pos[x][a[i]];\n}\n\ninline void destory(int x){\n    for(re int i=(x-1)*size+1;i<=x*size&&i<=n;++i){\n        a[i]=sam[x]?sam[x]:val[find(i)]+tag[x];\n        pos[x][val[i]]=0;\n    }\n    tag[x]=sam[x]=0;\n    s[x].clear();\n}\n\ninline void solve(int x,int y){\n    if(sam[x]){\n        if(sam[x]>y)\n            sam[x]-=y;\n        return;\n    }\n    if(maxv[x]-(y-tag[x])<=(y-tag[x])-minv[x]+1){\n        for(re int i=(y-tag[x])+1;i<=maxv[x];++i)\n            if(pos[x][i]){\n                s[x].erase(i);\n                if(!pos[x][i-y]){\n                    val[pos[x][i]]-=y;\n                    pos[x][i-y]=pos[x][i];\n                    s[x].insert(i-y);\n                }\n                else\n                    if(pos[x][i]>pos[x][i-y])\n                        f[pos[x][i]]=pos[x][i-y];\n                    else{\n                        f[pos[x][i-y]]=pos[x][i];\n                        pos[x][i-y]=pos[x][i];\n                        val[pos[x][i-y]]-=y;\n                    }\n                pos[x][i]=0;\n            }\n    }\n    else{\n        for(re int i=(y-tag[x]);i>=minv[x];--i)\n            if(pos[x][i]){\n                s[x].erase(i);\n                if(!pos[x][i+y]){\n                    val[pos[x][i]]+=y;\n                    pos[x][i+y]=pos[x][i];\n                    s[x].insert(i+y);\n                }\n                else\n                    if(pos[x][i]>pos[x][i+y])\n                        f[pos[x][i]]=pos[x][i+y];\n                    else{\n                        f[pos[x][i+y]]=pos[x][i];\n                        pos[x][i+y]=pos[x][i];\n                        val[pos[x][i+y]]+=y;\n                    }\n                pos[x][i]=0;\n            }\n        tag[x]-=y;\n    }\n    minv[x]=*s[x].begin();\n    std::set<int>::iterator it=s[x].end();\n    --it;\n    maxv[x]=*it;\n}\n\ninline void IntervalCut(int l,int r,int x){\n    int L=id[l],R=id[r];\n    destory(L);\n    for(re int i=l;i<=L*size&&i<=r;++i)\n        if(a[i]>x)\n            a[i]-=x;\n    init(L);\n    for(re int i=L+1;i<=R-1;++i)\n        solve(i,x);\n    if(L<R){\n        destory(R);\n        for(re int i=(R-1)*size+1;i<=r;++i)\n            if(a[i]>x)\n                a[i]-=x;\n        init(R);\n    }\n}\n\ninline void IntervalAssignToMin(int l,int r){\n    int L=id[l],R=id[r],res=2e9;\n    destory(L);\n    for(re int i=l;i<=L*size&&i<=r;++i)\n        res=min(res,a[i]);\n    for(re int i=L+1;i<=R-1;++i)\n        res=min(res,sam[i]?sam[i]:minv[i]+tag[i]);\n    if(L<R){\n        destory(R);\n        for(re int i=(R-1)*size+1;i<=r;++i)\n            res=min(res,a[i]);\n    }\n    for(re int i=l;i<=L*size&&i<=r;++i)\n        a[i]=res;\n    init(L);\n    for(re int i=L+1;i<=R-1;++i)\n        sam[i]=res;\n    if(L<R){\n        for(re int i=(R-1)*size+1;i<=r;++i)\n            a[i]=res;\n        init(R);\n    }\n}\n\ninline void IntervalPre(int l,int r,int x){\n    int L=id[l],R=id[r],p=0,res=-2e9;\n    if(sam[L]){\n        if(sam[L]<x&&sam[L]>res){\n            p=l;\n            res=sam[L];\n        }\n    }\n    else\n        for(re int i=l;i<=L*size&&i<=r;++i)\n            if(val[find(i)]+tag[L]<x&&val[find(i)]+tag[L]>res){\n                p=i;\n                res=val[f[i]]+tag[L];\n            }\n    for(re int i=L+1;i<=R-1;++i)\n        if(sam[i]){\n            if(sam[i]<x&&sam[i]>res){\n                p=(i-1)*size+1;\n                res=sam[i];\n            }\n        }\n        else{\n            std::set<int>::iterator it=s[i].lower_bound(x-tag[i]);\n            if(it!=s[i].begin()){\n                --it;\n                if(*it+tag[i]<x&&*it+tag[i]>res){\n                    p=pos[i][*it];\n                    res=*it+tag[i];\n                }\n            }\n        }\n    if(L<R){\n        if(sam[R]){\n            if(sam[R]<x&&sam[R]>res){\n                p=(R-1)*size+1;\n                res=sam[R];\n            }\n        }\n        else\n            for(re int i=(R-1)*size+1;i<=r;++i)\n                if(val[find(i)]+tag[R]<x&&val[find(i)]+tag[R]>res){\n                    p=i;\n                    res=val[f[i]]+tag[R];\n                }\n    }\n    if(p)\n        cltstream::write(p,'\\n');\n    else{\n        cltstream::pc('G');\n        cltstream::pc('R');\n        cltstream::pc('E');\n        cltstream::pc('A');\n        cltstream::pc('T');\n        cltstream::pc(10);\n    }\n}\n\nint main(){\n    cltstream::read(n);\n    cltstream::read(m);\n    for(re int i=1;i<=n;++i)\n        cltstream::read(a[i]);\n    for(;(size+1)*(size+1)<=n;++size);\n    for(re int i=1;(i-1)*size+1<=n;++i){\n        init(i);\n        for(re int j=(i-1)*size+1;j<=i*size&&j<=n;++j)\n            id[j]=i;\n    }\n    for(re int i=1;i<=m;++i){\n        int opt,l,r,x;\n        cltstream::read(opt);\n        cltstream::read(l);\n        cltstream::read(r);\n        switch(opt){\n            case 1:\n                cltstream::read(x);\n                IntervalCut(l,r,x);\n                break;\n            case 2:\n                IntervalAssignToMin(l,r);\n                break;\n            case 3:\n                cltstream::read(x);\n                IntervalPre(l,r,x);\n                break;\n        }\n    }\n    for(re int i=1;i<=n;++i)\n        (a[0]+=sam[id[i]]?sam[id[i]]:val[find(i)]+tag[id[i]])%=mod;\n    cltstream::write(a[0],'\\n');\n    cltstream::pc(-1);\n    return 0;\n}\n```\n\n{% endfold %}\n\n### [「T53987」ZJF日记](https://www.luogu.org/problemnew/show/T53987)\n\n最短路计数+次短路求解。\n\n其实这才应该是签到题啊，然而当初却被排到了T3。不是很懂（\n\n不过话说回来其实题面写的很好啊。\n\nsto __多弗桃__ orz\n\n#### 关于SPFA\n\n他死了。\n\n### [「T56269」选择性失忆](https://www.luogu.org/problemnew/show/T56269)\n\nsto __SnoWY__ orz\n\n才刚学了几个月就出这种神仙题，把我这种从初中就开始学OI的菜鸡吊起来打（\n\n首先我们看到要最小化第$k+1$大的边权。二分？那么问题就转化成了找一条路径，使得其中恰有$k$条边的边权小于某个给定数值。\n\nemmmmmm……这是什么鬼（\n\n总之二分大概不大可行。然后我觉得我扯不下去了，直接讲正解吧（\n\n构造一张$k+1$层的分层图。如果说我们在某一层有一条边从$u$到$v$，边权是$w$，我们就从这一层的$u$，向下一层的$v$连一条$0$权边。然后从最上层的$1$开始跑最短路，路径长度定义为边权最大值，跑到最下层的$n$。然后`dis[最下层的n]`就是答案。\n\n那么为什么这样做可行？假设说我们现在跑出了最上层的$n$的`dis`。现在我们将$n$下压一层，我们肯定会在之前边权最大的那一条边处跨越至下层。这样这条边的边权减为$0$，相当于是说被过滤掉了。不难想象出，如果我们下压$k$层到最底层，边权前$k$大的边就都被过滤掉了，这时路径上的边权最大值就是一开始的$k+1$大。\n\n相信各位应该都会了，我就不贴代码了。\n\n然后还是要%SnoWY。\n\n[](https://i.loli.net/2018/12/26/5c237e1c077b4.jpg)\n\n### [「T62117」复习](https://www.luogu.org/problemnew/show/T62117)\n\n这是一道被线段树踩爆了的分块题。\n\n每个块内维护总和、正数数量和绝对值最小的负数的绝对值。\n\n每次加的时候，散块还是暴力重构，整块就判断一下绝对值最小的负数加完会不会变号，会就重构。\n\n因为保证$k$非负，每个数最多变号一次，也就是说最多重构$n$次，时间复杂度$O(n\\sqrt{n})$。\n\n代码太丢人了不贴了。\n\n### [「T64137」「魔板」线段树 2](https://www.luogu.org/problemnew/show/T64137)\n\n这是一道~~丧心病狂的~~卡时空块状分块题。\n\n关于块状分块请看[这里](/block-decomposition/)。\n\n反正也没啥可说的，就是写起来麻烦，我就简单讲一下这题背后的故事吧。\n\n首先一开始我们定的时空限制是$1\\text{s}/4\\text{MB}$。然而还是放跑了空间复杂度足够优秀的线段树。然后一气之下删了`fread`，把空间限制改到$2\\text{MB}$，并把时间限制改到$850\\text{ms}$。然后有神仙通过将线段树的多个叶子结点合并起来的方法又水过去了。最后空间直接卡到了现在的$1.5\\text{MB}$。然后最后两个点询问加到$2\\times 10^{6}$，并塞入大量单点操作，才算把该卡的都卡掉了。\n\n顺便第一次写计分脚本祭。\n\n### [「T65749」斩整「土偶剪定」](https://www.luogu.org/problemnew/show/T65749)\n\n首先高维这种东西我们肯定不能硬想。\n\n首先假设$a_{i}\\gt 1$。如果说一个小土块恰有$k$面有颜色，这也就意味着，它恰有$k$个维度的坐标是$1$或$a_{i}$，剩下$n-k$个维度除了$1$和$a_{i}$以外随便选。那么我们的总方案数就是\n\n$$2^{k}\\sum_{\\mid S\\mid=n-k\\wedge\\forall i\\in S,i\\in[1,n]\\cap\\mathbb{Z}}\\prod_{i\\in S}(a_{i}-2)$$\n\n下文为了方便，我们定义$Q_{k}$为\n\n$$\\sum_{\\mid S\\mid=k\\wedge\\forall i\\in S,i\\in[1,n]\\cap\\mathbb{Z}}\\prod_{i\\in S}(a_{i}-2)$$\n\n也就是从所有的$a_{i}-2$中选$k$个相乘的所有方案的结果的总和。同时$Q_{0}=1$。\n\n没错就是[这道题](https://www.luogu.org/problemnew/show/P4247)。\n\n现在我们想要对于$[0,n]$内的每一个$i$求出$Q_{i}$。在上面那道题中我们采用的办法是分治。具体来说就是，如果说我们要在$[l,r]$内选$k$个数相乘，我们可以先在$[l,mid]$内选$x$个数相乘，再在$[mid+1,r]$内选$k-x$个数相乘，然后把结果相乘并累加。\n\n形式化地讲的话\n\n$$Q_{k}=\\sum_{i=0}^{k}Q_{l,i}Q_{r,k-i}$$\n\n然后我们直接$O(n^{2})$暴力算就好。但是我们发现如果说我们直接分治，我们会得到这么一个关于时间复杂度的递推式\n\n$$T(n)=2T(\\cfrac{n}{2})+O(n^{2})$$\n\n根据主定理，我们有$T(n)=O(n^{2})$。\n\n其实我一开始以为它是$O(n^{2}\\log n)$的，仔细一算才发现不对（\n\n不过我的标算并不是这么写的。我的做法是从头扫到尾，将前$k$个与第$k+1$个合并。这样的时间复杂度是\n\n$$T(n)=T(n-1)+O(n)$$\n\n很明显也是$O(n^{2})$的。不过好像常数相对较大？\n\n~~然而对比了一下发现常数小了不少（~~\n\n那么问题来了，如果说存在$a_{i}=1$怎么办？\n\n存在$a_{i}=1$就说明，这一维的坐标一定会同时碰到两个边界。那么我们就可以扔掉这个$1$，把它当成$n-1$维处理，然后在最左边添上两个$0$就行了。\n\n同理，如果存在$m$个$a_{i}=1$，我们就扔掉它们并当成$n-m$维处理，然后在最左边添上$2m$个$0$。\n\n其实这道题还可以优化。仔细观察这个式子\n\n$$Q_{k}=\\sum_{i=0}^{k}Q_{l,i}Q_{r,k-i}$$\n\n我们看到这其实就是一个卷积，我们套一波FFT/NTT就能把时间复杂度优化到\n\n$$T(n)=2T(\\cfrac{n}{2})+O(n\\log n)$$\n\n根据主定理，我们有$T(n)=O(n\\log^{2}n)$。一写发现跑得飞快。\n\n当然这是仅限于分治做法的，像我标算这种做法上了FFT/NTT也优化不了（\n\n![](/images/TIM截图20190116111347.png)\n\n上面这三个评测记录，最下面的是真正的标算，中间的是分治，上面的是NTT优化分治。\n\n#### 论如何用最简短的语言描述主定理\n\n$$T(n)=aT(\\cfrac{n}{b})+O(n^{c}\\log^{k}n)$$\n\n$$T(n)=\\begin{cases}\n&O(n^{c})\\;\\;&(c>\\log_{b}a\\wedge k=0)\\\\\n&O(n^{\\log_{b}a})&(c<\\log_{b}a\\wedge k=0)\\\\\n&O(n^{c}\\log^{k+1}n)&(c=\\log_{b}a)\n\\end{cases}$$\n","slug":"timuzu-solutions","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwf003v34cwh7e72jwt","content":"<script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script>\n<div id=\"hbe-security\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" class=\"hbe-form-control\" id=\"pass\" placeholder=\"输入密码继续阅读\" />\n    <label for=\"pass\">输入密码继续阅读</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n</div>\n<div id=\"decryptionError\" style=\"display: none;\">Incorrect Password!</div>\n<div id=\"noContentError\" style=\"display: none;\">No content to display!</div>\n<div id=\"encrypt-blog\" style=\"display:none\">\n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\n</div>\n<script src=\"/lib/crypto-js.js\"></script><script src=\"/lib/blog-encrypt.js\"></script><link href=\"/css/blog-encrypt.css\" rel=\"stylesheet\" type=\"text/css\">","site":{"data":{}},"excerpt":"该文章已被加密","more":"该文章已被加密","origin":"<p>先宣传一波<a href=\"https://www.luogu.org/team/show?teamid=11367\" target=\"_blank\" rel=\"noopener\">团队</a>。</p>\n<a id=\"more\"></a>\n<h3 id=\"「T47720」孤立元\"><a href=\"#「T47720」孤立元\" class=\"headerlink\" title=\"「T47720」孤立元\"></a><a href=\"https://www.luogu.org/problemnew/show/T47720\" target=\"_blank\" rel=\"noopener\">「T47720」孤立元</a></h3><p><a href=\"/luogu-t47720-solution/\">已有题解</a>。</p>\n<h3 id=\"「T53537」营救元首\"><a href=\"#「T53537」营救元首\" class=\"headerlink\" title=\"「T53537」营救元首\"></a><a href=\"https://www.luogu.org/problemnew/show/T53537\" target=\"_blank\" rel=\"noopener\">「T53537」营救元首</a></h3><p>能看出<a href=\"https://www.luogu.org/problemnew/show/P4117\" target=\"_blank\" rel=\"noopener\">五彩斑斓的世界</a>来吗？</p>\n<p>没错就是JF切了这道题以后<del>根号上脑</del>搞了这么一个东西。</p>\n<p>不过这道题相对之下有点麻烦的，因为你需要维护两个tag，一个处理减，一个处理推平。而且求前驱的时候不能值域分块，然后就只能套<code>set</code>。</p>\n<p>详细点说的话，就是每个块维护最大值和最小值。操作$1$可以选择枚举所有大于$k$的数，然后减去$k$；也可以枚举所有小于等于$k$的数，加上$k$之后整个块打上一个减$k$的标记，标记这个块内的所有数都被减去了$k$。哪个运算量少就选哪个。</p>\n<p>操作$2$就先查询最小值<del>（这个都会吧）</del>，然后散块直接改，整块打个标记就好，标记这个块内的所有数都被改成了另一个数。</p>\n<p>操作$3$就不必多说了，散块暴力找，整块<code>lower_bound</code>。</p>\n<p>不过说实话，写起来挺麻烦的。也懒得看以前我写的代码了，直接贴出来吧。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�24-->\n\n</div></div>\n<h3 id=\"「T53987」ZJF日记\"><a href=\"#「T53987」ZJF日记\" class=\"headerlink\" title=\"「T53987」ZJF日记\"></a><a href=\"https://www.luogu.org/problemnew/show/T53987\" target=\"_blank\" rel=\"noopener\">「T53987」ZJF日记</a></h3><p>最短路计数+次短路求解。</p>\n<p>其实这才应该是签到题啊，然而当初却被排到了T3。不是很懂（</p>\n<p>不过话说回来其实题面写的很好啊。</p>\n<p>sto <strong>多弗桃</strong> orz</p>\n<h4 id=\"关于SPFA\"><a href=\"#关于SPFA\" class=\"headerlink\" title=\"关于SPFA\"></a>关于SPFA</h4><p>他死了。</p>\n<h3 id=\"「T56269」选择性失忆\"><a href=\"#「T56269」选择性失忆\" class=\"headerlink\" title=\"「T56269」选择性失忆\"></a><a href=\"https://www.luogu.org/problemnew/show/T56269\" target=\"_blank\" rel=\"noopener\">「T56269」选择性失忆</a></h3><p>sto <strong>SnoWY</strong> orz</p>\n<p>才刚学了几个月就出这种神仙题，把我这种从初中就开始学OI的菜鸡吊起来打（</p>\n<p>首先我们看到要最小化第$k+1$大的边权。二分？那么问题就转化成了找一条路径，使得其中恰有$k$条边的边权小于某个给定数值。</p>\n<p>emmmmmm……这是什么鬼（</p>\n<p>总之二分大概不大可行。然后我觉得我扯不下去了，直接讲正解吧（</p>\n<p>构造一张$k+1$层的分层图。如果说我们在某一层有一条边从$u$到$v$，边权是$w$，我们就从这一层的$u$，向下一层的$v$连一条$0$权边。然后从最上层的$1$开始跑最短路，路径长度定义为边权最大值，跑到最下层的$n$。然后<code>dis[最下层的n]</code>就是答案。</p>\n<p>那么为什么这样做可行？假设说我们现在跑出了最上层的$n$的<code>dis</code>。现在我们将$n$下压一层，我们肯定会在之前边权最大的那一条边处跨越至下层。这样这条边的边权减为$0$，相当于是说被过滤掉了。不难想象出，如果我们下压$k$层到最底层，边权前$k$大的边就都被过滤掉了，这时路径上的边权最大值就是一开始的$k+1$大。</p>\n<p>相信各位应该都会了，我就不贴代码了。</p>\n<p>然后还是要%SnoWY。</p>\n<p><a href=\"https://i.loli.net/2018/12/26/5c237e1c077b4.jpg\" target=\"_blank\" rel=\"noopener\"></a></p>\n<h3 id=\"「T62117」复习\"><a href=\"#「T62117」复习\" class=\"headerlink\" title=\"「T62117」复习\"></a><a href=\"https://www.luogu.org/problemnew/show/T62117\" target=\"_blank\" rel=\"noopener\">「T62117」复习</a></h3><p>这是一道被线段树踩爆了的分块题。</p>\n<p>每个块内维护总和、正数数量和绝对值最小的负数的绝对值。</p>\n<p>每次加的时候，散块还是暴力重构，整块就判断一下绝对值最小的负数加完会不会变号，会就重构。</p>\n<p>因为保证$k$非负，每个数最多变号一次，也就是说最多重构$n$次，时间复杂度$O(n\\sqrt{n})$。</p>\n<p>代码太丢人了不贴了。</p>\n<h3 id=\"「T64137」「魔板」线段树-2\"><a href=\"#「T64137」「魔板」线段树-2\" class=\"headerlink\" title=\"「T64137」「魔板」线段树 2\"></a><a href=\"https://www.luogu.org/problemnew/show/T64137\" target=\"_blank\" rel=\"noopener\">「T64137」「魔板」线段树 2</a></h3><p>这是一道<del>丧心病狂的</del>卡时空块状分块题。</p>\n<p>关于块状分块请看<a href=\"/block-decomposition/\">这里</a>。</p>\n<p>反正也没啥可说的，就是写起来麻烦，我就简单讲一下这题背后的故事吧。</p>\n<p>首先一开始我们定的时空限制是$1\\text{s}/4\\text{MB}$。然而还是放跑了空间复杂度足够优秀的线段树。然后一气之下删了<code>fread</code>，把空间限制改到$2\\text{MB}$，并把时间限制改到$850\\text{ms}$。然后有神仙通过将线段树的多个叶子结点合并起来的方法又水过去了。最后空间直接卡到了现在的$1.5\\text{MB}$。然后最后两个点询问加到$2\\times 10^{6}$，并塞入大量单点操作，才算把该卡的都卡掉了。</p>\n<p>顺便第一次写计分脚本祭。</p>\n<h3 id=\"「T65749」斩整「土偶剪定」\"><a href=\"#「T65749」斩整「土偶剪定」\" class=\"headerlink\" title=\"「T65749」斩整「土偶剪定」\"></a><a href=\"https://www.luogu.org/problemnew/show/T65749\" target=\"_blank\" rel=\"noopener\">「T65749」斩整「土偶剪定」</a></h3><p>首先高维这种东西我们肯定不能硬想。</p>\n<p>首先假设$a_{i}\\gt 1$。如果说一个小土块恰有$k$面有颜色，这也就意味着，它恰有$k$个维度的坐标是$1$或$a_{i}$，剩下$n-k$个维度除了$1$和$a_{i}$以外随便选。那么我们的总方案数就是</p>\n<script type=\"math/tex; mode=display\">2^{k}\\sum_{\\mid S\\mid=n-k\\wedge\\forall i\\in S,i\\in[1,n]\\cap\\mathbb{Z}}\\prod_{i\\in S}(a_{i}-2)</script><p>下文为了方便，我们定义$Q_{k}$为</p>\n<script type=\"math/tex; mode=display\">\\sum_{\\mid S\\mid=k\\wedge\\forall i\\in S,i\\in[1,n]\\cap\\mathbb{Z}}\\prod_{i\\in S}(a_{i}-2)</script><p>也就是从所有的$a_{i}-2$中选$k$个相乘的所有方案的结果的总和。同时$Q_{0}=1$。</p>\n<p>没错就是<a href=\"https://www.luogu.org/problemnew/show/P4247\" target=\"_blank\" rel=\"noopener\">这道题</a>。</p>\n<p>现在我们想要对于$[0,n]$内的每一个$i$求出$Q_{i}$。在上面那道题中我们采用的办法是分治。具体来说就是，如果说我们要在$[l,r]$内选$k$个数相乘，我们可以先在$[l,mid]$内选$x$个数相乘，再在$[mid+1,r]$内选$k-x$个数相乘，然后把结果相乘并累加。</p>\n<p>形式化地讲的话</p>\n<script type=\"math/tex; mode=display\">Q_{k}=\\sum_{i=0}^{k}Q_{l,i}Q_{r,k-i}</script><p>然后我们直接$O(n^{2})$暴力算就好。但是我们发现如果说我们直接分治，我们会得到这么一个关于时间复杂度的递推式</p>\n<script type=\"math/tex; mode=display\">T(n)=2T(\\cfrac{n}{2})+O(n^{2})</script><p>根据主定理，我们有$T(n)=O(n^{2})$。</p>\n<p>其实我一开始以为它是$O(n^{2}\\log n)$的，仔细一算才发现不对（</p>\n<p>不过我的标算并不是这么写的。我的做法是从头扫到尾，将前$k$个与第$k+1$个合并。这样的时间复杂度是</p>\n<script type=\"math/tex; mode=display\">T(n)=T(n-1)+O(n)</script><p>很明显也是$O(n^{2})$的。不过好像常数相对较大？</p>\n<p><del>然而对比了一下发现常数小了不少（</del></p>\n<p>那么问题来了，如果说存在$a_{i}=1$怎么办？</p>\n<p>存在$a_{i}=1$就说明，这一维的坐标一定会同时碰到两个边界。那么我们就可以扔掉这个$1$，把它当成$n-1$维处理，然后在最左边添上两个$0$就行了。</p>\n<p>同理，如果存在$m$个$a_{i}=1$，我们就扔掉它们并当成$n-m$维处理，然后在最左边添上$2m$个$0$。</p>\n<p>其实这道题还可以优化。仔细观察这个式子</p>\n<script type=\"math/tex; mode=display\">Q_{k}=\\sum_{i=0}^{k}Q_{l,i}Q_{r,k-i}</script><p>我们看到这其实就是一个卷积，我们套一波FFT/NTT就能把时间复杂度优化到</p>\n<script type=\"math/tex; mode=display\">T(n)=2T(\\cfrac{n}{2})+O(n\\log n)</script><p>根据主定理，我们有$T(n)=O(n\\log^{2}n)$。一写发现跑得飞快。</p>\n<p>当然这是仅限于分治做法的，像我标算这种做法上了FFT/NTT也优化不了（</p>\n<p><img src=\"/images/TIM截图20190116111347.png\" alt=\"\"></p>\n<p>上面这三个评测记录，最下面的是真正的标算，中间的是分治，上面的是NTT优化分治。</p>\n<h4 id=\"论如何用最简短的语言描述主定理\"><a href=\"#论如何用最简短的语言描述主定理\" class=\"headerlink\" title=\"论如何用最简短的语言描述主定理\"></a>论如何用最简短的语言描述主定理</h4><script type=\"math/tex; mode=display\">T(n)=aT(\\cfrac{n}{b})+O(n^{c}\\log^{k}n)</script><script type=\"math/tex; mode=display\">T(n)=\\begin{cases}\n&O(n^{c})\\;\\;&(c>\\log_{b}a\\wedge k=0)\\\\\n&O(n^{\\log_{b}a})&(c<\\log_{b}a\\wedge k=0)\\\\\n&O(n^{c}\\log^{k+1}n)&(c=\\log_{b}a)\n\\end{cases}</script>","encrypt":true,"template":"<script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script>\n<div id=\"hbe-security\">\n  <div class=\"hbe-input-container\">\n  <input type=\"password\" class=\"hbe-form-control\" id=\"pass\" placeholder=\"输入密码继续阅读\" />\n    <label for=\"pass\">输入密码继续阅读</label>\n    <div class=\"bottom-line\"></div>\n  </div>\n</div>\n<div id=\"decryptionError\" style=\"display: none;\">Incorrect Password!</div>\n<div id=\"noContentError\" style=\"display: none;\">No content to display!</div>\n<div id=\"encrypt-blog\" style=\"display:none\">\n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\n</div>\n","decryptionError":"Incorrect Password!","noContentError":"No content to display!"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-21T02:57:11.000Z","title":"动态树学习笔记","password":null,"_content":"24号要出去学习，趁现在先自己xjb学点啥。\n\n<!-- more -->\n\n### 基本概念\n\n首先我们有一道[模板题](https://www.luogu.org/problemnew/show/P3690)。\n\n我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。\n\n这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\\log^{2}n)$。\n\n但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。\n\n很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。\n\n实链剖分一般被称为LCT，全称~~Link-Cat Tree~~ ~~Linear Challestend Transformation~~ Link-Cut Tree，也就是动态树。\n\n与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。\n\n为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：\n\n1. 每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。\n2. 每个节点属于且仅属于一棵Splay。\n3. 如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。\n4. 不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。\n\n以下图片来自https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。\n\n我们来看这样一棵树\n\n![](/images/1309909-20180123095924037-1618037447.png)\n\n其中粗线表示实边，虚线表示虚边。\n\n它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。\n\n![](/images/1309909-20180123095955350-1680422636.png)\n\n当然这并不是唯一的。\n\n为了方便，我先放出我Splay的代码实现\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nstruct SplayNode{\n\tSplayNode *ftr,*ls,*rs;\n\tint val,sum,rev;\n\n\tinline int isRoot(){\n\t\treturn ftr==NULL||(ftr->ls!=this&&ftr->rs!=this);\n\t\t//判断一个节点是否是原森林中的一棵树的树根\n\t}\n\n\tinline void reverse(){\n\t\tstd::swap(ls,rs);\n\t\trev^=1;\n\t}\n\n\tinline void pushDown(){\n\t\tif(rev){\n\t\t\tif(ls!=NULL)\n\t\t\t\tls->reverse();\n\t\t\tif(rs!=NULL)\n\t\t\t\trs->reverse();\n\t\t\trev=0;\n\t\t}\n\t}\n\n\tinline void pushUp(){\n\t\tsum=val;\n\t\tif(ls!=NULL)\n\t\t\tsum^=ls->sum;\n\t\tif(rs!=NULL)\n\t\t\tsum^=rs->sum;\n\t}\n};\n\nSplayNode mempool[maxn+1];\n\ninline void rotate(re SplayNode* p){\n\tre SplayNode* q=p->ftr;\n\tq->pushDown();\n\tp->pushDown();\n\tp->ftr=q->ftr;\n\tif(p->ftr!=NULL){\n\t\tif(p->ftr->ls==q)\n\t\t\tp->ftr->ls=p;\n\t\tif(p->ftr->rs==q)\n\t\t\tp->ftr->rs=p;\n\t}\n\tif(q->rs==p){\n\t\tq->rs=p->ls;\n\t\tif(q->rs!=NULL)\n\t\t\tq->rs->ftr=q;\n\t\tp->ls=q;\n\t\tq->ftr=p;\n\t}\n\telse{\n\t\tq->ls=p->rs;\n\t\tif(q->ls!=NULL)\n\t\t\tq->ls->ftr=q;\n\t\tp->rs=q;\n\t\tq->ftr=p;\n\t}\n\tq->pushUp();\n\tp->pushUp();\n}\n\ninline void splay(re SplayNode* p){\n//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可\n\tfor(;!p->isRoot();rotate(p))\n\t\tif(!p->ftr->isRoot())\n\t\t\trotate((p->ftr->ftr->ls==p->ftr)==(p->ftr->ls==p)?p->ftr:p);\n}\n```\n\n{% endfold %}\n\n### access\n\n首先我们有一个基本操作\n\n```cpp\nvoid access(SplayNode*)\n```\n\n首先有一个问题是，这个单词怎么读？\n\n`/ək'ses/`？不不不应该是`/'ækses/`。\n\n如果您有兴趣，可以在[这里](https://github.com/shimohq/chinese-programmer-wrong-pronunciation)看看自己以前都读错了多少单词（\n\n这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。\n\n我们来看看这个函数的具体过程。还是上面的例子，现在我们调用`access(N)`，整棵树会变成这样\n\n![](/images/1309909-20180123101901740-2118178734.png)\n\n~~虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（~~\n\n首先我们调用`splay(N)`，令$\\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。\n\n![](/images/1309909-20180123110136115-1112016464.png)\n\n向上找到$\\text{N}$的父亲$\\text{I}$，调用`splay(I)`，回收$\\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\\text{N}$，然后$\\text{N}$就成了$\\text{I}$的实儿子了。\n\n![](/images/1309909-20180123110156272-1242463729.png)\n\n然后继续向上，找到$\\text{I}$的父亲$\\text{H}$，调用`splay(H)`，并令$\\text{H}$的右儿子指针指向$\\text{I}$。\n\n![](/images/1309909-20180123110209772-2057141058.png)\n\n最后一步，找到$\\text{H}$的父亲$\\text{A}$，调用`splay(A)`，并令$\\text{A}$的右儿子指针指向$\\text{H}$。\n\n![](/images/1309909-20180123110213709-49169640.png)\n\n然后我们看到，$\\text{N}$和$\\text{A}$到了同一颗Splay中，完成任务，返回。\n\n代码实现：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void access(re SplayNode* p){\n\tsplay(p);\n\tp->pushDown();\n\tp->rs=NULL;\n\tp->pushUp();\n\tfor(re SplayNode* q=p;q->ftr!=NULL;q=q->ftr){\n\t\tsplay(q->ftr);\n\t\tq->ftr->pushDown();\n\t\tq->ftr->rs=q;\n\t\tq->ftr->pushUp();\n\t}\n\tsplay(p);\n\t//据说闲着没事瞎转转有利于摊开时间复杂度（\n}\n```\n\n{% endfold %}\n\n### findRoot\n\n有了`access`，我们就可以随心所欲的瞎搞了。比如说\n\n```cpp\nSplayNode* findRoot(SplayNode*)\n```\n\n返回给定节点所在的树的树根，也就是调用完`access`后它所在的实链上深度最小的节点。\n\n因为`access`的最后自带了一个`splay`，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline SplayNode* findRoot(re SplayNode* p){\n\taccess(p);\n\tfor(;p->ls!=NULL;p=p->ls);\n\tsplay(p);\n\treturn p;\n}\n```\n\n{% endfold %}\n\n### makeRoot && split\n\n现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。\n\n不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用`access(x)`，然后考虑翻转$x$的子树之后会发生什么。\n\n`access`结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。\n\n那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次`access(y)`就可以把它抽出来。\n\n我们实现下面两个函数\n\n```cpp\nvoid makeRoot(SplayNode*)\n```\n\n令给定节点成为树根。\n\n```cpp\nvoid split(SplayNode*,SplayNode*)\n```\n\n抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void makeRoot(re SplayNode* p){\n\taccess(p);\n\tp->reverse();\n}\n\ninline void split(re SplayNode* p,re SplayNode* q){\n\tmakeRoot(p);\n\taccess(q);\n}\n```\n\n{% endfold %}\n\n### link\n\n我们需要实现函数\n\n```cpp\nvoid link(SplayNode*,SplayNode*)\n```\n\n在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。\n\n思路很简单。假设我们指定$x$和$y$两个节点，首先调用`makeRoot(x)`，然后检查`findRoot(y)`的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即`findRoot(y)==x`，说明两个节点联通，直接返回。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void link(re SplayNode* p,re SplayNode* q){\n\tmakeRoot(p);\n\tif(findRoot(q)!=p)\n\t\tp->ftr=q;\n}\n```\n\n{% endfold %}\n\n### cut\n\n我们需要实现函数\n\n```cpp\nvoid cut(SplayNode*,SplayNode*)\n```\n\n切断给定的两个节点之间的边。不存在就什么也不做。\n\n需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用`makeRoot(x)`，此时$y$应该是$x$的右儿子，并且它不能有左儿子。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void cut(re SplayNode* p,re SplayNode* q){\n\tmakeRoot(p);\n\tif(findRoot(q)==p&&q->ftr==p&&q->ls==NULL){\n\t\tq->ftr=p->rs=NULL;\n\t\tp->pushUp();\n\t}\n}\n```\n\n{% endfold %}\n\n把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。\n\n完整板子：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define re register\n#define maxn 300000\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n\n\ttemplate <typename _tp>\n\tinline void swap(_tp& x,_tp& y){\n\t\t_tp z=x;\n\t\tx=y;\n\t\ty=z;\n\t}\n}\n\nstruct LinkCutTree{\n\tstruct SplayNode{\n\t\tSplayNode *ftr,*ls,*rs;\n\t\tint val,sum,rev;\n\n\t\tinline int isRoot(){\n\t\t\treturn ftr==NULL||(ftr->ls!=this&&ftr->rs!=this);\n\t\t}\n\n\t\tinline void reverse(){\n\t\t\tstd::swap(ls,rs);\n\t\t\trev^=1;\n\t\t}\n\n\t\tinline void pushDown(){\n\t\t\tif(rev){\n\t\t\t\tif(ls!=NULL)\n\t\t\t\t\tls->reverse();\n\t\t\t\tif(rs!=NULL)\n\t\t\t\t\trs->reverse();\n\t\t\t\trev=0;\n\t\t\t}\n\t\t}\n\n\t\tinline void pushUp(){\n\t\t\tsum=val;\n\t\t\tif(ls!=NULL)\n\t\t\t\tsum^=ls->sum;\n\t\t\tif(rs!=NULL)\n\t\t\t\tsum^=rs->sum;\n\t\t}\n\t};\n\n\tSplayNode mempool[maxn+1];\n\n\tinline void rotate(re SplayNode* p){\n\t\tre SplayNode* q=p->ftr;\n\t\tq->pushDown();\n\t\tp->pushDown();\n\t\tp->ftr=q->ftr;\n\t\tif(p->ftr!=NULL){\n\t\t\tif(p->ftr->ls==q)\n\t\t\t\tp->ftr->ls=p;\n\t\t\tif(p->ftr->rs==q)\n\t\t\t\tp->ftr->rs=p;\n\t\t}\n\t\tif(q->rs==p){\n\t\t\tq->rs=p->ls;\n\t\t\tif(q->rs!=NULL)\n\t\t\t\tq->rs->ftr=q;\n\t\t\tp->ls=q;\n\t\t\tq->ftr=p;\n\t\t}\n\t\telse{\n\t\t\tq->ls=p->rs;\n\t\t\tif(q->ls!=NULL)\n\t\t\t\tq->ls->ftr=q;\n\t\t\tp->rs=q;\n\t\t\tq->ftr=p;\n\t\t}\n\t\tq->pushUp();\n\t\tp->pushUp();\n\t}\n\n\tinline void splay(re SplayNode* p){\n\t\tfor(;!p->isRoot();rotate(p))\n\t\t\tif(!p->ftr->isRoot())\n\t\t\t\trotate((p->ftr->ftr->ls==p->ftr)==(p->ftr->ls==p)?p->ftr:p);\n\t}\n\n\tinline void build(re int n){\n\t\tfor(re int i=1;i<=n;++i){\n\t\t\tre SplayNode* p=mempool+i;\n\t\t\tp->ftr=p->ls=p->rs=NULL;\n\t\t\tcltstream::read(p->val);\n\t\t\tp->sum=p->val;\n\t\t\tp->rev=0;\n\t\t}\n\t}\n\n\tinline void access(re SplayNode* p){\n\t\tsplay(p);\n\t\tp->pushDown();\n\t\tp->rs=NULL;\n\t\tp->pushUp();\n\t\tfor(re SplayNode* q=p;q->ftr!=NULL;q=q->ftr){\n\t\t\tsplay(q->ftr);\n\t\t\tq->ftr->pushDown();\n\t\t\tq->ftr->rs=q;\n\t\t\tq->ftr->pushUp();\n\t\t}\n\t\tsplay(p);\n\t}\n\n\tinline SplayNode* findRoot(re SplayNode* p){\n\t\taccess(p);\n\t\tfor(;p->ls!=NULL;p=p->ls);\n\t\tsplay(p);\n\t\treturn p;\n\t}\n\n\tinline void makeRoot(re SplayNode* p){\n\t\taccess(p);\n\t\tp->reverse();\n\t}\n\n\tinline void split(re SplayNode* p,re SplayNode* q){\n\t\tmakeRoot(p);\n\t\taccess(q);\n\t}\n\n\tinline void link(re SplayNode* p,re SplayNode* q){\n\t\tmakeRoot(p);\n\t\tif(findRoot(q)!=p)\n\t\t\tp->ftr=q;\n\t}\n\n\tinline void cut(re SplayNode* p,re SplayNode* q){\n\t\tmakeRoot(p);\n\t\tif(findRoot(q)==p&&q->ftr==p&&q->ls==NULL){\n\t\t\tq->ftr=p->rs=NULL;\n\t\t\tp->pushUp();\n\t\t}\n\t}\n\n\tinline int queryPathXorSum(re int x,re int y){\n\t\tsplit(mempool+x,mempool+y);\n\t\treturn (mempool+y)->sum;\n\t}\n\n\tinline void createEdge(re int x,re int y){\n\t\tlink(mempool+x,mempool+y);\n\t}\n\n\tinline void destoryEdge(re int x,re int y){\n\t\tcut(mempool+x,mempool+y);\n\t}\n\n\tinline void modifyVertice(re int x,re int y){\n\t\tsplay(mempool+x);\n\t\t(mempool+x)->val=y;\n\t\t(mempool+x)->pushUp();\n\t}\n\n\tvoid printTree(re SplayNode* p){\n\t\tif(p!=NULL){\n\t\t\tp->pushDown();\n\t\t\tprintTree(p->ls);\n\t\t\tprintf(\n\t\t\t\t\"%d(%d,%d,%d)\\n\",\n\t\t\t\tp-mempool,\n\t\t\t\tp->ftr!=NULL?p->ftr-mempool:-1,\n\t\t\t\tp->ls!=NULL?p->ls-mempool:-1,\n\t\t\t\tp->rs!=NULL?p->rs-mempool:-1\n\t\t\t);\n\t\t\tprintTree(p->rs);\n\t\t}\n\t}\n};\n\nint n,m;\nLinkCutTree QAQ;\n\nint main(){\\\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tQAQ.build(n);\n\tfor(re int i=1;i<=m;++i){\n\t\tint opt,x,y;\n\t\tcltstream::read(opt);\n\t\tcltstream::read(x);\n\t\tcltstream::read(y);\n\t\tswitch(opt){\n\t\t\tcase 0:\n\t\t\t\tcltstream::write(QAQ.queryPathXorSum(x,y),10);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tQAQ.createEdge(x,y);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tQAQ.destoryEdge(x,y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tQAQ.modifyVertice(x,y);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n~~是不是感觉很好写呢（~~\n\n### 用LCT维护子树信息\n\n咕咕咕。\n","source":"_posts/2019-01-21-link-cut-tree-learning-notes.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-21 10:57:11\ntitle: 动态树学习笔记\ntags:\n  - Splay\n  - LCT\ncategories:\n  - 学习笔记\npassword:\n---\n24号要出去学习，趁现在先自己xjb学点啥。\n\n<!-- more -->\n\n### 基本概念\n\n首先我们有一道[模板题](https://www.luogu.org/problemnew/show/P3690)。\n\n我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。\n\n这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\\log^{2}n)$。\n\n但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。\n\n很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。\n\n实链剖分一般被称为LCT，全称~~Link-Cat Tree~~ ~~Linear Challestend Transformation~~ Link-Cut Tree，也就是动态树。\n\n与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。\n\n为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：\n\n1. 每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。\n2. 每个节点属于且仅属于一棵Splay。\n3. 如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。\n4. 不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。\n\n以下图片来自https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。\n\n我们来看这样一棵树\n\n![](/images/1309909-20180123095924037-1618037447.png)\n\n其中粗线表示实边，虚线表示虚边。\n\n它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。\n\n![](/images/1309909-20180123095955350-1680422636.png)\n\n当然这并不是唯一的。\n\n为了方便，我先放出我Splay的代码实现\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nstruct SplayNode{\n\tSplayNode *ftr,*ls,*rs;\n\tint val,sum,rev;\n\n\tinline int isRoot(){\n\t\treturn ftr==NULL||(ftr->ls!=this&&ftr->rs!=this);\n\t\t//判断一个节点是否是原森林中的一棵树的树根\n\t}\n\n\tinline void reverse(){\n\t\tstd::swap(ls,rs);\n\t\trev^=1;\n\t}\n\n\tinline void pushDown(){\n\t\tif(rev){\n\t\t\tif(ls!=NULL)\n\t\t\t\tls->reverse();\n\t\t\tif(rs!=NULL)\n\t\t\t\trs->reverse();\n\t\t\trev=0;\n\t\t}\n\t}\n\n\tinline void pushUp(){\n\t\tsum=val;\n\t\tif(ls!=NULL)\n\t\t\tsum^=ls->sum;\n\t\tif(rs!=NULL)\n\t\t\tsum^=rs->sum;\n\t}\n};\n\nSplayNode mempool[maxn+1];\n\ninline void rotate(re SplayNode* p){\n\tre SplayNode* q=p->ftr;\n\tq->pushDown();\n\tp->pushDown();\n\tp->ftr=q->ftr;\n\tif(p->ftr!=NULL){\n\t\tif(p->ftr->ls==q)\n\t\t\tp->ftr->ls=p;\n\t\tif(p->ftr->rs==q)\n\t\t\tp->ftr->rs=p;\n\t}\n\tif(q->rs==p){\n\t\tq->rs=p->ls;\n\t\tif(q->rs!=NULL)\n\t\t\tq->rs->ftr=q;\n\t\tp->ls=q;\n\t\tq->ftr=p;\n\t}\n\telse{\n\t\tq->ls=p->rs;\n\t\tif(q->ls!=NULL)\n\t\t\tq->ls->ftr=q;\n\t\tp->rs=q;\n\t\tq->ftr=p;\n\t}\n\tq->pushUp();\n\tp->pushUp();\n}\n\ninline void splay(re SplayNode* p){\n//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可\n\tfor(;!p->isRoot();rotate(p))\n\t\tif(!p->ftr->isRoot())\n\t\t\trotate((p->ftr->ftr->ls==p->ftr)==(p->ftr->ls==p)?p->ftr:p);\n}\n```\n\n{% endfold %}\n\n### access\n\n首先我们有一个基本操作\n\n```cpp\nvoid access(SplayNode*)\n```\n\n首先有一个问题是，这个单词怎么读？\n\n`/ək'ses/`？不不不应该是`/'ækses/`。\n\n如果您有兴趣，可以在[这里](https://github.com/shimohq/chinese-programmer-wrong-pronunciation)看看自己以前都读错了多少单词（\n\n这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。\n\n我们来看看这个函数的具体过程。还是上面的例子，现在我们调用`access(N)`，整棵树会变成这样\n\n![](/images/1309909-20180123101901740-2118178734.png)\n\n~~虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（~~\n\n首先我们调用`splay(N)`，令$\\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。\n\n![](/images/1309909-20180123110136115-1112016464.png)\n\n向上找到$\\text{N}$的父亲$\\text{I}$，调用`splay(I)`，回收$\\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\\text{N}$，然后$\\text{N}$就成了$\\text{I}$的实儿子了。\n\n![](/images/1309909-20180123110156272-1242463729.png)\n\n然后继续向上，找到$\\text{I}$的父亲$\\text{H}$，调用`splay(H)`，并令$\\text{H}$的右儿子指针指向$\\text{I}$。\n\n![](/images/1309909-20180123110209772-2057141058.png)\n\n最后一步，找到$\\text{H}$的父亲$\\text{A}$，调用`splay(A)`，并令$\\text{A}$的右儿子指针指向$\\text{H}$。\n\n![](/images/1309909-20180123110213709-49169640.png)\n\n然后我们看到，$\\text{N}$和$\\text{A}$到了同一颗Splay中，完成任务，返回。\n\n代码实现：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void access(re SplayNode* p){\n\tsplay(p);\n\tp->pushDown();\n\tp->rs=NULL;\n\tp->pushUp();\n\tfor(re SplayNode* q=p;q->ftr!=NULL;q=q->ftr){\n\t\tsplay(q->ftr);\n\t\tq->ftr->pushDown();\n\t\tq->ftr->rs=q;\n\t\tq->ftr->pushUp();\n\t}\n\tsplay(p);\n\t//据说闲着没事瞎转转有利于摊开时间复杂度（\n}\n```\n\n{% endfold %}\n\n### findRoot\n\n有了`access`，我们就可以随心所欲的瞎搞了。比如说\n\n```cpp\nSplayNode* findRoot(SplayNode*)\n```\n\n返回给定节点所在的树的树根，也就是调用完`access`后它所在的实链上深度最小的节点。\n\n因为`access`的最后自带了一个`splay`，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline SplayNode* findRoot(re SplayNode* p){\n\taccess(p);\n\tfor(;p->ls!=NULL;p=p->ls);\n\tsplay(p);\n\treturn p;\n}\n```\n\n{% endfold %}\n\n### makeRoot && split\n\n现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。\n\n不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用`access(x)`，然后考虑翻转$x$的子树之后会发生什么。\n\n`access`结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。\n\n那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次`access(y)`就可以把它抽出来。\n\n我们实现下面两个函数\n\n```cpp\nvoid makeRoot(SplayNode*)\n```\n\n令给定节点成为树根。\n\n```cpp\nvoid split(SplayNode*,SplayNode*)\n```\n\n抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void makeRoot(re SplayNode* p){\n\taccess(p);\n\tp->reverse();\n}\n\ninline void split(re SplayNode* p,re SplayNode* q){\n\tmakeRoot(p);\n\taccess(q);\n}\n```\n\n{% endfold %}\n\n### link\n\n我们需要实现函数\n\n```cpp\nvoid link(SplayNode*,SplayNode*)\n```\n\n在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。\n\n思路很简单。假设我们指定$x$和$y$两个节点，首先调用`makeRoot(x)`，然后检查`findRoot(y)`的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即`findRoot(y)==x`，说明两个节点联通，直接返回。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void link(re SplayNode* p,re SplayNode* q){\n\tmakeRoot(p);\n\tif(findRoot(q)!=p)\n\t\tp->ftr=q;\n}\n```\n\n{% endfold %}\n\n### cut\n\n我们需要实现函数\n\n```cpp\nvoid cut(SplayNode*,SplayNode*)\n```\n\n切断给定的两个节点之间的边。不存在就什么也不做。\n\n需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用`makeRoot(x)`，此时$y$应该是$x$的右儿子，并且它不能有左儿子。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ninline void cut(re SplayNode* p,re SplayNode* q){\n\tmakeRoot(p);\n\tif(findRoot(q)==p&&q->ftr==p&&q->ls==NULL){\n\t\tq->ftr=p->rs=NULL;\n\t\tp->pushUp();\n\t}\n}\n```\n\n{% endfold %}\n\n把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。\n\n完整板子：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<algorithm>\n#define re register\n#define maxn 300000\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n\n\ttemplate <typename _tp>\n\tinline void swap(_tp& x,_tp& y){\n\t\t_tp z=x;\n\t\tx=y;\n\t\ty=z;\n\t}\n}\n\nstruct LinkCutTree{\n\tstruct SplayNode{\n\t\tSplayNode *ftr,*ls,*rs;\n\t\tint val,sum,rev;\n\n\t\tinline int isRoot(){\n\t\t\treturn ftr==NULL||(ftr->ls!=this&&ftr->rs!=this);\n\t\t}\n\n\t\tinline void reverse(){\n\t\t\tstd::swap(ls,rs);\n\t\t\trev^=1;\n\t\t}\n\n\t\tinline void pushDown(){\n\t\t\tif(rev){\n\t\t\t\tif(ls!=NULL)\n\t\t\t\t\tls->reverse();\n\t\t\t\tif(rs!=NULL)\n\t\t\t\t\trs->reverse();\n\t\t\t\trev=0;\n\t\t\t}\n\t\t}\n\n\t\tinline void pushUp(){\n\t\t\tsum=val;\n\t\t\tif(ls!=NULL)\n\t\t\t\tsum^=ls->sum;\n\t\t\tif(rs!=NULL)\n\t\t\t\tsum^=rs->sum;\n\t\t}\n\t};\n\n\tSplayNode mempool[maxn+1];\n\n\tinline void rotate(re SplayNode* p){\n\t\tre SplayNode* q=p->ftr;\n\t\tq->pushDown();\n\t\tp->pushDown();\n\t\tp->ftr=q->ftr;\n\t\tif(p->ftr!=NULL){\n\t\t\tif(p->ftr->ls==q)\n\t\t\t\tp->ftr->ls=p;\n\t\t\tif(p->ftr->rs==q)\n\t\t\t\tp->ftr->rs=p;\n\t\t}\n\t\tif(q->rs==p){\n\t\t\tq->rs=p->ls;\n\t\t\tif(q->rs!=NULL)\n\t\t\t\tq->rs->ftr=q;\n\t\t\tp->ls=q;\n\t\t\tq->ftr=p;\n\t\t}\n\t\telse{\n\t\t\tq->ls=p->rs;\n\t\t\tif(q->ls!=NULL)\n\t\t\t\tq->ls->ftr=q;\n\t\t\tp->rs=q;\n\t\t\tq->ftr=p;\n\t\t}\n\t\tq->pushUp();\n\t\tp->pushUp();\n\t}\n\n\tinline void splay(re SplayNode* p){\n\t\tfor(;!p->isRoot();rotate(p))\n\t\t\tif(!p->ftr->isRoot())\n\t\t\t\trotate((p->ftr->ftr->ls==p->ftr)==(p->ftr->ls==p)?p->ftr:p);\n\t}\n\n\tinline void build(re int n){\n\t\tfor(re int i=1;i<=n;++i){\n\t\t\tre SplayNode* p=mempool+i;\n\t\t\tp->ftr=p->ls=p->rs=NULL;\n\t\t\tcltstream::read(p->val);\n\t\t\tp->sum=p->val;\n\t\t\tp->rev=0;\n\t\t}\n\t}\n\n\tinline void access(re SplayNode* p){\n\t\tsplay(p);\n\t\tp->pushDown();\n\t\tp->rs=NULL;\n\t\tp->pushUp();\n\t\tfor(re SplayNode* q=p;q->ftr!=NULL;q=q->ftr){\n\t\t\tsplay(q->ftr);\n\t\t\tq->ftr->pushDown();\n\t\t\tq->ftr->rs=q;\n\t\t\tq->ftr->pushUp();\n\t\t}\n\t\tsplay(p);\n\t}\n\n\tinline SplayNode* findRoot(re SplayNode* p){\n\t\taccess(p);\n\t\tfor(;p->ls!=NULL;p=p->ls);\n\t\tsplay(p);\n\t\treturn p;\n\t}\n\n\tinline void makeRoot(re SplayNode* p){\n\t\taccess(p);\n\t\tp->reverse();\n\t}\n\n\tinline void split(re SplayNode* p,re SplayNode* q){\n\t\tmakeRoot(p);\n\t\taccess(q);\n\t}\n\n\tinline void link(re SplayNode* p,re SplayNode* q){\n\t\tmakeRoot(p);\n\t\tif(findRoot(q)!=p)\n\t\t\tp->ftr=q;\n\t}\n\n\tinline void cut(re SplayNode* p,re SplayNode* q){\n\t\tmakeRoot(p);\n\t\tif(findRoot(q)==p&&q->ftr==p&&q->ls==NULL){\n\t\t\tq->ftr=p->rs=NULL;\n\t\t\tp->pushUp();\n\t\t}\n\t}\n\n\tinline int queryPathXorSum(re int x,re int y){\n\t\tsplit(mempool+x,mempool+y);\n\t\treturn (mempool+y)->sum;\n\t}\n\n\tinline void createEdge(re int x,re int y){\n\t\tlink(mempool+x,mempool+y);\n\t}\n\n\tinline void destoryEdge(re int x,re int y){\n\t\tcut(mempool+x,mempool+y);\n\t}\n\n\tinline void modifyVertice(re int x,re int y){\n\t\tsplay(mempool+x);\n\t\t(mempool+x)->val=y;\n\t\t(mempool+x)->pushUp();\n\t}\n\n\tvoid printTree(re SplayNode* p){\n\t\tif(p!=NULL){\n\t\t\tp->pushDown();\n\t\t\tprintTree(p->ls);\n\t\t\tprintf(\n\t\t\t\t\"%d(%d,%d,%d)\\n\",\n\t\t\t\tp-mempool,\n\t\t\t\tp->ftr!=NULL?p->ftr-mempool:-1,\n\t\t\t\tp->ls!=NULL?p->ls-mempool:-1,\n\t\t\t\tp->rs!=NULL?p->rs-mempool:-1\n\t\t\t);\n\t\t\tprintTree(p->rs);\n\t\t}\n\t}\n};\n\nint n,m;\nLinkCutTree QAQ;\n\nint main(){\\\n\tcltstream::read(n);\n\tcltstream::read(m);\n\tQAQ.build(n);\n\tfor(re int i=1;i<=m;++i){\n\t\tint opt,x,y;\n\t\tcltstream::read(opt);\n\t\tcltstream::read(x);\n\t\tcltstream::read(y);\n\t\tswitch(opt){\n\t\t\tcase 0:\n\t\t\t\tcltstream::write(QAQ.queryPathXorSum(x,y),10);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tQAQ.createEdge(x,y);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tQAQ.destoryEdge(x,y);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tQAQ.modifyVertice(x,y);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n~~是不是感觉很好写呢（~~\n\n### 用LCT维护子树信息\n\n咕咕咕。\n","slug":"link-cut-tree-learning-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwh003z34cwye6iiyy8","content":"<p>24号要出去学习，趁现在先自己xjb学点啥。</p>\n<a id=\"more\"></a>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>首先我们有一道<a href=\"https://www.luogu.org/problemnew/show/P3690\" target=\"_blank\" rel=\"noopener\">模板题</a>。</p>\n<p>我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。</p>\n<p>这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\\log^{2}n)$。</p>\n<p>但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。</p>\n<p>很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。</p>\n<p>实链剖分一般被称为LCT，全称<del>Link-Cat Tree</del> <del>Linear Challestend Transformation</del> Link-Cut Tree，也就是动态树。</p>\n<p>与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。</p>\n<p>为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：</p>\n<ol>\n<li>每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。</li>\n<li>每个节点属于且仅属于一棵Splay。</li>\n<li>如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。</li>\n<li>不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。</li>\n</ol>\n<p>以下图片来自<a href=\"https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。\" target=\"_blank\" rel=\"noopener\">https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。</a></p>\n<p>我们来看这样一棵树</p>\n<p><img src=\"/images/1309909-20180123095924037-1618037447.png\" alt=\"\"></p>\n<p>其中粗线表示实边，虚线表示虚边。</p>\n<p>它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。</p>\n<p><img src=\"/images/1309909-20180123095955350-1680422636.png\" alt=\"\"></p>\n<p>当然这并不是唯一的。</p>\n<p>为了方便，我先放出我Splay的代码实现</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SplayNode</span>&#123;</span></span><br><span class=\"line\">\tSplayNode *ftr,*ls,*rs;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> val,sum,rev;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">isRoot</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ftr==<span class=\"literal\">NULL</span>||(ftr-&gt;ls!=<span class=\"keyword\">this</span>&amp;&amp;ftr-&gt;rs!=<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t<span class=\"comment\">//判断一个节点是否是原森林中的一棵树的树根</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">std</span>::swap(ls,rs);</span><br><span class=\"line\">\t\trev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushDown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(rev)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ls!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\tls-&gt;reverse();</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(rs!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\trs-&gt;reverse();</span><br><span class=\"line\">\t\t\trev=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tsum=val;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(ls!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\tsum^=ls-&gt;sum;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(rs!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\tsum^=rs-&gt;sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">SplayNode mempool[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\tre SplayNode* q=p-&gt;ftr;</span><br><span class=\"line\">\tq-&gt;pushDown();</span><br><span class=\"line\">\tp-&gt;pushDown();</span><br><span class=\"line\">\tp-&gt;ftr=q-&gt;ftr;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p-&gt;ftr!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class=\"line\">\t\t\tp-&gt;ftr-&gt;ls=p;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class=\"line\">\t\t\tp-&gt;ftr-&gt;rs=p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q-&gt;rs==p)&#123;</span><br><span class=\"line\">\t\tq-&gt;rs=p-&gt;ls;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;rs!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\tq-&gt;rs-&gt;ftr=q;</span><br><span class=\"line\">\t\tp-&gt;ls=q;</span><br><span class=\"line\">\t\tq-&gt;ftr=p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tq-&gt;ls=p-&gt;rs;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;ls!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\tq-&gt;ls-&gt;ftr=q;</span><br><span class=\"line\">\t\tp-&gt;rs=q;</span><br><span class=\"line\">\t\tq-&gt;ftr=p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tq-&gt;pushUp();</span><br><span class=\"line\">\tp-&gt;pushUp();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class=\"line\">\t\t\trotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"access\"><a href=\"#access\" class=\"headerlink\" title=\"access\"></a>access</h3><p>首先我们有一个基本操作</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">access</span><span class=\"params\">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>\n<p>首先有一个问题是，这个单词怎么读？</p>\n<p><code>/ək&#39;ses/</code>？不不不应该是<code>/&#39;ækses/</code>。</p>\n<p>如果您有兴趣，可以在<a href=\"https://github.com/shimohq/chinese-programmer-wrong-pronunciation\">这里</a>看看自己以前都读错了多少单词（</p>\n<p>这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。</p>\n<p>我们来看看这个函数的具体过程。还是上面的例子，现在我们调用<code>access(N)</code>，整棵树会变成这样</p>\n<p><img src=\"/images/1309909-20180123101901740-2118178734.png\" alt=\"\"></p>\n<p><del>虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（</del></p>\n<p>首先我们调用<code>splay(N)</code>，令$\\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。</p>\n<p><img src=\"/images/1309909-20180123110136115-1112016464.png\" alt=\"\"></p>\n<p>向上找到$\\text{N}$的父亲$\\text{I}$，调用<code>splay(I)</code>，回收$\\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\\text{N}$，然后$\\text{N}$就成了$\\text{I}$的实儿子了。</p>\n<p><img src=\"/images/1309909-20180123110156272-1242463729.png\" alt=\"\"></p>\n<p>然后继续向上，找到$\\text{I}$的父亲$\\text{H}$，调用<code>splay(H)</code>，并令$\\text{H}$的右儿子指针指向$\\text{I}$。</p>\n<p><img src=\"/images/1309909-20180123110209772-2057141058.png\" alt=\"\"></p>\n<p>最后一步，找到$\\text{H}$的父亲$\\text{A}$，调用<code>splay(A)</code>，并令$\\text{A}$的右儿子指针指向$\\text{H}$。</p>\n<p><img src=\"/images/1309909-20180123110213709-49169640.png\" alt=\"\"></p>\n<p>然后我们看到，$\\text{N}$和$\\text{A}$到了同一颗Splay中，完成任务，返回。</p>\n<p>代码实现：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">access</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\tsplay(p);</span><br><span class=\"line\">\tp-&gt;pushDown();</span><br><span class=\"line\">\tp-&gt;rs=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tp-&gt;pushUp();</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class=\"literal\">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class=\"line\">\t\tsplay(q-&gt;ftr);</span><br><span class=\"line\">\t\tq-&gt;ftr-&gt;pushDown();</span><br><span class=\"line\">\t\tq-&gt;ftr-&gt;rs=q;</span><br><span class=\"line\">\t\tq-&gt;ftr-&gt;pushUp();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tsplay(p);</span><br><span class=\"line\">\t<span class=\"comment\">//据说闲着没事瞎转转有利于摊开时间复杂度（</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"findRoot\"><a href=\"#findRoot\" class=\"headerlink\" title=\"findRoot\"></a>findRoot</h3><p>有了<code>access</code>，我们就可以随心所欲的瞎搞了。比如说</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SplayNode* <span class=\"title\">findRoot</span><span class=\"params\">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>\n<p>返回给定节点所在的树的树根，也就是调用完<code>access</code>后它所在的实链上深度最小的节点。</p>\n<p>因为<code>access</code>的最后自带了一个<code>splay</code>，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> SplayNode* <span class=\"title\">findRoot</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\taccess(p);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;p-&gt;ls!=<span class=\"literal\">NULL</span>;p=p-&gt;ls);</span><br><span class=\"line\">\tsplay(p);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"makeRoot-amp-amp-split\"><a href=\"#makeRoot-amp-amp-split\" class=\"headerlink\" title=\"makeRoot &amp;&amp; split\"></a>makeRoot &amp;&amp; split</h3><p>现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。</p>\n<p>不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用<code>access(x)</code>，然后考虑翻转$x$的子树之后会发生什么。</p>\n<p><code>access</code>结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。</p>\n<p>那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次<code>access(y)</code>就可以把它抽出来。</p>\n<p>我们实现下面两个函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">makeRoot</span><span class=\"params\">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure>\n<p>令给定节点成为树根。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>\n<p>抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">makeRoot</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\taccess(p);</span><br><span class=\"line\">\tp-&gt;reverse();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class=\"line\">\tmakeRoot(p);</span><br><span class=\"line\">\taccess(q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"link\"><a href=\"#link\" class=\"headerlink\" title=\"link\"></a>link</h3><p>我们需要实现函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>\n<p>在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。</p>\n<p>思路很简单。假设我们指定$x$和$y$两个节点，首先调用<code>makeRoot(x)</code>，然后检查<code>findRoot(y)</code>的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即<code>findRoot(y)==x</code>，说明两个节点联通，直接返回。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class=\"line\">\tmakeRoot(p);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(findRoot(q)!=p)</span><br><span class=\"line\">\t\tp-&gt;ftr=q;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"cut\"><a href=\"#cut\" class=\"headerlink\" title=\"cut\"></a>cut</h3><p>我们需要实现函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">cut</span><span class=\"params\">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure>\n<p>切断给定的两个节点之间的边。不存在就什么也不做。</p>\n<p>需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用<code>makeRoot(x)</code>，此时$y$应该是$x$的右儿子，并且它不能有左儿子。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">cut</span><span class=\"params\">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class=\"line\">\tmakeRoot(p);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\tq-&gt;ftr=p-&gt;rs=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tp-&gt;pushUp();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。</p>\n<p>完整板子：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 300000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t\t_tp z=x;</span><br><span class=\"line\">\t\tx=y;</span><br><span class=\"line\">\t\ty=z;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkCutTree</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">SplayNode</span>&#123;</span></span><br><span class=\"line\">\t\tSplayNode *ftr,*ls,*rs;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> val,sum,rev;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">isRoot</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> ftr==<span class=\"literal\">NULL</span>||(ftr-&gt;ls!=<span class=\"keyword\">this</span>&amp;&amp;ftr-&gt;rs!=<span class=\"keyword\">this</span>);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">reverse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">std</span>::swap(ls,rs);</span><br><span class=\"line\">\t\t\trev^=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushDown</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(rev)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ls!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t\tls-&gt;reverse();</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(rs!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\t\trs-&gt;reverse();</span><br><span class=\"line\">\t\t\t\trev=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pushUp</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t\tsum=val;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ls!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\tsum^=ls-&gt;sum;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(rs!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\tsum^=rs-&gt;sum;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">\tSplayNode mempool[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">rotate</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\t\tre SplayNode* q=p-&gt;ftr;</span><br><span class=\"line\">\t\tq-&gt;pushDown();</span><br><span class=\"line\">\t\tp-&gt;pushDown();</span><br><span class=\"line\">\t\tp-&gt;ftr=q-&gt;ftr;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p-&gt;ftr!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class=\"line\">\t\t\t\tp-&gt;ftr-&gt;ls=p;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class=\"line\">\t\t\t\tp-&gt;ftr-&gt;rs=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(q-&gt;rs==p)&#123;</span><br><span class=\"line\">\t\t\tq-&gt;rs=p-&gt;ls;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(q-&gt;rs!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\tq-&gt;rs-&gt;ftr=q;</span><br><span class=\"line\">\t\t\tp-&gt;ls=q;</span><br><span class=\"line\">\t\t\tq-&gt;ftr=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tq-&gt;ls=p-&gt;rs;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(q-&gt;ls!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t\tq-&gt;ls-&gt;ftr=q;</span><br><span class=\"line\">\t\t\tp-&gt;rs=q;</span><br><span class=\"line\">\t\t\tq-&gt;ftr=p;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tq-&gt;pushUp();</span><br><span class=\"line\">\t\tp-&gt;pushUp();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">splay</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class=\"line\">\t\t\t\trotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">build</span><span class=\"params\">(re <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)&#123;</span><br><span class=\"line\">\t\t\tre SplayNode* p=mempool+i;</span><br><span class=\"line\">\t\t\tp-&gt;ftr=p-&gt;ls=p-&gt;rs=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\tcltstream::read(p-&gt;val);</span><br><span class=\"line\">\t\t\tp-&gt;sum=p-&gt;val;</span><br><span class=\"line\">\t\t\tp-&gt;rev=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">access</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\t\tsplay(p);</span><br><span class=\"line\">\t\tp-&gt;pushDown();</span><br><span class=\"line\">\t\tp-&gt;rs=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\tp-&gt;pushUp();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class=\"literal\">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class=\"line\">\t\t\tsplay(q-&gt;ftr);</span><br><span class=\"line\">\t\t\tq-&gt;ftr-&gt;pushDown();</span><br><span class=\"line\">\t\t\tq-&gt;ftr-&gt;rs=q;</span><br><span class=\"line\">\t\t\tq-&gt;ftr-&gt;pushUp();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tsplay(p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> SplayNode* <span class=\"title\">findRoot</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\t\taccess(p);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;p-&gt;ls!=<span class=\"literal\">NULL</span>;p=p-&gt;ls);</span><br><span class=\"line\">\t\tsplay(p);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> p;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">makeRoot</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\t\taccess(p);</span><br><span class=\"line\">\t\tp-&gt;reverse();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">split</span><span class=\"params\">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class=\"line\">\t\tmakeRoot(p);</span><br><span class=\"line\">\t\taccess(q);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">link</span><span class=\"params\">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class=\"line\">\t\tmakeRoot(p);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(findRoot(q)!=p)</span><br><span class=\"line\">\t\t\tp-&gt;ftr=q;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">cut</span><span class=\"params\">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class=\"line\">\t\tmakeRoot(p);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t\tq-&gt;ftr=p-&gt;rs=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t\t\tp-&gt;pushUp();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">queryPathXorSum</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t\tsplit(mempool+x,mempool+y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (mempool+y)-&gt;sum;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">createEdge</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t\tlink(mempool+x,mempool+y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">destoryEdge</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t\tcut(mempool+x,mempool+y);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">modifyVertice</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t\tsplay(mempool+x);</span><br><span class=\"line\">\t\t(mempool+x)-&gt;val=y;</span><br><span class=\"line\">\t\t(mempool+x)-&gt;pushUp();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">printTree</span><span class=\"params\">(re SplayNode* p)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p!=<span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t\tp-&gt;pushDown();</span><br><span class=\"line\">\t\t\tprintTree(p-&gt;ls);</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(</span><br><span class=\"line\">\t\t\t\t<span class=\"string\">\"%d(%d,%d,%d)\\n\"</span>,</span><br><span class=\"line\">\t\t\t\tp-mempool,</span><br><span class=\"line\">\t\t\t\tp-&gt;ftr!=<span class=\"literal\">NULL</span>?p-&gt;ftr-mempool:<span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\t\t\tp-&gt;ls!=<span class=\"literal\">NULL</span>?p-&gt;ls-mempool:<span class=\"number\">-1</span>,</span><br><span class=\"line\">\t\t\t\tp-&gt;rs!=<span class=\"literal\">NULL</span>?p-&gt;rs-mempool:<span class=\"number\">-1</span></span><br><span class=\"line\">\t\t\t);</span><br><span class=\"line\">\t\t\tprintTree(p-&gt;rs);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\">LinkCutTree QAQ;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;\\</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\tcltstream::read(m);</span><br><span class=\"line\">\tQAQ.build(n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> opt,x,y;</span><br><span class=\"line\">\t\tcltstream::read(opt);</span><br><span class=\"line\">\t\tcltstream::read(x);</span><br><span class=\"line\">\t\tcltstream::read(y);</span><br><span class=\"line\">\t\t<span class=\"keyword\">switch</span>(opt)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t\t\tcltstream::write(QAQ.queryPathXorSum(x,y),<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\t\t\tQAQ.createEdge(x,y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">\t\t\t\tQAQ.destoryEdge(x,y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">\t\t\t\tQAQ.modifyVertice(x,y);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p><del>是不是感觉很好写呢（</del></p>\n<h3 id=\"用LCT维护子树信息\"><a href=\"#用LCT维护子树信息\" class=\"headerlink\" title=\"用LCT维护子树信息\"></a>用LCT维护子树信息</h3><p>咕咕咕。</p>\n","site":{"data":{}},"excerpt":"<p>24号要出去学习，趁现在先自己xjb学点啥。</p>","more":"<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>首先我们有一道<a href=\"https://www.luogu.org/problemnew/show/P3690\" target=\"_blank\" rel=\"noopener\">模板题</a>。</p>\n<p>我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。</p>\n<p>这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\\log^{2}n)$。</p>\n<p>但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。</p>\n<p>很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。</p>\n<p>实链剖分一般被称为LCT，全称<del>Link-Cat Tree</del> <del>Linear Challestend Transformation</del> Link-Cut Tree，也就是动态树。</p>\n<p>与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。</p>\n<p>为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：</p>\n<ol>\n<li>每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。</li>\n<li>每个节点属于且仅属于一棵Splay。</li>\n<li>如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。</li>\n<li>不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。</li>\n</ol>\n<p>以下图片来自<a href=\"https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。\" target=\"_blank\" rel=\"noopener\">https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。</a></p>\n<p>我们来看这样一棵树</p>\n<p><img src=\"/images/1309909-20180123095924037-1618037447.png\" alt=\"\"></p>\n<p>其中粗线表示实边，虚线表示虚边。</p>\n<p>它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。</p>\n<p><img src=\"/images/1309909-20180123095955350-1680422636.png\" alt=\"\"></p>\n<p>当然这并不是唯一的。</p>\n<p>为了方便，我先放出我Splay的代码实现</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�25-->\n\n</div></div>\n<h3 id=\"access\"><a href=\"#access\" class=\"headerlink\" title=\"access\"></a>access</h3><p>首先我们有一个基本操作</p>\n<!--�26-->\n<p>首先有一个问题是，这个单词怎么读？</p>\n<p><code>/ək&#39;ses/</code>？不不不应该是<code>/&#39;ækses/</code>。</p>\n<p>如果您有兴趣，可以在<a href=\"https://github.com/shimohq/chinese-programmer-wrong-pronunciation\">这里</a>看看自己以前都读错了多少单词（</p>\n<p>这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。</p>\n<p>我们来看看这个函数的具体过程。还是上面的例子，现在我们调用<code>access(N)</code>，整棵树会变成这样</p>\n<p><img src=\"/images/1309909-20180123101901740-2118178734.png\" alt=\"\"></p>\n<p><del>虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（</del></p>\n<p>首先我们调用<code>splay(N)</code>，令$\\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。</p>\n<p><img src=\"/images/1309909-20180123110136115-1112016464.png\" alt=\"\"></p>\n<p>向上找到$\\text{N}$的父亲$\\text{I}$，调用<code>splay(I)</code>，回收$\\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\\text{N}$，然后$\\text{N}$就成了$\\text{I}$的实儿子了。</p>\n<p><img src=\"/images/1309909-20180123110156272-1242463729.png\" alt=\"\"></p>\n<p>然后继续向上，找到$\\text{I}$的父亲$\\text{H}$，调用<code>splay(H)</code>，并令$\\text{H}$的右儿子指针指向$\\text{I}$。</p>\n<p><img src=\"/images/1309909-20180123110209772-2057141058.png\" alt=\"\"></p>\n<p>最后一步，找到$\\text{H}$的父亲$\\text{A}$，调用<code>splay(A)</code>，并令$\\text{A}$的右儿子指针指向$\\text{H}$。</p>\n<p><img src=\"/images/1309909-20180123110213709-49169640.png\" alt=\"\"></p>\n<p>然后我们看到，$\\text{N}$和$\\text{A}$到了同一颗Splay中，完成任务，返回。</p>\n<p>代码实现：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�27-->\n\n</div></div>\n<h3 id=\"findRoot\"><a href=\"#findRoot\" class=\"headerlink\" title=\"findRoot\"></a>findRoot</h3><p>有了<code>access</code>，我们就可以随心所欲的瞎搞了。比如说</p>\n<!--�28-->\n<p>返回给定节点所在的树的树根，也就是调用完<code>access</code>后它所在的实链上深度最小的节点。</p>\n<p>因为<code>access</code>的最后自带了一个<code>splay</code>，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�29-->\n\n</div></div>\n<h3 id=\"makeRoot-amp-amp-split\"><a href=\"#makeRoot-amp-amp-split\" class=\"headerlink\" title=\"makeRoot &amp;&amp; split\"></a>makeRoot &amp;&amp; split</h3><p>现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。</p>\n<p>不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用<code>access(x)</code>，然后考虑翻转$x$的子树之后会发生什么。</p>\n<p><code>access</code>结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。</p>\n<p>那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次<code>access(y)</code>就可以把它抽出来。</p>\n<p>我们实现下面两个函数</p>\n<!--�30-->\n<p>令给定节点成为树根。</p>\n<!--�31-->\n<p>抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�32-->\n\n</div></div>\n<h3 id=\"link\"><a href=\"#link\" class=\"headerlink\" title=\"link\"></a>link</h3><p>我们需要实现函数</p>\n<!--�33-->\n<p>在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。</p>\n<p>思路很简单。假设我们指定$x$和$y$两个节点，首先调用<code>makeRoot(x)</code>，然后检查<code>findRoot(y)</code>的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即<code>findRoot(y)==x</code>，说明两个节点联通，直接返回。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�34-->\n\n</div></div>\n<h3 id=\"cut\"><a href=\"#cut\" class=\"headerlink\" title=\"cut\"></a>cut</h3><p>我们需要实现函数</p>\n<!--�35-->\n<p>切断给定的两个节点之间的边。不存在就什么也不做。</p>\n<p>需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用<code>makeRoot(x)</code>，此时$y$应该是$x$的右儿子，并且它不能有左儿子。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�36-->\n\n</div></div>\n<p>把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。</p>\n<p>完整板子：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�37-->\n\n</div></div>\n<p><del>是不是感觉很好写呢（</del></p>\n<h3 id=\"用LCT维护子树信息\"><a href=\"#用LCT维护子树信息\" class=\"headerlink\" title=\"用LCT维护子树信息\"></a>用LCT维护子树信息</h3><p>咕咕咕。</p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-02-13T13:41:39.000Z","title":"「年轻人，你渴望力量吗？」","password":null,"_content":"标题来自某学长安利min_25筛的方式（\n\n<!-- more -->\n\n### 概述\n\n我们知道，[杜教筛](/number-theory-learning-notes/)可以在$O(n^{\\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。\n\n但是现在我们希望更快。于是我们有了min_25筛（\n\n以下，我们约定$p$是一个质数。$\\mathbb{P}_{i}$表示第$i$小的质数，$\\mathbb{P}_{0}=0$。$\\text{minp}(n)$表示$n$最小的质因数，$\\text{minp}(1)=0$。\n\n现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：\n\n1. $f(p)$是一个__可以快速求前缀和的完全积性函数__，或者能用多个这样的函数运算得到。\n2. $f(p^{k})$可以快速求，大概$O(k)$以内就可以。\n\n### 第一部分\n\n我们要对每一个$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，求出\n\n$$\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)$$\n\n定义\n\n$$F(x,y)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}\\vee\\text{minp}(i)\\gt\\mathbb{P}_{y}]f^{\\prime}(i)$$\n\n也就是把所有质数和最小质因数大于$\\mathbb{P}_y$的合数全部当成质数代入$f^{\\prime}$求值并求和。不难发现\n\n$$F(x,+\\infty)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)$$\n\n我们回忆一下埃式筛法的运行过程。\n\n筛完$k$次后，我们除去了最小质因数小于等于$\\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\\mathbb{P}_k$的合数。\n\n可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\\prime}$的值的和。\n\n首先，第$y$次筛掉的最小的数很明显是$\\mathbb{P}_{y}^{2}$，如果$\\mathbb{P}_{y}^{2}\\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。\n\n也因此，筛质数筛到$\\sqrt{n}$即可。\n\n否则，即$\\mathbb{P}_{y}^{2}\\leqslant x$，我们将所有数除以$\\mathbb{P}_{y}$，之前所有最小质因数等于$\\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\\mathbb{P}_{y}$的数。\n\n又因为$f^{\\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\\prime}(\\cfrac{z}{\\mathbb{P}_{y}})f^{\\prime}(\\mathbb{P}_{y})$计算$f^{\\prime}(z)$。\n\n那么看起来\n\n$$F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$$\n\n$F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$包含了三类数的$f^{\\prime}$的值：\n\n1. 大于等于$\\mathbb{P}_{y}$的质数。\n2. 最小质因数大于等于$\\mathbb{P}_{y}$（大于$\\mathbb{P}_{y-1}$）的合数。\n3. 小于$\\mathbb{P}_{y}$的质数。\n\n但是很明显第三类数不能被除去，因此实际上\n\n$$F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)$$\n\n综上所述\n\n$$F(x,y)=\\begin{cases}\n&F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum\\limits_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)\\;\\;&(\\mathbb{P}_{y}^{2}\\leqslant x)\\\\\n&F(x,y-1)&(\\mathbb{P}_{y}^{2}\\gt x)\n\\end{cases}$$\n\n初值为\n\n$$F(x,0)=\\sum_{i=2}^{x}f^{\\prime}(i)$$\n\n注意到第二维只与$y-1$有关，我们可以滚掉。\n\n还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。\n\n因为$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，这样的$x$最多只有$2\\sqrt{n}$个，我们可以离散化存储。\n\n具体实现细节我说不清，看代码吧（\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ncltstream::read(n);\nsq=sqrt(n);\nfor(re int i=2;i<=sq;++i){\n\tif(!f[i]){\n\t\tg[++g[0]]=i;\n\t\tfsum[g[0]]=fsum[g[0]-1]+/**/;\n\t\t//注释处应填f`(i)\n\t}\n\tfor(re int j=1;j<=g[0]&&i*g[j]<=sq;++j){\n\t\tf[i*g[j]]=1;\n\t\tif(!(i%g[j]))\n\t\t\tbreak;\n\t}\n}\nm=0;\nfor(re int l=1,r;l<=n;r=n/(n/l),l=r+1){\n\tw[++m]=n/l;\n\t//编号对应的离散化前的值\n\tF[m]=/**/;\n\t//注释处应填\\sum_{t=2}^{w[m]}f`(t)\n\tif(w[m]<=sq)\n\t\tid1[w[m]]=m;\n\telse\n\t\tid2[n/w[m]]=m;\n\t//分段存储值对应的编号，这样数组只需要开到sqrt{n}\n}\nfor(re int j=1;j<=g[0];++j)\n\tfor(re int i=1;i<=m&&w[i]>=g[j]*g[j];++i){\n\t//w[i]>=g[j]*g[j]，所以w[i]/g[j]>=g[j]\n\t\tre int id=w[i]/g[j]<=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];\n\t\tF[i]-=/**/*(F[id]-fsum[j-1]);\n\t\t//注释处应填f`(g[j])\n\t}\n```\n\n{% endfold %}\n\n这一部分的时间复杂度已被证明是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。~~然而看上去很奇怪（~~\n\n### 第二部分\n\n在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。\n\n定义\n\n$$S(x,y)=\\sum_{i=1}^{x}[\\text{minp}(i)\\geqslant\\mathbb{P}_{y}]f(i)$$\n\n也就是所有最小质因数大于等于$\\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。\n\n首先我们需要统计所有质数的贡献，也就是$F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})$。\n\n关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。\n\n$$\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$$\n\n但是还有一个问题是$S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$中不包括$f(1)$，因此$f(\\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来\n\n$$\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)$$\n\n于是\n\n$$S(x,y)=F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})+\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)$$\n\n然后暴力搜，记忆化都不需要，时间复杂度还是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。~~就很神奇（~~\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nint S(re int x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int id=x<=sq?id1[x]:id2[n/x];\n\t\tre int res=F[id]-fsum[y-1];\n\t\tfor(re int i=y;i<=g[0]&&g[i]*g[i]<=x;++i)\n\t\t\tfor(re int p=g[i];p*g[i]<=x;p*=g[i])\n\t\t\t\tres+=/*1*/*S(x/p,i+1)+/*2*/;\n\t\t\t\t//1处应填f(p)，2处应填f(p*g[i])\n\t\treturn res;\n\t}\n}\n```\n\n{% endfold %}\n\n### [「Luogu-P4213」「模板」杜教筛（Sum）](https://www.luogu.org/problemnew/show/P4213)\n\n首先我们有\n\n$$\\varphi(p)=\\text{id}(p)-1$$\n\n$$\\mu(p)=-1$$\n\n然后$\\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。\n\n说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#define re register\n#define maxn 50000\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint t,n,sq,m;\nint f[maxn+1],g[maxn+1],w[(maxn<<1)+1],id1[maxn+1],id2[maxn+1];\nint prmcnt[maxn+1],prmCnt[(maxn<<1)+1];\nlong long prmsum[maxn+1],prmSum[(maxn<<1)+1];\n\nlong long getPhi(re int x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int id=x<=sq?id1[x]:id2[n/x];\n\t\tre long long res=(prmSum[id]-prmCnt[id])-(prmsum[y-1]-prmcnt[y-1]);\n\t\tfor(re int i=y;i<=g[0]&&1LL*g[i]*g[i]<=x;++i)\n\t\t\tfor(re int p=g[i];1LL*p*g[i]<=x;p*=g[i])\n\t\t\t\tres+=1LL*p/g[i]*(g[i]-1)*getPhi(x/p,i+1)+1LL*p*(g[i]-1);\n\t\treturn res;\n\t}\n}\n\nint getMu(re int x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int id=x<=sq?id1[x]:id2[n/x];\n\t\tre int res=prmcnt[y-1]-prmCnt[id];\n\t\tfor(re int i=y;i<=g[0]&&1LL*g[i]*g[i]<=x;++i)\n\t\t\tres-=getMu(x/g[i],i+1);\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tfor(re int i=2;i<=maxn;++i){\n\t\tif(!f[i]){\n\t\t\tg[++g[0]]=i;\n\t\t\tprmcnt[g[0]]=prmcnt[g[0]-1]+1;\n\t\t\tprmsum[g[0]]=prmsum[g[0]-1]+i;\n\t\t}\n\t\tfor(re int j=1;j<=g[0]&&1LL*i*g[j]<=maxn;++j){\n\t\t\tf[i*g[j]]=1;\n\t\t\tif(!(i%g[j]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcltstream::read(t);\n\tfor(;t;--t){\n\t\tcltstream::read(n);\n\t\tsq=sqrt(n);\n\t\tm=0;\n\t\tfor(re int l=1,r;l<=n;r=n/(n/l),l=r+1){\n\t\t\tw[++m]=n/l;\n\t\t\tprmCnt[m]=w[m]-1;\n\t\t\tprmSum[m]=1LL*(w[m]-1)*(w[m]+2)/2;\n\t\t\tif(w[m]<=sq)\n\t\t\t\tid1[w[m]]=m;\n\t\t\telse\n\t\t\t\tid2[n/w[m]]=m;\n\t\t}\n\t\tfor(re int j=1;j<=g[0];++j)\n\t\t\tfor(re int i=1;i<=m&&w[i]>=1LL*g[j]*g[j];++i){\n\t\t\t\tre int id=w[i]/g[j]<=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];\n\t\t\t\tprmCnt[i]-=prmCnt[id]-prmcnt[j-1];\n\t\t\t\tprmSum[i]-=1LL*g[j]*(prmSum[id]-prmsum[j-1]);\n\t\t\t}\n\t\tcltstream::write(getPhi(n,1)+1,32);\n\t\tcltstream::write(getMu(n,1)+1,10);\n\t}\n\tclop();\n\treturn 0;\n}\n```\n{% endfold %}\n\n![](/images/TIM截图20190214152934.png)\n\n上为min_25筛，下为杜教筛。\n\nmin_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说\n\n### [「LOJ6053」简单的函数](https://loj.ac/problem/6053)\n\n总结一下这个函数：\n\n$$f(1)=1$$\n\n$$f\\left(\\prod_{i=1}^{N}p_{i}^{r_{i}}\\right)=\\prod_{i=1}^{N}(p_{i}\\otimes r_{i})$$\n\n其中$\\otimes$表示按位异或。\n\n![](/images/TIM图片20190103092627.png)\n\n按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（\n\n注意到\n\n$$f(p)=p\\otimes 1=\\begin{cases}\n&p+1\\;\\;&(p=2)\\\\\n&p-1\\;\\;&(p\\gt 2)\n\\end{cases}$$\n\n我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。\n\n然后还是要用min_25筛的前半部分筛出$\\text{id}$和$1$，其实和上面的$\\varphi$没多大区别就是加了点细节（\n\n[好像这种能随便看代码的OJ可以直接扔个提交记录](https://loj.ac/submission/336101)。\n\n### [「UOJ188」Sanrd](http://uoj.ac/problem/188)\n\n次大质因数和。\n\n其实这个题面有点考阅读的。\n\n但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。~~说好的只能筛积性函数呢（~~\n\n我们来分析一下min_25筛的运行过程。\n\n调用到$S(x,y)$时，剩下的最小质因数大于等于$\\mathbb{P}_{y}$的数中，只有质数与$\\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\\mathbb{P}_{y-1}$的数。这部分可以直接算。\n\n关于次大质因数大于$\\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\\mathbb{P}_{i}^{j})$，手动加。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nlong long S(re long long n,re long long x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int k=id[x<=sq?x:n/x+sq];\n\t\tre long long res=(y>1?g[y-1]:0)*(prmCnt[k]-y+1);\n\t\tfor(re int i=y;i<=g[0]&&1LL*g[i]*g[i]<=x;++i)\n\t\t\tfor(re long long p=g[i];p*g[i]<=x;p*=g[i])\n\t\t\t\tres+=S(n,x/p,i+1)+g[i];\n\t\treturn res;\n\t}\n}\n```\n\n{% endfold %}\n\n[提交记录](http://uoj.ac/submission/324057)。\n\n~~一道比一道神仙，像我这种菜鸡只能抄题解了（~~\n\n### 课后习题\n\n- [「LOJ572」「LibreOJ Round #11」Misaka Network与求和](https://loj.ac/problem/572)\n- [「SP34096」DIVCNTK - Counting Divisors (general)](https://www.spoj.com/problems/DIVCNTK/)\n- [「SP19985」GCDEX2 - GCD Extreme (hard)](https://www.spoj.com/problems/GCDEX2/)\n- [「SP19975」APS2 - Amazing Prime Sequence (hard)](https://www.spoj.com/problems/APS2/)\n\n### 其它文献\n\n- https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096\n- https://www.cnblogs.com/zhoushuyu/p/9187319.html\n- https://www.cnblogs.com/cjyyb/p/10169190.html\n","source":"_posts/2019-02-13-min-25-sieve-learning-notes.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-02-13 21:41:39\ntitle: 「年轻人，你渴望力量吗？」\ntags:\n  - min_25筛\ncategories:\n  - 学习笔记\npassword:\n---\n标题来自某学长安利min_25筛的方式（\n\n<!-- more -->\n\n### 概述\n\n我们知道，[杜教筛](/number-theory-learning-notes/)可以在$O(n^{\\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。\n\n但是现在我们希望更快。于是我们有了min_25筛（\n\n以下，我们约定$p$是一个质数。$\\mathbb{P}_{i}$表示第$i$小的质数，$\\mathbb{P}_{0}=0$。$\\text{minp}(n)$表示$n$最小的质因数，$\\text{minp}(1)=0$。\n\n现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：\n\n1. $f(p)$是一个__可以快速求前缀和的完全积性函数__，或者能用多个这样的函数运算得到。\n2. $f(p^{k})$可以快速求，大概$O(k)$以内就可以。\n\n### 第一部分\n\n我们要对每一个$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，求出\n\n$$\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)$$\n\n定义\n\n$$F(x,y)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}\\vee\\text{minp}(i)\\gt\\mathbb{P}_{y}]f^{\\prime}(i)$$\n\n也就是把所有质数和最小质因数大于$\\mathbb{P}_y$的合数全部当成质数代入$f^{\\prime}$求值并求和。不难发现\n\n$$F(x,+\\infty)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)$$\n\n我们回忆一下埃式筛法的运行过程。\n\n筛完$k$次后，我们除去了最小质因数小于等于$\\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\\mathbb{P}_k$的合数。\n\n可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\\prime}$的值的和。\n\n首先，第$y$次筛掉的最小的数很明显是$\\mathbb{P}_{y}^{2}$，如果$\\mathbb{P}_{y}^{2}\\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。\n\n也因此，筛质数筛到$\\sqrt{n}$即可。\n\n否则，即$\\mathbb{P}_{y}^{2}\\leqslant x$，我们将所有数除以$\\mathbb{P}_{y}$，之前所有最小质因数等于$\\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\\mathbb{P}_{y}$的数。\n\n又因为$f^{\\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\\prime}(\\cfrac{z}{\\mathbb{P}_{y}})f^{\\prime}(\\mathbb{P}_{y})$计算$f^{\\prime}(z)$。\n\n那么看起来\n\n$$F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$$\n\n$F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$包含了三类数的$f^{\\prime}$的值：\n\n1. 大于等于$\\mathbb{P}_{y}$的质数。\n2. 最小质因数大于等于$\\mathbb{P}_{y}$（大于$\\mathbb{P}_{y-1}$）的合数。\n3. 小于$\\mathbb{P}_{y}$的质数。\n\n但是很明显第三类数不能被除去，因此实际上\n\n$$F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)$$\n\n综上所述\n\n$$F(x,y)=\\begin{cases}\n&F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum\\limits_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)\\;\\;&(\\mathbb{P}_{y}^{2}\\leqslant x)\\\\\n&F(x,y-1)&(\\mathbb{P}_{y}^{2}\\gt x)\n\\end{cases}$$\n\n初值为\n\n$$F(x,0)=\\sum_{i=2}^{x}f^{\\prime}(i)$$\n\n注意到第二维只与$y-1$有关，我们可以滚掉。\n\n还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。\n\n因为$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，这样的$x$最多只有$2\\sqrt{n}$个，我们可以离散化存储。\n\n具体实现细节我说不清，看代码吧（\n\n{% fold \"Toggle Code\" %}\n\n```cpp\ncltstream::read(n);\nsq=sqrt(n);\nfor(re int i=2;i<=sq;++i){\n\tif(!f[i]){\n\t\tg[++g[0]]=i;\n\t\tfsum[g[0]]=fsum[g[0]-1]+/**/;\n\t\t//注释处应填f`(i)\n\t}\n\tfor(re int j=1;j<=g[0]&&i*g[j]<=sq;++j){\n\t\tf[i*g[j]]=1;\n\t\tif(!(i%g[j]))\n\t\t\tbreak;\n\t}\n}\nm=0;\nfor(re int l=1,r;l<=n;r=n/(n/l),l=r+1){\n\tw[++m]=n/l;\n\t//编号对应的离散化前的值\n\tF[m]=/**/;\n\t//注释处应填\\sum_{t=2}^{w[m]}f`(t)\n\tif(w[m]<=sq)\n\t\tid1[w[m]]=m;\n\telse\n\t\tid2[n/w[m]]=m;\n\t//分段存储值对应的编号，这样数组只需要开到sqrt{n}\n}\nfor(re int j=1;j<=g[0];++j)\n\tfor(re int i=1;i<=m&&w[i]>=g[j]*g[j];++i){\n\t//w[i]>=g[j]*g[j]，所以w[i]/g[j]>=g[j]\n\t\tre int id=w[i]/g[j]<=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];\n\t\tF[i]-=/**/*(F[id]-fsum[j-1]);\n\t\t//注释处应填f`(g[j])\n\t}\n```\n\n{% endfold %}\n\n这一部分的时间复杂度已被证明是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。~~然而看上去很奇怪（~~\n\n### 第二部分\n\n在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。\n\n定义\n\n$$S(x,y)=\\sum_{i=1}^{x}[\\text{minp}(i)\\geqslant\\mathbb{P}_{y}]f(i)$$\n\n也就是所有最小质因数大于等于$\\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。\n\n首先我们需要统计所有质数的贡献，也就是$F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})$。\n\n关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。\n\n$$\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$$\n\n但是还有一个问题是$S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$中不包括$f(1)$，因此$f(\\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来\n\n$$\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)$$\n\n于是\n\n$$S(x,y)=F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})+\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)$$\n\n然后暴力搜，记忆化都不需要，时间复杂度还是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。~~就很神奇（~~\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nint S(re int x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int id=x<=sq?id1[x]:id2[n/x];\n\t\tre int res=F[id]-fsum[y-1];\n\t\tfor(re int i=y;i<=g[0]&&g[i]*g[i]<=x;++i)\n\t\t\tfor(re int p=g[i];p*g[i]<=x;p*=g[i])\n\t\t\t\tres+=/*1*/*S(x/p,i+1)+/*2*/;\n\t\t\t\t//1处应填f(p)，2处应填f(p*g[i])\n\t\treturn res;\n\t}\n}\n```\n\n{% endfold %}\n\n### [「Luogu-P4213」「模板」杜教筛（Sum）](https://www.luogu.org/problemnew/show/P4213)\n\n首先我们有\n\n$$\\varphi(p)=\\text{id}(p)-1$$\n\n$$\\mu(p)=-1$$\n\n然后$\\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。\n\n说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#define re register\n#define maxn 50000\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint t,n,sq,m;\nint f[maxn+1],g[maxn+1],w[(maxn<<1)+1],id1[maxn+1],id2[maxn+1];\nint prmcnt[maxn+1],prmCnt[(maxn<<1)+1];\nlong long prmsum[maxn+1],prmSum[(maxn<<1)+1];\n\nlong long getPhi(re int x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int id=x<=sq?id1[x]:id2[n/x];\n\t\tre long long res=(prmSum[id]-prmCnt[id])-(prmsum[y-1]-prmcnt[y-1]);\n\t\tfor(re int i=y;i<=g[0]&&1LL*g[i]*g[i]<=x;++i)\n\t\t\tfor(re int p=g[i];1LL*p*g[i]<=x;p*=g[i])\n\t\t\t\tres+=1LL*p/g[i]*(g[i]-1)*getPhi(x/p,i+1)+1LL*p*(g[i]-1);\n\t\treturn res;\n\t}\n}\n\nint getMu(re int x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int id=x<=sq?id1[x]:id2[n/x];\n\t\tre int res=prmcnt[y-1]-prmCnt[id];\n\t\tfor(re int i=y;i<=g[0]&&1LL*g[i]*g[i]<=x;++i)\n\t\t\tres-=getMu(x/g[i],i+1);\n\t\treturn res;\n\t}\n}\n\nint main(){\n\tfor(re int i=2;i<=maxn;++i){\n\t\tif(!f[i]){\n\t\t\tg[++g[0]]=i;\n\t\t\tprmcnt[g[0]]=prmcnt[g[0]-1]+1;\n\t\t\tprmsum[g[0]]=prmsum[g[0]-1]+i;\n\t\t}\n\t\tfor(re int j=1;j<=g[0]&&1LL*i*g[j]<=maxn;++j){\n\t\t\tf[i*g[j]]=1;\n\t\t\tif(!(i%g[j]))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tcltstream::read(t);\n\tfor(;t;--t){\n\t\tcltstream::read(n);\n\t\tsq=sqrt(n);\n\t\tm=0;\n\t\tfor(re int l=1,r;l<=n;r=n/(n/l),l=r+1){\n\t\t\tw[++m]=n/l;\n\t\t\tprmCnt[m]=w[m]-1;\n\t\t\tprmSum[m]=1LL*(w[m]-1)*(w[m]+2)/2;\n\t\t\tif(w[m]<=sq)\n\t\t\t\tid1[w[m]]=m;\n\t\t\telse\n\t\t\t\tid2[n/w[m]]=m;\n\t\t}\n\t\tfor(re int j=1;j<=g[0];++j)\n\t\t\tfor(re int i=1;i<=m&&w[i]>=1LL*g[j]*g[j];++i){\n\t\t\t\tre int id=w[i]/g[j]<=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];\n\t\t\t\tprmCnt[i]-=prmCnt[id]-prmcnt[j-1];\n\t\t\t\tprmSum[i]-=1LL*g[j]*(prmSum[id]-prmsum[j-1]);\n\t\t\t}\n\t\tcltstream::write(getPhi(n,1)+1,32);\n\t\tcltstream::write(getMu(n,1)+1,10);\n\t}\n\tclop();\n\treturn 0;\n}\n```\n{% endfold %}\n\n![](/images/TIM截图20190214152934.png)\n\n上为min_25筛，下为杜教筛。\n\nmin_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说\n\n### [「LOJ6053」简单的函数](https://loj.ac/problem/6053)\n\n总结一下这个函数：\n\n$$f(1)=1$$\n\n$$f\\left(\\prod_{i=1}^{N}p_{i}^{r_{i}}\\right)=\\prod_{i=1}^{N}(p_{i}\\otimes r_{i})$$\n\n其中$\\otimes$表示按位异或。\n\n![](/images/TIM图片20190103092627.png)\n\n按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（\n\n注意到\n\n$$f(p)=p\\otimes 1=\\begin{cases}\n&p+1\\;\\;&(p=2)\\\\\n&p-1\\;\\;&(p\\gt 2)\n\\end{cases}$$\n\n我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。\n\n然后还是要用min_25筛的前半部分筛出$\\text{id}$和$1$，其实和上面的$\\varphi$没多大区别就是加了点细节（\n\n[好像这种能随便看代码的OJ可以直接扔个提交记录](https://loj.ac/submission/336101)。\n\n### [「UOJ188」Sanrd](http://uoj.ac/problem/188)\n\n次大质因数和。\n\n其实这个题面有点考阅读的。\n\n但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。~~说好的只能筛积性函数呢（~~\n\n我们来分析一下min_25筛的运行过程。\n\n调用到$S(x,y)$时，剩下的最小质因数大于等于$\\mathbb{P}_{y}$的数中，只有质数与$\\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\\mathbb{P}_{y-1}$的数。这部分可以直接算。\n\n关于次大质因数大于$\\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\\mathbb{P}_{i}^{j})$，手动加。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nlong long S(re long long n,re long long x,re int y){\n\tif(x<=1||g[y]>x)\n\t\treturn 0;\n\telse{\n\t\tre int k=id[x<=sq?x:n/x+sq];\n\t\tre long long res=(y>1?g[y-1]:0)*(prmCnt[k]-y+1);\n\t\tfor(re int i=y;i<=g[0]&&1LL*g[i]*g[i]<=x;++i)\n\t\t\tfor(re long long p=g[i];p*g[i]<=x;p*=g[i])\n\t\t\t\tres+=S(n,x/p,i+1)+g[i];\n\t\treturn res;\n\t}\n}\n```\n\n{% endfold %}\n\n[提交记录](http://uoj.ac/submission/324057)。\n\n~~一道比一道神仙，像我这种菜鸡只能抄题解了（~~\n\n### 课后习题\n\n- [「LOJ572」「LibreOJ Round #11」Misaka Network与求和](https://loj.ac/problem/572)\n- [「SP34096」DIVCNTK - Counting Divisors (general)](https://www.spoj.com/problems/DIVCNTK/)\n- [「SP19985」GCDEX2 - GCD Extreme (hard)](https://www.spoj.com/problems/GCDEX2/)\n- [「SP19975」APS2 - Amazing Prime Sequence (hard)](https://www.spoj.com/problems/APS2/)\n\n### 其它文献\n\n- https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096\n- https://www.cnblogs.com/zhoushuyu/p/9187319.html\n- https://www.cnblogs.com/cjyyb/p/10169190.html\n","slug":"min-25-sieve-learning-notes","published":1,"updated":"2019-02-15T09:19:15.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpwi004034cwanrv06yh","content":"<p>标题来自某学长安利min_25筛的方式（</p>\n<a id=\"more\"></a>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>我们知道，<a href=\"/number-theory-learning-notes/\">杜教筛</a>可以在$O(n^{\\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。</p>\n<p>但是现在我们希望更快。于是我们有了min_25筛（</p>\n<p>以下，我们约定$p$是一个质数。$\\mathbb{P}_{i}$表示第$i$小的质数，$\\mathbb{P}_{0}=0$。$\\text{minp}(n)$表示$n$最小的质因数，$\\text{minp}(1)=0$。</p>\n<p>现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：</p>\n<ol>\n<li>$f(p)$是一个<strong>可以快速求前缀和的完全积性函数</strong>，或者能用多个这样的函数运算得到。</li>\n<li>$f(p^{k})$可以快速求，大概$O(k)$以内就可以。</li>\n</ol>\n<h3 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h3><p>我们要对每一个$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，求出</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)</script><p>定义</p>\n<script type=\"math/tex; mode=display\">F(x,y)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}\\vee\\text{minp}(i)\\gt\\mathbb{P}_{y}]f^{\\prime}(i)</script><p>也就是把所有质数和最小质因数大于$\\mathbb{P}_y$的合数全部当成质数代入$f^{\\prime}$求值并求和。不难发现</p>\n<script type=\"math/tex; mode=display\">F(x,+\\infty)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)</script><p>我们回忆一下埃式筛法的运行过程。</p>\n<p>筛完$k$次后，我们除去了最小质因数小于等于$\\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\\mathbb{P}_k$的合数。</p>\n<p>可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\\prime}$的值的和。</p>\n<p>首先，第$y$次筛掉的最小的数很明显是$\\mathbb{P}_{y}^{2}$，如果$\\mathbb{P}_{y}^{2}\\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。</p>\n<p>也因此，筛质数筛到$\\sqrt{n}$即可。</p>\n<p>否则，即$\\mathbb{P}_{y}^{2}\\leqslant x$，我们将所有数除以$\\mathbb{P}_{y}$，之前所有最小质因数等于$\\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\\mathbb{P}_{y}$的数。</p>\n<p>又因为$f^{\\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\\prime}(\\cfrac{z}{\\mathbb{P}_{y}})f^{\\prime}(\\mathbb{P}_{y})$计算$f^{\\prime}(z)$。</p>\n<p>那么看起来</p>\n<script type=\"math/tex; mode=display\">F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)</script><p>$F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$包含了三类数的$f^{\\prime}$的值：</p>\n<ol>\n<li>大于等于$\\mathbb{P}_{y}$的质数。</li>\n<li>最小质因数大于等于$\\mathbb{P}_{y}$（大于$\\mathbb{P}_{y-1}$）的合数。</li>\n<li>小于$\\mathbb{P}_{y}$的质数。</li>\n</ol>\n<p>但是很明显第三类数不能被除去，因此实际上</p>\n<script type=\"math/tex; mode=display\">F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)</script><p>综上所述</p>\n<script type=\"math/tex; mode=display\">F(x,y)=\\begin{cases}\n&F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum\\limits_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)\\;\\;&(\\mathbb{P}_{y}^{2}\\leqslant x)\\\\\n&F(x,y-1)&(\\mathbb{P}_{y}^{2}\\gt x)\n\\end{cases}</script><p>初值为</p>\n<script type=\"math/tex; mode=display\">F(x,0)=\\sum_{i=2}^{x}f^{\\prime}(i)</script><p>注意到第二维只与$y-1$有关，我们可以滚掉。</p>\n<p>还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。</p>\n<p>因为$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，这样的$x$最多只有$2\\sqrt{n}$个，我们可以离散化存储。</p>\n<p>具体实现细节我说不清，看代码吧（</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cltstream::read(n);</span><br><span class=\"line\">sq=<span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=sq;++i)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!f[i])&#123;</span><br><span class=\"line\">\t\tg[++g[<span class=\"number\">0</span>]]=i;</span><br><span class=\"line\">\t\tfsum[g[<span class=\"number\">0</span>]]=fsum[g[<span class=\"number\">0</span>]<span class=\"number\">-1</span>]+<span class=\"comment\">/**/</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//注释处应填f`(i)</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=g[<span class=\"number\">0</span>]&amp;&amp;i*g[j]&lt;=sq;++j)&#123;</span><br><span class=\"line\">\t\tf[i*g[j]]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!(i%g[j]))</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">m=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> l=<span class=\"number\">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\tw[++m]=n/l;</span><br><span class=\"line\">\t<span class=\"comment\">//编号对应的离散化前的值</span></span><br><span class=\"line\">\tF[m]=<span class=\"comment\">/**/</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//注释处应填\\sum_&#123;t=2&#125;^&#123;w[m]&#125;f`(t)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(w[m]&lt;=sq)</span><br><span class=\"line\">\t\tid1[w[m]]=m;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\tid2[n/w[m]]=m;</span><br><span class=\"line\">\t<span class=\"comment\">//分段存储值对应的编号，这样数组只需要开到sqrt&#123;n&#125;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=g[<span class=\"number\">0</span>];++j)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=g[j]*g[j];++i)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//w[i]&gt;=g[j]*g[j]，所以w[i]/g[j]&gt;=g[j]</span></span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class=\"line\">\t\tF[i]-=<span class=\"comment\">/**/</span>*(F[id]-fsum[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t<span class=\"comment\">//注释处应填f`(g[j])</span></span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>这一部分的时间复杂度已被证明是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。<del>然而看上去很奇怪（</del></p>\n<h3 id=\"第二部分\"><a href=\"#第二部分\" class=\"headerlink\" title=\"第二部分\"></a>第二部分</h3><p>在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。</p>\n<p>定义</p>\n<script type=\"math/tex; mode=display\">S(x,y)=\\sum_{i=1}^{x}[\\text{minp}(i)\\geqslant\\mathbb{P}_{y}]f(i)</script><p>也就是所有最小质因数大于等于$\\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。</p>\n<p>首先我们需要统计所有质数的贡献，也就是$F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})$。</p>\n<p>关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)</script><p>但是还有一个问题是$S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$中不包括$f(1)$，因此$f(\\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)</script><p>于是</p>\n<script type=\"math/tex; mode=display\">S(x,y)=F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})+\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)</script><p>然后暴力搜，记忆化都不需要，时间复杂度还是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。<del>就很神奇（</del></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">S</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">1</span>||g[y]&gt;x)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> res=F[id]-fsum[y<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=y;i&lt;=g[<span class=\"number\">0</span>]&amp;&amp;g[i]*g[i]&lt;=x;++i)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class=\"line\">\t\t\t\tres+=<span class=\"comment\">/*1*/</span>*S(x/p,i+<span class=\"number\">1</span>)+<span class=\"comment\">/*2*/</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"comment\">//1处应填f(p)，2处应填f(p*g[i])</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h3 id=\"「Luogu-P4213」「模板」杜教筛（Sum）\"><a href=\"#「Luogu-P4213」「模板」杜教筛（Sum）\" class=\"headerlink\" title=\"「Luogu-P4213」「模板」杜教筛（Sum）\"></a><a href=\"https://www.luogu.org/problemnew/show/P4213\" target=\"_blank\" rel=\"noopener\">「Luogu-P4213」「模板」杜教筛（Sum）</a></h3><p>首先我们有</p>\n<script type=\"math/tex; mode=display\">\\varphi(p)=\\text{id}(p)-1</script><script type=\"math/tex; mode=display\">\\mu(p)=-1</script><p>然后$\\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。</p>\n<p>说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 50000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t,n,sq,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> f[maxn+<span class=\"number\">1</span>],g[maxn+<span class=\"number\">1</span>],w[(maxn&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>],id1[maxn+<span class=\"number\">1</span>],id2[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> prmcnt[maxn+<span class=\"number\">1</span>],prmCnt[(maxn&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> prmsum[maxn+<span class=\"number\">1</span>],prmSum[(maxn&lt;&lt;<span class=\"number\">1</span>)+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">getPhi</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">1</span>||g[y]&gt;x)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class=\"line\">\t\tre <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res=(prmSum[id]-prmCnt[id])-(prmsum[y<span class=\"number\">-1</span>]-prmcnt[y<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=y;i&lt;=g[<span class=\"number\">0</span>]&amp;&amp;<span class=\"number\">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> p=g[i];<span class=\"number\">1L</span>L*p*g[i]&lt;=x;p*=g[i])</span><br><span class=\"line\">\t\t\t\tres+=<span class=\"number\">1L</span>L*p/g[i]*(g[i]<span class=\"number\">-1</span>)*getPhi(x/p,i+<span class=\"number\">1</span>)+<span class=\"number\">1L</span>L*p*(g[i]<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getMu</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">1</span>||g[y]&gt;x)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> res=prmcnt[y<span class=\"number\">-1</span>]-prmCnt[id];</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=y;i&lt;=g[<span class=\"number\">0</span>]&amp;&amp;<span class=\"number\">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class=\"line\">\t\t\tres-=getMu(x/g[i],i+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!f[i])&#123;</span><br><span class=\"line\">\t\t\tg[++g[<span class=\"number\">0</span>]]=i;</span><br><span class=\"line\">\t\t\tprmcnt[g[<span class=\"number\">0</span>]]=prmcnt[g[<span class=\"number\">0</span>]<span class=\"number\">-1</span>]+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\tprmsum[g[<span class=\"number\">0</span>]]=prmsum[g[<span class=\"number\">0</span>]<span class=\"number\">-1</span>]+i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=g[<span class=\"number\">0</span>]&amp;&amp;<span class=\"number\">1L</span>L*i*g[j]&lt;=maxn;++j)&#123;</span><br><span class=\"line\">\t\t\tf[i*g[j]]=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(!(i%g[j]))</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">break</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tcltstream::read(t);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;t;--t)&#123;</span><br><span class=\"line\">\t\tcltstream::read(n);</span><br><span class=\"line\">\t\tsq=<span class=\"built_in\">sqrt</span>(n);</span><br><span class=\"line\">\t\tm=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> l=<span class=\"number\">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tw[++m]=n/l;</span><br><span class=\"line\">\t\t\tprmCnt[m]=w[m]<span class=\"number\">-1</span>;</span><br><span class=\"line\">\t\t\tprmSum[m]=<span class=\"number\">1L</span>L*(w[m]<span class=\"number\">-1</span>)*(w[m]+<span class=\"number\">2</span>)/<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(w[m]&lt;=sq)</span><br><span class=\"line\">\t\t\t\tid1[w[m]]=m;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\tid2[n/w[m]]=m;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">1</span>;j&lt;=g[<span class=\"number\">0</span>];++j)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=<span class=\"number\">1L</span>L*g[j]*g[j];++i)&#123;</span><br><span class=\"line\">\t\t\t\tre <span class=\"keyword\">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class=\"line\">\t\t\t\tprmCnt[i]-=prmCnt[id]-prmcnt[j<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t\t\t\tprmSum[i]-=<span class=\"number\">1L</span>L*g[j]*(prmSum[id]-prmsum[j<span class=\"number\">-1</span>]);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\tcltstream::write(getPhi(n,<span class=\"number\">1</span>)+<span class=\"number\">1</span>,<span class=\"number\">32</span>);</span><br><span class=\"line\">\t\tcltstream::write(getMu(n,<span class=\"number\">1</span>)+<span class=\"number\">1</span>,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p><img src=\"/images/TIM截图20190214152934.png\" alt=\"\"></p>\n<p>上为min_25筛，下为杜教筛。</p>\n<p>min_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说</p>\n<h3 id=\"「LOJ6053」简单的函数\"><a href=\"#「LOJ6053」简单的函数\" class=\"headerlink\" title=\"「LOJ6053」简单的函数\"></a><a href=\"https://loj.ac/problem/6053\" target=\"_blank\" rel=\"noopener\">「LOJ6053」简单的函数</a></h3><p>总结一下这个函数：</p>\n<script type=\"math/tex; mode=display\">f(1)=1</script><script type=\"math/tex; mode=display\">f\\left(\\prod_{i=1}^{N}p_{i}^{r_{i}}\\right)=\\prod_{i=1}^{N}(p_{i}\\otimes r_{i})</script><p>其中$\\otimes$表示按位异或。</p>\n<p><img src=\"/images/TIM图片20190103092627.png\" alt=\"\"></p>\n<p>按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（</p>\n<p>注意到</p>\n<script type=\"math/tex; mode=display\">f(p)=p\\otimes 1=\\begin{cases}\n&p+1\\;\\;&(p=2)\\\\\n&p-1\\;\\;&(p\\gt 2)\n\\end{cases}</script><p>我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。</p>\n<p>然后还是要用min_25筛的前半部分筛出$\\text{id}$和$1$，其实和上面的$\\varphi$没多大区别就是加了点细节（</p>\n<p><a href=\"https://loj.ac/submission/336101\" target=\"_blank\" rel=\"noopener\">好像这种能随便看代码的OJ可以直接扔个提交记录</a>。</p>\n<h3 id=\"「UOJ188」Sanrd\"><a href=\"#「UOJ188」Sanrd\" class=\"headerlink\" title=\"「UOJ188」Sanrd\"></a><a href=\"http://uoj.ac/problem/188\" target=\"_blank\" rel=\"noopener\">「UOJ188」Sanrd</a></h3><p>次大质因数和。</p>\n<p>其实这个题面有点考阅读的。</p>\n<p>但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。<del>说好的只能筛积性函数呢（</del></p>\n<p>我们来分析一下min_25筛的运行过程。</p>\n<p>调用到$S(x,y)$时，剩下的最小质因数大于等于$\\mathbb{P}_{y}$的数中，只有质数与$\\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\\mathbb{P}_{y-1}$的数。这部分可以直接算。</p>\n<p>关于次大质因数大于$\\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\\mathbb{P}_{i}^{j})$，手动加。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">S</span><span class=\"params\">(re <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> n,re <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(x&lt;=<span class=\"number\">1</span>||g[y]&gt;x)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> k=id[x&lt;=sq?x:n/x+sq];</span><br><span class=\"line\">\t\tre <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res=(y&gt;<span class=\"number\">1</span>?g[y<span class=\"number\">-1</span>]:<span class=\"number\">0</span>)*(prmCnt[k]-y+<span class=\"number\">1</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=y;i&lt;=g[<span class=\"number\">0</span>]&amp;&amp;<span class=\"number\">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class=\"line\">\t\t\t\tres+=S(n,x/p,i+<span class=\"number\">1</span>)+g[i];</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p><a href=\"http://uoj.ac/submission/324057\" target=\"_blank\" rel=\"noopener\">提交记录</a>。</p>\n<p><del>一道比一道神仙，像我这种菜鸡只能抄题解了（</del></p>\n<h3 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h3><ul>\n<li><a href=\"https://loj.ac/problem/572\" target=\"_blank\" rel=\"noopener\">「LOJ572」「LibreOJ Round #11」Misaka Network与求和</a></li>\n<li><a href=\"https://www.spoj.com/problems/DIVCNTK/\" target=\"_blank\" rel=\"noopener\">「SP34096」DIVCNTK - Counting Divisors (general)</a></li>\n<li><a href=\"https://www.spoj.com/problems/GCDEX2/\" target=\"_blank\" rel=\"noopener\">「SP19985」GCDEX2 - GCD Extreme (hard)</a></li>\n<li><a href=\"https://www.spoj.com/problems/APS2/\" target=\"_blank\" rel=\"noopener\">「SP19975」APS2 - Amazing Prime Sequence (hard)</a></li>\n</ul>\n<h3 id=\"其它文献\"><a href=\"#其它文献\" class=\"headerlink\" title=\"其它文献\"></a>其它文献</h3><ul>\n<li><a href=\"https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096\" target=\"_blank\" rel=\"noopener\">https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096</a></li>\n<li><a href=\"https://www.cnblogs.com/zhoushuyu/p/9187319.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhoushuyu/p/9187319.html</a></li>\n<li><a href=\"https://www.cnblogs.com/cjyyb/p/10169190.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cjyyb/p/10169190.html</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>标题来自某学长安利min_25筛的方式（</p>","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>我们知道，<a href=\"/number-theory-learning-notes/\">杜教筛</a>可以在$O(n^{\\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。</p>\n<p>但是现在我们希望更快。于是我们有了min_25筛（</p>\n<p>以下，我们约定$p$是一个质数。$\\mathbb{P}_{i}$表示第$i$小的质数，$\\mathbb{P}_{0}=0$。$\\text{minp}(n)$表示$n$最小的质因数，$\\text{minp}(1)=0$。</p>\n<p>现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：</p>\n<ol>\n<li>$f(p)$是一个<strong>可以快速求前缀和的完全积性函数</strong>，或者能用多个这样的函数运算得到。</li>\n<li>$f(p^{k})$可以快速求，大概$O(k)$以内就可以。</li>\n</ol>\n<h3 id=\"第一部分\"><a href=\"#第一部分\" class=\"headerlink\" title=\"第一部分\"></a>第一部分</h3><p>我们要对每一个$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，求出</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)</script><p>定义</p>\n<script type=\"math/tex; mode=display\">F(x,y)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}\\vee\\text{minp}(i)\\gt\\mathbb{P}_{y}]f^{\\prime}(i)</script><p>也就是把所有质数和最小质因数大于$\\mathbb{P}_y$的合数全部当成质数代入$f^{\\prime}$求值并求和。不难发现</p>\n<script type=\"math/tex; mode=display\">F(x,+\\infty)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)</script><p>我们回忆一下埃式筛法的运行过程。</p>\n<p>筛完$k$次后，我们除去了最小质因数小于等于$\\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\\mathbb{P}_k$的合数。</p>\n<p>可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\\prime}$的值的和。</p>\n<p>首先，第$y$次筛掉的最小的数很明显是$\\mathbb{P}_{y}^{2}$，如果$\\mathbb{P}_{y}^{2}\\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。</p>\n<p>也因此，筛质数筛到$\\sqrt{n}$即可。</p>\n<p>否则，即$\\mathbb{P}_{y}^{2}\\leqslant x$，我们将所有数除以$\\mathbb{P}_{y}$，之前所有最小质因数等于$\\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\\mathbb{P}_{y}$的数。</p>\n<p>又因为$f^{\\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\\prime}(\\cfrac{z}{\\mathbb{P}_{y}})f^{\\prime}(\\mathbb{P}_{y})$计算$f^{\\prime}(z)$。</p>\n<p>那么看起来</p>\n<script type=\"math/tex; mode=display\">F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)</script><p>$F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$包含了三类数的$f^{\\prime}$的值：</p>\n<ol>\n<li>大于等于$\\mathbb{P}_{y}$的质数。</li>\n<li>最小质因数大于等于$\\mathbb{P}_{y}$（大于$\\mathbb{P}_{y-1}$）的合数。</li>\n<li>小于$\\mathbb{P}_{y}$的质数。</li>\n</ol>\n<p>但是很明显第三类数不能被除去，因此实际上</p>\n<script type=\"math/tex; mode=display\">F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)</script><p>综上所述</p>\n<script type=\"math/tex; mode=display\">F(x,y)=\\begin{cases}\n&F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum\\limits_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)\\;\\;&(\\mathbb{P}_{y}^{2}\\leqslant x)\\\\\n&F(x,y-1)&(\\mathbb{P}_{y}^{2}\\gt x)\n\\end{cases}</script><p>初值为</p>\n<script type=\"math/tex; mode=display\">F(x,0)=\\sum_{i=2}^{x}f^{\\prime}(i)</script><p>注意到第二维只与$y-1$有关，我们可以滚掉。</p>\n<p>还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。</p>\n<p>因为$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，这样的$x$最多只有$2\\sqrt{n}$个，我们可以离散化存储。</p>\n<p>具体实现细节我说不清，看代码吧（</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�38-->\n\n</div></div>\n<p>这一部分的时间复杂度已被证明是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。<del>然而看上去很奇怪（</del></p>\n<h3 id=\"第二部分\"><a href=\"#第二部分\" class=\"headerlink\" title=\"第二部分\"></a>第二部分</h3><p>在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。</p>\n<p>定义</p>\n<script type=\"math/tex; mode=display\">S(x,y)=\\sum_{i=1}^{x}[\\text{minp}(i)\\geqslant\\mathbb{P}_{y}]f(i)</script><p>也就是所有最小质因数大于等于$\\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。</p>\n<p>首先我们需要统计所有质数的贡献，也就是$F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})$。</p>\n<p>关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)</script><p>但是还有一个问题是$S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$中不包括$f(1)$，因此$f(\\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)</script><p>于是</p>\n<script type=\"math/tex; mode=display\">S(x,y)=F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})+\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)</script><p>然后暴力搜，记忆化都不需要，时间复杂度还是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。<del>就很神奇（</del></p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�39-->\n\n</div></div>\n<h3 id=\"「Luogu-P4213」「模板」杜教筛（Sum）\"><a href=\"#「Luogu-P4213」「模板」杜教筛（Sum）\" class=\"headerlink\" title=\"「Luogu-P4213」「模板」杜教筛（Sum）\"></a><a href=\"https://www.luogu.org/problemnew/show/P4213\" target=\"_blank\" rel=\"noopener\">「Luogu-P4213」「模板」杜教筛（Sum）</a></h3><p>首先我们有</p>\n<script type=\"math/tex; mode=display\">\\varphi(p)=\\text{id}(p)-1</script><script type=\"math/tex; mode=display\">\\mu(p)=-1</script><p>然后$\\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。</p>\n<p>说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�40-->\n\n</div></div>\n<p><img src=\"/images/TIM截图20190214152934.png\" alt=\"\"></p>\n<p>上为min_25筛，下为杜教筛。</p>\n<p>min_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说</p>\n<h3 id=\"「LOJ6053」简单的函数\"><a href=\"#「LOJ6053」简单的函数\" class=\"headerlink\" title=\"「LOJ6053」简单的函数\"></a><a href=\"https://loj.ac/problem/6053\" target=\"_blank\" rel=\"noopener\">「LOJ6053」简单的函数</a></h3><p>总结一下这个函数：</p>\n<script type=\"math/tex; mode=display\">f(1)=1</script><script type=\"math/tex; mode=display\">f\\left(\\prod_{i=1}^{N}p_{i}^{r_{i}}\\right)=\\prod_{i=1}^{N}(p_{i}\\otimes r_{i})</script><p>其中$\\otimes$表示按位异或。</p>\n<p><img src=\"/images/TIM图片20190103092627.png\" alt=\"\"></p>\n<p>按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（</p>\n<p>注意到</p>\n<script type=\"math/tex; mode=display\">f(p)=p\\otimes 1=\\begin{cases}\n&p+1\\;\\;&(p=2)\\\\\n&p-1\\;\\;&(p\\gt 2)\n\\end{cases}</script><p>我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。</p>\n<p>然后还是要用min_25筛的前半部分筛出$\\text{id}$和$1$，其实和上面的$\\varphi$没多大区别就是加了点细节（</p>\n<p><a href=\"https://loj.ac/submission/336101\" target=\"_blank\" rel=\"noopener\">好像这种能随便看代码的OJ可以直接扔个提交记录</a>。</p>\n<h3 id=\"「UOJ188」Sanrd\"><a href=\"#「UOJ188」Sanrd\" class=\"headerlink\" title=\"「UOJ188」Sanrd\"></a><a href=\"http://uoj.ac/problem/188\" target=\"_blank\" rel=\"noopener\">「UOJ188」Sanrd</a></h3><p>次大质因数和。</p>\n<p>其实这个题面有点考阅读的。</p>\n<p>但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。<del>说好的只能筛积性函数呢（</del></p>\n<p>我们来分析一下min_25筛的运行过程。</p>\n<p>调用到$S(x,y)$时，剩下的最小质因数大于等于$\\mathbb{P}_{y}$的数中，只有质数与$\\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\\mathbb{P}_{y-1}$的数。这部分可以直接算。</p>\n<p>关于次大质因数大于$\\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\\mathbb{P}_{i}^{j})$，手动加。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�41-->\n\n</div></div>\n<p><a href=\"http://uoj.ac/submission/324057\" target=\"_blank\" rel=\"noopener\">提交记录</a>。</p>\n<p><del>一道比一道神仙，像我这种菜鸡只能抄题解了（</del></p>\n<h3 id=\"课后习题\"><a href=\"#课后习题\" class=\"headerlink\" title=\"课后习题\"></a>课后习题</h3><ul>\n<li><a href=\"https://loj.ac/problem/572\" target=\"_blank\" rel=\"noopener\">「LOJ572」「LibreOJ Round #11」Misaka Network与求和</a></li>\n<li><a href=\"https://www.spoj.com/problems/DIVCNTK/\" target=\"_blank\" rel=\"noopener\">「SP34096」DIVCNTK - Counting Divisors (general)</a></li>\n<li><a href=\"https://www.spoj.com/problems/GCDEX2/\" target=\"_blank\" rel=\"noopener\">「SP19985」GCDEX2 - GCD Extreme (hard)</a></li>\n<li><a href=\"https://www.spoj.com/problems/APS2/\" target=\"_blank\" rel=\"noopener\">「SP19975」APS2 - Amazing Prime Sequence (hard)</a></li>\n</ul>\n<h3 id=\"其它文献\"><a href=\"#其它文献\" class=\"headerlink\" title=\"其它文献\"></a>其它文献</h3><ul>\n<li><a href=\"https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096\" target=\"_blank\" rel=\"noopener\">https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096</a></li>\n<li><a href=\"https://www.cnblogs.com/zhoushuyu/p/9187319.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/zhoushuyu/p/9187319.html</a></li>\n<li><a href=\"https://www.cnblogs.com/cjyyb/p/10169190.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/cjyyb/p/10169190.html</a></li>\n</ul>"},{"title":"一些乱七八糟的数论","date":"2018-11-29T06:41:17.000Z","mathjax":true,"_content":"最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。\n\n~~抄袭来源~~参考文献：\n\n- [铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演](https://lx-2003.blog.luogu.org/mobius-inversion)\n- [浅谈杜教筛](https://www.luogu.org/blog/54745/dls-tql)\n- [铃悬的数学小讲堂——杜教筛](https://lx-2003.blog.luogu.org/dujiao-sieve)\n\n<!-- more -->\n\n# 数论函数\n\n## 定义与相关性质\n\n数论函数就是定义域为$\\mathbb{N}^{+}$的函数。\n\n两个数论函数相加，就是简单地把函数值相加。\n\n$$(f+g)(n)=f(n)+g(n)$$\n\n数乘也是类似的。\n\n$$(\\alpha f)(n)=\\alpha f(n)$$\n\n点积也是类似的。\n\n$$(f\\cdot g)(n)=f(n)g(n)$$\n\n~~好像没啥用。~~\n\n在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：\n\n$$(f\\times g)(n)=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})$$\n\n或者说：\n\n$$(f\\times g)(n)=\\sum\\limits_{ij=n}f(i)g(j)$$\n\n它具有以下的一些性质：\n\n交换律，即$f\\times g=g\\times f$。\n\n这很明显。\n\n结合律，即$(f\\times g)\\times h=f\\times(g\\times h)$。\n\n$$\\begin{aligned}\n((f\\times g)\\times h)(n)&=\\sum\\limits_{ij=n}(\\sum\\limits_{kl=i}f(k)g(l))h(j)\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}$$\n\n$$\\begin{aligned}\n(f\\times(g\\times h))(n)&=\\sum\\limits_{ij=n}f(i)(\\sum\\limits_{kl=j}g(k)h(l))\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}$$\n\n分配率，即$(f+g)\\times h=f\\times h+g\\times h$。\n\n$$\\begin{aligned}\n((f+g)\\times h)(n)&=\\sum\\limits_{ij=n}(f+g)(i)h(j)\\\\\n&=\\sum\\limits_{ij=n}f(i)h(j)+g(i)h(j)\\\\\n&=(f\\times h)(n)+(g\\times h)(n)\n\\end{aligned}$$\n\n单位元为$\\epsilon(n)=[n=1]$，$f\\times\\epsilon =f$。\n\n这也很明显。\n\n对于任意一个满足$f(1)\\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\\times g=\\epsilon$。这时我们称$g$是$f$的逆。\n\n我们可以这样定义一个函数的逆：\n\n$$g(n)=\\cfrac{\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})}{f(1)}$$\n\n这样我们就有\n\n$$\\begin{aligned}\n(f\\times g)(n)&=\\sum_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=f(1)g(n)+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)\n\\end{aligned}$$\n\n## 积性函数与完全积性函数\n\n如果一个数论函数$f$满足\n\n$$\\forall x,y\\in\\mathbb{N}^{+}\\wedge x\\perp y\\;\\;f(xy)=f(x)f(y)$$\n\n我们就说$f$是一个积性函数。\n\n特别的，如果上式去掉$x\\perp y$仍成立，则称$f$是一个完全积性函数。\n\n很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\\times n)=f(1)\\times f(n)=f(n)$。\n\n常见的完全积性函数有$\\epsilon,id^{k}$。$\\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。\n\n常见的积性函数有$\\varphi,d,\\sigma$。$\\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\\sigma(n)$的值分别等于$n$的约数个数和约数和。\n\n关于$\\varphi$的积性，我并不会证（\n\n我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设\n\n$$n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}$$\n\n其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有\n\n$$d(n)=\\prod\\limits_{i=1}^{N}(r_{i}+1)$$\n\n我们再假设有一个$m$，且\n\n$$m=\\prod\\limits_{i=1}^{M}q_{i}^{s_{i}}$$\n\n如果说$n\\perp m$，肯定有\n\n$$\\forall i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z}\\;\\;p_{i}\\neq q_{j}$$\n\n于是我们就有\n\n$$nm=(\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}})(\\prod\\limits_{j=1}^{M}q_{j}^{s_{j}})$$\n\n$$\\begin{aligned}\nd(nm)&=(\\prod\\limits_{i=1}^{N}(r_{i}+1))(\\prod\\limits_{j=1}^{M}(s_{j}+1))\\\\\n&=d(n)d(m)\n\\end{aligned}$$\n\n不妨再反过来考虑。如果说$n\\not\\perp m$，那么一定存在一对$(i,j)(i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\\neq d(n)d(m)$。\n\n我们再来分析$\\sigma$的积性。还是设\n\n$$n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}$$\n\n其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\\in [0,r_{i}]\\cap\\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是\n\n$$\\prod\\limits_{i=1}^{N}\\sum\\limits_{j=0}^{r_{i}}p_{i}^{j}$$\n\n这正是$\\sigma(n)$的值。\n\n接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。\n\n现在我们来分析，两个积性函数的卷积是否也是积性函数。~~虽然说都这么问了肯定就是了。~~\n\n$$\\begin{aligned}\n(f\\times g)(n)(f\\times g)(m)&=(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(i)g(\\cfrac{n}{i})f(j)g(\\cfrac{m}{j})\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(ij)g(\\cfrac{nm}{ij})\\\\\n&=\\sum\\limits_{k\\mid nm}f(k)g(\\cfrac{nm}{k})\\\\\n&=(f\\times g)(nm)\n\\end{aligned}$$\n\n关于上面的第四个等号。时刻注意$n\\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。\n\n再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。\n\n设有一个积性函数$f$，它的逆是$g$。\n\n当$nm=1$时，$g(1)=1$。\n\n当$nm>1$时，我们假设对于任意$n^{\\prime}m^{\\prime}<nm$，都有$g(n^{\\prime}m^{\\prime})=g(n^{\\prime})g(m^{\\prime})$。此时\n\n$$\\begin{aligned}\ng(nm)&=-\\sum\\limits_{k\\mid nm,k\\neq 1}f(k)g(\\cfrac{nm}{k})\\\\\n&=-\\sum\\limits_{i\\mid n,j\\mid m,ij\\neq 1}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-\\sum\\limits_{i\\mid n,j\\mid m}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=g(n)g(m)-\\epsilon(n)\\epsilon(m)\\\\\n&=g(n)g(m)\n\\end{aligned}$$\n\n~~其实上面这些全都是抄来的（~~\n\n# 莫比乌斯反演\n\n## 正向反演\n\n定义$\\mu$为$1$的逆。也就是说，$\\mu\\times 1=\\epsilon$。\n\n如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：\n\n> 首先地，$\\mu(1)=1$。当$n>1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\\mu(n)=(-1)^{k}$。否则，$\\mu(n)=0$。\n\n那么，这两种定义等价吗？\n\n考虑到$\\mu$是一个积性函数，对于任意一个$n>1$，如果我们把它分解成\n\n$$n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}$$\n\n我们就有\n\n$$\\mu(n)=\\prod\\limits_{i=1}^{N}\\mu(p_{i}^{r_{i}})$$\n\n因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。\n\n设有一个质数$p$。不难发现\n\n$$\\mu(p)=-\\mu(1)=-1$$\n\n$$\\mu(p^{2})=-\\mu(1)-\\mu(p)=-1+1=0$$\n\n$$\\mu(p^{3})=-\\mu(1)-\\mu(p)-\\mu(p^{2})=-1+1+0=0$$\n\n$$\\vdots$$\n\n至此，不难看出上文给出的两种定义是等价的。\n\n那么这个东西有什么用呢？\n\n我们设\n\n$$F(n)=\\sum\\limits_{i\\mid n}f(i)$$\n\n或者等价地说，$F=f\\times 1$。我们可以得到\n\n$$\\begin{aligned}\nF&=f\\times 1\\\\\nF\\times\\mu&=f\\times 1\\times\\mu\\\\\nF\\times\\mu&=f\n\\end{aligned}$$\n\n像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说\n\n$$f(n)=\\sum\\limits_{i\\mid n}F(i)\\mu(\\cfrac{n}{i})$$\n\n## 反向反演\n\n有些时候我们还需要用到像下面这样反过来的莫比乌斯反演\n\n$$F(n)=\\sum\\limits_{n\\mid d}f(d)⇔f(n)=\\sum\\limits_{n\\mid d}F(d)\\mu(\\cfrac{d}{n})$$\n\n我们可以定义一种新的运算\n\n$$(f\\otimes g)(n)=\\sum\\limits_{n\\mid d}f(d)g(\\cfrac{d}{n})$$\n\n我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有\n\n$$F=f\\otimes 1⇔F\\otimes\\mu=f$$\n\n于是就有了上面的反向反演。\n\n> Updated on 2018-12-03\n>\n> 例题……还是算了吧（\n>\n> 发现反演常用的套路都忘的差不多了，还是别丢人了（\n\n# 杜教筛\n\n## 实现与模板题\n\n接下来才是主要内容。\n\n现在，我们要求一个积性函数的前$n$项和。$n\\leqslant 10^{10}$。\n\n我们定义\n\n$$S(n)=\\sum\\limits_{i=1}^{n}f(i)$$\n\n再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。\n\n$$\\begin{aligned}\n\\sum_{i=1}^{n}(f\\times g)(i)&=\\sum_{i=1}^{n}\\sum_{j\\mid i}f(j)g(\\cfrac{i}{j})\\\\\n&=\\sum_{i=1}^{n}g(i)\\sum_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}$$\n\n然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（\n\n因为$g$也是积性函数，有$g(1)=1$，所以\n\n$$\\begin{aligned}\nS(n)&=g(1)S(n)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\\\\\n&=\\sum_{i=1}^{n}(f\\times g)(i)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}$$\n\n就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。\n\n如果说我们选择的$g$可以让我们迅速地求出$f\\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。\n\n关于后面的$g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。\n\n我们来分析一下$\\lfloor\\cfrac{n}{i}\\rfloor$。如果$1\\leqslant i\\leqslant\\sqrt{n}$，因为$i$只有$\\sqrt{n}$种不同的取值，$\\lfloor\\cfrac{n}{i}\\rfloor$同样也只有$\\sqrt{n}$种不同的取值。如果$\\sqrt{n}<i\\leqslant n$，$1\\leqslant\\lfloor\\cfrac{n}{i}\\rfloor<\\sqrt{n}$，又因为要向下取整，自然也只有$\\sqrt{n}$种不同的取值。如果我们能够把$\\lfloor\\cfrac{n}{i}\\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\\sqrt{n})$。\n\n大体代码如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int l=1,r;l<=n;l=r+1){\n\tr=n/(n/l);\n\t//......\n}\n```\n\n{% endfold %}\n\n关于$r$的这个上界是怎么来的，我并不会证（\n\n这样一来，要计算$S(n)$，我们需要调用所有的$\\lfloor\\cfrac{n}{x}\\rfloor$，分别是$\\lfloor\\cfrac{n}{1}\\rfloor,\\lfloor\\cfrac{n}{2}\\rfloor,\\cdots,\\lfloor\\cfrac{n}{\\sqrt{n}}\\rfloor,\\sqrt{n},\\sqrt{n}-1,\\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\\sqrt{n})$的。那么这样一来，总体的时间复杂度就是\n\n$$\\begin{aligned}\nO(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{i}+\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})&=O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{x}\\rfloor}dx)\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\cfrac{n}{x}}dx)\\\\\n&=O(2n^{\\frac{1}{2}}(n^{\\frac{1}{4}}-1))\\\\\n&=O(n^{\\frac{3}{4}})\n\\end{aligned}$$\n\n因为相比之下$\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor}$很明显要大一些，我们就可以将$\\sqrt{i}$舍去。然后去掉取整符号并用积分近似。\n\n这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\\cfrac{n}{\\sqrt{m}})$，当$m=n^{\\frac{2}{3}}$时取得最小值$O(n^{\\frac{2}{3}})$。\n\n举个例子，就比如说我们要求\n\n$$\\sum\\limits_{i=1}^{n}\\varphi(i)$$\n\n我们取$f=\\varphi,g=1$，这样根据$\\varphi$的性质，$f\\times g=id$。不难看出$g$与$f\\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nlong long getSum(int n){\n\tif(n<=maxn)\n\t\treturn phi[n];\n\t//phi是提前线性筛好的前缀和\n\tif(ans.count(n))\n\t\treturn ans[n];\n\t//ans用来实现记忆化的哈希表，比如说unordered_map\n\tre long long res=1LL*n*(n+1)>>1;\n\t//f*g的前缀和\n\tfor(re int l=2,r;l<=n;l=r+1){\n\t//注意要从2开始\n\t\tr=n/(n/l);\n\t\tres-=(r-l+1)*getSum(n/l);\n\t\t//r-l+1是g的前缀和\n\t\t//像这样递归+记忆化求解f的前缀和\n\t}\n\treturn ans[n]=res;\n\t//返回的时候不要忘记存一下\n\t//就比如说我就忘过一次（\n}\n```\n\n{% endfold %}\n\n以及，不用哈希表也是可以的。因为我们查询的数都是形如$\\lfloor\\cfrac{n}{x}\\rfloor$的，当这个值大于$n^{\\frac{2}{3}}$，即$x<n^{\\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令`ans[x]`表示$S(\\lfloor\\cfrac{n}{x}\\rfloor)$。具体代码我就不写了（\n\n再举个例子，求\n\n$$\\sum\\limits_{i=1}^{n}\\mu(i)$$\n\n取$f=\\mu,g=1,f\\times g=\\epsilon$。代码和上面差不多。\n\n如果您理解了上面两个函数，这道[模板题](https://www.luogu.org/problemnew/show/P4213)您就可以切了。\n\n## 其他题\n\n### [「Luogu-P3768」简单的数学题](https://www.luogu.org/problemnew/show/P3768)\n\n快乐地推式子：\n\n$$\\begin{aligned}\n\\sum\\limits_{i=1}^{n}i\\sum\\limits_{j=1}^{n}j\\text{gcd}(i,j)&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}x^{2}\\mu(x)\\text{Sum}^{2}(\\lfloor\\cfrac{n}{dx}\\rfloor)\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\sum\\limits_{j\\mid i}j\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\varphi(i)\n\\end{aligned}$$\n\n其中\n\n$$\\text{Sum}(n)=\\sum\\limits_{i=1}^{n}i$$\n\n最后一步是因为\n\n$$\\begin{aligned}\nid\\times\\mu&=\\varphi\\times 1\\times\\mu\\\\\n&=\\varphi\\times\\epsilon\\\\\n&=\\varphi\n\\end{aligned}$$\n\n理解不了上面的式子的话就多看看吧（\n\n不难发现我们是要求$f(n)=n^{2}\\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？\n\n~~枚举瞎蒙（~~\n\n考虑$g(n)=n^{2}$。\n\n$$\\begin{aligned}\n(f\\times g)(n)&=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=\\sum\\limits_{i\\mid n}i^{2}\\varphi(i)\\cfrac{n^{2}}{i^{2}}\\\\\n&=n^{2}\\sum\\limits_{i\\mid n}\\varphi(i)\\\\\n&=n^{3}\n\\end{aligned}$$\n\n~~其实我都不知道我当时是怎么想到这种操作的（~~\n\n然后就和上面一样了。\n\n### [「Luogu-U18201」分析矿洞](https://www.luogu.org/problemnew/show/U18201)\n\n不知道从哪翻出来的题（\n\n是某场个人邀请赛的$\\text{T}1$~~，从某种意义上也能看出那场比赛有多么神仙~~。\n\n$$\\begin{aligned}\n\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\varphi(\\text{gcd}^{2}(i,j))&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(x)\\lfloor\\cfrac{n}{dx}\\rfloor^{2}\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}\\varphi(j^{2})\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}j\\varphi(j)\\mu(\\cfrac{i}{j})\n\\end{aligned}$$\n\n设$f_1(n)=n\\varphi(n),f_2(n)=\\mu(n)$，考虑筛$f=f_1\\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\\times g$的前缀和。一种较优的方案是，令$g=1$，$f\\times g=(id\\cdot\\varphi)\\times\\mu\\times 1=id\\cdot\\varphi$，这样，我们还需要筛出$f_1(n)=n\\varphi(n)$的前缀和。\n\n怎么办？\n\n再套一层杜教筛！\n\n然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（\n\n以及，像这种$n$爆了`int`的，一定要注意经常取模。~~因为这个WA了好几次（~~\n\n最后，源文件$17\\text{KB}​$祭，blog翻页祭。\n","source":"_posts/2018-11-29-number-theory-learning-notes.md","raw":"---\ntitle: 一些乱七八糟的数论\ndate: 2018-11-29 14:41:17\ntags:\n  - 数论\n  - 杜教筛\ncategories:\n  - 学习笔记\nmathjax: true\n---\n最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。\n\n~~抄袭来源~~参考文献：\n\n- [铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演](https://lx-2003.blog.luogu.org/mobius-inversion)\n- [浅谈杜教筛](https://www.luogu.org/blog/54745/dls-tql)\n- [铃悬的数学小讲堂——杜教筛](https://lx-2003.blog.luogu.org/dujiao-sieve)\n\n<!-- more -->\n\n# 数论函数\n\n## 定义与相关性质\n\n数论函数就是定义域为$\\mathbb{N}^{+}$的函数。\n\n两个数论函数相加，就是简单地把函数值相加。\n\n$$(f+g)(n)=f(n)+g(n)$$\n\n数乘也是类似的。\n\n$$(\\alpha f)(n)=\\alpha f(n)$$\n\n点积也是类似的。\n\n$$(f\\cdot g)(n)=f(n)g(n)$$\n\n~~好像没啥用。~~\n\n在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：\n\n$$(f\\times g)(n)=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})$$\n\n或者说：\n\n$$(f\\times g)(n)=\\sum\\limits_{ij=n}f(i)g(j)$$\n\n它具有以下的一些性质：\n\n交换律，即$f\\times g=g\\times f$。\n\n这很明显。\n\n结合律，即$(f\\times g)\\times h=f\\times(g\\times h)$。\n\n$$\\begin{aligned}\n((f\\times g)\\times h)(n)&=\\sum\\limits_{ij=n}(\\sum\\limits_{kl=i}f(k)g(l))h(j)\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}$$\n\n$$\\begin{aligned}\n(f\\times(g\\times h))(n)&=\\sum\\limits_{ij=n}f(i)(\\sum\\limits_{kl=j}g(k)h(l))\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}$$\n\n分配率，即$(f+g)\\times h=f\\times h+g\\times h$。\n\n$$\\begin{aligned}\n((f+g)\\times h)(n)&=\\sum\\limits_{ij=n}(f+g)(i)h(j)\\\\\n&=\\sum\\limits_{ij=n}f(i)h(j)+g(i)h(j)\\\\\n&=(f\\times h)(n)+(g\\times h)(n)\n\\end{aligned}$$\n\n单位元为$\\epsilon(n)=[n=1]$，$f\\times\\epsilon =f$。\n\n这也很明显。\n\n对于任意一个满足$f(1)\\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\\times g=\\epsilon$。这时我们称$g$是$f$的逆。\n\n我们可以这样定义一个函数的逆：\n\n$$g(n)=\\cfrac{\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})}{f(1)}$$\n\n这样我们就有\n\n$$\\begin{aligned}\n(f\\times g)(n)&=\\sum_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=f(1)g(n)+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)\n\\end{aligned}$$\n\n## 积性函数与完全积性函数\n\n如果一个数论函数$f$满足\n\n$$\\forall x,y\\in\\mathbb{N}^{+}\\wedge x\\perp y\\;\\;f(xy)=f(x)f(y)$$\n\n我们就说$f$是一个积性函数。\n\n特别的，如果上式去掉$x\\perp y$仍成立，则称$f$是一个完全积性函数。\n\n很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\\times n)=f(1)\\times f(n)=f(n)$。\n\n常见的完全积性函数有$\\epsilon,id^{k}$。$\\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。\n\n常见的积性函数有$\\varphi,d,\\sigma$。$\\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\\sigma(n)$的值分别等于$n$的约数个数和约数和。\n\n关于$\\varphi$的积性，我并不会证（\n\n我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设\n\n$$n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}$$\n\n其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有\n\n$$d(n)=\\prod\\limits_{i=1}^{N}(r_{i}+1)$$\n\n我们再假设有一个$m$，且\n\n$$m=\\prod\\limits_{i=1}^{M}q_{i}^{s_{i}}$$\n\n如果说$n\\perp m$，肯定有\n\n$$\\forall i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z}\\;\\;p_{i}\\neq q_{j}$$\n\n于是我们就有\n\n$$nm=(\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}})(\\prod\\limits_{j=1}^{M}q_{j}^{s_{j}})$$\n\n$$\\begin{aligned}\nd(nm)&=(\\prod\\limits_{i=1}^{N}(r_{i}+1))(\\prod\\limits_{j=1}^{M}(s_{j}+1))\\\\\n&=d(n)d(m)\n\\end{aligned}$$\n\n不妨再反过来考虑。如果说$n\\not\\perp m$，那么一定存在一对$(i,j)(i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\\neq d(n)d(m)$。\n\n我们再来分析$\\sigma$的积性。还是设\n\n$$n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}$$\n\n其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\\in [0,r_{i}]\\cap\\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是\n\n$$\\prod\\limits_{i=1}^{N}\\sum\\limits_{j=0}^{r_{i}}p_{i}^{j}$$\n\n这正是$\\sigma(n)$的值。\n\n接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。\n\n现在我们来分析，两个积性函数的卷积是否也是积性函数。~~虽然说都这么问了肯定就是了。~~\n\n$$\\begin{aligned}\n(f\\times g)(n)(f\\times g)(m)&=(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(i)g(\\cfrac{n}{i})f(j)g(\\cfrac{m}{j})\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(ij)g(\\cfrac{nm}{ij})\\\\\n&=\\sum\\limits_{k\\mid nm}f(k)g(\\cfrac{nm}{k})\\\\\n&=(f\\times g)(nm)\n\\end{aligned}$$\n\n关于上面的第四个等号。时刻注意$n\\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。\n\n再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。\n\n设有一个积性函数$f$，它的逆是$g$。\n\n当$nm=1$时，$g(1)=1$。\n\n当$nm>1$时，我们假设对于任意$n^{\\prime}m^{\\prime}<nm$，都有$g(n^{\\prime}m^{\\prime})=g(n^{\\prime})g(m^{\\prime})$。此时\n\n$$\\begin{aligned}\ng(nm)&=-\\sum\\limits_{k\\mid nm,k\\neq 1}f(k)g(\\cfrac{nm}{k})\\\\\n&=-\\sum\\limits_{i\\mid n,j\\mid m,ij\\neq 1}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-\\sum\\limits_{i\\mid n,j\\mid m}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=g(n)g(m)-\\epsilon(n)\\epsilon(m)\\\\\n&=g(n)g(m)\n\\end{aligned}$$\n\n~~其实上面这些全都是抄来的（~~\n\n# 莫比乌斯反演\n\n## 正向反演\n\n定义$\\mu$为$1$的逆。也就是说，$\\mu\\times 1=\\epsilon$。\n\n如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：\n\n> 首先地，$\\mu(1)=1$。当$n>1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\\mu(n)=(-1)^{k}$。否则，$\\mu(n)=0$。\n\n那么，这两种定义等价吗？\n\n考虑到$\\mu$是一个积性函数，对于任意一个$n>1$，如果我们把它分解成\n\n$$n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}$$\n\n我们就有\n\n$$\\mu(n)=\\prod\\limits_{i=1}^{N}\\mu(p_{i}^{r_{i}})$$\n\n因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。\n\n设有一个质数$p$。不难发现\n\n$$\\mu(p)=-\\mu(1)=-1$$\n\n$$\\mu(p^{2})=-\\mu(1)-\\mu(p)=-1+1=0$$\n\n$$\\mu(p^{3})=-\\mu(1)-\\mu(p)-\\mu(p^{2})=-1+1+0=0$$\n\n$$\\vdots$$\n\n至此，不难看出上文给出的两种定义是等价的。\n\n那么这个东西有什么用呢？\n\n我们设\n\n$$F(n)=\\sum\\limits_{i\\mid n}f(i)$$\n\n或者等价地说，$F=f\\times 1$。我们可以得到\n\n$$\\begin{aligned}\nF&=f\\times 1\\\\\nF\\times\\mu&=f\\times 1\\times\\mu\\\\\nF\\times\\mu&=f\n\\end{aligned}$$\n\n像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说\n\n$$f(n)=\\sum\\limits_{i\\mid n}F(i)\\mu(\\cfrac{n}{i})$$\n\n## 反向反演\n\n有些时候我们还需要用到像下面这样反过来的莫比乌斯反演\n\n$$F(n)=\\sum\\limits_{n\\mid d}f(d)⇔f(n)=\\sum\\limits_{n\\mid d}F(d)\\mu(\\cfrac{d}{n})$$\n\n我们可以定义一种新的运算\n\n$$(f\\otimes g)(n)=\\sum\\limits_{n\\mid d}f(d)g(\\cfrac{d}{n})$$\n\n我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有\n\n$$F=f\\otimes 1⇔F\\otimes\\mu=f$$\n\n于是就有了上面的反向反演。\n\n> Updated on 2018-12-03\n>\n> 例题……还是算了吧（\n>\n> 发现反演常用的套路都忘的差不多了，还是别丢人了（\n\n# 杜教筛\n\n## 实现与模板题\n\n接下来才是主要内容。\n\n现在，我们要求一个积性函数的前$n$项和。$n\\leqslant 10^{10}$。\n\n我们定义\n\n$$S(n)=\\sum\\limits_{i=1}^{n}f(i)$$\n\n再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。\n\n$$\\begin{aligned}\n\\sum_{i=1}^{n}(f\\times g)(i)&=\\sum_{i=1}^{n}\\sum_{j\\mid i}f(j)g(\\cfrac{i}{j})\\\\\n&=\\sum_{i=1}^{n}g(i)\\sum_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}$$\n\n然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（\n\n因为$g$也是积性函数，有$g(1)=1$，所以\n\n$$\\begin{aligned}\nS(n)&=g(1)S(n)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\\\\\n&=\\sum_{i=1}^{n}(f\\times g)(i)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}$$\n\n就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。\n\n如果说我们选择的$g$可以让我们迅速地求出$f\\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。\n\n关于后面的$g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。\n\n我们来分析一下$\\lfloor\\cfrac{n}{i}\\rfloor$。如果$1\\leqslant i\\leqslant\\sqrt{n}$，因为$i$只有$\\sqrt{n}$种不同的取值，$\\lfloor\\cfrac{n}{i}\\rfloor$同样也只有$\\sqrt{n}$种不同的取值。如果$\\sqrt{n}<i\\leqslant n$，$1\\leqslant\\lfloor\\cfrac{n}{i}\\rfloor<\\sqrt{n}$，又因为要向下取整，自然也只有$\\sqrt{n}$种不同的取值。如果我们能够把$\\lfloor\\cfrac{n}{i}\\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\\sqrt{n})$。\n\n大体代码如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(re int l=1,r;l<=n;l=r+1){\n\tr=n/(n/l);\n\t//......\n}\n```\n\n{% endfold %}\n\n关于$r$的这个上界是怎么来的，我并不会证（\n\n这样一来，要计算$S(n)$，我们需要调用所有的$\\lfloor\\cfrac{n}{x}\\rfloor$，分别是$\\lfloor\\cfrac{n}{1}\\rfloor,\\lfloor\\cfrac{n}{2}\\rfloor,\\cdots,\\lfloor\\cfrac{n}{\\sqrt{n}}\\rfloor,\\sqrt{n},\\sqrt{n}-1,\\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\\sqrt{n})$的。那么这样一来，总体的时间复杂度就是\n\n$$\\begin{aligned}\nO(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{i}+\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})&=O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{x}\\rfloor}dx)\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\cfrac{n}{x}}dx)\\\\\n&=O(2n^{\\frac{1}{2}}(n^{\\frac{1}{4}}-1))\\\\\n&=O(n^{\\frac{3}{4}})\n\\end{aligned}$$\n\n因为相比之下$\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor}$很明显要大一些，我们就可以将$\\sqrt{i}$舍去。然后去掉取整符号并用积分近似。\n\n这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\\cfrac{n}{\\sqrt{m}})$，当$m=n^{\\frac{2}{3}}$时取得最小值$O(n^{\\frac{2}{3}})$。\n\n举个例子，就比如说我们要求\n\n$$\\sum\\limits_{i=1}^{n}\\varphi(i)$$\n\n我们取$f=\\varphi,g=1$，这样根据$\\varphi$的性质，$f\\times g=id$。不难看出$g$与$f\\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nlong long getSum(int n){\n\tif(n<=maxn)\n\t\treturn phi[n];\n\t//phi是提前线性筛好的前缀和\n\tif(ans.count(n))\n\t\treturn ans[n];\n\t//ans用来实现记忆化的哈希表，比如说unordered_map\n\tre long long res=1LL*n*(n+1)>>1;\n\t//f*g的前缀和\n\tfor(re int l=2,r;l<=n;l=r+1){\n\t//注意要从2开始\n\t\tr=n/(n/l);\n\t\tres-=(r-l+1)*getSum(n/l);\n\t\t//r-l+1是g的前缀和\n\t\t//像这样递归+记忆化求解f的前缀和\n\t}\n\treturn ans[n]=res;\n\t//返回的时候不要忘记存一下\n\t//就比如说我就忘过一次（\n}\n```\n\n{% endfold %}\n\n以及，不用哈希表也是可以的。因为我们查询的数都是形如$\\lfloor\\cfrac{n}{x}\\rfloor$的，当这个值大于$n^{\\frac{2}{3}}$，即$x<n^{\\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令`ans[x]`表示$S(\\lfloor\\cfrac{n}{x}\\rfloor)$。具体代码我就不写了（\n\n再举个例子，求\n\n$$\\sum\\limits_{i=1}^{n}\\mu(i)$$\n\n取$f=\\mu,g=1,f\\times g=\\epsilon$。代码和上面差不多。\n\n如果您理解了上面两个函数，这道[模板题](https://www.luogu.org/problemnew/show/P4213)您就可以切了。\n\n## 其他题\n\n### [「Luogu-P3768」简单的数学题](https://www.luogu.org/problemnew/show/P3768)\n\n快乐地推式子：\n\n$$\\begin{aligned}\n\\sum\\limits_{i=1}^{n}i\\sum\\limits_{j=1}^{n}j\\text{gcd}(i,j)&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}x^{2}\\mu(x)\\text{Sum}^{2}(\\lfloor\\cfrac{n}{dx}\\rfloor)\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\sum\\limits_{j\\mid i}j\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\varphi(i)\n\\end{aligned}$$\n\n其中\n\n$$\\text{Sum}(n)=\\sum\\limits_{i=1}^{n}i$$\n\n最后一步是因为\n\n$$\\begin{aligned}\nid\\times\\mu&=\\varphi\\times 1\\times\\mu\\\\\n&=\\varphi\\times\\epsilon\\\\\n&=\\varphi\n\\end{aligned}$$\n\n理解不了上面的式子的话就多看看吧（\n\n不难发现我们是要求$f(n)=n^{2}\\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？\n\n~~枚举瞎蒙（~~\n\n考虑$g(n)=n^{2}$。\n\n$$\\begin{aligned}\n(f\\times g)(n)&=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=\\sum\\limits_{i\\mid n}i^{2}\\varphi(i)\\cfrac{n^{2}}{i^{2}}\\\\\n&=n^{2}\\sum\\limits_{i\\mid n}\\varphi(i)\\\\\n&=n^{3}\n\\end{aligned}$$\n\n~~其实我都不知道我当时是怎么想到这种操作的（~~\n\n然后就和上面一样了。\n\n### [「Luogu-U18201」分析矿洞](https://www.luogu.org/problemnew/show/U18201)\n\n不知道从哪翻出来的题（\n\n是某场个人邀请赛的$\\text{T}1$~~，从某种意义上也能看出那场比赛有多么神仙~~。\n\n$$\\begin{aligned}\n\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\varphi(\\text{gcd}^{2}(i,j))&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(x)\\lfloor\\cfrac{n}{dx}\\rfloor^{2}\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}\\varphi(j^{2})\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}j\\varphi(j)\\mu(\\cfrac{i}{j})\n\\end{aligned}$$\n\n设$f_1(n)=n\\varphi(n),f_2(n)=\\mu(n)$，考虑筛$f=f_1\\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\\times g$的前缀和。一种较优的方案是，令$g=1$，$f\\times g=(id\\cdot\\varphi)\\times\\mu\\times 1=id\\cdot\\varphi$，这样，我们还需要筛出$f_1(n)=n\\varphi(n)$的前缀和。\n\n怎么办？\n\n再套一层杜教筛！\n\n然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（\n\n以及，像这种$n$爆了`int`的，一定要注意经常取模。~~因为这个WA了好几次（~~\n\n最后，源文件$17\\text{KB}​$祭，blog翻页祭。\n","slug":"number-theory-learning-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpxk004o34cwg5dzzj7d","content":"<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p>\n<p><del>抄袭来源</del>参考文献：</p>\n<ul>\n<li><a href=\"https://lx-2003.blog.luogu.org/mobius-inversion\" target=\"_blank\" rel=\"noopener\">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li>\n<li><a href=\"https://www.luogu.org/blog/54745/dls-tql\" target=\"_blank\" rel=\"noopener\">浅谈杜教筛</a></li>\n<li><a href=\"https://lx-2003.blog.luogu.org/dujiao-sieve\" target=\"_blank\" rel=\"noopener\">铃悬的数学小讲堂——杜教筛</a></li>\n</ul>\n<a id=\"more\"></a>\n<h1 id=\"数论函数\"><a href=\"#数论函数\" class=\"headerlink\" title=\"数论函数\"></a>数论函数</h1><h2 id=\"定义与相关性质\"><a href=\"#定义与相关性质\" class=\"headerlink\" title=\"定义与相关性质\"></a>定义与相关性质</h2><p>数论函数就是定义域为$\\mathbb{N}^{+}$的函数。</p>\n<p>两个数论函数相加，就是简单地把函数值相加。</p>\n<script type=\"math/tex; mode=display\">(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p>\n<script type=\"math/tex; mode=display\">(\\alpha f)(n)=\\alpha f(n)</script><p>点积也是类似的。</p>\n<script type=\"math/tex; mode=display\">(f\\cdot g)(n)=f(n)g(n)</script><p><del>好像没啥用。</del></p>\n<p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p>\n<script type=\"math/tex; mode=display\">(f\\times g)(n)=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})</script><p>或者说：</p>\n<script type=\"math/tex; mode=display\">(f\\times g)(n)=\\sum\\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p>\n<p>交换律，即$f\\times g=g\\times f$。</p>\n<p>这很明显。</p>\n<p>结合律，即$(f\\times g)\\times h=f\\times(g\\times h)$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n((f\\times g)\\times h)(n)&=\\sum\\limits_{ij=n}(\\sum\\limits_{kl=i}f(k)g(l))h(j)\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times(g\\times h))(n)&=\\sum\\limits_{ij=n}f(i)(\\sum\\limits_{kl=j}g(k)h(l))\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}</script><p>分配率，即$(f+g)\\times h=f\\times h+g\\times h$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n((f+g)\\times h)(n)&=\\sum\\limits_{ij=n}(f+g)(i)h(j)\\\\\n&=\\sum\\limits_{ij=n}f(i)h(j)+g(i)h(j)\\\\\n&=(f\\times h)(n)+(g\\times h)(n)\n\\end{aligned}</script><p>单位元为$\\epsilon(n)=[n=1]$，$f\\times\\epsilon =f$。</p>\n<p>这也很明显。</p>\n<p>对于任意一个满足$f(1)\\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\\times g=\\epsilon$。这时我们称$g$是$f$的逆。</p>\n<p>我们可以这样定义一个函数的逆：</p>\n<script type=\"math/tex; mode=display\">g(n)=\\cfrac{\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times g)(n)&=\\sum_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=f(1)g(n)+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)\n\\end{aligned}</script><h2 id=\"积性函数与完全积性函数\"><a href=\"#积性函数与完全积性函数\" class=\"headerlink\" title=\"积性函数与完全积性函数\"></a>积性函数与完全积性函数</h2><p>如果一个数论函数$f$满足</p>\n<script type=\"math/tex; mode=display\">\\forall x,y\\in\\mathbb{N}^{+}\\wedge x\\perp y\\;\\;f(xy)=f(x)f(y)</script><p>我们就说$f$是一个积性函数。</p>\n<p>特别的，如果上式去掉$x\\perp y$仍成立，则称$f$是一个完全积性函数。</p>\n<p>很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\\times n)=f(1)\\times f(n)=f(n)$。</p>\n<p>常见的完全积性函数有$\\epsilon,id^{k}$。$\\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p>\n<p>常见的积性函数有$\\varphi,d,\\sigma$。$\\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\\sigma(n)$的值分别等于$n$的约数个数和约数和。</p>\n<p>关于$\\varphi$的积性，我并不会证（</p>\n<p>我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设</p>\n<script type=\"math/tex; mode=display\">n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有</p>\n<script type=\"math/tex; mode=display\">d(n)=\\prod\\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个$m$，且</p>\n<script type=\"math/tex; mode=display\">m=\\prod\\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说$n\\perp m$，肯定有</p>\n<script type=\"math/tex; mode=display\">\\forall i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z}\\;\\;p_{i}\\neq q_{j}</script><p>于是我们就有</p>\n<script type=\"math/tex; mode=display\">nm=(\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}})(\\prod\\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nd(nm)&=(\\prod\\limits_{i=1}^{N}(r_{i}+1))(\\prod\\limits_{j=1}^{M}(s_{j}+1))\\\\\n&=d(n)d(m)\n\\end{aligned}</script><p>不妨再反过来考虑。如果说$n\\not\\perp m$，那么一定存在一对$(i,j)(i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\\neq d(n)d(m)$。</p>\n<p>我们再来分析$\\sigma$的积性。还是设</p>\n<script type=\"math/tex; mode=display\">n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\\in [0,r_{i}]\\cap\\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p>\n<script type=\"math/tex; mode=display\">\\prod\\limits_{i=1}^{N}\\sum\\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是$\\sigma(n)$的值。</p>\n<p>接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。</p>\n<p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times g)(n)(f\\times g)(m)&=(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(i)g(\\cfrac{n}{i})f(j)g(\\cfrac{m}{j})\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(ij)g(\\cfrac{nm}{ij})\\\\\n&=\\sum\\limits_{k\\mid nm}f(k)g(\\cfrac{nm}{k})\\\\\n&=(f\\times g)(nm)\n\\end{aligned}</script><p>关于上面的第四个等号。时刻注意$n\\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。</p>\n<p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p>\n<p>设有一个积性函数$f$，它的逆是$g$。</p>\n<p>当$nm=1$时，$g(1)=1$。</p>\n<p>当$nm&gt;1$时，我们假设对于任意$n^{\\prime}m^{\\prime}&lt;nm$，都有$g(n^{\\prime}m^{\\prime})=g(n^{\\prime})g(m^{\\prime})$。此时</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(nm)&=-\\sum\\limits_{k\\mid nm,k\\neq 1}f(k)g(\\cfrac{nm}{k})\\\\\n&=-\\sum\\limits_{i\\mid n,j\\mid m,ij\\neq 1}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-\\sum\\limits_{i\\mid n,j\\mid m}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=g(n)g(m)-\\epsilon(n)\\epsilon(m)\\\\\n&=g(n)g(m)\n\\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p>\n<h1 id=\"莫比乌斯反演\"><a href=\"#莫比乌斯反演\" class=\"headerlink\" title=\"莫比乌斯反演\"></a>莫比乌斯反演</h1><h2 id=\"正向反演\"><a href=\"#正向反演\" class=\"headerlink\" title=\"正向反演\"></a>正向反演</h2><p>定义$\\mu$为$1$的逆。也就是说，$\\mu\\times 1=\\epsilon$。</p>\n<p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p>\n<blockquote>\n<p>首先地，$\\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\\mu(n)=(-1)^{k}$。否则，$\\mu(n)=0$。</p>\n</blockquote>\n<p>那么，这两种定义等价吗？</p>\n<p>考虑到$\\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成</p>\n<script type=\"math/tex; mode=display\">n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p>\n<script type=\"math/tex; mode=display\">\\mu(n)=\\prod\\limits_{i=1}^{N}\\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p>\n<p>设有一个质数$p$。不难发现</p>\n<script type=\"math/tex; mode=display\">\\mu(p)=-\\mu(1)=-1</script><script type=\"math/tex; mode=display\">\\mu(p^{2})=-\\mu(1)-\\mu(p)=-1+1=0</script><script type=\"math/tex; mode=display\">\\mu(p^{3})=-\\mu(1)-\\mu(p)-\\mu(p^{2})=-1+1+0=0</script><script type=\"math/tex; mode=display\">\\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p>\n<p>那么这个东西有什么用呢？</p>\n<p>我们设</p>\n<script type=\"math/tex; mode=display\">F(n)=\\sum\\limits_{i\\mid n}f(i)</script><p>或者等价地说，$F=f\\times 1$。我们可以得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF&=f\\times 1\\\\\nF\\times\\mu&=f\\times 1\\times\\mu\\\\\nF\\times\\mu&=f\n\\end{aligned}</script><p>像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说</p>\n<script type=\"math/tex; mode=display\">f(n)=\\sum\\limits_{i\\mid n}F(i)\\mu(\\cfrac{n}{i})</script><h2 id=\"反向反演\"><a href=\"#反向反演\" class=\"headerlink\" title=\"反向反演\"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p>\n<script type=\"math/tex; mode=display\">F(n)=\\sum\\limits_{n\\mid d}f(d)⇔f(n)=\\sum\\limits_{n\\mid d}F(d)\\mu(\\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p>\n<script type=\"math/tex; mode=display\">(f\\otimes g)(n)=\\sum\\limits_{n\\mid d}f(d)g(\\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p>\n<script type=\"math/tex; mode=display\">F=f\\otimes 1⇔F\\otimes\\mu=f</script><p>于是就有了上面的反向反演。</p>\n<blockquote>\n<p>Updated on 2018-12-03</p>\n<p>例题……还是算了吧（</p>\n<p>发现反演常用的套路都忘的差不多了，还是别丢人了（</p>\n</blockquote>\n<h1 id=\"杜教筛\"><a href=\"#杜教筛\" class=\"headerlink\" title=\"杜教筛\"></a>杜教筛</h1><h2 id=\"实现与模板题\"><a href=\"#实现与模板题\" class=\"headerlink\" title=\"实现与模板题\"></a>实现与模板题</h2><p>接下来才是主要内容。</p>\n<p>现在，我们要求一个积性函数的前$n$项和。$n\\leqslant 10^{10}$。</p>\n<p>我们定义</p>\n<script type=\"math/tex; mode=display\">S(n)=\\sum\\limits_{i=1}^{n}f(i)</script><p>再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum_{i=1}^{n}(f\\times g)(i)&=\\sum_{i=1}^{n}\\sum_{j\\mid i}f(j)g(\\cfrac{i}{j})\\\\\n&=\\sum_{i=1}^{n}g(i)\\sum_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}</script><p>然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（</p>\n<p>因为$g$也是积性函数，有$g(1)=1$，所以</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nS(n)&=g(1)S(n)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\\\\\n&=\\sum_{i=1}^{n}(f\\times g)(i)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}</script><p>就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。</p>\n<p>如果说我们选择的$g$可以让我们迅速地求出$f\\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。</p>\n<p>关于后面的$g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。</p>\n<p>我们来分析一下$\\lfloor\\cfrac{n}{i}\\rfloor$。如果$1\\leqslant i\\leqslant\\sqrt{n}$，因为$i$只有$\\sqrt{n}$种不同的取值，$\\lfloor\\cfrac{n}{i}\\rfloor$同样也只有$\\sqrt{n}$种不同的取值。如果$\\sqrt{n}&lt;i\\leqslant n$，$1\\leqslant\\lfloor\\cfrac{n}{i}\\rfloor&lt;\\sqrt{n}$，又因为要向下取整，自然也只有$\\sqrt{n}$种不同的取值。如果我们能够把$\\lfloor\\cfrac{n}{i}\\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\\sqrt{n})$。</p>\n<p>大体代码如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> l=<span class=\"number\">1</span>,r;l&lt;=n;l=r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\tr=n/(n/l);</span><br><span class=\"line\">\t<span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>关于$r$的这个上界是怎么来的，我并不会证（</p>\n<p>这样一来，要计算$S(n)$，我们需要调用所有的$\\lfloor\\cfrac{n}{x}\\rfloor$，分别是$\\lfloor\\cfrac{n}{1}\\rfloor,\\lfloor\\cfrac{n}{2}\\rfloor,\\cdots,\\lfloor\\cfrac{n}{\\sqrt{n}}\\rfloor,\\sqrt{n},\\sqrt{n}-1,\\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\\sqrt{n})$的。那么这样一来，总体的时间复杂度就是</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nO(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{i}+\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})&=O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{x}\\rfloor}dx)\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\cfrac{n}{x}}dx)\\\\\n&=O(2n^{\\frac{1}{2}}(n^{\\frac{1}{4}}-1))\\\\\n&=O(n^{\\frac{3}{4}})\n\\end{aligned}</script><p>因为相比之下$\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor}$很明显要大一些，我们就可以将$\\sqrt{i}$舍去。然后去掉取整符号并用积分近似。</p>\n<p>这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\\cfrac{n}{\\sqrt{m}})$，当$m=n^{\\frac{2}{3}}$时取得最小值$O(n^{\\frac{2}{3}})$。</p>\n<p>举个例子，就比如说我们要求</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\varphi(i)</script><p>我们取$f=\\varphi,g=1$，这样根据$\\varphi$的性质，$f\\times g=id$。不难看出$g$与$f\\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"keyword\">long</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n&lt;=maxn)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> phi[n];</span><br><span class=\"line\">\t<span class=\"comment\">//phi是提前线性筛好的前缀和</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(ans.count(n))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ans[n];</span><br><span class=\"line\">\t<span class=\"comment\">//ans用来实现记忆化的哈希表，比如说unordered_map</span></span><br><span class=\"line\">\tre <span class=\"keyword\">long</span> <span class=\"keyword\">long</span> res=<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)&gt;&gt;<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//f*g的前缀和</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> l=<span class=\"number\">2</span>,r;l&lt;=n;l=r+<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//注意要从2开始</span></span><br><span class=\"line\">\t\tr=n/(n/l);</span><br><span class=\"line\">\t\tres-=(r-l+<span class=\"number\">1</span>)*getSum(n/l);</span><br><span class=\"line\">\t\t<span class=\"comment\">//r-l+1是g的前缀和</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//像这样递归+记忆化求解f的前缀和</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> ans[n]=res;</span><br><span class=\"line\">\t<span class=\"comment\">//返回的时候不要忘记存一下</span></span><br><span class=\"line\">\t<span class=\"comment\">//就比如说我就忘过一次（</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>以及，不用哈希表也是可以的。因为我们查询的数都是形如$\\lfloor\\cfrac{n}{x}\\rfloor$的，当这个值大于$n^{\\frac{2}{3}}$，即$x&lt;n^{\\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令<code>ans[x]</code>表示$S(\\lfloor\\cfrac{n}{x}\\rfloor)$。具体代码我就不写了（</p>\n<p>再举个例子，求</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\mu(i)</script><p>取$f=\\mu,g=1,f\\times g=\\epsilon$。代码和上面差不多。</p>\n<p>如果您理解了上面两个函数，这道<a href=\"https://www.luogu.org/problemnew/show/P4213\" target=\"_blank\" rel=\"noopener\">模板题</a>您就可以切了。</p>\n<h2 id=\"其他题\"><a href=\"#其他题\" class=\"headerlink\" title=\"其他题\"></a>其他题</h2><h3 id=\"「Luogu-P3768」简单的数学题\"><a href=\"#「Luogu-P3768」简单的数学题\" class=\"headerlink\" title=\"「Luogu-P3768」简单的数学题\"></a><a href=\"https://www.luogu.org/problemnew/show/P3768\" target=\"_blank\" rel=\"noopener\">「Luogu-P3768」简单的数学题</a></h3><p>快乐地推式子：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum\\limits_{i=1}^{n}i\\sum\\limits_{j=1}^{n}j\\text{gcd}(i,j)&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}x^{2}\\mu(x)\\text{Sum}^{2}(\\lfloor\\cfrac{n}{dx}\\rfloor)\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\sum\\limits_{j\\mid i}j\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\varphi(i)\n\\end{aligned}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\\text{Sum}(n)=\\sum\\limits_{i=1}^{n}i</script><p>最后一步是因为</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nid\\times\\mu&=\\varphi\\times 1\\times\\mu\\\\\n&=\\varphi\\times\\epsilon\\\\\n&=\\varphi\n\\end{aligned}</script><p>理解不了上面的式子的话就多看看吧（</p>\n<p>不难发现我们是要求$f(n)=n^{2}\\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？</p>\n<p><del>枚举瞎蒙（</del></p>\n<p>考虑$g(n)=n^{2}$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times g)(n)&=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=\\sum\\limits_{i\\mid n}i^{2}\\varphi(i)\\cfrac{n^{2}}{i^{2}}\\\\\n&=n^{2}\\sum\\limits_{i\\mid n}\\varphi(i)\\\\\n&=n^{3}\n\\end{aligned}</script><p><del>其实我都不知道我当时是怎么想到这种操作的（</del></p>\n<p>然后就和上面一样了。</p>\n<h3 id=\"「Luogu-U18201」分析矿洞\"><a href=\"#「Luogu-U18201」分析矿洞\" class=\"headerlink\" title=\"「Luogu-U18201」分析矿洞\"></a><a href=\"https://www.luogu.org/problemnew/show/U18201\" target=\"_blank\" rel=\"noopener\">「Luogu-U18201」分析矿洞</a></h3><p>不知道从哪翻出来的题（</p>\n<p>是某场个人邀请赛的$\\text{T}1$<del>，从某种意义上也能看出那场比赛有多么神仙</del>。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\varphi(\\text{gcd}^{2}(i,j))&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(x)\\lfloor\\cfrac{n}{dx}\\rfloor^{2}\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}\\varphi(j^{2})\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}j\\varphi(j)\\mu(\\cfrac{i}{j})\n\\end{aligned}</script><p>设$f_1(n)=n\\varphi(n),f_2(n)=\\mu(n)$，考虑筛$f=f_1\\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\\times g$的前缀和。一种较优的方案是，令$g=1$，$f\\times g=(id\\cdot\\varphi)\\times\\mu\\times 1=id\\cdot\\varphi$，这样，我们还需要筛出$f_1(n)=n\\varphi(n)$的前缀和。</p>\n<p>怎么办？</p>\n<p>再套一层杜教筛！</p>\n<p>然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（</p>\n<p>以及，像这种$n$爆了<code>int</code>的，一定要注意经常取模。<del>因为这个WA了好几次（</del></p>\n<p>最后，源文件$17\\text{KB}​$祭，blog翻页祭。</p>\n","site":{"data":{}},"excerpt":"<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p>\n<p><del>抄袭来源</del>参考文献：</p>\n<ul>\n<li><a href=\"https://lx-2003.blog.luogu.org/mobius-inversion\" target=\"_blank\" rel=\"noopener\">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li>\n<li><a href=\"https://www.luogu.org/blog/54745/dls-tql\" target=\"_blank\" rel=\"noopener\">浅谈杜教筛</a></li>\n<li><a href=\"https://lx-2003.blog.luogu.org/dujiao-sieve\" target=\"_blank\" rel=\"noopener\">铃悬的数学小讲堂——杜教筛</a></li>\n</ul>","more":"<h1 id=\"数论函数\"><a href=\"#数论函数\" class=\"headerlink\" title=\"数论函数\"></a>数论函数</h1><h2 id=\"定义与相关性质\"><a href=\"#定义与相关性质\" class=\"headerlink\" title=\"定义与相关性质\"></a>定义与相关性质</h2><p>数论函数就是定义域为$\\mathbb{N}^{+}$的函数。</p>\n<p>两个数论函数相加，就是简单地把函数值相加。</p>\n<script type=\"math/tex; mode=display\">(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p>\n<script type=\"math/tex; mode=display\">(\\alpha f)(n)=\\alpha f(n)</script><p>点积也是类似的。</p>\n<script type=\"math/tex; mode=display\">(f\\cdot g)(n)=f(n)g(n)</script><p><del>好像没啥用。</del></p>\n<p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p>\n<script type=\"math/tex; mode=display\">(f\\times g)(n)=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})</script><p>或者说：</p>\n<script type=\"math/tex; mode=display\">(f\\times g)(n)=\\sum\\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p>\n<p>交换律，即$f\\times g=g\\times f$。</p>\n<p>这很明显。</p>\n<p>结合律，即$(f\\times g)\\times h=f\\times(g\\times h)$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n((f\\times g)\\times h)(n)&=\\sum\\limits_{ij=n}(\\sum\\limits_{kl=i}f(k)g(l))h(j)\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times(g\\times h))(n)&=\\sum\\limits_{ij=n}f(i)(\\sum\\limits_{kl=j}g(k)h(l))\\\\\n&=\\sum\\limits_{ijk=n}f(i)g(j)h(k)\n\\end{aligned}</script><p>分配率，即$(f+g)\\times h=f\\times h+g\\times h$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n((f+g)\\times h)(n)&=\\sum\\limits_{ij=n}(f+g)(i)h(j)\\\\\n&=\\sum\\limits_{ij=n}f(i)h(j)+g(i)h(j)\\\\\n&=(f\\times h)(n)+(g\\times h)(n)\n\\end{aligned}</script><p>单位元为$\\epsilon(n)=[n=1]$，$f\\times\\epsilon =f$。</p>\n<p>这也很明显。</p>\n<p>对于任意一个满足$f(1)\\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\\times g=\\epsilon$。这时我们称$g$是$f$的逆。</p>\n<p>我们可以这样定义一个函数的逆：</p>\n<script type=\"math/tex; mode=display\">g(n)=\\cfrac{\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times g)(n)&=\\sum_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=f(1)g(n)+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\\n&=\\epsilon(n)\n\\end{aligned}</script><h2 id=\"积性函数与完全积性函数\"><a href=\"#积性函数与完全积性函数\" class=\"headerlink\" title=\"积性函数与完全积性函数\"></a>积性函数与完全积性函数</h2><p>如果一个数论函数$f$满足</p>\n<script type=\"math/tex; mode=display\">\\forall x,y\\in\\mathbb{N}^{+}\\wedge x\\perp y\\;\\;f(xy)=f(x)f(y)</script><p>我们就说$f$是一个积性函数。</p>\n<p>特别的，如果上式去掉$x\\perp y$仍成立，则称$f$是一个完全积性函数。</p>\n<p>很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\\times n)=f(1)\\times f(n)=f(n)$。</p>\n<p>常见的完全积性函数有$\\epsilon,id^{k}$。$\\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p>\n<p>常见的积性函数有$\\varphi,d,\\sigma$。$\\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\\sigma(n)$的值分别等于$n$的约数个数和约数和。</p>\n<p>关于$\\varphi$的积性，我并不会证（</p>\n<p>我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设</p>\n<script type=\"math/tex; mode=display\">n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有</p>\n<script type=\"math/tex; mode=display\">d(n)=\\prod\\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个$m$，且</p>\n<script type=\"math/tex; mode=display\">m=\\prod\\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说$n\\perp m$，肯定有</p>\n<script type=\"math/tex; mode=display\">\\forall i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z}\\;\\;p_{i}\\neq q_{j}</script><p>于是我们就有</p>\n<script type=\"math/tex; mode=display\">nm=(\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}})(\\prod\\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nd(nm)&=(\\prod\\limits_{i=1}^{N}(r_{i}+1))(\\prod\\limits_{j=1}^{M}(s_{j}+1))\\\\\n&=d(n)d(m)\n\\end{aligned}</script><p>不妨再反过来考虑。如果说$n\\not\\perp m$，那么一定存在一对$(i,j)(i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\\neq d(n)d(m)$。</p>\n<p>我们再来分析$\\sigma$的积性。还是设</p>\n<script type=\"math/tex; mode=display\">n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\\in [0,r_{i}]\\cap\\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p>\n<script type=\"math/tex; mode=display\">\\prod\\limits_{i=1}^{N}\\sum\\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是$\\sigma(n)$的值。</p>\n<p>接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。</p>\n<p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times g)(n)(f\\times g)(m)&=(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(i)g(\\cfrac{n}{i})f(j)g(\\cfrac{m}{j})\\\\\n&=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(ij)g(\\cfrac{nm}{ij})\\\\\n&=\\sum\\limits_{k\\mid nm}f(k)g(\\cfrac{nm}{k})\\\\\n&=(f\\times g)(nm)\n\\end{aligned}</script><p>关于上面的第四个等号。时刻注意$n\\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。</p>\n<p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p>\n<p>设有一个积性函数$f$，它的逆是$g$。</p>\n<p>当$nm=1$时，$g(1)=1$。</p>\n<p>当$nm&gt;1$时，我们假设对于任意$n^{\\prime}m^{\\prime}&lt;nm$，都有$g(n^{\\prime}m^{\\prime})=g(n^{\\prime})g(m^{\\prime})$。此时</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(nm)&=-\\sum\\limits_{k\\mid nm,k\\neq 1}f(k)g(\\cfrac{nm}{k})\\\\\n&=-\\sum\\limits_{i\\mid n,j\\mid m,ij\\neq 1}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-\\sum\\limits_{i\\mid n,j\\mid m}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\\n&=g(n)g(m)-(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\\n&=g(n)g(m)-\\epsilon(n)\\epsilon(m)\\\\\n&=g(n)g(m)\n\\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p>\n<h1 id=\"莫比乌斯反演\"><a href=\"#莫比乌斯反演\" class=\"headerlink\" title=\"莫比乌斯反演\"></a>莫比乌斯反演</h1><h2 id=\"正向反演\"><a href=\"#正向反演\" class=\"headerlink\" title=\"正向反演\"></a>正向反演</h2><p>定义$\\mu$为$1$的逆。也就是说，$\\mu\\times 1=\\epsilon$。</p>\n<p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p>\n<blockquote>\n<p>首先地，$\\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\\mu(n)=(-1)^{k}$。否则，$\\mu(n)=0$。</p>\n</blockquote>\n<p>那么，这两种定义等价吗？</p>\n<p>考虑到$\\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成</p>\n<script type=\"math/tex; mode=display\">n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p>\n<script type=\"math/tex; mode=display\">\\mu(n)=\\prod\\limits_{i=1}^{N}\\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p>\n<p>设有一个质数$p$。不难发现</p>\n<script type=\"math/tex; mode=display\">\\mu(p)=-\\mu(1)=-1</script><script type=\"math/tex; mode=display\">\\mu(p^{2})=-\\mu(1)-\\mu(p)=-1+1=0</script><script type=\"math/tex; mode=display\">\\mu(p^{3})=-\\mu(1)-\\mu(p)-\\mu(p^{2})=-1+1+0=0</script><script type=\"math/tex; mode=display\">\\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p>\n<p>那么这个东西有什么用呢？</p>\n<p>我们设</p>\n<script type=\"math/tex; mode=display\">F(n)=\\sum\\limits_{i\\mid n}f(i)</script><p>或者等价地说，$F=f\\times 1$。我们可以得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF&=f\\times 1\\\\\nF\\times\\mu&=f\\times 1\\times\\mu\\\\\nF\\times\\mu&=f\n\\end{aligned}</script><p>像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说</p>\n<script type=\"math/tex; mode=display\">f(n)=\\sum\\limits_{i\\mid n}F(i)\\mu(\\cfrac{n}{i})</script><h2 id=\"反向反演\"><a href=\"#反向反演\" class=\"headerlink\" title=\"反向反演\"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p>\n<script type=\"math/tex; mode=display\">F(n)=\\sum\\limits_{n\\mid d}f(d)⇔f(n)=\\sum\\limits_{n\\mid d}F(d)\\mu(\\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p>\n<script type=\"math/tex; mode=display\">(f\\otimes g)(n)=\\sum\\limits_{n\\mid d}f(d)g(\\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p>\n<script type=\"math/tex; mode=display\">F=f\\otimes 1⇔F\\otimes\\mu=f</script><p>于是就有了上面的反向反演。</p>\n<blockquote>\n<p>Updated on 2018-12-03</p>\n<p>例题……还是算了吧（</p>\n<p>发现反演常用的套路都忘的差不多了，还是别丢人了（</p>\n</blockquote>\n<h1 id=\"杜教筛\"><a href=\"#杜教筛\" class=\"headerlink\" title=\"杜教筛\"></a>杜教筛</h1><h2 id=\"实现与模板题\"><a href=\"#实现与模板题\" class=\"headerlink\" title=\"实现与模板题\"></a>实现与模板题</h2><p>接下来才是主要内容。</p>\n<p>现在，我们要求一个积性函数的前$n$项和。$n\\leqslant 10^{10}$。</p>\n<p>我们定义</p>\n<script type=\"math/tex; mode=display\">S(n)=\\sum\\limits_{i=1}^{n}f(i)</script><p>再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum_{i=1}^{n}(f\\times g)(i)&=\\sum_{i=1}^{n}\\sum_{j\\mid i}f(j)g(\\cfrac{i}{j})\\\\\n&=\\sum_{i=1}^{n}g(i)\\sum_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}</script><p>然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（</p>\n<p>因为$g$也是积性函数，有$g(1)=1$，所以</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nS(n)&=g(1)S(n)\\\\\n&=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\\\\\n&=\\sum_{i=1}^{n}(f\\times g)(i)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\n\\end{aligned}</script><p>就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。</p>\n<p>如果说我们选择的$g$可以让我们迅速地求出$f\\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。</p>\n<p>关于后面的$g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。</p>\n<p>我们来分析一下$\\lfloor\\cfrac{n}{i}\\rfloor$。如果$1\\leqslant i\\leqslant\\sqrt{n}$，因为$i$只有$\\sqrt{n}$种不同的取值，$\\lfloor\\cfrac{n}{i}\\rfloor$同样也只有$\\sqrt{n}$种不同的取值。如果$\\sqrt{n}&lt;i\\leqslant n$，$1\\leqslant\\lfloor\\cfrac{n}{i}\\rfloor&lt;\\sqrt{n}$，又因为要向下取整，自然也只有$\\sqrt{n}$种不同的取值。如果我们能够把$\\lfloor\\cfrac{n}{i}\\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\\sqrt{n})$。</p>\n<p>大体代码如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�42-->\n\n</div></div>\n<p>关于$r$的这个上界是怎么来的，我并不会证（</p>\n<p>这样一来，要计算$S(n)$，我们需要调用所有的$\\lfloor\\cfrac{n}{x}\\rfloor$，分别是$\\lfloor\\cfrac{n}{1}\\rfloor,\\lfloor\\cfrac{n}{2}\\rfloor,\\cdots,\\lfloor\\cfrac{n}{\\sqrt{n}}\\rfloor,\\sqrt{n},\\sqrt{n}-1,\\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\\sqrt{n})$的。那么这样一来，总体的时间复杂度就是</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nO(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{i}+\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})&=O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{x}\\rfloor}dx)\\\\\n&=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\cfrac{n}{x}}dx)\\\\\n&=O(2n^{\\frac{1}{2}}(n^{\\frac{1}{4}}-1))\\\\\n&=O(n^{\\frac{3}{4}})\n\\end{aligned}</script><p>因为相比之下$\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor}$很明显要大一些，我们就可以将$\\sqrt{i}$舍去。然后去掉取整符号并用积分近似。</p>\n<p>这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\\cfrac{n}{\\sqrt{m}})$，当$m=n^{\\frac{2}{3}}$时取得最小值$O(n^{\\frac{2}{3}})$。</p>\n<p>举个例子，就比如说我们要求</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\varphi(i)</script><p>我们取$f=\\varphi,g=1$，这样根据$\\varphi$的性质，$f\\times g=id$。不难看出$g$与$f\\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�43-->\n\n</div></div>\n<p>以及，不用哈希表也是可以的。因为我们查询的数都是形如$\\lfloor\\cfrac{n}{x}\\rfloor$的，当这个值大于$n^{\\frac{2}{3}}$，即$x&lt;n^{\\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令<code>ans[x]</code>表示$S(\\lfloor\\cfrac{n}{x}\\rfloor)$。具体代码我就不写了（</p>\n<p>再举个例子，求</p>\n<script type=\"math/tex; mode=display\">\\sum\\limits_{i=1}^{n}\\mu(i)</script><p>取$f=\\mu,g=1,f\\times g=\\epsilon$。代码和上面差不多。</p>\n<p>如果您理解了上面两个函数，这道<a href=\"https://www.luogu.org/problemnew/show/P4213\" target=\"_blank\" rel=\"noopener\">模板题</a>您就可以切了。</p>\n<h2 id=\"其他题\"><a href=\"#其他题\" class=\"headerlink\" title=\"其他题\"></a>其他题</h2><h3 id=\"「Luogu-P3768」简单的数学题\"><a href=\"#「Luogu-P3768」简单的数学题\" class=\"headerlink\" title=\"「Luogu-P3768」简单的数学题\"></a><a href=\"https://www.luogu.org/problemnew/show/P3768\" target=\"_blank\" rel=\"noopener\">「Luogu-P3768」简单的数学题</a></h3><p>快乐地推式子：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum\\limits_{i=1}^{n}i\\sum\\limits_{j=1}^{n}j\\text{gcd}(i,j)&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}x^{2}\\mu(x)\\text{Sum}^{2}(\\lfloor\\cfrac{n}{dx}\\rfloor)\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\sum\\limits_{j\\mid i}j\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\varphi(i)\n\\end{aligned}</script><p>其中</p>\n<script type=\"math/tex; mode=display\">\\text{Sum}(n)=\\sum\\limits_{i=1}^{n}i</script><p>最后一步是因为</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nid\\times\\mu&=\\varphi\\times 1\\times\\mu\\\\\n&=\\varphi\\times\\epsilon\\\\\n&=\\varphi\n\\end{aligned}</script><p>理解不了上面的式子的话就多看看吧（</p>\n<p>不难发现我们是要求$f(n)=n^{2}\\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？</p>\n<p><del>枚举瞎蒙（</del></p>\n<p>考虑$g(n)=n^{2}$。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n(f\\times g)(n)&=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\\n&=\\sum\\limits_{i\\mid n}i^{2}\\varphi(i)\\cfrac{n^{2}}{i^{2}}\\\\\n&=n^{2}\\sum\\limits_{i\\mid n}\\varphi(i)\\\\\n&=n^{3}\n\\end{aligned}</script><p><del>其实我都不知道我当时是怎么想到这种操作的（</del></p>\n<p>然后就和上面一样了。</p>\n<h3 id=\"「Luogu-U18201」分析矿洞\"><a href=\"#「Luogu-U18201」分析矿洞\" class=\"headerlink\" title=\"「Luogu-U18201」分析矿洞\"></a><a href=\"https://www.luogu.org/problemnew/show/U18201\" target=\"_blank\" rel=\"noopener\">「Luogu-U18201」分析矿洞</a></h3><p>不知道从哪翻出来的题（</p>\n<p>是某场个人邀请赛的$\\text{T}1$<del>，从某种意义上也能看出那场比赛有多么神仙</del>。</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\n\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\varphi(\\text{gcd}^{2}(i,j))&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[i\\perp j]\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\\n&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(x)\\lfloor\\cfrac{n}{dx}\\rfloor^{2}\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}\\varphi(j^{2})\\mu(\\cfrac{i}{j})\\\\\n&=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}j\\varphi(j)\\mu(\\cfrac{i}{j})\n\\end{aligned}</script><p>设$f_1(n)=n\\varphi(n),f_2(n)=\\mu(n)$，考虑筛$f=f_1\\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\\times g$的前缀和。一种较优的方案是，令$g=1$，$f\\times g=(id\\cdot\\varphi)\\times\\mu\\times 1=id\\cdot\\varphi$，这样，我们还需要筛出$f_1(n)=n\\varphi(n)$的前缀和。</p>\n<p>怎么办？</p>\n<p>再套一层杜教筛！</p>\n<p>然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（</p>\n<p>以及，像这种$n$爆了<code>int</code>的，一定要注意经常取模。<del>因为这个WA了好几次（</del></p>\n<p>最后，源文件$17\\text{KB}​$祭，blog翻页祭。</p>"},{"mathjax":true,"date":"2018-12-19T12:23:01.000Z","title":"「多项式学习笔记Part I」最基本的多项式乘法","_content":"最近正好月考，然而并不想去月考，于是来颓blog吧。\n\n<!-- more -->\n\n给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\\times G)(x)$的各项系数。$n,m\\leqslant 10^{6}$。\n\n我们不妨将$F(x)$的$i$次项系数记为$F[i]$\n\n$$F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}$$\n\n$$G(x)=\\sum\\limits_{i=0}^{m-1}G[i]x^{i}$$\n\n$$(F\\times G)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}$$\n\n$$(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]$$\n\n不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。\n\n不过为了优化，我们得先扯远点。\n\n# 点值表达\n\n如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。\n\n就比如说\n\n$$(0,2),(1,7),(2,4)$$\n\n~~瞎写的（~~\n\n我们可以列出如下的三元一次方程组：\n\n$$\\begin{cases}\n&\\text{C}=2\\\\\n&\\text{A}+\\text{B}+\\text{C}=7\\\\\n&4\\text{A}+2\\text{B}+\\text{C}=4\n\\end{cases}$$\n\n解得\n\n$$\\begin{cases}\n&\\text{A}=-4\\\\\n&\\text{B}=9\\\\\n&\\text{C}=2\n\\end{cases}$$\n\n注意到$(F\\times G)(x)=F(x)G(x)$~~（废话）~~，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\\times G)(x)$的点值表达了。因为$(F\\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。\n\n但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（\n\n于是我们还需要优化，于是我们还需要再扯远一点。\n\n# 复数\n\n对，你没看错，扯到复数了。\n\n## 基本概念\n\n根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说\n\n$$x^{2}+1=0$$\n\n我们知道，它的判别式是$\\Delta=b^{2}-4ac=-4\\lt 0$，因此它没有实数根。\n\n于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\\operatorname{tan}^{-1}\\cfrac{y}{x}$。\n\n因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。\n\n![](https://i.loli.net/2018/12/19/5c1a46b4d785b.png)\n\n上图展示了$4+i$和$3+4i$。\n\n复数的运算其实没什么出乎意料的：\n\n$$(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i$$\n\n$$(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i$$\n\n$$(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i$$\n\n$$\\begin{aligned}\n\\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\\\\n&=\\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\\\\n&=\\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i\n\\end{aligned}$$\n\n我们来单独考虑一下复数相乘的几何意义。\n\n假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\\alpha_{1}$，$\\alpha_{2}$。不难发现我们有\n\n$$c_{1}=r_{1}(\\operatorname{cos}\\alpha_{1}+i\\operatorname{sin}\\alpha_{1})$$\n\n$$c_{2}=r_{2}(\\operatorname{cos}\\alpha_{2}+i\\operatorname{sin}\\alpha_{2})$$\n\n$$\\begin{aligned}\nc_{1}c_{2}&=r_{1}r_{2}(\\cos\\alpha_{1}+i\\sin\\alpha_{1})(\\cos\\alpha_{2}+i\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}(\\cos\\alpha_{1}\\cos\\alpha_{2}+i\\cos\\alpha_{1}\\sin\\alpha_{2}+i\\sin\\alpha_{1}\\cos\\alpha_{2}-\\sin\\alpha_{1}\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}[\\cos(\\alpha_{1}+\\alpha_{2})+i\\sin(\\alpha_{1}+\\alpha_{2})]\n\\end{aligned}$$\n\n总结成一句话，就是「模长相乘，幅角相加」。\n\n## 单位圆与单位根\n\n单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。\n\n![](https://i.loli.net/2018/12/20/5c1b06e5602fa.png)\n\n考虑这么一个方程\n\n$$x^{n}=1$$\n\n它的所有复数根。\n\n因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有\n\n$$2\\pi\\mid na$$\n\n$$\\cfrac{2\\pi}{n}\\mid a$$\n\n不难想象出我们有$n$个这样的复数，它们的幅角通式是$\\cfrac{2k\\pi}{n}(k\\in[0,n)\\cap\\mathbb{Z})$。我们称其中幅角等于$\\cfrac{2\\pi}{n}$的复数，即$\\cos\\cfrac{2\\pi}{n}+i\\sin\\cfrac{2\\pi}{n}$为$n$次单位根$\\omega_{n}$，我们就可以把这$n$个复数表示为$\\omega_{n}^{k}(k\\in[0,n)\\cap\\mathbb{Z})$。\n\n它有如下的一些性质\n\n$$\\omega_{2n}^{2k}=\\omega_{n}^{k}$$\n\n因为它们的模长都是$1$，幅角相等就相等了。\n\n然后就没了，读者自证不难（\n\n$$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}$$\n\n因为$\\omega_{n}^{\\frac{n}{2}}$的幅角是$\\cfrac{2\\times\\frac{n}{2}\\pi}{n}=\\pi$，不难发现它就是$-1$了。\n\n# 快速傅里叶变换（Fast Fourier Transformation）\n\n## 运行过程\n\n那么问题来了，我们刚才扯了这么些，有什么用呢？\n\n就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。\n\n首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。\n\n然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：\n\n$$\\begin{aligned}\nF_{1}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i]x^{i}\\\\\n&=F[0]x^{0}+F[2]x^{1}+\\cdots+F[n-2]x^{\\frac{n}{2}-1}\n\\end{aligned}$$\n\n$$\\begin{aligned}\nF_{2}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i+1]x^{i}\\\\\n&=F[1]x^{0}+F[3]x^{1}+\\cdots+F[n-1]x^{\\frac{n}{2}-1}\n\\end{aligned}$$\n\n于是我们有\n\n$$F(x)=F_{1}(x^{2})+xF_{2}(x^{2})$$\n\n现在我们假设$0\\leqslant k<\\cfrac{n}{2}$，将$x=\\omega_{n}^{k}$和$x=\\omega_{n}^{k+\\frac{n}{2}}$代入\n\n$$\\begin{aligned}\nF(\\omega_{n}^{k})&=F_{1}(\\omega_{n}^{2k})+\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})+\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}$$\n\n$$\\begin{aligned}\nF(\\omega_{n}^{k+\\frac{n}{2}})&=F_{1}(\\omega_{n}^{2k+n})+\\omega_{n}^{k+\\frac{n}{2}}F_{2}(\\omega_{n}^{2k+n})\\\\\n&=F_{1}(\\omega_{n}^{2k})-\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}$$\n\n我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。\n\n简单地贴一下代码：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nvoid work(complex* F,int n){\n\tif(n==1)\n\t\treturn;\n\tcomplex F1[n>>1],F2[n>>1];\n    for(int i=0;i<n;i+=2){\n    \tF1[i]=F[2*i];\n        F2[i]=F[2*i+1];\n\t}\n    work(F1,n>>1);\n    work(F2,n>>1);\n    complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;\n    for(int i=0;i<(n>>1);++i,tmp=tmp*unit){\n    \tcomplex w=F2[i+(n>>1)]*tmp;\n        F[i]=F1[i]+w;\n        F[i+(n>>1)]=F1[i]-w;\n\t}\n}\n```\n\n{% endfold %}\n\n不过，以上代码是我现写出来的，~~保证其不正确性~~不保证其正确性。\n\n不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，`F`数组的每一个位置上实际存的是几次项：\n\n```plaintext\n0 1 2 3 4 5 6 7\n0 2 4 6|1 3 5 7\n0 4|2 6|1 5|3 7\n0|4|2|6|1|5|3|7\n```\n\n写成二进制看看：\n\n| 位置（十进制） | 位置（二进制） | 次数（十进制） | 次数（二进制） |\n| :-: | :-: | :-: | :-: |\n| $0$ | $000$ | $0$ | $000$ |\n| $1$ | $001$ | $4$ | $100$ |\n| $2$ | $010$ | $2$ | $010$ |\n| $3$ | $011$ | $6$ | $110$ |\n| $4$ | $100$ | $1$ | $001$ |\n| $5$ | $101$ | $5$ | $101$ |\n| $6$ | $110$ | $3$ | $011$ |\n| $7$ | $111$ | $7$ | $111$ |\n\n注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。\n\n我们可以$O(n)$地处理处每个数的镜像：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(int i=0;i<n;++i)\n\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n```\n\n{% endfold %}\n\n中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。\n\n接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nvoid work(complex* F,int n){\n\tfor(int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(int len=2,p=1;len<=n;len<<=1,p<<=1){\n\t\tcomplex unit(cos(Pi/p),sin(Pi/p));\n\t\tfor(int i=0;i<n;i+=len){\n\t\t\tcomplex cur(1,0);\n\t\t\tfor(int j=i;j<i+p;++j){\n\t\t\t\tcomplex tmp=F[j+p]*cur;\n\t\t\t\tF[j+p]=F[j]-tmp;\n\t\t\t\tF[j]=F[j]+tmp;\n\t\t\t\tcur=cur*unit;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n{% endfold %}\n\n那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\\omega_{n}^{0}),F(\\omega_{n}^{1}),\\cdots,F(\\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：\n\n$$\\begin{bmatrix}\n&(\\omega_{n}^{0})^{0}&(\\omega_{n}^{0})^{1}&\\cdots&(\\omega_{n}^{0})^{n-1}&\\\\\n&(\\omega_{n}^{1})^{0}&(\\omega_{n}^{1})^{1}&\\cdots&(\\omega_{n}^{1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&(\\omega_{n}^{n-1})^{0}&(\\omega_{n}^{n-1})^{1}&\\cdots&(\\omega_{n}^{n-1})^{n-1}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n&F[0]&\\\\\n&F[1]\\\\\n&\\vdots\\\\\n&F[n-1]\n\\end{bmatrix}\n=\\begin{bmatrix}\n&y_{0}&\\\\\n&y_{1}\\\\\n&\\vdots\\\\\n&y_{n-1}\n\\end{bmatrix}$$\n\n我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：\n\n$$\\begin{bmatrix}\n&\\frac{1}{n}(\\omega_{n}^{0})^{0}&\\frac{1}{n}(\\omega_{n}^{0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{0})^{n-1}&\\\\\n&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\n\\end{bmatrix}$$\n\n现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\\times B=C$。不难发现$A[i][j]=\\omega_{n}^{ij}$，$B[i][j]=\\cfrac{1}{n}\\omega_{n}^{-ij}$，我们有\n\n$$\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}A[i][k]B[k][j]\\\\\n&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{ik-kj}\n\\end{aligned}$$\n\n若$i=j$，不难发现此时$C[i][j]=1$。\n\n否则，即$i\\neq j$，设$i-j=l$，我们有\n\n$$\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{lk}\\\\\n&=\\cfrac{\\omega_{n}^{ln}-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=\\cfrac{1-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=0\n\\end{aligned}$$\n\n综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。\n\n因此我们有\n\n$$\\begin{bmatrix}&\\frac{1}{n}(\\omega_{n}^{-0})^{0}&\\frac{1}{n}(\\omega_{n}^{-0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-0})^{n-1}&\\\\&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\&\\vdots&\\vdots&\\ddots&\\vdots\\\\&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\\end{bmatrix}\\begin{bmatrix}&y_{0}&\\\\&y_{1}\\\\&\\vdots\\\\&y_{n-1}\\end{bmatrix}=\\begin{bmatrix}&F[0]&\\\\&F[1]\\\\&\\vdots\\\\&F[n-1]\\end{bmatrix}$$\n\n注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$换成$\\omega_{n}^{0},\\omega_{n}^{-1},\\cdots,\\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。\n\n注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的\n\n```cpp\ncomplex unit(cos(Pi/p),sin(Pi/p));\n```\n\n改成\n\n```cpp\ncomplex unit(cos(Pi/p),tp*sin(Pi/p));\n```\n\n然后调用时再传一个参数`tp`进去。`tp=1`表示是系数转点值，`tp=-1`表示是点值转系数。\n\n完整代码如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#define maxn 2097152\n\nconst double Pi=acos(-1.0);\n\nint n,m;\nint rev[maxn+1];\nstruct complex{\n\tdouble r,c;\n\n\tcomplex(double _r=0,double _c=0){\n\t\tr=_r;\n\t\tc=_c;\n\t}\n};\ncomplex F[maxn+1],G[maxn+1];\n\ninline complex operator+(complex& a,complex& b){\n\treturn complex(a.r+b.r,a.c+b.c);\n}\n\ninline complex operator-(complex& a,complex& b){\n\treturn complex(a.r-b.r,a.c-b.c);\n}\n\ninline complex operator*(complex& a,complex& b){\n\treturn complex(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);\n}\n\ntemplate<typename _tp>\ninline void swap(_tp& x,_tp& y){\n\t_tp tmp=x;\n\tx=y;\n\ty=tmp;\n}\n\ninline void FAQ(complex F[],int tp){\n\tfor(register int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(register int len=2,p=1;len<=n;len<<=1,p<<=1){\n\t\tregister complex unit(cos(Pi/p),tp*sin(Pi/p));\n\t\tfor(register int i=0;i<n;i+=len){\n\t\t\tregister complex cur(1,0);\n\t\t\tfor(register int j=i;j<i+p;++j){\n\t\t\t\tregister complex tmp=F[j+p]*cur;\n\t\t\t\tF[j+p]=F[j]-tmp;\n\t\t\t\tF[j]=F[j]+tmp;\n\t\t\t\tcur=cur*unit;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\t++n;\n\tfor(register int i=0;i<n;++i)\n\t\tscanf(\"%d\",&F[i].r);\n\t++m;\n\tfor(register int i=0;i<m;++i)\n\t\tscanf(\"%d\",&G[i].r);\n\tfor(m+=n-1,n=1;n<m;n<<=1);\n\tfor(register int i=0;i<n;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n\tFAQ(F,1);\n\tFAQ(G,1);\n\tfor(register int i=0;i<n;++i)\n\t\tF[i]=F[i]*G[i];\n\tFAQ(F,-1);\n\tfor(register int i=0;i<m;++i)\n\t\tprintf(\"%0.0lf \",F[i].r/n);\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n~~不要问我`cltstream`哪去了（~~\n\n然后您就可以切掉这道[板子题](https://www.luogu.org/problemnew/show/P3803)了。\n\n其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（\n\n最好还是自己写吧（\n\n什么？想知道是哪道题？往下看（\n\n## 例题\n\n### [「ZJOI2014」力](https://www.luogu.org/problemnew/show/P3338)\n\n这是一道裸的卷积题。\n\n考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足\n\n$$H[i]=\\sum\\limits_{j=0}^{i}F[j]G[i-j]=\\sum\\limits_{0\\leqslant j<n,0\\leqslant k<n,j+k=i}F[j]G[k]$$\n\n在本页面往上翻，翻到这个式子：\n\n$$(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]$$\n\n发现了吗？这两个过程其实是一样的。\n\n于是，我们如下构造两个多项式\n\n$$F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}$$\n\n$$G(x)=\\sum\\limits_{i=0}^{n-1}G[i]x^{i}$$\n\n然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。\n\n那么这题呢？首先我们把$j\\lt i$和$j\\gt i$分开计算。\n\n先考虑$j\\lt i$，令$F[i]=q_{i}$，$G[i]=\\begin{cases}&\\cfrac{1}{i^{2}}\\;\\;&(i\\gt 0)\\\\&0&(i=0)\\end{cases}$，那么\n\n$$\\begin{aligned}\nE_{i}&=\\sum_{j=0}^{i-1}F[j]G[i-j]\\\\\n&=\\sum_{j=0}^{i}F[j]G[i-j]\n\\end{aligned}$$\n\n直接套板子就行。\n\n对于$j>i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（\n\n具体还是看代码吧：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include\\lt cstdio>\n#include<cmath>\n#define maxn 2097152\n\nconst double Pi=acos(-1.0);\n\nint n,m;\nint rev[maxn+1];\nstruct complex{\n\tdouble r,c;\n\n\tcomplex(double _r=0,double _c=0){\n\t\tr=_r;\n\t\tc=_c;\n\t}\n};\ncomplex F1[maxn+1],F2[maxn+1],G[maxn+1];\n\ninline complex operator+(complex& a,complex& b){\n\treturn complex(a.r+b.r,a.c+b.c);\n}\n\ninline complex operator-(complex& a,complex& b){\n\treturn complex(a.r-b.r,a.c-b.c);\n}\n\ninline complex operator*(complex& a,complex& b){\n\treturn complex(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);\n}\n\ntemplate<typename _tp>\ninline void swap(_tp& x,_tp& y){\n\t_tp tmp=x;\n\tx=y;\n\ty=tmp;\n}\n\ninline void FAQ(complex F[],int tp){\n\tfor(register int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(register int len=2,p=1;len<=n;len<<=1,p<<=1){\n\t\tregister complex unit(cos(Pi/p),tp*sin(Pi/p));\n\t\tfor(register int i=0;i<n;i+=len){\n\t\t\tregister complex cur(1,0);\n\t\t\tfor(register int j=i;j<i+p;++j){\n\t\t\t\tregister complex tmp=F[j+p]*cur;\n\t\t\t\tF[j+p]=F[j]-tmp;\n\t\t\t\tF[j]=F[j]+tmp;\n\t\t\t\tcur=cur*unit;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(register int i=0;i<n;++i){\n\t\tscanf(\"%lf\",&F1[i].r);\n\t\tF2[n-i-1].r=F1[i].r;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tG[i]=1.0/i/i;\n\tfor(m=n,n=1;n<m;n<<=1);\n\tn<<=1;\n\tfor(register int i=0;i<n;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n\tFAQ(G,1);\n\tFAQ(F1,1);\n\tfor(register int i=0;i<n;++i)\n\t\tF1[i]=F1[i]*G[i];\n\tFAQ(F1,-1);\n\tFAQ(F2,1);\n\tfor(register int i=0;i<n;++i)\n\t\tF2[i]=F2[i]*G[i];\n\tFAQ(F2,-1);\n\tfor(register int i=0;i<m;++i)\n\t\tprintf(\"%lf\\n\",(F1[i].r-F2[m-i-1].r)/n);\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n# 数论变换（Number-Theoretic Transformation）\n\n注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用`double`存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。\n\n这就启示我们，能不能用其他的什么东西替换掉单位复根。\n\n设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\\equiv 1\\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\\delta_{p}(a)$。\n\n如果说$\\delta_{p}(a)=\\varphi(p)$，我们就称$a$是模$p$的一个原根。\n\n现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：\n\n$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。\n\n虽然我不会证，不过我们的确有$g^{0},g^{1},\\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。\n\n$\\omega_{2n}^{2k}=\\omega_{n}^{k}$。这是为了让我们可以分治。\n\n根据定义，$\\omega_{2n}=g^{\\frac{a}{2}}$，就是将现在的$p$进一步拆成$\\cfrac{a}{2}\\cdot2n+1$。不难发现\n\n$$\\omega_{2n}^{2k}=g^{\\frac{a}{2}\\cdot{2}k}=g^{ak}=\\omega_{n}^{k}$$\n\n因而原根有上述性质。\n\n$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}$，或者说$\\omega_{n}^{\\frac{n}{2}}=-1$。这同样是为了让我们可以分治。\n\n因为$p=an+1$，根据费马小定理，我们有\n\n$$\\omega_{n}^{n}\\equiv g^{an}\\equiv g^{p-1}\\equiv 1\\pmod{p}$$\n\n因而$\\omega_{n}^{\\frac{n}{2}}\\equiv\\pm 1\\pmod{p}$。又因为$\\omega_{n}^{0}=1$，而$\\omega_{n}^{\\frac{n}{2}}\\not\\equiv\\omega_{n}^{0}\\pmod{p}$，我们就得到$\\omega_{n}^{\\frac{n}{2}}\\equiv -1\\pmod{p}$。\n\n若$k\\neq 0$，$\\sum_{i=0}^{n-1}(\\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。\n\n以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\\times 17\\times 2^{23}+1$，它的原根是$3$。\n\n需要注意的是，我们还有一个可以优化的小细节。注意到$\\omega_{n}=g^{a}=g^{\\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\\omega_{2},\\omega_{4},\\cdots,\\omega_{2^{23}}$。注意到\n\n$$\\omega_{2^{23}}=3^{7\\times 17}=3^{119}$$\n\n$$\\omega_{2^{k}}=\\omega_{2^{k+1}}^{2}$$\n\n我们一遍快速幂算出$\\omega_{2^{23}}$然后倒着推出剩下的即可。\n\n关于$\\omega_{n}^{-k}$，注意到它就是$\\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。\n\n然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。\n\n代码：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#define re register\n#define maxn 2097152\n#define mod 998244353\n#define swap(a,b) a^=b,b^=a,a^=b\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m;\nint unit[2][24],rev[maxn+1],F[maxn+1],G[maxn+1];\n\ninline int cltpow(re int x,re int y){\n\tre int res=1;\n\tfor(;y;){\n\t\tif(y&1)\n\t\t\tres=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\ninline void NTT(int* F,re int tp){\n\tfor(re int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(re int k=1,p=1;p<n;++k,p<<=1)\n\t\tfor(re int i=0;i<n;i+=p<<1)\n\t\t\tfor(re int j=i,tmp=1;j<i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod){\n\t\t\t\tre int x=F[j],y=1LL*F[j+p]*tmp%mod;\n\t\t\t\tF[j]=(x+y)%mod;\n\t\t\t\tF[j+p]=(x-y+mod)%mod;\n\t\t\t}\n}\n\nint main(){\n\tunit[0][23]=cltpow(3,119);\n\tunit[1][23]=cltpow(332748118,119);\n\tfor(re int i=0;i<2;++i)\n\t\tfor(re int j=22;j>=0;--j)\n\t\t\tunit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod;\n\tcltstream::read(n);\n\tcltstream::read(m);\n\t++n;\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::read(F[i]);\n\t++m;\n\tfor(re int i=0;i<m;++i)\n\t\tcltstream::read(G[i]);\n\tfor(m+=n-1,n=1;n<m;n<<=1);\n\tfor(re int i=0;i<n;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n\tNTT(F,0);\n\tNTT(G,0);\n\tfor(re int i=0;i<n;++i)\n\t\tF[i]=1LL*F[i]*G[i]%mod;\n\tNTT(F,1);\n\tn=cltpow(n,mod-2);\n\tfor(re int i=0;i<m;++i)\n\t\tcltstream::write(1LL*F[i]*n%mod,i<m-1?32:-1);\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n以上。\n","source":"_posts/2018-12-19-polynomial-learning-notes-pt1.md","raw":"---\nmathjax: true\ndate: 2018-12-19 20:23:01\ntitle: 「多项式学习笔记Part I」最基本的多项式乘法\ntags:\n  - FFT\n  - NTT\ncategories:\n  - 学习笔记\n---\n最近正好月考，然而并不想去月考，于是来颓blog吧。\n\n<!-- more -->\n\n给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\\times G)(x)$的各项系数。$n,m\\leqslant 10^{6}$。\n\n我们不妨将$F(x)$的$i$次项系数记为$F[i]$\n\n$$F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}$$\n\n$$G(x)=\\sum\\limits_{i=0}^{m-1}G[i]x^{i}$$\n\n$$(F\\times G)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}$$\n\n$$(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]$$\n\n不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。\n\n不过为了优化，我们得先扯远点。\n\n# 点值表达\n\n如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。\n\n就比如说\n\n$$(0,2),(1,7),(2,4)$$\n\n~~瞎写的（~~\n\n我们可以列出如下的三元一次方程组：\n\n$$\\begin{cases}\n&\\text{C}=2\\\\\n&\\text{A}+\\text{B}+\\text{C}=7\\\\\n&4\\text{A}+2\\text{B}+\\text{C}=4\n\\end{cases}$$\n\n解得\n\n$$\\begin{cases}\n&\\text{A}=-4\\\\\n&\\text{B}=9\\\\\n&\\text{C}=2\n\\end{cases}$$\n\n注意到$(F\\times G)(x)=F(x)G(x)$~~（废话）~~，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\\times G)(x)$的点值表达了。因为$(F\\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。\n\n但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（\n\n于是我们还需要优化，于是我们还需要再扯远一点。\n\n# 复数\n\n对，你没看错，扯到复数了。\n\n## 基本概念\n\n根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说\n\n$$x^{2}+1=0$$\n\n我们知道，它的判别式是$\\Delta=b^{2}-4ac=-4\\lt 0$，因此它没有实数根。\n\n于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\\operatorname{tan}^{-1}\\cfrac{y}{x}$。\n\n因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。\n\n![](https://i.loli.net/2018/12/19/5c1a46b4d785b.png)\n\n上图展示了$4+i$和$3+4i$。\n\n复数的运算其实没什么出乎意料的：\n\n$$(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i$$\n\n$$(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i$$\n\n$$(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i$$\n\n$$\\begin{aligned}\n\\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\\\\n&=\\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\\\\n&=\\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i\n\\end{aligned}$$\n\n我们来单独考虑一下复数相乘的几何意义。\n\n假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\\alpha_{1}$，$\\alpha_{2}$。不难发现我们有\n\n$$c_{1}=r_{1}(\\operatorname{cos}\\alpha_{1}+i\\operatorname{sin}\\alpha_{1})$$\n\n$$c_{2}=r_{2}(\\operatorname{cos}\\alpha_{2}+i\\operatorname{sin}\\alpha_{2})$$\n\n$$\\begin{aligned}\nc_{1}c_{2}&=r_{1}r_{2}(\\cos\\alpha_{1}+i\\sin\\alpha_{1})(\\cos\\alpha_{2}+i\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}(\\cos\\alpha_{1}\\cos\\alpha_{2}+i\\cos\\alpha_{1}\\sin\\alpha_{2}+i\\sin\\alpha_{1}\\cos\\alpha_{2}-\\sin\\alpha_{1}\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}[\\cos(\\alpha_{1}+\\alpha_{2})+i\\sin(\\alpha_{1}+\\alpha_{2})]\n\\end{aligned}$$\n\n总结成一句话，就是「模长相乘，幅角相加」。\n\n## 单位圆与单位根\n\n单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。\n\n![](https://i.loli.net/2018/12/20/5c1b06e5602fa.png)\n\n考虑这么一个方程\n\n$$x^{n}=1$$\n\n它的所有复数根。\n\n因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有\n\n$$2\\pi\\mid na$$\n\n$$\\cfrac{2\\pi}{n}\\mid a$$\n\n不难想象出我们有$n$个这样的复数，它们的幅角通式是$\\cfrac{2k\\pi}{n}(k\\in[0,n)\\cap\\mathbb{Z})$。我们称其中幅角等于$\\cfrac{2\\pi}{n}$的复数，即$\\cos\\cfrac{2\\pi}{n}+i\\sin\\cfrac{2\\pi}{n}$为$n$次单位根$\\omega_{n}$，我们就可以把这$n$个复数表示为$\\omega_{n}^{k}(k\\in[0,n)\\cap\\mathbb{Z})$。\n\n它有如下的一些性质\n\n$$\\omega_{2n}^{2k}=\\omega_{n}^{k}$$\n\n因为它们的模长都是$1$，幅角相等就相等了。\n\n然后就没了，读者自证不难（\n\n$$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}$$\n\n因为$\\omega_{n}^{\\frac{n}{2}}$的幅角是$\\cfrac{2\\times\\frac{n}{2}\\pi}{n}=\\pi$，不难发现它就是$-1$了。\n\n# 快速傅里叶变换（Fast Fourier Transformation）\n\n## 运行过程\n\n那么问题来了，我们刚才扯了这么些，有什么用呢？\n\n就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。\n\n首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。\n\n然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：\n\n$$\\begin{aligned}\nF_{1}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i]x^{i}\\\\\n&=F[0]x^{0}+F[2]x^{1}+\\cdots+F[n-2]x^{\\frac{n}{2}-1}\n\\end{aligned}$$\n\n$$\\begin{aligned}\nF_{2}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i+1]x^{i}\\\\\n&=F[1]x^{0}+F[3]x^{1}+\\cdots+F[n-1]x^{\\frac{n}{2}-1}\n\\end{aligned}$$\n\n于是我们有\n\n$$F(x)=F_{1}(x^{2})+xF_{2}(x^{2})$$\n\n现在我们假设$0\\leqslant k<\\cfrac{n}{2}$，将$x=\\omega_{n}^{k}$和$x=\\omega_{n}^{k+\\frac{n}{2}}$代入\n\n$$\\begin{aligned}\nF(\\omega_{n}^{k})&=F_{1}(\\omega_{n}^{2k})+\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})+\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}$$\n\n$$\\begin{aligned}\nF(\\omega_{n}^{k+\\frac{n}{2}})&=F_{1}(\\omega_{n}^{2k+n})+\\omega_{n}^{k+\\frac{n}{2}}F_{2}(\\omega_{n}^{2k+n})\\\\\n&=F_{1}(\\omega_{n}^{2k})-\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}$$\n\n我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。\n\n简单地贴一下代码：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nvoid work(complex* F,int n){\n\tif(n==1)\n\t\treturn;\n\tcomplex F1[n>>1],F2[n>>1];\n    for(int i=0;i<n;i+=2){\n    \tF1[i]=F[2*i];\n        F2[i]=F[2*i+1];\n\t}\n    work(F1,n>>1);\n    work(F2,n>>1);\n    complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;\n    for(int i=0;i<(n>>1);++i,tmp=tmp*unit){\n    \tcomplex w=F2[i+(n>>1)]*tmp;\n        F[i]=F1[i]+w;\n        F[i+(n>>1)]=F1[i]-w;\n\t}\n}\n```\n\n{% endfold %}\n\n不过，以上代码是我现写出来的，~~保证其不正确性~~不保证其正确性。\n\n不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，`F`数组的每一个位置上实际存的是几次项：\n\n```plaintext\n0 1 2 3 4 5 6 7\n0 2 4 6|1 3 5 7\n0 4|2 6|1 5|3 7\n0|4|2|6|1|5|3|7\n```\n\n写成二进制看看：\n\n| 位置（十进制） | 位置（二进制） | 次数（十进制） | 次数（二进制） |\n| :-: | :-: | :-: | :-: |\n| $0$ | $000$ | $0$ | $000$ |\n| $1$ | $001$ | $4$ | $100$ |\n| $2$ | $010$ | $2$ | $010$ |\n| $3$ | $011$ | $6$ | $110$ |\n| $4$ | $100$ | $1$ | $001$ |\n| $5$ | $101$ | $5$ | $101$ |\n| $6$ | $110$ | $3$ | $011$ |\n| $7$ | $111$ | $7$ | $111$ |\n\n注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。\n\n我们可以$O(n)$地处理处每个数的镜像：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nfor(int i=0;i<n;++i)\n\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n```\n\n{% endfold %}\n\n中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。\n\n接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\nvoid work(complex* F,int n){\n\tfor(int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(int len=2,p=1;len<=n;len<<=1,p<<=1){\n\t\tcomplex unit(cos(Pi/p),sin(Pi/p));\n\t\tfor(int i=0;i<n;i+=len){\n\t\t\tcomplex cur(1,0);\n\t\t\tfor(int j=i;j<i+p;++j){\n\t\t\t\tcomplex tmp=F[j+p]*cur;\n\t\t\t\tF[j+p]=F[j]-tmp;\n\t\t\t\tF[j]=F[j]+tmp;\n\t\t\t\tcur=cur*unit;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n{% endfold %}\n\n那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\\omega_{n}^{0}),F(\\omega_{n}^{1}),\\cdots,F(\\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：\n\n$$\\begin{bmatrix}\n&(\\omega_{n}^{0})^{0}&(\\omega_{n}^{0})^{1}&\\cdots&(\\omega_{n}^{0})^{n-1}&\\\\\n&(\\omega_{n}^{1})^{0}&(\\omega_{n}^{1})^{1}&\\cdots&(\\omega_{n}^{1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&(\\omega_{n}^{n-1})^{0}&(\\omega_{n}^{n-1})^{1}&\\cdots&(\\omega_{n}^{n-1})^{n-1}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n&F[0]&\\\\\n&F[1]\\\\\n&\\vdots\\\\\n&F[n-1]\n\\end{bmatrix}\n=\\begin{bmatrix}\n&y_{0}&\\\\\n&y_{1}\\\\\n&\\vdots\\\\\n&y_{n-1}\n\\end{bmatrix}$$\n\n我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：\n\n$$\\begin{bmatrix}\n&\\frac{1}{n}(\\omega_{n}^{0})^{0}&\\frac{1}{n}(\\omega_{n}^{0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{0})^{n-1}&\\\\\n&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\n\\end{bmatrix}$$\n\n现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\\times B=C$。不难发现$A[i][j]=\\omega_{n}^{ij}$，$B[i][j]=\\cfrac{1}{n}\\omega_{n}^{-ij}$，我们有\n\n$$\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}A[i][k]B[k][j]\\\\\n&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{ik-kj}\n\\end{aligned}$$\n\n若$i=j$，不难发现此时$C[i][j]=1$。\n\n否则，即$i\\neq j$，设$i-j=l$，我们有\n\n$$\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{lk}\\\\\n&=\\cfrac{\\omega_{n}^{ln}-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=\\cfrac{1-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=0\n\\end{aligned}$$\n\n综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。\n\n因此我们有\n\n$$\\begin{bmatrix}&\\frac{1}{n}(\\omega_{n}^{-0})^{0}&\\frac{1}{n}(\\omega_{n}^{-0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-0})^{n-1}&\\\\&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\&\\vdots&\\vdots&\\ddots&\\vdots\\\\&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\\end{bmatrix}\\begin{bmatrix}&y_{0}&\\\\&y_{1}\\\\&\\vdots\\\\&y_{n-1}\\end{bmatrix}=\\begin{bmatrix}&F[0]&\\\\&F[1]\\\\&\\vdots\\\\&F[n-1]\\end{bmatrix}$$\n\n注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$换成$\\omega_{n}^{0},\\omega_{n}^{-1},\\cdots,\\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。\n\n注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的\n\n```cpp\ncomplex unit(cos(Pi/p),sin(Pi/p));\n```\n\n改成\n\n```cpp\ncomplex unit(cos(Pi/p),tp*sin(Pi/p));\n```\n\n然后调用时再传一个参数`tp`进去。`tp=1`表示是系数转点值，`tp=-1`表示是点值转系数。\n\n完整代码如下：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<cmath>\n#define maxn 2097152\n\nconst double Pi=acos(-1.0);\n\nint n,m;\nint rev[maxn+1];\nstruct complex{\n\tdouble r,c;\n\n\tcomplex(double _r=0,double _c=0){\n\t\tr=_r;\n\t\tc=_c;\n\t}\n};\ncomplex F[maxn+1],G[maxn+1];\n\ninline complex operator+(complex& a,complex& b){\n\treturn complex(a.r+b.r,a.c+b.c);\n}\n\ninline complex operator-(complex& a,complex& b){\n\treturn complex(a.r-b.r,a.c-b.c);\n}\n\ninline complex operator*(complex& a,complex& b){\n\treturn complex(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);\n}\n\ntemplate<typename _tp>\ninline void swap(_tp& x,_tp& y){\n\t_tp tmp=x;\n\tx=y;\n\ty=tmp;\n}\n\ninline void FAQ(complex F[],int tp){\n\tfor(register int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(register int len=2,p=1;len<=n;len<<=1,p<<=1){\n\t\tregister complex unit(cos(Pi/p),tp*sin(Pi/p));\n\t\tfor(register int i=0;i<n;i+=len){\n\t\t\tregister complex cur(1,0);\n\t\t\tfor(register int j=i;j<i+p;++j){\n\t\t\t\tregister complex tmp=F[j+p]*cur;\n\t\t\t\tF[j+p]=F[j]-tmp;\n\t\t\t\tF[j]=F[j]+tmp;\n\t\t\t\tcur=cur*unit;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\t++n;\n\tfor(register int i=0;i<n;++i)\n\t\tscanf(\"%d\",&F[i].r);\n\t++m;\n\tfor(register int i=0;i<m;++i)\n\t\tscanf(\"%d\",&G[i].r);\n\tfor(m+=n-1,n=1;n<m;n<<=1);\n\tfor(register int i=0;i<n;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n\tFAQ(F,1);\n\tFAQ(G,1);\n\tfor(register int i=0;i<n;++i)\n\t\tF[i]=F[i]*G[i];\n\tFAQ(F,-1);\n\tfor(register int i=0;i<m;++i)\n\t\tprintf(\"%0.0lf \",F[i].r/n);\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n~~不要问我`cltstream`哪去了（~~\n\n然后您就可以切掉这道[板子题](https://www.luogu.org/problemnew/show/P3803)了。\n\n其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（\n\n最好还是自己写吧（\n\n什么？想知道是哪道题？往下看（\n\n## 例题\n\n### [「ZJOI2014」力](https://www.luogu.org/problemnew/show/P3338)\n\n这是一道裸的卷积题。\n\n考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足\n\n$$H[i]=\\sum\\limits_{j=0}^{i}F[j]G[i-j]=\\sum\\limits_{0\\leqslant j<n,0\\leqslant k<n,j+k=i}F[j]G[k]$$\n\n在本页面往上翻，翻到这个式子：\n\n$$(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]$$\n\n发现了吗？这两个过程其实是一样的。\n\n于是，我们如下构造两个多项式\n\n$$F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}$$\n\n$$G(x)=\\sum\\limits_{i=0}^{n-1}G[i]x^{i}$$\n\n然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。\n\n那么这题呢？首先我们把$j\\lt i$和$j\\gt i$分开计算。\n\n先考虑$j\\lt i$，令$F[i]=q_{i}$，$G[i]=\\begin{cases}&\\cfrac{1}{i^{2}}\\;\\;&(i\\gt 0)\\\\&0&(i=0)\\end{cases}$，那么\n\n$$\\begin{aligned}\nE_{i}&=\\sum_{j=0}^{i-1}F[j]G[i-j]\\\\\n&=\\sum_{j=0}^{i}F[j]G[i-j]\n\\end{aligned}$$\n\n直接套板子就行。\n\n对于$j>i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（\n\n具体还是看代码吧：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include\\lt cstdio>\n#include<cmath>\n#define maxn 2097152\n\nconst double Pi=acos(-1.0);\n\nint n,m;\nint rev[maxn+1];\nstruct complex{\n\tdouble r,c;\n\n\tcomplex(double _r=0,double _c=0){\n\t\tr=_r;\n\t\tc=_c;\n\t}\n};\ncomplex F1[maxn+1],F2[maxn+1],G[maxn+1];\n\ninline complex operator+(complex& a,complex& b){\n\treturn complex(a.r+b.r,a.c+b.c);\n}\n\ninline complex operator-(complex& a,complex& b){\n\treturn complex(a.r-b.r,a.c-b.c);\n}\n\ninline complex operator*(complex& a,complex& b){\n\treturn complex(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);\n}\n\ntemplate<typename _tp>\ninline void swap(_tp& x,_tp& y){\n\t_tp tmp=x;\n\tx=y;\n\ty=tmp;\n}\n\ninline void FAQ(complex F[],int tp){\n\tfor(register int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(register int len=2,p=1;len<=n;len<<=1,p<<=1){\n\t\tregister complex unit(cos(Pi/p),tp*sin(Pi/p));\n\t\tfor(register int i=0;i<n;i+=len){\n\t\t\tregister complex cur(1,0);\n\t\t\tfor(register int j=i;j<i+p;++j){\n\t\t\t\tregister complex tmp=F[j+p]*cur;\n\t\t\t\tF[j+p]=F[j]-tmp;\n\t\t\t\tF[j]=F[j]+tmp;\n\t\t\t\tcur=cur*unit;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(register int i=0;i<n;++i){\n\t\tscanf(\"%lf\",&F1[i].r);\n\t\tF2[n-i-1].r=F1[i].r;\n\t}\n\tfor(register int i=1;i<n;++i)\n\t\tG[i]=1.0/i/i;\n\tfor(m=n,n=1;n<m;n<<=1);\n\tn<<=1;\n\tfor(register int i=0;i<n;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n\tFAQ(G,1);\n\tFAQ(F1,1);\n\tfor(register int i=0;i<n;++i)\n\t\tF1[i]=F1[i]*G[i];\n\tFAQ(F1,-1);\n\tFAQ(F2,1);\n\tfor(register int i=0;i<n;++i)\n\t\tF2[i]=F2[i]*G[i];\n\tFAQ(F2,-1);\n\tfor(register int i=0;i<m;++i)\n\t\tprintf(\"%lf\\n\",(F1[i].r-F2[m-i-1].r)/n);\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n# 数论变换（Number-Theoretic Transformation）\n\n注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用`double`存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。\n\n这就启示我们，能不能用其他的什么东西替换掉单位复根。\n\n设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\\equiv 1\\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\\delta_{p}(a)$。\n\n如果说$\\delta_{p}(a)=\\varphi(p)$，我们就称$a$是模$p$的一个原根。\n\n现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：\n\n$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。\n\n虽然我不会证，不过我们的确有$g^{0},g^{1},\\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。\n\n$\\omega_{2n}^{2k}=\\omega_{n}^{k}$。这是为了让我们可以分治。\n\n根据定义，$\\omega_{2n}=g^{\\frac{a}{2}}$，就是将现在的$p$进一步拆成$\\cfrac{a}{2}\\cdot2n+1$。不难发现\n\n$$\\omega_{2n}^{2k}=g^{\\frac{a}{2}\\cdot{2}k}=g^{ak}=\\omega_{n}^{k}$$\n\n因而原根有上述性质。\n\n$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}$，或者说$\\omega_{n}^{\\frac{n}{2}}=-1$。这同样是为了让我们可以分治。\n\n因为$p=an+1$，根据费马小定理，我们有\n\n$$\\omega_{n}^{n}\\equiv g^{an}\\equiv g^{p-1}\\equiv 1\\pmod{p}$$\n\n因而$\\omega_{n}^{\\frac{n}{2}}\\equiv\\pm 1\\pmod{p}$。又因为$\\omega_{n}^{0}=1$，而$\\omega_{n}^{\\frac{n}{2}}\\not\\equiv\\omega_{n}^{0}\\pmod{p}$，我们就得到$\\omega_{n}^{\\frac{n}{2}}\\equiv -1\\pmod{p}$。\n\n若$k\\neq 0$，$\\sum_{i=0}^{n-1}(\\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。\n\n以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\\times 17\\times 2^{23}+1$，它的原根是$3$。\n\n需要注意的是，我们还有一个可以优化的小细节。注意到$\\omega_{n}=g^{a}=g^{\\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\\omega_{2},\\omega_{4},\\cdots,\\omega_{2^{23}}$。注意到\n\n$$\\omega_{2^{23}}=3^{7\\times 17}=3^{119}$$\n\n$$\\omega_{2^{k}}=\\omega_{2^{k+1}}^{2}$$\n\n我们一遍快速幂算出$\\omega_{2^{23}}$然后倒着推出剩下的即可。\n\n关于$\\omega_{n}^{-k}$，注意到它就是$\\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。\n\n然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。\n\n代码：\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#define re register\n#define maxn 2097152\n#define mod 998244353\n#define swap(a,b) a^=b,b^=a,a^=b\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m;\nint unit[2][24],rev[maxn+1],F[maxn+1],G[maxn+1];\n\ninline int cltpow(re int x,re int y){\n\tre int res=1;\n\tfor(;y;){\n\t\tif(y&1)\n\t\t\tres=1LL*res*x%mod;\n\t\tx=1LL*x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\n\ninline void NTT(int* F,re int tp){\n\tfor(re int i=0;i<n;++i)\n\t\tif(i<rev[i])\n\t\t\tswap(F[i],F[rev[i]]);\n\tfor(re int k=1,p=1;p<n;++k,p<<=1)\n\t\tfor(re int i=0;i<n;i+=p<<1)\n\t\t\tfor(re int j=i,tmp=1;j<i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod){\n\t\t\t\tre int x=F[j],y=1LL*F[j+p]*tmp%mod;\n\t\t\t\tF[j]=(x+y)%mod;\n\t\t\t\tF[j+p]=(x-y+mod)%mod;\n\t\t\t}\n}\n\nint main(){\n\tunit[0][23]=cltpow(3,119);\n\tunit[1][23]=cltpow(332748118,119);\n\tfor(re int i=0;i<2;++i)\n\t\tfor(re int j=22;j>=0;--j)\n\t\t\tunit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod;\n\tcltstream::read(n);\n\tcltstream::read(m);\n\t++n;\n\tfor(re int i=0;i<n;++i)\n\t\tcltstream::read(F[i]);\n\t++m;\n\tfor(re int i=0;i<m;++i)\n\t\tcltstream::read(G[i]);\n\tfor(m+=n-1,n=1;n<m;n<<=1);\n\tfor(re int i=0;i<n;++i)\n\t\trev[i]=(rev[i>>1]>>1)|((i&1)?(n>>1):0);\n\tNTT(F,0);\n\tNTT(G,0);\n\tfor(re int i=0;i<n;++i)\n\t\tF[i]=1LL*F[i]*G[i]%mod;\n\tNTT(F,1);\n\tn=cltpow(n,mod-2);\n\tfor(re int i=0;i<m;++i)\n\t\tcltstream::write(1LL*F[i]*n%mod,i<m-1?32:-1);\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n以上。\n","slug":"polynomial-learning-notes-pt1","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpxl004p34cwsjgnmqn9","content":"<p>最近正好月考，然而并不想去月考，于是来颓blog吧。</p>\n<a id=\"more\"></a>\n<p>给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\\times G)(x)$的各项系数。$n,m\\leqslant 10^{6}$。</p>\n<p>我们不妨将$F(x)$的$i$次项系数记为$F[i]$</p>\n<script type=\"math/tex; mode=display\">F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}</script><script type=\"math/tex; mode=display\">G(x)=\\sum\\limits_{i=0}^{m-1}G[i]x^{i}</script><script type=\"math/tex; mode=display\">(F\\times G)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}</script><script type=\"math/tex; mode=display\">(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]</script><p>不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。</p>\n<p>不过为了优化，我们得先扯远点。</p>\n<h1 id=\"点值表达\"><a href=\"#点值表达\" class=\"headerlink\" title=\"点值表达\"></a>点值表达</h1><p>如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。</p>\n<p>就比如说</p>\n<script type=\"math/tex; mode=display\">(0,2),(1,7),(2,4)</script><p><del>瞎写的（</del></p>\n<p>我们可以列出如下的三元一次方程组：</p>\n<script type=\"math/tex; mode=display\">\\begin{cases}\n&\\text{C}=2\\\\\n&\\text{A}+\\text{B}+\\text{C}=7\\\\\n&4\\text{A}+2\\text{B}+\\text{C}=4\n\\end{cases}</script><p>解得</p>\n<script type=\"math/tex; mode=display\">\\begin{cases}\n&\\text{A}=-4\\\\\n&\\text{B}=9\\\\\n&\\text{C}=2\n\\end{cases}</script><p>注意到$(F\\times G)(x)=F(x)G(x)$<del>（废话）</del>，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\\times G)(x)$的点值表达了。因为$(F\\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。</p>\n<p>但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（</p>\n<p>于是我们还需要优化，于是我们还需要再扯远一点。</p>\n<h1 id=\"复数\"><a href=\"#复数\" class=\"headerlink\" title=\"复数\"></a>复数</h1><p>对，你没看错，扯到复数了。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说</p>\n<script type=\"math/tex; mode=display\">x^{2}+1=0</script><p>我们知道，它的判别式是$\\Delta=b^{2}-4ac=-4\\lt 0$，因此它没有实数根。</p>\n<p>于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\\operatorname{tan}^{-1}\\cfrac{y}{x}$。</p>\n<p>因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。</p>\n<p><img src=\"https://i.loli.net/2018/12/19/5c1a46b4d785b.png\" alt=\"\"></p>\n<p>上图展示了$4+i$和$3+4i$。</p>\n<p>复数的运算其实没什么出乎意料的：</p>\n<script type=\"math/tex; mode=display\">(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i</script><script type=\"math/tex; mode=display\">(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i</script><script type=\"math/tex; mode=display\">(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i</script><script type=\"math/tex; mode=display\">\\begin{aligned}\n\\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\\\\n&=\\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\\\\n&=\\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i\n\\end{aligned}</script><p>我们来单独考虑一下复数相乘的几何意义。</p>\n<p>假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\\alpha_{1}$，$\\alpha_{2}$。不难发现我们有</p>\n<script type=\"math/tex; mode=display\">c_{1}=r_{1}(\\operatorname{cos}\\alpha_{1}+i\\operatorname{sin}\\alpha_{1})</script><script type=\"math/tex; mode=display\">c_{2}=r_{2}(\\operatorname{cos}\\alpha_{2}+i\\operatorname{sin}\\alpha_{2})</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nc_{1}c_{2}&=r_{1}r_{2}(\\cos\\alpha_{1}+i\\sin\\alpha_{1})(\\cos\\alpha_{2}+i\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}(\\cos\\alpha_{1}\\cos\\alpha_{2}+i\\cos\\alpha_{1}\\sin\\alpha_{2}+i\\sin\\alpha_{1}\\cos\\alpha_{2}-\\sin\\alpha_{1}\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}[\\cos(\\alpha_{1}+\\alpha_{2})+i\\sin(\\alpha_{1}+\\alpha_{2})]\n\\end{aligned}</script><p>总结成一句话，就是「模长相乘，幅角相加」。</p>\n<h2 id=\"单位圆与单位根\"><a href=\"#单位圆与单位根\" class=\"headerlink\" title=\"单位圆与单位根\"></a>单位圆与单位根</h2><p>单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。</p>\n<p><img src=\"https://i.loli.net/2018/12/20/5c1b06e5602fa.png\" alt=\"\"></p>\n<p>考虑这么一个方程</p>\n<script type=\"math/tex; mode=display\">x^{n}=1</script><p>它的所有复数根。</p>\n<p>因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有</p>\n<script type=\"math/tex; mode=display\">2\\pi\\mid na</script><script type=\"math/tex; mode=display\">\\cfrac{2\\pi}{n}\\mid a</script><p>不难想象出我们有$n$个这样的复数，它们的幅角通式是$\\cfrac{2k\\pi}{n}(k\\in[0,n)\\cap\\mathbb{Z})$。我们称其中幅角等于$\\cfrac{2\\pi}{n}$的复数，即$\\cos\\cfrac{2\\pi}{n}+i\\sin\\cfrac{2\\pi}{n}$为$n$次单位根$\\omega_{n}$，我们就可以把这$n$个复数表示为$\\omega_{n}^{k}(k\\in[0,n)\\cap\\mathbb{Z})$。</p>\n<p>它有如下的一些性质</p>\n<script type=\"math/tex; mode=display\">\\omega_{2n}^{2k}=\\omega_{n}^{k}</script><p>因为它们的模长都是$1$，幅角相等就相等了。</p>\n<p>然后就没了，读者自证不难（</p>\n<script type=\"math/tex; mode=display\">\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}</script><p>因为$\\omega_{n}^{\\frac{n}{2}}$的幅角是$\\cfrac{2\\times\\frac{n}{2}\\pi}{n}=\\pi$，不难发现它就是$-1$了。</p>\n<h1 id=\"快速傅里叶变换（Fast-Fourier-Transformation）\"><a href=\"#快速傅里叶变换（Fast-Fourier-Transformation）\" class=\"headerlink\" title=\"快速傅里叶变换（Fast Fourier Transformation）\"></a>快速傅里叶变换（Fast Fourier Transformation）</h1><h2 id=\"运行过程\"><a href=\"#运行过程\" class=\"headerlink\" title=\"运行过程\"></a>运行过程</h2><p>那么问题来了，我们刚才扯了这么些，有什么用呢？</p>\n<p>就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。</p>\n<p>首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。</p>\n<p>然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF_{1}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i]x^{i}\\\\\n&=F[0]x^{0}+F[2]x^{1}+\\cdots+F[n-2]x^{\\frac{n}{2}-1}\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nF_{2}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i+1]x^{i}\\\\\n&=F[1]x^{0}+F[3]x^{1}+\\cdots+F[n-1]x^{\\frac{n}{2}-1}\n\\end{aligned}</script><p>于是我们有</p>\n<script type=\"math/tex; mode=display\">F(x)=F_{1}(x^{2})+xF_{2}(x^{2})</script><p>现在我们假设$0\\leqslant k&lt;\\cfrac{n}{2}$，将$x=\\omega_{n}^{k}$和$x=\\omega_{n}^{k+\\frac{n}{2}}$代入</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(\\omega_{n}^{k})&=F_{1}(\\omega_{n}^{2k})+\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})+\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nF(\\omega_{n}^{k+\\frac{n}{2}})&=F_{1}(\\omega_{n}^{2k+n})+\\omega_{n}^{k+\\frac{n}{2}}F_{2}(\\omega_{n}^{2k+n})\\\\\n&=F_{1}(\\omega_{n}^{2k})-\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}</script><p>我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。</p>\n<p>简单地贴一下代码：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">complex</span>* F,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n==<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">complex</span> F1[n&gt;&gt;<span class=\"number\">1</span>],F2[n&gt;&gt;<span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    \tF1[i]=F[<span class=\"number\">2</span>*i];</span><br><span class=\"line\">        F2[i]=F[<span class=\"number\">2</span>*i+<span class=\"number\">1</span>];</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    work(F1,n&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">    work(F2,n&gt;&gt;<span class=\"number\">1</span>);</span><br><span class=\"line\">    complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;(n&gt;&gt;<span class=\"number\">1</span>);++i,tmp=tmp*unit)&#123;</span><br><span class=\"line\">    \t<span class=\"keyword\">complex</span> w=F2[i+(n&gt;&gt;<span class=\"number\">1</span>)]*tmp;</span><br><span class=\"line\">        F[i]=F1[i]+w;</span><br><span class=\"line\">        F[i+(n&gt;&gt;<span class=\"number\">1</span>)]=F1[i]-w;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>不过，以上代码是我现写出来的，<del>保证其不正确性</del>不保证其正确性。</p>\n<p>不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，<code>F</code>数组的每一个位置上实际存的是几次项：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0 1 2 3 4 5 6 7</span><br><span class=\"line\">0 2 4 6|1 3 5 7</span><br><span class=\"line\">0 4|2 6|1 5|3 7</span><br><span class=\"line\">0|4|2|6|1|5|3|7</span><br></pre></td></tr></table></figure>\n<p>写成二进制看看：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">位置（十进制）</th>\n<th style=\"text-align:center\">位置（二进制）</th>\n<th style=\"text-align:center\">次数（十进制）</th>\n<th style=\"text-align:center\">次数（二进制）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$000$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$000$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$001$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$100$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$010$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$010$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$011$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$110$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$100$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$001$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$5$</td>\n<td style=\"text-align:center\">$101$</td>\n<td style=\"text-align:center\">$5$</td>\n<td style=\"text-align:center\">$101$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$110$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$011$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$7$</td>\n<td style=\"text-align:center\">$111$</td>\n<td style=\"text-align:center\">$7$</td>\n<td style=\"text-align:center\">$111$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。</p>\n<p>我们可以$O(n)$地处理处每个数的镜像：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\trev[i]=(rev[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|((i&amp;<span class=\"number\">1</span>)?(n&gt;&gt;<span class=\"number\">1</span>):<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。</p>\n<p>接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">work</span><span class=\"params\">(<span class=\"keyword\">complex</span>* F,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&lt;rev[i])</span><br><span class=\"line\">\t\t\tswap(F[i],F[rev[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> len=<span class=\"number\">2</span>,p=<span class=\"number\">1</span>;len&lt;=n;len&lt;&lt;=<span class=\"number\">1</span>,p&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tcomplex unit(cos(Pi/p),sin(Pi/p));</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=len)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">complex</span> <span class=\"title\">cur</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">complex</span> tmp=F[j+p]*cur;</span><br><span class=\"line\">\t\t\t\tF[j+p]=F[j]-tmp;</span><br><span class=\"line\">\t\t\t\tF[j]=F[j]+tmp;</span><br><span class=\"line\">\t\t\t\tcur=cur*unit;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\\omega_{n}^{0}),F(\\omega_{n}^{1}),\\cdots,F(\\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}\n&(\\omega_{n}^{0})^{0}&(\\omega_{n}^{0})^{1}&\\cdots&(\\omega_{n}^{0})^{n-1}&\\\\\n&(\\omega_{n}^{1})^{0}&(\\omega_{n}^{1})^{1}&\\cdots&(\\omega_{n}^{1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&(\\omega_{n}^{n-1})^{0}&(\\omega_{n}^{n-1})^{1}&\\cdots&(\\omega_{n}^{n-1})^{n-1}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n&F[0]&\\\\\n&F[1]\\\\\n&\\vdots\\\\\n&F[n-1]\n\\end{bmatrix}\n=\\begin{bmatrix}\n&y_{0}&\\\\\n&y_{1}\\\\\n&\\vdots\\\\\n&y_{n-1}\n\\end{bmatrix}</script><p>我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}\n&\\frac{1}{n}(\\omega_{n}^{0})^{0}&\\frac{1}{n}(\\omega_{n}^{0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{0})^{n-1}&\\\\\n&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\n\\end{bmatrix}</script><p>现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\\times B=C$。不难发现$A[i][j]=\\omega_{n}^{ij}$，$B[i][j]=\\cfrac{1}{n}\\omega_{n}^{-ij}$，我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}A[i][k]B[k][j]\\\\\n&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{ik-kj}\n\\end{aligned}</script><p>若$i=j$，不难发现此时$C[i][j]=1$。</p>\n<p>否则，即$i\\neq j$，设$i-j=l$，我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{lk}\\\\\n&=\\cfrac{\\omega_{n}^{ln}-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=\\cfrac{1-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=0\n\\end{aligned}</script><p>综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。</p>\n<p>因此我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}&\\frac{1}{n}(\\omega_{n}^{-0})^{0}&\\frac{1}{n}(\\omega_{n}^{-0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-0})^{n-1}&\\\\&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\&\\vdots&\\vdots&\\ddots&\\vdots\\\\&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\\end{bmatrix}\\begin{bmatrix}&y_{0}&\\\\&y_{1}\\\\&\\vdots\\\\&y_{n-1}\\end{bmatrix}=\\begin{bmatrix}&F[0]&\\\\&F[1]\\\\&\\vdots\\\\&F[n-1]\\end{bmatrix}</script><p>注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$换成$\\omega_{n}^{0},\\omega_{n}^{-1},\\cdots,\\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。</p>\n<p>注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">complex unit(cos(Pi/p),sin(Pi/p));</span><br></pre></td></tr></table></figure>\n<p>改成</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br></pre></td></tr></table></figure>\n<p>然后调用时再传一个参数<code>tp</code>进去。<code>tp=1</code>表示是系数转点值，<code>tp=-1</code>表示是点值转系数。</p>\n<p>完整代码如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 2097152</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> Pi=<span class=\"built_in\">acos</span>(<span class=\"number\">-1.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> rev[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">complex</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> r,c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">complex</span>(<span class=\"keyword\">double</span> _r=<span class=\"number\">0</span>,<span class=\"keyword\">double</span> _c=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tr=_r;</span><br><span class=\"line\">\t\tc=_c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">complex</span> F[maxn+<span class=\"number\">1</span>],G[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">complex</span> <span class=\"keyword\">operator</span>+(<span class=\"keyword\">complex</span>&amp; a,<span class=\"keyword\">complex</span>&amp; b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">complex</span> <span class=\"keyword\">operator</span>-(<span class=\"keyword\">complex</span>&amp; a,<span class=\"keyword\">complex</span>&amp; b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">complex</span> <span class=\"keyword\">operator</span>*(<span class=\"keyword\">complex</span>&amp; a,<span class=\"keyword\">complex</span>&amp; b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t_tp tmp=x;</span><br><span class=\"line\">\tx=y;</span><br><span class=\"line\">\ty=tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">FAQ</span><span class=\"params\">(<span class=\"keyword\">complex</span> F[],<span class=\"keyword\">int</span> tp)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&lt;rev[i])</span><br><span class=\"line\">\t\t\tswap(F[i],F[rev[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> len=<span class=\"number\">2</span>,p=<span class=\"number\">1</span>;len&lt;=n;len&lt;&lt;=<span class=\"number\">1</span>,p&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tregister complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=len)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">register</span> <span class=\"keyword\">complex</span> <span class=\"title\">cur</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">register</span> <span class=\"keyword\">complex</span> tmp=F[j+p]*cur;</span><br><span class=\"line\">\t\t\t\tF[j+p]=F[j]-tmp;</span><br><span class=\"line\">\t\t\t\tF[j]=F[j]+tmp;</span><br><span class=\"line\">\t\t\t\tcur=cur*unit;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d%d\"</span>,&amp;n,&amp;m);</span><br><span class=\"line\">\t++n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;F[i].r);</span><br><span class=\"line\">\t++m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;G[i].r);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(m+=n<span class=\"number\">-1</span>,n=<span class=\"number\">1</span>;n&lt;m;n&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\trev[i]=(rev[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|((i&amp;<span class=\"number\">1</span>)?(n&gt;&gt;<span class=\"number\">1</span>):<span class=\"number\">0</span>);</span><br><span class=\"line\">\tFAQ(F,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tFAQ(G,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tF[i]=F[i]*G[i];</span><br><span class=\"line\">\tFAQ(F,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%0.0lf \"</span>,F[i].r/n);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p><del>不要问我<code>cltstream</code>哪去了（</del></p>\n<p>然后您就可以切掉这道<a href=\"https://www.luogu.org/problemnew/show/P3803\" target=\"_blank\" rel=\"noopener\">板子题</a>了。</p>\n<p>其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（</p>\n<p>最好还是自己写吧（</p>\n<p>什么？想知道是哪道题？往下看（</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h3 id=\"「ZJOI2014」力\"><a href=\"#「ZJOI2014」力\" class=\"headerlink\" title=\"「ZJOI2014」力\"></a><a href=\"https://www.luogu.org/problemnew/show/P3338\" target=\"_blank\" rel=\"noopener\">「ZJOI2014」力</a></h3><p>这是一道裸的卷积题。</p>\n<p>考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足</p>\n<script type=\"math/tex; mode=display\">H[i]=\\sum\\limits_{j=0}^{i}F[j]G[i-j]=\\sum\\limits_{0\\leqslant j<n,0\\leqslant k<n,j+k=i}F[j]G[k]</script><p>在本页面往上翻，翻到这个式子：</p>\n<script type=\"math/tex; mode=display\">(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]</script><p>发现了吗？这两个过程其实是一样的。</p>\n<p>于是，我们如下构造两个多项式</p>\n<script type=\"math/tex; mode=display\">F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}</script><script type=\"math/tex; mode=display\">G(x)=\\sum\\limits_{i=0}^{n-1}G[i]x^{i}</script><p>然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。</p>\n<p>那么这题呢？首先我们把$j\\lt i$和$j\\gt i$分开计算。</p>\n<p>先考虑$j\\lt i$，令$F[i]=q_{i}$，$G[i]=\\begin{cases}&amp;\\cfrac{1}{i^{2}}\\;\\;&amp;(i\\gt 0)\\\\&amp;0&amp;(i=0)\\end{cases}$，那么</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nE_{i}&=\\sum_{j=0}^{i-1}F[j]G[i-j]\\\\\n&=\\sum_{j=0}^{i}F[j]G[i-j]\n\\end{aligned}</script><p>直接套板子就行。</p>\n<p>对于$j&gt;i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（</p>\n<p>具体还是看代码吧：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>\\lt cstdio&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 2097152</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> Pi=<span class=\"built_in\">acos</span>(<span class=\"number\">-1.0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> rev[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">complex</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">double</span> r,c;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">complex</span>(<span class=\"keyword\">double</span> _r=<span class=\"number\">0</span>,<span class=\"keyword\">double</span> _c=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">\t\tr=_r;</span><br><span class=\"line\">\t\tc=_c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">complex</span> F1[maxn+<span class=\"number\">1</span>],F2[maxn+<span class=\"number\">1</span>],G[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">complex</span> <span class=\"keyword\">operator</span>+(<span class=\"keyword\">complex</span>&amp; a,<span class=\"keyword\">complex</span>&amp; b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">complex</span> <span class=\"keyword\">operator</span>-(<span class=\"keyword\">complex</span>&amp; a,<span class=\"keyword\">complex</span>&amp; b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">complex</span> <span class=\"keyword\">operator</span>*(<span class=\"keyword\">complex</span>&amp; a,<span class=\"keyword\">complex</span>&amp; b)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class=\"line\">\t_tp tmp=x;</span><br><span class=\"line\">\tx=y;</span><br><span class=\"line\">\ty=tmp;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">FAQ</span><span class=\"params\">(<span class=\"keyword\">complex</span> F[],<span class=\"keyword\">int</span> tp)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&lt;rev[i])</span><br><span class=\"line\">\t\t\tswap(F[i],F[rev[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> len=<span class=\"number\">2</span>,p=<span class=\"number\">1</span>;len&lt;=n;len&lt;&lt;=<span class=\"number\">1</span>,p&lt;&lt;=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\tregister complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=len)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"function\"><span class=\"keyword\">register</span> <span class=\"keyword\">complex</span> <span class=\"title\">cur</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">register</span> <span class=\"keyword\">complex</span> tmp=F[j+p]*cur;</span><br><span class=\"line\">\t\t\t\tF[j+p]=F[j]-tmp;</span><br><span class=\"line\">\t\t\t\tF[j]=F[j]+tmp;</span><br><span class=\"line\">\t\t\t\tcur=cur*unit;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>,&amp;F1[i].r);</span><br><span class=\"line\">\t\tF2[n-i<span class=\"number\">-1</span>].r=F1[i].r;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tG[i]=<span class=\"number\">1.0</span>/i/i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(m=n,n=<span class=\"number\">1</span>;n&lt;m;n&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">\tn&lt;&lt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\trev[i]=(rev[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|((i&amp;<span class=\"number\">1</span>)?(n&gt;&gt;<span class=\"number\">1</span>):<span class=\"number\">0</span>);</span><br><span class=\"line\">\tFAQ(G,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tFAQ(F1,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tF1[i]=F1[i]*G[i];</span><br><span class=\"line\">\tFAQ(F1,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tFAQ(F2,<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tF2[i]=F2[i]*G[i];</span><br><span class=\"line\">\tFAQ(F2,<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%lf\\n\"</span>,(F1[i].r-F2[m-i<span class=\"number\">-1</span>].r)/n);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<h1 id=\"数论变换（Number-Theoretic-Transformation）\"><a href=\"#数论变换（Number-Theoretic-Transformation）\" class=\"headerlink\" title=\"数论变换（Number-Theoretic Transformation）\"></a>数论变换（Number-Theoretic Transformation）</h1><p>注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用<code>double</code>存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。</p>\n<p>这就启示我们，能不能用其他的什么东西替换掉单位复根。</p>\n<p>设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\\equiv 1\\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\\delta_{p}(a)$。</p>\n<p>如果说$\\delta_{p}(a)=\\varphi(p)$，我们就称$a$是模$p$的一个原根。</p>\n<p>现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：</p>\n<p>$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。</p>\n<p>虽然我不会证，不过我们的确有$g^{0},g^{1},\\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。</p>\n<p>$\\omega_{2n}^{2k}=\\omega_{n}^{k}$。这是为了让我们可以分治。</p>\n<p>根据定义，$\\omega_{2n}=g^{\\frac{a}{2}}$，就是将现在的$p$进一步拆成$\\cfrac{a}{2}\\cdot2n+1$。不难发现</p>\n<script type=\"math/tex; mode=display\">\\omega_{2n}^{2k}=g^{\\frac{a}{2}\\cdot{2}k}=g^{ak}=\\omega_{n}^{k}</script><p>因而原根有上述性质。</p>\n<p>$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}$，或者说$\\omega_{n}^{\\frac{n}{2}}=-1$。这同样是为了让我们可以分治。</p>\n<p>因为$p=an+1$，根据费马小定理，我们有</p>\n<script type=\"math/tex; mode=display\">\\omega_{n}^{n}\\equiv g^{an}\\equiv g^{p-1}\\equiv 1\\pmod{p}</script><p>因而$\\omega_{n}^{\\frac{n}{2}}\\equiv\\pm 1\\pmod{p}$。又因为$\\omega_{n}^{0}=1$，而$\\omega_{n}^{\\frac{n}{2}}\\not\\equiv\\omega_{n}^{0}\\pmod{p}$，我们就得到$\\omega_{n}^{\\frac{n}{2}}\\equiv -1\\pmod{p}$。</p>\n<p>若$k\\neq 0$，$\\sum_{i=0}^{n-1}(\\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。</p>\n<p>以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\\times 17\\times 2^{23}+1$，它的原根是$3$。</p>\n<p>需要注意的是，我们还有一个可以优化的小细节。注意到$\\omega_{n}=g^{a}=g^{\\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\\omega_{2},\\omega_{4},\\cdots,\\omega_{2^{23}}$。注意到</p>\n<script type=\"math/tex; mode=display\">\\omega_{2^{23}}=3^{7\\times 17}=3^{119}</script><script type=\"math/tex; mode=display\">\\omega_{2^{k}}=\\omega_{2^{k+1}}^{2}</script><p>我们一遍快速幂算出$\\omega_{2^{23}}$然后倒着推出剩下的即可。</p>\n<p>关于$\\omega_{n}^{-k}$，注意到它就是$\\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。</p>\n<p>然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。</p>\n<p>代码：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> maxn 2097152</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 998244353</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"><span class=\"keyword\">int</span> unit[<span class=\"number\">2</span>][<span class=\"number\">24</span>],rev[maxn+<span class=\"number\">1</span>],F[maxn+<span class=\"number\">1</span>],G[maxn+<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">cltpow</span><span class=\"params\">(re <span class=\"keyword\">int</span> x,re <span class=\"keyword\">int</span> y)</span></span>&#123;</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> res=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;y;)&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(y&amp;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\tres=<span class=\"number\">1L</span>L*res*x%mod;</span><br><span class=\"line\">\t\tx=<span class=\"number\">1L</span>L*x*x%mod;</span><br><span class=\"line\">\t\ty&gt;&gt;=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">NTT</span><span class=\"params\">(<span class=\"keyword\">int</span>* F,re <span class=\"keyword\">int</span> tp)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(i&lt;rev[i])</span><br><span class=\"line\">\t\t\tswap(F[i],F[rev[i]]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> k=<span class=\"number\">1</span>,p=<span class=\"number\">1</span>;p&lt;n;++k,p&lt;&lt;=<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i+=p&lt;&lt;<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=i,tmp=<span class=\"number\">1</span>;j&lt;i+p;++j,tmp=<span class=\"number\">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class=\"line\">\t\t\t\tre <span class=\"keyword\">int</span> x=F[j],y=<span class=\"number\">1L</span>L*F[j+p]*tmp%mod;</span><br><span class=\"line\">\t\t\t\tF[j]=(x+y)%mod;</span><br><span class=\"line\">\t\t\t\tF[j+p]=(x-y+mod)%mod;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tunit[<span class=\"number\">0</span>][<span class=\"number\">23</span>]=cltpow(<span class=\"number\">3</span>,<span class=\"number\">119</span>);</span><br><span class=\"line\">\tunit[<span class=\"number\">1</span>][<span class=\"number\">23</span>]=cltpow(<span class=\"number\">332748118</span>,<span class=\"number\">119</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">2</span>;++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> j=<span class=\"number\">22</span>;j&gt;=<span class=\"number\">0</span>;--j)</span><br><span class=\"line\">\t\t\tunit[i][j]=<span class=\"number\">1L</span>L*unit[i][j+<span class=\"number\">1</span>]*unit[i][j+<span class=\"number\">1</span>]%mod;</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\tcltstream::read(m);</span><br><span class=\"line\">\t++n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tcltstream::read(F[i]);</span><br><span class=\"line\">\t++m;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)</span><br><span class=\"line\">\t\tcltstream::read(G[i]);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(m+=n<span class=\"number\">-1</span>,n=<span class=\"number\">1</span>;n&lt;m;n&lt;&lt;=<span class=\"number\">1</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\trev[i]=(rev[i&gt;&gt;<span class=\"number\">1</span>]&gt;&gt;<span class=\"number\">1</span>)|((i&amp;<span class=\"number\">1</span>)?(n&gt;&gt;<span class=\"number\">1</span>):<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(F,<span class=\"number\">0</span>);</span><br><span class=\"line\">\tNTT(G,<span class=\"number\">0</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;++i)</span><br><span class=\"line\">\t\tF[i]=<span class=\"number\">1L</span>L*F[i]*G[i]%mod;</span><br><span class=\"line\">\tNTT(F,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tn=cltpow(n,mod<span class=\"number\">-2</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)</span><br><span class=\"line\">\t\tcltstream::write(<span class=\"number\">1L</span>L*F[i]*n%mod,i&lt;m<span class=\"number\">-1</span>?<span class=\"number\">32</span>:<span class=\"number\">-1</span>);</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>以上。</p>\n","site":{"data":{}},"excerpt":"<p>最近正好月考，然而并不想去月考，于是来颓blog吧。</p>","more":"<p>给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\\times G)(x)$的各项系数。$n,m\\leqslant 10^{6}$。</p>\n<p>我们不妨将$F(x)$的$i$次项系数记为$F[i]$</p>\n<script type=\"math/tex; mode=display\">F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}</script><script type=\"math/tex; mode=display\">G(x)=\\sum\\limits_{i=0}^{m-1}G[i]x^{i}</script><script type=\"math/tex; mode=display\">(F\\times G)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}</script><script type=\"math/tex; mode=display\">(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]</script><p>不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。</p>\n<p>不过为了优化，我们得先扯远点。</p>\n<h1 id=\"点值表达\"><a href=\"#点值表达\" class=\"headerlink\" title=\"点值表达\"></a>点值表达</h1><p>如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。</p>\n<p>就比如说</p>\n<script type=\"math/tex; mode=display\">(0,2),(1,7),(2,4)</script><p><del>瞎写的（</del></p>\n<p>我们可以列出如下的三元一次方程组：</p>\n<script type=\"math/tex; mode=display\">\\begin{cases}\n&\\text{C}=2\\\\\n&\\text{A}+\\text{B}+\\text{C}=7\\\\\n&4\\text{A}+2\\text{B}+\\text{C}=4\n\\end{cases}</script><p>解得</p>\n<script type=\"math/tex; mode=display\">\\begin{cases}\n&\\text{A}=-4\\\\\n&\\text{B}=9\\\\\n&\\text{C}=2\n\\end{cases}</script><p>注意到$(F\\times G)(x)=F(x)G(x)$<del>（废话）</del>，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\\times G)(x)$的点值表达了。因为$(F\\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。</p>\n<p>但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（</p>\n<p>于是我们还需要优化，于是我们还需要再扯远一点。</p>\n<h1 id=\"复数\"><a href=\"#复数\" class=\"headerlink\" title=\"复数\"></a>复数</h1><p>对，你没看错，扯到复数了。</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p>根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说</p>\n<script type=\"math/tex; mode=display\">x^{2}+1=0</script><p>我们知道，它的判别式是$\\Delta=b^{2}-4ac=-4\\lt 0$，因此它没有实数根。</p>\n<p>于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\\operatorname{tan}^{-1}\\cfrac{y}{x}$。</p>\n<p>因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。</p>\n<p><img src=\"https://i.loli.net/2018/12/19/5c1a46b4d785b.png\" alt=\"\"></p>\n<p>上图展示了$4+i$和$3+4i$。</p>\n<p>复数的运算其实没什么出乎意料的：</p>\n<script type=\"math/tex; mode=display\">(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i</script><script type=\"math/tex; mode=display\">(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i</script><script type=\"math/tex; mode=display\">(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i</script><script type=\"math/tex; mode=display\">\\begin{aligned}\n\\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\\\\n&=\\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\\\\n&=\\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i\n\\end{aligned}</script><p>我们来单独考虑一下复数相乘的几何意义。</p>\n<p>假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\\alpha_{1}$，$\\alpha_{2}$。不难发现我们有</p>\n<script type=\"math/tex; mode=display\">c_{1}=r_{1}(\\operatorname{cos}\\alpha_{1}+i\\operatorname{sin}\\alpha_{1})</script><script type=\"math/tex; mode=display\">c_{2}=r_{2}(\\operatorname{cos}\\alpha_{2}+i\\operatorname{sin}\\alpha_{2})</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nc_{1}c_{2}&=r_{1}r_{2}(\\cos\\alpha_{1}+i\\sin\\alpha_{1})(\\cos\\alpha_{2}+i\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}(\\cos\\alpha_{1}\\cos\\alpha_{2}+i\\cos\\alpha_{1}\\sin\\alpha_{2}+i\\sin\\alpha_{1}\\cos\\alpha_{2}-\\sin\\alpha_{1}\\sin\\alpha_{2})\\\\\n&=r_{1}r_{2}[\\cos(\\alpha_{1}+\\alpha_{2})+i\\sin(\\alpha_{1}+\\alpha_{2})]\n\\end{aligned}</script><p>总结成一句话，就是「模长相乘，幅角相加」。</p>\n<h2 id=\"单位圆与单位根\"><a href=\"#单位圆与单位根\" class=\"headerlink\" title=\"单位圆与单位根\"></a>单位圆与单位根</h2><p>单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。</p>\n<p><img src=\"https://i.loli.net/2018/12/20/5c1b06e5602fa.png\" alt=\"\"></p>\n<p>考虑这么一个方程</p>\n<script type=\"math/tex; mode=display\">x^{n}=1</script><p>它的所有复数根。</p>\n<p>因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有</p>\n<script type=\"math/tex; mode=display\">2\\pi\\mid na</script><script type=\"math/tex; mode=display\">\\cfrac{2\\pi}{n}\\mid a</script><p>不难想象出我们有$n$个这样的复数，它们的幅角通式是$\\cfrac{2k\\pi}{n}(k\\in[0,n)\\cap\\mathbb{Z})$。我们称其中幅角等于$\\cfrac{2\\pi}{n}$的复数，即$\\cos\\cfrac{2\\pi}{n}+i\\sin\\cfrac{2\\pi}{n}$为$n$次单位根$\\omega_{n}$，我们就可以把这$n$个复数表示为$\\omega_{n}^{k}(k\\in[0,n)\\cap\\mathbb{Z})$。</p>\n<p>它有如下的一些性质</p>\n<script type=\"math/tex; mode=display\">\\omega_{2n}^{2k}=\\omega_{n}^{k}</script><p>因为它们的模长都是$1$，幅角相等就相等了。</p>\n<p>然后就没了，读者自证不难（</p>\n<script type=\"math/tex; mode=display\">\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}</script><p>因为$\\omega_{n}^{\\frac{n}{2}}$的幅角是$\\cfrac{2\\times\\frac{n}{2}\\pi}{n}=\\pi$，不难发现它就是$-1$了。</p>\n<h1 id=\"快速傅里叶变换（Fast-Fourier-Transformation）\"><a href=\"#快速傅里叶变换（Fast-Fourier-Transformation）\" class=\"headerlink\" title=\"快速傅里叶变换（Fast Fourier Transformation）\"></a>快速傅里叶变换（Fast Fourier Transformation）</h1><h2 id=\"运行过程\"><a href=\"#运行过程\" class=\"headerlink\" title=\"运行过程\"></a>运行过程</h2><p>那么问题来了，我们刚才扯了这么些，有什么用呢？</p>\n<p>就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。</p>\n<p>首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。</p>\n<p>然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF_{1}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i]x^{i}\\\\\n&=F[0]x^{0}+F[2]x^{1}+\\cdots+F[n-2]x^{\\frac{n}{2}-1}\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nF_{2}(x)&=\\sum\\limits_{i=0}^{\\frac{n}{2}-1}F[2i+1]x^{i}\\\\\n&=F[1]x^{0}+F[3]x^{1}+\\cdots+F[n-1]x^{\\frac{n}{2}-1}\n\\end{aligned}</script><p>于是我们有</p>\n<script type=\"math/tex; mode=display\">F(x)=F_{1}(x^{2})+xF_{2}(x^{2})</script><p>现在我们假设$0\\leqslant k&lt;\\cfrac{n}{2}$，将$x=\\omega_{n}^{k}$和$x=\\omega_{n}^{k+\\frac{n}{2}}$代入</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nF(\\omega_{n}^{k})&=F_{1}(\\omega_{n}^{2k})+\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})+\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}</script><script type=\"math/tex; mode=display\">\\begin{aligned}\nF(\\omega_{n}^{k+\\frac{n}{2}})&=F_{1}(\\omega_{n}^{2k+n})+\\omega_{n}^{k+\\frac{n}{2}}F_{2}(\\omega_{n}^{2k+n})\\\\\n&=F_{1}(\\omega_{n}^{2k})-\\omega_{n}^{k}F_{2}(\\omega_{n}^{2k})\\\\\n&=F_{1}(\\omega_{\\frac{n}{2}}^{k})-\\omega_{n}^{k}F_{2}(\\omega_{\\frac{n}{2}}^{k})\n\\end{aligned}</script><p>我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。</p>\n<p>简单地贴一下代码：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�44-->\n\n</div></div>\n<p>不过，以上代码是我现写出来的，<del>保证其不正确性</del>不保证其正确性。</p>\n<p>不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，<code>F</code>数组的每一个位置上实际存的是几次项：</p>\n<!--�45-->\n<p>写成二进制看看：</p>\n<div class=\"table-container\">\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">位置（十进制）</th>\n<th style=\"text-align:center\">位置（二进制）</th>\n<th style=\"text-align:center\">次数（十进制）</th>\n<th style=\"text-align:center\">次数（二进制）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$000$</td>\n<td style=\"text-align:center\">$0$</td>\n<td style=\"text-align:center\">$000$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$001$</td>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$100$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$010$</td>\n<td style=\"text-align:center\">$2$</td>\n<td style=\"text-align:center\">$010$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$011$</td>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$110$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$4$</td>\n<td style=\"text-align:center\">$100$</td>\n<td style=\"text-align:center\">$1$</td>\n<td style=\"text-align:center\">$001$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$5$</td>\n<td style=\"text-align:center\">$101$</td>\n<td style=\"text-align:center\">$5$</td>\n<td style=\"text-align:center\">$101$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$6$</td>\n<td style=\"text-align:center\">$110$</td>\n<td style=\"text-align:center\">$3$</td>\n<td style=\"text-align:center\">$011$</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">$7$</td>\n<td style=\"text-align:center\">$111$</td>\n<td style=\"text-align:center\">$7$</td>\n<td style=\"text-align:center\">$111$</td>\n</tr>\n</tbody>\n</table>\n</div>\n<p>注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。</p>\n<p>我们可以$O(n)$地处理处每个数的镜像：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�46-->\n\n</div></div>\n<p>中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。</p>\n<p>接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�47-->\n\n</div></div>\n<p>那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\\omega_{n}^{0}),F(\\omega_{n}^{1}),\\cdots,F(\\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}\n&(\\omega_{n}^{0})^{0}&(\\omega_{n}^{0})^{1}&\\cdots&(\\omega_{n}^{0})^{n-1}&\\\\\n&(\\omega_{n}^{1})^{0}&(\\omega_{n}^{1})^{1}&\\cdots&(\\omega_{n}^{1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&(\\omega_{n}^{n-1})^{0}&(\\omega_{n}^{n-1})^{1}&\\cdots&(\\omega_{n}^{n-1})^{n-1}\\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n&F[0]&\\\\\n&F[1]\\\\\n&\\vdots\\\\\n&F[n-1]\n\\end{bmatrix}\n=\\begin{bmatrix}\n&y_{0}&\\\\\n&y_{1}\\\\\n&\\vdots\\\\\n&y_{n-1}\n\\end{bmatrix}</script><p>我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}\n&\\frac{1}{n}(\\omega_{n}^{0})^{0}&\\frac{1}{n}(\\omega_{n}^{0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{0})^{n-1}&\\\\\n&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\\n&\\vdots&\\vdots&\\ddots&\\vdots\\\\\n&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\n\\end{bmatrix}</script><p>现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\\times B=C$。不难发现$A[i][j]=\\omega_{n}^{ij}$，$B[i][j]=\\cfrac{1}{n}\\omega_{n}^{-ij}$，我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}A[i][k]B[k][j]\\\\\n&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{ik-kj}\n\\end{aligned}</script><p>若$i=j$，不难发现此时$C[i][j]=1$。</p>\n<p>否则，即$i\\neq j$，设$i-j=l$，我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nC[i][j]&=\\sum\\limits_{k=0}^{n-1}\\cfrac{1}{n}\\omega_{n}^{lk}\\\\\n&=\\cfrac{\\omega_{n}^{ln}-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=\\cfrac{1-1}{n(\\omega_{n}^{l}-1)}\\\\\n&=0\n\\end{aligned}</script><p>综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。</p>\n<p>因此我们有</p>\n<script type=\"math/tex; mode=display\">\\begin{bmatrix}&\\frac{1}{n}(\\omega_{n}^{-0})^{0}&\\frac{1}{n}(\\omega_{n}^{-0})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-0})^{n-1}&\\\\&\\frac{1}{n}(\\omega_{n}^{-1})^{0}&\\frac{1}{n}(\\omega_{n}^{-1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-1})^{n-1}\\\\&\\vdots&\\vdots&\\ddots&\\vdots\\\\&\\frac{1}{n}(\\omega_{n}^{-n+1})^{0}&\\frac{1}{n}(\\omega_{n}^{-n+1})^{1}&\\cdots&\\frac{1}{n}(\\omega_{n}^{-n+1})^{n-1}\\\\\\end{bmatrix}\\begin{bmatrix}&y_{0}&\\\\&y_{1}\\\\&\\vdots\\\\&y_{n-1}\\end{bmatrix}=\\begin{bmatrix}&F[0]&\\\\&F[1]\\\\&\\vdots\\\\&F[n-1]\\end{bmatrix}</script><p>注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$换成$\\omega_{n}^{0},\\omega_{n}^{-1},\\cdots,\\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。</p>\n<p>注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的</p>\n<!--�48-->\n<p>改成</p>\n<!--�49-->\n<p>然后调用时再传一个参数<code>tp</code>进去。<code>tp=1</code>表示是系数转点值，<code>tp=-1</code>表示是点值转系数。</p>\n<p>完整代码如下：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�50-->\n\n</div></div>\n<p><del>不要问我<code>cltstream</code>哪去了（</del></p>\n<p>然后您就可以切掉这道<a href=\"https://www.luogu.org/problemnew/show/P3803\" target=\"_blank\" rel=\"noopener\">板子题</a>了。</p>\n<p>其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（</p>\n<p>最好还是自己写吧（</p>\n<p>什么？想知道是哪道题？往下看（</p>\n<h2 id=\"例题\"><a href=\"#例题\" class=\"headerlink\" title=\"例题\"></a>例题</h2><h3 id=\"「ZJOI2014」力\"><a href=\"#「ZJOI2014」力\" class=\"headerlink\" title=\"「ZJOI2014」力\"></a><a href=\"https://www.luogu.org/problemnew/show/P3338\" target=\"_blank\" rel=\"noopener\">「ZJOI2014」力</a></h3><p>这是一道裸的卷积题。</p>\n<p>考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足</p>\n<script type=\"math/tex; mode=display\">H[i]=\\sum\\limits_{j=0}^{i}F[j]G[i-j]=\\sum\\limits_{0\\leqslant j<n,0\\leqslant k<n,j+k=i}F[j]G[k]</script><p>在本页面往上翻，翻到这个式子：</p>\n<script type=\"math/tex; mode=display\">(F\\times G)[k]=\\sum\\limits_{0\\leqslant i<n,0\\leqslant j<m,i+j=k}F[i]G[j]</script><p>发现了吗？这两个过程其实是一样的。</p>\n<p>于是，我们如下构造两个多项式</p>\n<script type=\"math/tex; mode=display\">F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}</script><script type=\"math/tex; mode=display\">G(x)=\\sum\\limits_{i=0}^{n-1}G[i]x^{i}</script><p>然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。</p>\n<p>那么这题呢？首先我们把$j\\lt i$和$j\\gt i$分开计算。</p>\n<p>先考虑$j\\lt i$，令$F[i]=q_{i}$，$G[i]=\\begin{cases}&amp;\\cfrac{1}{i^{2}}\\;\\;&amp;(i\\gt 0)\\\\&amp;0&amp;(i=0)\\end{cases}$，那么</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nE_{i}&=\\sum_{j=0}^{i-1}F[j]G[i-j]\\\\\n&=\\sum_{j=0}^{i}F[j]G[i-j]\n\\end{aligned}</script><p>直接套板子就行。</p>\n<p>对于$j&gt;i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（</p>\n<p>具体还是看代码吧：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�51-->\n\n</div></div>\n<h1 id=\"数论变换（Number-Theoretic-Transformation）\"><a href=\"#数论变换（Number-Theoretic-Transformation）\" class=\"headerlink\" title=\"数论变换（Number-Theoretic Transformation）\"></a>数论变换（Number-Theoretic Transformation）</h1><p>注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用<code>double</code>存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。</p>\n<p>这就启示我们，能不能用其他的什么东西替换掉单位复根。</p>\n<p>设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\\equiv 1\\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\\delta_{p}(a)$。</p>\n<p>如果说$\\delta_{p}(a)=\\varphi(p)$，我们就称$a$是模$p$的一个原根。</p>\n<p>现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：</p>\n<p>$\\omega_{n}^{0},\\omega_{n}^{1},\\cdots,\\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。</p>\n<p>虽然我不会证，不过我们的确有$g^{0},g^{1},\\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。</p>\n<p>$\\omega_{2n}^{2k}=\\omega_{n}^{k}$。这是为了让我们可以分治。</p>\n<p>根据定义，$\\omega_{2n}=g^{\\frac{a}{2}}$，就是将现在的$p$进一步拆成$\\cfrac{a}{2}\\cdot2n+1$。不难发现</p>\n<script type=\"math/tex; mode=display\">\\omega_{2n}^{2k}=g^{\\frac{a}{2}\\cdot{2}k}=g^{ak}=\\omega_{n}^{k}</script><p>因而原根有上述性质。</p>\n<p>$\\omega_{n}^{k+\\frac{n}{2}}=-\\omega_{n}^{k}$，或者说$\\omega_{n}^{\\frac{n}{2}}=-1$。这同样是为了让我们可以分治。</p>\n<p>因为$p=an+1$，根据费马小定理，我们有</p>\n<script type=\"math/tex; mode=display\">\\omega_{n}^{n}\\equiv g^{an}\\equiv g^{p-1}\\equiv 1\\pmod{p}</script><p>因而$\\omega_{n}^{\\frac{n}{2}}\\equiv\\pm 1\\pmod{p}$。又因为$\\omega_{n}^{0}=1$，而$\\omega_{n}^{\\frac{n}{2}}\\not\\equiv\\omega_{n}^{0}\\pmod{p}$，我们就得到$\\omega_{n}^{\\frac{n}{2}}\\equiv -1\\pmod{p}$。</p>\n<p>若$k\\neq 0$，$\\sum_{i=0}^{n-1}(\\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。</p>\n<p>以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\\times 17\\times 2^{23}+1$，它的原根是$3$。</p>\n<p>需要注意的是，我们还有一个可以优化的小细节。注意到$\\omega_{n}=g^{a}=g^{\\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\\omega_{2},\\omega_{4},\\cdots,\\omega_{2^{23}}$。注意到</p>\n<script type=\"math/tex; mode=display\">\\omega_{2^{23}}=3^{7\\times 17}=3^{119}</script><script type=\"math/tex; mode=display\">\\omega_{2^{k}}=\\omega_{2^{k+1}}^{2}</script><p>我们一遍快速幂算出$\\omega_{2^{23}}$然后倒着推出剩下的即可。</p>\n<p>关于$\\omega_{n}^{-k}$，注意到它就是$\\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。</p>\n<p>然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。</p>\n<p>代码：</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�52-->\n\n</div></div>\n<p>以上。</p>"},{"mathjax":true,"abstract":"该文章已被加密","message":"输入密码继续阅读","date":"2019-01-10T05:37:33.000Z","title":"类欧几里得算法学习笔记","password":null,"_content":"其实我也不知道这个算法的英文名是啥（\n\n我就yy出来一个「Similar Euclid Algorithm」（\n\n<!-- more -->\n\n给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出\n\n$$\\sum_{i=0}^{n}i^{k_{1}}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{k_{2}}\\pmod{1000000007}$$\n\n$n,a,b,c\\leqslant 10^{9}$，$k_{1}+k_{2}\\leqslant 10$。\n\n![](https://i.loli.net/2019/01/10/5c36dbda14c92.jpg)\n\n太难了，告辞（\n\n所以我们现在来研究简单一点的。\n\n给你四个非负整数$n,a,b,c$，你需要求出\n\n$$\\begin{aligned}\nf(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\ng(n,a,b,c)&\\equiv\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\nh(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\pmod{998244353}\n\\end{aligned}$$\n\n$n,a,b,c\\leqslant 10^{9}$，$10^{5}$组询问。\n\n[传送门](https://www.luogu.org/problemnew/show/P5170)\n\n于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。\n\n首先考虑$f(n,a,b,c)$，假设$a\\geqslant c\\vee b\\geqslant c$\n\n$$\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}$$\n\n也就是说，我们只需要重点关注$a\\lt c\\wedge b\\lt c$时的情况即可。我们令$m=\\lfloor\\cfrac{an+b}{c}\\rfloor$，然后继续往下推\n\n$$\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\leqslant ai+b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\geqslant cj+c-b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\geqslant\\cfrac{cj+c-b}{a}\\right]\\\\\n\\end{aligned}$$\n\n然后我们发现，我们可能需要在$\\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。\n\n考虑转换一下思路。既然$cj+c\\leqslant ai+b$，我们就有$cj+c\\lt ai+b+1$，然后再往下\n\n$$\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\lt ai+b+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\gt cj+c-b-1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\\\\\n&=\\sum_{j=0}^{m-1}\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=mn-\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=mn-f(m-1,c,c-b-1,a)\n\\end{aligned}$$\n\n然后我们看到，这个函数它递归了！\n\n注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\\log a$次，时间复杂度就是$O(\\log a)$了。\n\n然后考虑$g(n,a,b,c)$。\n\n$a\\geqslant c\\vee b\\geqslant c$：\n\n$$\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor+i\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}$$\n\n$a\\lt c\\wedge b\\lt c$，当然$m$还是$\\lfloor\\cfrac{an+b}{c}\\rfloor$：\n\n$$\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}i\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}i\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\n\\end{aligned}$$\n\n我们可以把上面这个式子理解成$\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor$且$\\leqslant n$的所有自然数之和，于是差分一下我们得到\n\n$$\\begin{aligned}\ng(n,a,b,c)&=\\sum_{j=0}^{m-1}\\left(\\cfrac{n(n+1)}{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)\n\\end{aligned}$$\n\n我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。\n\n$a\\geqslant c\\vee b\\geqslant c$：\n\n$$\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\n\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\right)\\\\\n&=\n\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\\\\&\n+2\\lfloor\\cfrac{a}{c}\\rfloor\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\\\\n&=\nh(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}$$\n\n您绝对想象不到上面这一坨子东西的$\\TeX$源码长什么样（\n\n$a\\lt c\\wedge b\\lt c$：\n\n$$\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m^{2}}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[c^{2}j+c^{2}\\lt a^{2}i^{2}+2abi+b^{2}+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[i\\gt\\sqrt{\\lfloor\\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\\rfloor}\\right]\n\\end{aligned}$$\n\n![](https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg)\n\n然后我们发现推不下去了。\n\n不过办法总是有的。首先我们有一个看起来没啥用的式子\n\n$$x^{2}=2\\sum_{i=1}^{n}i-x$$\n\n套进去\n\n$$\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(2\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right)\\\\\n&=2\\sum_{i=0}^{n}\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=2\\sum_{j=1}^{m}j\\sum_{i=0}^{n}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^{n}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)-f(n,a,b,c)\\\\\n&=m(m+1)n-2\\sum_{j=0}^{m-1}j\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-2\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-f(n,a,b,c)\\\\\n&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\\\n\\end{aligned}$$\n\n然后我们看到它奇迹般地递归了！\n\n我们来总结一下。\n\n$$f(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&mn-f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}$$\n\n$$g(n,a,b,c)=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}$$\n\n$$h(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}=\\begin{cases}\n&h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;\n&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}$$\n\n但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：\n\n$$f(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}$$\n\n$$g(n,a,b,c)=\\begin{cases}\n&0\\;\\;&(n=0)\\\\\n&\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}$$\n\n$$h(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(a=0)\n\\end{cases}$$\n\n另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#define re register\n#define mod 998244353\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint t,a,b,c,n,I2=499122177,I6=166374059;\nstruct Query{\n\tint f,g,h;\n\n\tQuery(re int _f,re int _g,re int _h){\n\t\tf=_f;\n\t\tg=_g;\n\t\th=_h;\n\t}\n};\n\ninline Query query(re int a,re int b,re int c,re int n){\n\tif(!n){\n\t\tb/=c;\n\t\treturn Query(b,0,1LL*b*b%mod);\n\t}\n\tif(!a){\n\t\tb/=c;\n\t\treturn Query(1LL*(n+1)*b%mod,1LL*n*(n+1)%mod*I2%mod*b%mod,1LL*(n+1)*b%mod*b%mod);\n\t}\n\tif(a>=c||b>=c){\n\t\tre Query res=query(a%c,b%c,c,n);\n\t\ta/=c,\n\t\tb/=c;\n\t\treturn Query(\n\t\t\t(res.f+1LL*n*(n+1)%mod*I2%mod*a%mod+1LL*(n+1)*b%mod)%mod,\n\t\t\t(res.g+1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod+1LL*n*(n+1)%mod*I2%mod*b%mod)%mod,\n\t\t\t(res.h+2LL*a*res.g%mod+2LL*b*res.f%mod\n\t\t\t\t  +1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod*a%mod\n\t\t\t\t  +1LL*(n+1)*b%mod*b%mod+1LL*n*(n+1)%mod*a%mod*b%mod)%mod\n\t\t);\n\t}\n\telse{\n\t\tre int m=(1LL*a*n+b)/c;\n\t\tre Query res=query(c,c-b-1,a,m-1);\n\t\tre int tmp=((1LL*m*n%mod-res.f)%mod+mod)%mod;\n\t\treturn Query(\n\t\t\ttmp,\n\t\t\t((1LL*m*n%mod*(n+1)%mod-res.h-res.f)%mod+mod)*I2%mod,\n\t\t\t((1LL*m*(m+1)%mod*n%mod-2LL*res.g%mod-2LL*res.f%mod-tmp)%mod+mod)%mod\n\t\t);\n\t}\n}\n\nint main(){\n\tcltstream::read(t);\n\tfor(;t;--t){\n\t\tcltstream::read(n);\n\t\tcltstream::read(a);\n\t\tcltstream::read(b);\n\t\tcltstream::read(c);\n\t\tQuery ans=query(a,b,c,n);\n\t\tcltstream::write(ans.f,32);\n\t\tcltstream::write(ans.h,32);\n\t\tcltstream::write(ans.g,10);\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n那么问题来了，这个东西有什么用啊。\n\n~~没啥用（~~\n\n其他的模板题我就不举了，我们来看一下[这样一道题](https://www.luogu.org/problemnew/show/P4433)。\n\n看到推平操作我们可以直接往珂朵莉树上想了。\n\n那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息`l,r,L,R,a,b`，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\\sum_{i=L}^{R}ai\\operatorname{mod}b$颗石头。注意这里的`l,r,L,R`一定不要搞混~~，我就是因为这样WA了整整四遍（~~。\n\n~~这三个样例一定是故意的。~~\n\n然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：\n\n$$\\sum_{i=L}^{R}ai\\operatorname{mod}b=\\sum_{i=L}^{R}\\left(ai-\\lfloor\\cfrac{ai}{b}\\rfloor b\\right)=\\cfrac{(R+L)(R-L+1)}{2}-\\sum_{i=0}^{R}\\lfloor\\cfrac{ai}{b}\\rfloor b+\\sum_{i=0}^{L-1}\\lfloor\\cfrac{ai}{b}\\rfloor b$$\n\n直接一波板子套上去。\n\n还有就是，这么算的话中间量会爆`long long`，我们可以考虑用`__int128_t`来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以\n\n```cpp\n#ifdef ONLINE_JUDGE\n\t#define int __int128_t\n#endif\n```\n\n然后把一些没必要用或者是不能用`__int128_t`的改成`signed`即可。\n\n代码还是有必要贴一下的。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<set>\n#define re register\n#define _it std::set<node>::iterator\n#ifdef ONLINE_JUDGE\n\t#define int __int128_t\n#endif\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tsigned sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tsigned digit[50];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m;\n\ninline int simEuc(re int n,re int a,re int b,re int c){\n\tif(!n)\n\t\treturn b/c;\n\tif(!a)\n\t\treturn (n+1)*(b/c);\n\tif(a>=c||b>=c){\n\t\tre int res=simEuc(n,a%c,b%c,c);\n\t\treturn res+n*(n+1)*(a/c)/2+(n+1)*(b/c);\n\t}\n\telse{\n\t\tre int m=(a*n+b)/c;\n\t\treturn m*n-simEuc(m-1,c,c-b-1,a);\n\t}\n}\n\nstruct node{\n\tint l,r,L,R,a,b,sum;\n\n\tnode(re int _l,re int _r,re int _L,re int _R,re int _a,re int _b){\n\t\tl=_l;\n\t\tr=_r;\n\t\tL=_L;\n\t\tR=_R;\n\t\ta=_a;\n\t\tb=_b;\n\t\tsum=(R+L)*(R-L+1)*a/2-simEuc(R,a,0,b)*b+simEuc(L-1,a,0,b)*b;\n\t}\n};\nstd::set<node> s;\n\ninline bool operator<(re node p1,re node p2){\n\treturn p1.l<p2.l;\n}\n\ninline _it split(re int pos){\n\tre _it it=s.lower_bound(node(pos,0,1,0,0,1));\n\tif(it!=s.end()&&it->l==pos)\n\t\treturn it;\n\telse{\n\t\t--it;\n\t\tre int l=it->l,r=it->r,L=it->L,R=it->R,a=it->a,b=it->b;\n\t\ts.erase(it);\n\t\ts.insert(node(l,pos-1,L,L+pos-l-1,a,b));\n\t\treturn s.insert(node(pos,r,L+pos-l,R,a,b)).first;\n\t}\n}\n\ninline void modifyStone(re int l,re int r,re int a,re int b){\n\tre _it itr=split(r+1),itl=split(l);\n\ts.erase(itl,itr);\n\ts.insert(node(l,r,1,r-l+1,a,b));\n}\n\ninline int queryStone(re int l,re int r){\n\tre _it itr=split(r+1),itl=split(l);\n\tre int res=0;\n\tfor(;itl!=itr;res+=itl->sum,++itl);\n\treturn res;\n}\n\nsigned main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\ts.insert(node(1,n,1,0,0,1));\n\tfor(re int i=1;i<=m;++i){\n\t\tre int opt,l,r,a,b;\n\t\tcltstream::read(opt);\n\t\tcltstream::read(l);\n\t\tcltstream::read(r);\n\t\tif(opt==1){\n\t\t\tcltstream::read(a);\n\t\t\tcltstream::read(b);\n\t\t\tmodifyStone(l,r,a,b);\n\t\t}\n\t\telse\n\t\t\tcltstream::write(queryStone(l,r),10);\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n","source":"_posts/2019-01-10-similar-euclid-algorithm-learning-notes.md","raw":"---\nmathjax: true\nabstract: 该文章已被加密\nmessage: 输入密码继续阅读\ndate: 2019-01-10 13:37:33\ntitle: 类欧几里得算法学习笔记\ntags:\n  - 数论\n  - 类欧几里得\ncategories:\n  - 学习笔记\npassword:\n---\n其实我也不知道这个算法的英文名是啥（\n\n我就yy出来一个「Similar Euclid Algorithm」（\n\n<!-- more -->\n\n给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出\n\n$$\\sum_{i=0}^{n}i^{k_{1}}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{k_{2}}\\pmod{1000000007}$$\n\n$n,a,b,c\\leqslant 10^{9}$，$k_{1}+k_{2}\\leqslant 10$。\n\n![](https://i.loli.net/2019/01/10/5c36dbda14c92.jpg)\n\n太难了，告辞（\n\n所以我们现在来研究简单一点的。\n\n给你四个非负整数$n,a,b,c$，你需要求出\n\n$$\\begin{aligned}\nf(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\ng(n,a,b,c)&\\equiv\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\nh(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\pmod{998244353}\n\\end{aligned}$$\n\n$n,a,b,c\\leqslant 10^{9}$，$10^{5}$组询问。\n\n[传送门](https://www.luogu.org/problemnew/show/P5170)\n\n于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。\n\n首先考虑$f(n,a,b,c)$，假设$a\\geqslant c\\vee b\\geqslant c$\n\n$$\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}$$\n\n也就是说，我们只需要重点关注$a\\lt c\\wedge b\\lt c$时的情况即可。我们令$m=\\lfloor\\cfrac{an+b}{c}\\rfloor$，然后继续往下推\n\n$$\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\leqslant ai+b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\geqslant cj+c-b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\geqslant\\cfrac{cj+c-b}{a}\\right]\\\\\n\\end{aligned}$$\n\n然后我们发现，我们可能需要在$\\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。\n\n考虑转换一下思路。既然$cj+c\\leqslant ai+b$，我们就有$cj+c\\lt ai+b+1$，然后再往下\n\n$$\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\lt ai+b+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\gt cj+c-b-1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\\\\\n&=\\sum_{j=0}^{m-1}\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=mn-\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=mn-f(m-1,c,c-b-1,a)\n\\end{aligned}$$\n\n然后我们看到，这个函数它递归了！\n\n注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\\log a$次，时间复杂度就是$O(\\log a)$了。\n\n然后考虑$g(n,a,b,c)$。\n\n$a\\geqslant c\\vee b\\geqslant c$：\n\n$$\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor+i\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}$$\n\n$a\\lt c\\wedge b\\lt c$，当然$m$还是$\\lfloor\\cfrac{an+b}{c}\\rfloor$：\n\n$$\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}i\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}i\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\n\\end{aligned}$$\n\n我们可以把上面这个式子理解成$\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor$且$\\leqslant n$的所有自然数之和，于是差分一下我们得到\n\n$$\\begin{aligned}\ng(n,a,b,c)&=\\sum_{j=0}^{m-1}\\left(\\cfrac{n(n+1)}{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)\n\\end{aligned}$$\n\n我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。\n\n$a\\geqslant c\\vee b\\geqslant c$：\n\n$$\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\n\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\right)\\\\\n&=\n\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\\\\&\n+2\\lfloor\\cfrac{a}{c}\\rfloor\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\\\\n&=\nh(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}$$\n\n您绝对想象不到上面这一坨子东西的$\\TeX$源码长什么样（\n\n$a\\lt c\\wedge b\\lt c$：\n\n$$\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m^{2}}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[c^{2}j+c^{2}\\lt a^{2}i^{2}+2abi+b^{2}+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[i\\gt\\sqrt{\\lfloor\\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\\rfloor}\\right]\n\\end{aligned}$$\n\n![](https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg)\n\n然后我们发现推不下去了。\n\n不过办法总是有的。首先我们有一个看起来没啥用的式子\n\n$$x^{2}=2\\sum_{i=1}^{n}i-x$$\n\n套进去\n\n$$\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(2\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right)\\\\\n&=2\\sum_{i=0}^{n}\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=2\\sum_{j=1}^{m}j\\sum_{i=0}^{n}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^{n}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)-f(n,a,b,c)\\\\\n&=m(m+1)n-2\\sum_{j=0}^{m-1}j\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-2\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-f(n,a,b,c)\\\\\n&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\\\n\\end{aligned}$$\n\n然后我们看到它奇迹般地递归了！\n\n我们来总结一下。\n\n$$f(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&mn-f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}$$\n\n$$g(n,a,b,c)=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}$$\n\n$$h(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}=\\begin{cases}\n&h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;\n&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}$$\n\n但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：\n\n$$f(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}$$\n\n$$g(n,a,b,c)=\\begin{cases}\n&0\\;\\;&(n=0)\\\\\n&\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}$$\n\n$$h(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(a=0)\n\\end{cases}$$\n\n另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#define re register\n#define mod 998244353\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tint sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tint digit[22];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint t,a,b,c,n,I2=499122177,I6=166374059;\nstruct Query{\n\tint f,g,h;\n\n\tQuery(re int _f,re int _g,re int _h){\n\t\tf=_f;\n\t\tg=_g;\n\t\th=_h;\n\t}\n};\n\ninline Query query(re int a,re int b,re int c,re int n){\n\tif(!n){\n\t\tb/=c;\n\t\treturn Query(b,0,1LL*b*b%mod);\n\t}\n\tif(!a){\n\t\tb/=c;\n\t\treturn Query(1LL*(n+1)*b%mod,1LL*n*(n+1)%mod*I2%mod*b%mod,1LL*(n+1)*b%mod*b%mod);\n\t}\n\tif(a>=c||b>=c){\n\t\tre Query res=query(a%c,b%c,c,n);\n\t\ta/=c,\n\t\tb/=c;\n\t\treturn Query(\n\t\t\t(res.f+1LL*n*(n+1)%mod*I2%mod*a%mod+1LL*(n+1)*b%mod)%mod,\n\t\t\t(res.g+1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod+1LL*n*(n+1)%mod*I2%mod*b%mod)%mod,\n\t\t\t(res.h+2LL*a*res.g%mod+2LL*b*res.f%mod\n\t\t\t\t  +1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod*a%mod\n\t\t\t\t  +1LL*(n+1)*b%mod*b%mod+1LL*n*(n+1)%mod*a%mod*b%mod)%mod\n\t\t);\n\t}\n\telse{\n\t\tre int m=(1LL*a*n+b)/c;\n\t\tre Query res=query(c,c-b-1,a,m-1);\n\t\tre int tmp=((1LL*m*n%mod-res.f)%mod+mod)%mod;\n\t\treturn Query(\n\t\t\ttmp,\n\t\t\t((1LL*m*n%mod*(n+1)%mod-res.h-res.f)%mod+mod)*I2%mod,\n\t\t\t((1LL*m*(m+1)%mod*n%mod-2LL*res.g%mod-2LL*res.f%mod-tmp)%mod+mod)%mod\n\t\t);\n\t}\n}\n\nint main(){\n\tcltstream::read(t);\n\tfor(;t;--t){\n\t\tcltstream::read(n);\n\t\tcltstream::read(a);\n\t\tcltstream::read(b);\n\t\tcltstream::read(c);\n\t\tQuery ans=query(a,b,c,n);\n\t\tcltstream::write(ans.f,32);\n\t\tcltstream::write(ans.h,32);\n\t\tcltstream::write(ans.g,10);\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n\n那么问题来了，这个东西有什么用啊。\n\n~~没啥用（~~\n\n其他的模板题我就不举了，我们来看一下[这样一道题](https://www.luogu.org/problemnew/show/P4433)。\n\n看到推平操作我们可以直接往珂朵莉树上想了。\n\n那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息`l,r,L,R,a,b`，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\\sum_{i=L}^{R}ai\\operatorname{mod}b$颗石头。注意这里的`l,r,L,R`一定不要搞混~~，我就是因为这样WA了整整四遍（~~。\n\n~~这三个样例一定是故意的。~~\n\n然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：\n\n$$\\sum_{i=L}^{R}ai\\operatorname{mod}b=\\sum_{i=L}^{R}\\left(ai-\\lfloor\\cfrac{ai}{b}\\rfloor b\\right)=\\cfrac{(R+L)(R-L+1)}{2}-\\sum_{i=0}^{R}\\lfloor\\cfrac{ai}{b}\\rfloor b+\\sum_{i=0}^{L-1}\\lfloor\\cfrac{ai}{b}\\rfloor b$$\n\n直接一波板子套上去。\n\n还有就是，这么算的话中间量会爆`long long`，我们可以考虑用`__int128_t`来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以\n\n```cpp\n#ifdef ONLINE_JUDGE\n\t#define int __int128_t\n#endif\n```\n\n然后把一些没必要用或者是不能用`__int128_t`的改成`signed`即可。\n\n代码还是有必要贴一下的。\n\n{% fold \"Toggle Code\" %}\n\n```cpp\n#include<cstdio>\n#include<iostream>\n#include<set>\n#define re register\n#define _it std::set<node>::iterator\n#ifdef ONLINE_JUDGE\n\t#define int __int128_t\n#endif\n\nnamespace cltstream{\n\t#define size 1048576\n\tchar cltin[size+1],*ih=cltin,*it=cltin;\n\tinline char gc(){\n\t\t#ifdef ONLINE_JUDGE\n\t\t\tif(ih==it){\n\t\t\t\tit=(ih=cltin)+fread(cltin,1,size,stdin);\n\t\t\t\tif(ih==it)\n\t\t\t\t\treturn EOF;\n\t\t\t}\n\t\t\treturn *ih++;\n\t\t#else\n\t\t\treturn getchar();\n\t\t#endif\n\t}\n\n\tchar cltout[size+1],*oh=cltout,*ot=cltout+size;\n\tinline void pc(char c){\n\t\tif(oh==ot){\n\t\t\tfwrite(cltout,1,size,stdout);\n\t\t\toh=cltout;\n\t\t}\n\t\t*oh++=c;\n\t}\n\t#define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout\n\t#undef size\n\n\ttemplate <typename _tp>\n\tinline void read(_tp& x){\n\t\tsigned sn=1;\n\t\tchar c=gc();\n\t\tfor(;c!=45&&(c<48||c>57)&&c!=EOF;c=gc());\n\t\tif(c==45&&c!=EOF)\n\t\t\tsn=-1,c=gc();\n\t\tfor(x=0;c>=48&&c<=57&&c!=EOF;x=(x<<3)+(x<<1)+(c^48),c=gc());\n\t\tx*=sn;\n\t}\n\n\ttemplate <typename _tp>\n\tinline void write(_tp x,char text=-1){\n\t\tif(x<0)\n\t\t\tpc(45),x=-x;\n\t\tif(!x)\n\t\t\tpc(48);\n\t\telse{\n\t\t\tsigned digit[50];\n\t\t\tfor(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10);\n\t\t\tfor(;digit[0];pc(digit[digit[0]--]^48));\n\t\t}\n\t\tif(text>=0)\n\t\t\tpc(text);\n\t}\n}\n\nint n,m;\n\ninline int simEuc(re int n,re int a,re int b,re int c){\n\tif(!n)\n\t\treturn b/c;\n\tif(!a)\n\t\treturn (n+1)*(b/c);\n\tif(a>=c||b>=c){\n\t\tre int res=simEuc(n,a%c,b%c,c);\n\t\treturn res+n*(n+1)*(a/c)/2+(n+1)*(b/c);\n\t}\n\telse{\n\t\tre int m=(a*n+b)/c;\n\t\treturn m*n-simEuc(m-1,c,c-b-1,a);\n\t}\n}\n\nstruct node{\n\tint l,r,L,R,a,b,sum;\n\n\tnode(re int _l,re int _r,re int _L,re int _R,re int _a,re int _b){\n\t\tl=_l;\n\t\tr=_r;\n\t\tL=_L;\n\t\tR=_R;\n\t\ta=_a;\n\t\tb=_b;\n\t\tsum=(R+L)*(R-L+1)*a/2-simEuc(R,a,0,b)*b+simEuc(L-1,a,0,b)*b;\n\t}\n};\nstd::set<node> s;\n\ninline bool operator<(re node p1,re node p2){\n\treturn p1.l<p2.l;\n}\n\ninline _it split(re int pos){\n\tre _it it=s.lower_bound(node(pos,0,1,0,0,1));\n\tif(it!=s.end()&&it->l==pos)\n\t\treturn it;\n\telse{\n\t\t--it;\n\t\tre int l=it->l,r=it->r,L=it->L,R=it->R,a=it->a,b=it->b;\n\t\ts.erase(it);\n\t\ts.insert(node(l,pos-1,L,L+pos-l-1,a,b));\n\t\treturn s.insert(node(pos,r,L+pos-l,R,a,b)).first;\n\t}\n}\n\ninline void modifyStone(re int l,re int r,re int a,re int b){\n\tre _it itr=split(r+1),itl=split(l);\n\ts.erase(itl,itr);\n\ts.insert(node(l,r,1,r-l+1,a,b));\n}\n\ninline int queryStone(re int l,re int r){\n\tre _it itr=split(r+1),itl=split(l);\n\tre int res=0;\n\tfor(;itl!=itr;res+=itl->sum,++itl);\n\treturn res;\n}\n\nsigned main(){\n\tcltstream::read(n);\n\tcltstream::read(m);\n\ts.insert(node(1,n,1,0,0,1));\n\tfor(re int i=1;i<=m;++i){\n\t\tre int opt,l,r,a,b;\n\t\tcltstream::read(opt);\n\t\tcltstream::read(l);\n\t\tcltstream::read(r);\n\t\tif(opt==1){\n\t\t\tcltstream::read(a);\n\t\t\tcltstream::read(b);\n\t\t\tmodifyStone(l,r,a,b);\n\t\t}\n\t\telse\n\t\t\tcltstream::write(queryStone(l,r),10);\n\t}\n\tclop();\n\treturn 0;\n}\n```\n\n{% endfold %}\n","slug":"similar-euclid-algorithm-learning-notes","published":1,"updated":"2019-02-13T00:16:28.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs60fpxm004r34cwgzhh0ssj","content":"<p>其实我也不知道这个算法的英文名是啥（</p>\n<p>我就yy出来一个「Similar Euclid Algorithm」（</p>\n<a id=\"more\"></a>\n<p>给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=0}^{n}i^{k_{1}}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{k_{2}}\\pmod{1000000007}</script><p>$n,a,b,c\\leqslant 10^{9}$，$k_{1}+k_{2}\\leqslant 10$。</p>\n<p><img src=\"https://i.loli.net/2019/01/10/5c36dbda14c92.jpg\" alt=\"\"></p>\n<p>太难了，告辞（</p>\n<p>所以我们现在来研究简单一点的。</p>\n<p>给你四个非负整数$n,a,b,c$，你需要求出</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\ng(n,a,b,c)&\\equiv\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\nh(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\pmod{998244353}\n\\end{aligned}</script><p>$n,a,b,c\\leqslant 10^{9}$，$10^{5}$组询问。</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P5170\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p>于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。</p>\n<p>首先考虑$f(n,a,b,c)$，假设$a\\geqslant c\\vee b\\geqslant c$</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}</script><p>也就是说，我们只需要重点关注$a\\lt c\\wedge b\\lt c$时的情况即可。我们令$m=\\lfloor\\cfrac{an+b}{c}\\rfloor$，然后继续往下推</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\leqslant ai+b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\geqslant cj+c-b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\geqslant\\cfrac{cj+c-b}{a}\\right]\\\\\n\\end{aligned}</script><p>然后我们发现，我们可能需要在$\\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。</p>\n<p>考虑转换一下思路。既然$cj+c\\leqslant ai+b$，我们就有$cj+c\\lt ai+b+1$，然后再往下</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\lt ai+b+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\gt cj+c-b-1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\\\\\n&=\\sum_{j=0}^{m-1}\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=mn-\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=mn-f(m-1,c,c-b-1,a)\n\\end{aligned}</script><p>然后我们看到，这个函数它递归了！</p>\n<p>注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\\log a$次，时间复杂度就是$O(\\log a)$了。</p>\n<p>然后考虑$g(n,a,b,c)$。</p>\n<p>$a\\geqslant c\\vee b\\geqslant c$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor+i\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}</script><p>$a\\lt c\\wedge b\\lt c$，当然$m$还是$\\lfloor\\cfrac{an+b}{c}\\rfloor$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}i\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}i\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\n\\end{aligned}</script><p>我们可以把上面这个式子理解成$\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor$且$\\leqslant n$的所有自然数之和，于是差分一下我们得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(n,a,b,c)&=\\sum_{j=0}^{m-1}\\left(\\cfrac{n(n+1)}{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)\n\\end{aligned}</script><p>我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。</p>\n<p>$a\\geqslant c\\vee b\\geqslant c$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\n\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\right)\\\\\n&=\n\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\\\\&\n+2\\lfloor\\cfrac{a}{c}\\rfloor\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\\\\n&=\nh(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}</script><p>您绝对想象不到上面这一坨子东西的$\\TeX$源码长什么样（</p>\n<p>$a\\lt c\\wedge b\\lt c$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m^{2}}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[c^{2}j+c^{2}\\lt a^{2}i^{2}+2abi+b^{2}+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[i\\gt\\sqrt{\\lfloor\\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\\rfloor}\\right]\n\\end{aligned}</script><p><img src=\"https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg\" alt=\"\"></p>\n<p>然后我们发现推不下去了。</p>\n<p>不过办法总是有的。首先我们有一个看起来没啥用的式子</p>\n<script type=\"math/tex; mode=display\">x^{2}=2\\sum_{i=1}^{n}i-x</script><p>套进去</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(2\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right)\\\\\n&=2\\sum_{i=0}^{n}\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=2\\sum_{j=1}^{m}j\\sum_{i=0}^{n}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^{n}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)-f(n,a,b,c)\\\\\n&=m(m+1)n-2\\sum_{j=0}^{m-1}j\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-2\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-f(n,a,b,c)\\\\\n&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\\\n\\end{aligned}</script><p>然后我们看到它奇迹般地递归了！</p>\n<p>我们来总结一下。</p>\n<script type=\"math/tex; mode=display\">f(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&mn-f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}</script><script type=\"math/tex; mode=display\">g(n,a,b,c)=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}</script><script type=\"math/tex; mode=display\">h(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}=\\begin{cases}\n&h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;\n&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}</script><p>但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：</p>\n<script type=\"math/tex; mode=display\">f(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}</script><script type=\"math/tex; mode=display\">g(n,a,b,c)=\\begin{cases}\n&0\\;\\;&(n=0)\\\\\n&\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}</script><script type=\"math/tex; mode=display\">h(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(a=0)\n\\end{cases}</script><p>另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> mod 998244353</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">int</span> digit[<span class=\"number\">22</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> t,a,b,c,n,I2=<span class=\"number\">499122177</span>,I6=<span class=\"number\">166374059</span>;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Query</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> f,g,h;</span><br><span class=\"line\"></span><br><span class=\"line\">\tQuery(re <span class=\"keyword\">int</span> _f,re <span class=\"keyword\">int</span> _g,re <span class=\"keyword\">int</span> _h)&#123;</span><br><span class=\"line\">\t\tf=_f;</span><br><span class=\"line\">\t\tg=_g;</span><br><span class=\"line\">\t\th=_h;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> Query <span class=\"title\">query</span><span class=\"params\">(re <span class=\"keyword\">int</span> a,re <span class=\"keyword\">int</span> b,re <span class=\"keyword\">int</span> c,re <span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!n)&#123;</span><br><span class=\"line\">\t\tb/=c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Query(b,<span class=\"number\">0</span>,<span class=\"number\">1L</span>L*b*b%mod);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!a)&#123;</span><br><span class=\"line\">\t\tb/=c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Query(<span class=\"number\">1L</span>L*(n+<span class=\"number\">1</span>)*b%mod,<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)%mod*I2%mod*b%mod,<span class=\"number\">1L</span>L*(n+<span class=\"number\">1</span>)*b%mod*b%mod);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class=\"line\">\t\tre Query res=query(a%c,b%c,c,n);</span><br><span class=\"line\">\t\ta/=c,</span><br><span class=\"line\">\t\tb/=c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Query(</span><br><span class=\"line\">\t\t\t(res.f+<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)%mod*I2%mod*a%mod+<span class=\"number\">1L</span>L*(n+<span class=\"number\">1</span>)*b%mod)%mod,</span><br><span class=\"line\">\t\t\t(res.g+<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)%mod*(<span class=\"number\">2</span>*n+<span class=\"number\">1</span>)%mod*I6%mod*a%mod+<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)%mod*I2%mod*b%mod)%mod,</span><br><span class=\"line\">\t\t\t(res.h+<span class=\"number\">2L</span>L*a*res.g%mod+<span class=\"number\">2L</span>L*b*res.f%mod</span><br><span class=\"line\">\t\t\t\t  +<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)%mod*(<span class=\"number\">2</span>*n+<span class=\"number\">1</span>)%mod*I6%mod*a%mod*a%mod</span><br><span class=\"line\">\t\t\t\t  +<span class=\"number\">1L</span>L*(n+<span class=\"number\">1</span>)*b%mod*b%mod+<span class=\"number\">1L</span>L*n*(n+<span class=\"number\">1</span>)%mod*a%mod*b%mod)%mod</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> m=(<span class=\"number\">1L</span>L*a*n+b)/c;</span><br><span class=\"line\">\t\tre Query res=query(c,c-b<span class=\"number\">-1</span>,a,m<span class=\"number\">-1</span>);</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> tmp=((<span class=\"number\">1L</span>L*m*n%mod-res.f)%mod+mod)%mod;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Query(</span><br><span class=\"line\">\t\t\ttmp,</span><br><span class=\"line\">\t\t\t((<span class=\"number\">1L</span>L*m*n%mod*(n+<span class=\"number\">1</span>)%mod-res.h-res.f)%mod+mod)*I2%mod,</span><br><span class=\"line\">\t\t\t((<span class=\"number\">1L</span>L*m*(m+<span class=\"number\">1</span>)%mod*n%mod<span class=\"number\">-2L</span>L*res.g%mod<span class=\"number\">-2L</span>L*res.f%mod-tmp)%mod+mod)%mod</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcltstream::read(t);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;t;--t)&#123;</span><br><span class=\"line\">\t\tcltstream::read(n);</span><br><span class=\"line\">\t\tcltstream::read(a);</span><br><span class=\"line\">\t\tcltstream::read(b);</span><br><span class=\"line\">\t\tcltstream::read(c);</span><br><span class=\"line\">\t\tQuery ans=query(a,b,c,n);</span><br><span class=\"line\">\t\tcltstream::write(ans.f,<span class=\"number\">32</span>);</span><br><span class=\"line\">\t\tcltstream::write(ans.h,<span class=\"number\">32</span>);</span><br><span class=\"line\">\t\tcltstream::write(ans.g,<span class=\"number\">10</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n<p>那么问题来了，这个东西有什么用啊。</p>\n<p><del>没啥用（</del></p>\n<p>其他的模板题我就不举了，我们来看一下<a href=\"https://www.luogu.org/problemnew/show/P4433\" target=\"_blank\" rel=\"noopener\">这样一道题</a>。</p>\n<p>看到推平操作我们可以直接往珂朵莉树上想了。</p>\n<p>那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息<code>l,r,L,R,a,b</code>，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\\sum_{i=L}^{R}ai\\operatorname{mod}b$颗石头。注意这里的<code>l,r,L,R</code>一定不要搞混<del>，我就是因为这样WA了整整四遍（</del>。</p>\n<p><del>这三个样例一定是故意的。</del></p>\n<p>然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=L}^{R}ai\\operatorname{mod}b=\\sum_{i=L}^{R}\\left(ai-\\lfloor\\cfrac{ai}{b}\\rfloor b\\right)=\\cfrac{(R+L)(R-L+1)}{2}-\\sum_{i=0}^{R}\\lfloor\\cfrac{ai}{b}\\rfloor b+\\sum_{i=0}^{L-1}\\lfloor\\cfrac{ai}{b}\\rfloor b</script><p>直接一波板子套上去。</p>\n<p>还有就是，这么算的话中间量会爆<code>long long</code>，我们可以考虑用<code>__int128_t</code>来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> int __int128_t</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>然后把一些没必要用或者是不能用<code>__int128_t</code>的改成<code>signed</code>即可。</p>\n<p>代码还是有必要贴一下的。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;set&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> re register</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _it std::set<span class=\"meta-string\">&lt;node&gt;::iterator</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> int __int128_t</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> cltstream&#123;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> size 1048576</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltin[size+<span class=\"number\">1</span>],*ih=cltin,*it=cltin;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">char</span> <span class=\"title\">gc</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> ONLINE_JUDGE</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(ih==it)&#123;</span><br><span class=\"line\">\t\t\t\tit=(ih=cltin)+fread(cltin,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdin</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(ih==it)</span><br><span class=\"line\">\t\t\t\t\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> *ih++;</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> getchar();</span><br><span class=\"line\">\t\t<span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> cltout[size+<span class=\"number\">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">pc</span><span class=\"params\">(<span class=\"keyword\">char</span> c)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(oh==ot)&#123;</span><br><span class=\"line\">\t\t\tfwrite(cltout,<span class=\"number\">1</span>,size,<span class=\"built_in\">stdout</span>);</span><br><span class=\"line\">\t\t\toh=cltout;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t*oh++=c;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class=\"line\">\t<span class=\"meta\">#<span class=\"meta-keyword\">undef</span> size</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">read</span><span class=\"params\">(_tp&amp; x)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">signed</span> sn=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">char</span> c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(;c!=<span class=\"number\">45</span>&amp;&amp;(c&lt;<span class=\"number\">48</span>||c&gt;<span class=\"number\">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(c==<span class=\"number\">45</span>&amp;&amp;c!=EOF)</span><br><span class=\"line\">\t\t\tsn=<span class=\"number\">-1</span>,c=gc();</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(x=<span class=\"number\">0</span>;c&gt;=<span class=\"number\">48</span>&amp;&amp;c&lt;=<span class=\"number\">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class=\"number\">3</span>)+(x&lt;&lt;<span class=\"number\">1</span>)+(c^<span class=\"number\">48</span>),c=gc());</span><br><span class=\"line\">\t\tx*=sn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">template</span> &lt;<span class=\"keyword\">typename</span> _tp&gt;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">write</span><span class=\"params\">(_tp x,<span class=\"keyword\">char</span> text=<span class=\"number\">-1</span>)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(x&lt;<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">45</span>),x=-x;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!x)</span><br><span class=\"line\">\t\t\tpc(<span class=\"number\">48</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">signed</span> digit[<span class=\"number\">50</span>];</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(digit[<span class=\"number\">0</span>]=<span class=\"number\">0</span>;x;digit[++digit[<span class=\"number\">0</span>]]=x%<span class=\"number\">10</span>,x/=<span class=\"number\">10</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span>(;digit[<span class=\"number\">0</span>];pc(digit[digit[<span class=\"number\">0</span>]--]^<span class=\"number\">48</span>));</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(text&gt;=<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\tpc(text);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> n,m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">simEuc</span><span class=\"params\">(re <span class=\"keyword\">int</span> n,re <span class=\"keyword\">int</span> a,re <span class=\"keyword\">int</span> b,re <span class=\"keyword\">int</span> c)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!n)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> b/c;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!a)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> (n+<span class=\"number\">1</span>)*(b/c);</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> res=simEuc(n,a%c,b%c,c);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> res+n*(n+<span class=\"number\">1</span>)*(a/c)/<span class=\"number\">2</span>+(n+<span class=\"number\">1</span>)*(b/c);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> m=(a*n+b)/c;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> m*n-simEuc(m<span class=\"number\">-1</span>,c,c-b<span class=\"number\">-1</span>,a);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> l,r,L,R,a,b,sum;</span><br><span class=\"line\"></span><br><span class=\"line\">\tnode(re <span class=\"keyword\">int</span> _l,re <span class=\"keyword\">int</span> _r,re <span class=\"keyword\">int</span> _L,re <span class=\"keyword\">int</span> _R,re <span class=\"keyword\">int</span> _a,re <span class=\"keyword\">int</span> _b)&#123;</span><br><span class=\"line\">\t\tl=_l;</span><br><span class=\"line\">\t\tr=_r;</span><br><span class=\"line\">\t\tL=_L;</span><br><span class=\"line\">\t\tR=_R;</span><br><span class=\"line\">\t\ta=_a;</span><br><span class=\"line\">\t\tb=_b;</span><br><span class=\"line\">\t\tsum=(R+L)*(R-L+<span class=\"number\">1</span>)*a/<span class=\"number\">2</span>-simEuc(R,a,<span class=\"number\">0</span>,b)*b+simEuc(L<span class=\"number\">-1</span>,a,<span class=\"number\">0</span>,b)*b;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">std</span>::<span class=\"built_in\">set</span>&lt;node&gt; s;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"keyword\">bool</span> <span class=\"keyword\">operator</span>&lt;(re node p1,re node p2)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> p1.l&lt;p2.l;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> _<span class=\"function\">it <span class=\"title\">split</span><span class=\"params\">(re <span class=\"keyword\">int</span> pos)</span></span>&#123;</span><br><span class=\"line\">\tre _it it=s.lower_bound(node(pos,<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> it;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t--it;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b;</span><br><span class=\"line\">\t\ts.erase(it);</span><br><span class=\"line\">\t\ts.insert(node(l,pos<span class=\"number\">-1</span>,L,L+pos-l<span class=\"number\">-1</span>,a,b));</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> s.insert(node(pos,r,L+pos-l,R,a,b)).first;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">void</span> <span class=\"title\">modifyStone</span><span class=\"params\">(re <span class=\"keyword\">int</span> l,re <span class=\"keyword\">int</span> r,re <span class=\"keyword\">int</span> a,re <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">\tre _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">\ts.erase(itl,itr);</span><br><span class=\"line\">\ts.insert(node(l,r,<span class=\"number\">1</span>,r-l+<span class=\"number\">1</span>,a,b));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">queryStone</span><span class=\"params\">(re <span class=\"keyword\">int</span> l,re <span class=\"keyword\">int</span> r)</span></span>&#123;</span><br><span class=\"line\">\tre _it itr=split(r+<span class=\"number\">1</span>),itl=split(l);</span><br><span class=\"line\">\tre <span class=\"keyword\">int</span> res=<span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(;itl!=itr;res+=itl-&gt;sum,++itl);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\tcltstream::read(n);</span><br><span class=\"line\">\tcltstream::read(m);</span><br><span class=\"line\">\ts.insert(node(<span class=\"number\">1</span>,n,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">1</span>));</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(re <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;=m;++i)&#123;</span><br><span class=\"line\">\t\tre <span class=\"keyword\">int</span> opt,l,r,a,b;</span><br><span class=\"line\">\t\tcltstream::read(opt);</span><br><span class=\"line\">\t\tcltstream::read(l);</span><br><span class=\"line\">\t\tcltstream::read(r);</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(opt==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">\t\t\tcltstream::read(a);</span><br><span class=\"line\">\t\t\tcltstream::read(b);</span><br><span class=\"line\">\t\t\tmodifyStone(l,r,a,b);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tcltstream::write(queryStone(l,r),<span class=\"number\">10</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tclop();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</div></div>\n","site":{"data":{}},"excerpt":"<p>其实我也不知道这个算法的英文名是啥（</p>\n<p>我就yy出来一个「Similar Euclid Algorithm」（</p>","more":"<p>给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=0}^{n}i^{k_{1}}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{k_{2}}\\pmod{1000000007}</script><p>$n,a,b,c\\leqslant 10^{9}$，$k_{1}+k_{2}\\leqslant 10$。</p>\n<p><img src=\"https://i.loli.net/2019/01/10/5c36dbda14c92.jpg\" alt=\"\"></p>\n<p>太难了，告辞（</p>\n<p>所以我们现在来研究简单一点的。</p>\n<p>给你四个非负整数$n,a,b,c$，你需要求出</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\ng(n,a,b,c)&\\equiv\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\\nh(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\pmod{998244353}\n\\end{aligned}</script><p>$n,a,b,c\\leqslant 10^{9}$，$10^{5}$组询问。</p>\n<p><a href=\"https://www.luogu.org/problemnew/show/P5170\" target=\"_blank\" rel=\"noopener\">传送门</a></p>\n<p>于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。</p>\n<p>首先考虑$f(n,a,b,c)$，假设$a\\geqslant c\\vee b\\geqslant c$</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}</script><p>也就是说，我们只需要重点关注$a\\lt c\\wedge b\\lt c$时的情况即可。我们令$m=\\lfloor\\cfrac{an+b}{c}\\rfloor$，然后继续往下推</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\leqslant ai+b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\geqslant cj+c-b\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\geqslant\\cfrac{cj+c-b}{a}\\right]\\\\\n\\end{aligned}</script><p>然后我们发现，我们可能需要在$\\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。</p>\n<p>考虑转换一下思路。既然$cj+c\\leqslant ai+b$，我们就有$cj+c\\lt ai+b+1$，然后再往下</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nf(n,a,b,c)&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\lt ai+b+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\gt cj+c-b-1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\\\\\n&=\\sum_{j=0}^{m-1}\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=mn-\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=mn-f(m-1,c,c-b-1,a)\n\\end{aligned}</script><p>然后我们看到，这个函数它递归了！</p>\n<p>注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\\log a$次，时间复杂度就是$O(\\log a)$了。</p>\n<p>然后考虑$g(n,a,b,c)$。</p>\n<p>$a\\geqslant c\\vee b\\geqslant c$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\left(i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor+i\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\\n&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\\\\n&=g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}</script><p>$a\\lt c\\wedge b\\lt c$，当然$m$还是$\\lfloor\\cfrac{an+b}{c}\\rfloor$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m}i\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}i\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\n\\end{aligned}</script><p>我们可以把上面这个式子理解成$\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor$且$\\leqslant n$的所有自然数之和，于是差分一下我们得到</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\ng(n,a,b,c)&=\\sum_{j=0}^{m-1}\\left(\\cfrac{n(n+1)}{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\\n&=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)\n\\end{aligned}</script><p>我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。</p>\n<p>$a\\geqslant c\\vee b\\geqslant c$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(\n\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\right)\\\\\n&=\n\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2}\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\\\\&\n+2\\lfloor\\cfrac{a}{c}\\rfloor\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+2\\lfloor\\cfrac{b}{c}\\rfloor\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\\\\n&=\nh(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\n\\end{aligned}</script><p>您绝对想象不到上面这一坨子东西的$\\TeX$源码长什么样（</p>\n<p>$a\\lt c\\wedge b\\lt c$：</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=1}^{m^{2}}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[c^{2}j+c^{2}\\lt a^{2}i^{2}+2abi+b^{2}+1\\right]\\\\\n&=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[i\\gt\\sqrt{\\lfloor\\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\\rfloor}\\right]\n\\end{aligned}</script><p><img src=\"https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg\" alt=\"\"></p>\n<p>然后我们发现推不下去了。</p>\n<p>不过办法总是有的。首先我们有一个看起来没啥用的式子</p>\n<script type=\"math/tex; mode=display\">x^{2}=2\\sum_{i=1}^{n}i-x</script><p>套进去</p>\n<script type=\"math/tex; mode=display\">\\begin{aligned}\nh(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\\n&=\\sum_{i=0}^{n}\\left(2\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right)\\\\\n&=2\\sum_{i=0}^{n}\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\\n&=2\\sum_{j=1}^{m}j\\sum_{i=0}^{n}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^{n}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]-f(n,a,b,c)\\\\\n&=2\\sum_{j=0}^{m-1}(j+1)\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)-f(n,a,b,c)\\\\\n&=m(m+1)n-2\\sum_{j=0}^{m-1}j\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-2\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-f(n,a,b,c)\\\\\n&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\\\n\\end{aligned}</script><p>然后我们看到它奇迹般地递归了！</p>\n<p>我们来总结一下。</p>\n<script type=\"math/tex; mode=display\">f(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&mn-f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}</script><script type=\"math/tex; mode=display\">g(n,a,b,c)=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases}\n&g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}</script><script type=\"math/tex; mode=display\">h(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}=\\begin{cases}\n&h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\n+2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\&\n+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2}\n+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\n+n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;\n&(a\\geqslant c\\vee b\\geqslant c)\\\\\n&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\\lt c\\wedge b\\lt c)\n\\end{cases}</script><p>但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：</p>\n<script type=\"math/tex; mode=display\">f(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}</script><script type=\"math/tex; mode=display\">g(n,a,b,c)=\\begin{cases}\n&0\\;\\;&(n=0)\\\\\n&\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor&(a=0)\n\\end{cases}</script><script type=\"math/tex; mode=display\">h(n,a,b,c)=\\begin{cases}\n&\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(n=0)\\\\\n&(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(a=0)\n\\end{cases}</script><p>另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�53-->\n\n</div></div>\n<p>那么问题来了，这个东西有什么用啊。</p>\n<p><del>没啥用（</del></p>\n<p>其他的模板题我就不举了，我们来看一下<a href=\"https://www.luogu.org/problemnew/show/P4433\" target=\"_blank\" rel=\"noopener\">这样一道题</a>。</p>\n<p>看到推平操作我们可以直接往珂朵莉树上想了。</p>\n<p>那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息<code>l,r,L,R,a,b</code>，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\\sum_{i=L}^{R}ai\\operatorname{mod}b$颗石头。注意这里的<code>l,r,L,R</code>一定不要搞混<del>，我就是因为这样WA了整整四遍（</del>。</p>\n<p><del>这三个样例一定是故意的。</del></p>\n<p>然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：</p>\n<script type=\"math/tex; mode=display\">\\sum_{i=L}^{R}ai\\operatorname{mod}b=\\sum_{i=L}^{R}\\left(ai-\\lfloor\\cfrac{ai}{b}\\rfloor b\\right)=\\cfrac{(R+L)(R-L+1)}{2}-\\sum_{i=0}^{R}\\lfloor\\cfrac{ai}{b}\\rfloor b+\\sum_{i=0}^{L-1}\\lfloor\\cfrac{ai}{b}\\rfloor b</script><p>直接一波板子套上去。</p>\n<p>还有就是，这么算的话中间量会爆<code>long long</code>，我们可以考虑用<code>__int128_t</code>来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以</p>\n<!--�54-->\n<p>然后把一些没必要用或者是不能用<code>__int128_t</code>的改成<code>signed</code>即可。</p>\n<p>代码还是有必要贴一下的。</p>\n<div><div class=\"fold_hider\"><div class=\"close hider_title\">Toggle Code</div></div><div class=\"fold\">\n<!--�55-->\n\n</div></div>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjs60fpub000134cwnkmxkqes","category_id":"cjs60fpui000534cw4avfe35w","_id":"cjs60fput000g34cwlk2939wh"},{"post_id":"cjs60fpup000e34cwrxwpd9x7","category_id":"cjs60fpui000534cw4avfe35w","_id":"cjs60fpuw000m34cw5olxcr8w"},{"post_id":"cjs60fpug000334cw8jhgtlrm","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpuy000q34cwayyp49gm"},{"post_id":"cjs60fpuk000734cwcl9j5wjj","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpuz000t34cwr4g85stj"},{"post_id":"cjs60fpum000934cw3y7bb2vy","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv2000z34cww90hwv9k"},{"post_id":"cjs60fpuy000r34cwhp29c9mp","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv3001334cws5005cwj"},{"post_id":"cjs60fpv0000v34cw2rzerami","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv4001634cwfz57odin"},{"post_id":"cjs60fpun000a34cwomlc1pj0","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv5001934cwtrn5bph5"},{"post_id":"cjs60fpv2001134cwtdeuovpm","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv7001d34cwp2j3iyyt"},{"post_id":"cjs60fpus000f34cweapb71hb","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpv7001g34cw41ckdm4a"},{"post_id":"cjs60fpv3001534cwejpe4f07","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv8001i34cwke3qhyvl"},{"post_id":"cjs60fpv5001834cw0f77bbg9","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpv9001k34cwzcq29kml"},{"post_id":"cjs60fpuv000k34cwt0p6k7ii","category_id":"cjs60fpv4001734cwndq75h6f","_id":"cjs60fpv9001n34cw4r1conyu"},{"post_id":"cjs60fpv6001b34cwbyiu0gnp","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpva001q34cwfnggubxz"},{"post_id":"cjs60fpuw000l34cw8xrxmsfo","category_id":"cjs60fpv7001e34cw4n07i3rc","_id":"cjs60fpvb001s34cw5j1dy3q3"},{"post_id":"cjs60fpux000p34cw5l27g9bw","category_id":"cjs60fpv7001e34cw4n07i3rc","_id":"cjs60fpvb001t34cwos80krd2"},{"post_id":"cjs60fpv1000x34cw4mgah8uy","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpvc001v34cwu0ytvhhn"},{"post_id":"cjs60fpwb003n34cw2u7epae1","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpwf003t34cwl6718k9t"},{"post_id":"cjs60fpwc003p34cwjf55ld5o","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpwg003w34cwmk4lko97"},{"post_id":"cjs60fpwe003s34cwaiu5jtjy","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpwj004134cwwmcgq349"},{"post_id":"cjs60fpwf003v34cwh7e72jwt","category_id":"cjs60fpuo000b34cwejv4f683","_id":"cjs60fpwk004334cwlk8tduxw"},{"post_id":"cjs60fpwh003z34cwye6iiyy8","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpwk004534cwltys57ia"},{"post_id":"cjs60fpwd003r34cwinxi624m","category_id":"cjs60fpwf003u34cwgan78t25","_id":"cjs60fpwl004834cwrr6jhf79"},{"post_id":"cjs60fpwi004034cwanrv06yh","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpwl004a34cwzrmi6soz"},{"post_id":"cjs60fpxk004o34cwg5dzzj7d","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpxn004t34cwa8sutt3o"},{"post_id":"cjs60fpxl004p34cwsjgnmqn9","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpxn004v34cw1no8ng36"},{"post_id":"cjs60fpxm004r34cwgzhh0ssj","category_id":"cjs60fpv2000y34cwl5jybo88","_id":"cjs60fpxo004y34cwad56j1nc"}],"PostTag":[{"post_id":"cjs60fpub000134cwnkmxkqes","tag_id":"cjs60fpuk000634cwbpcdmj3h","_id":"cjs60fpup000d34cwhj0e661u"},{"post_id":"cjs60fpup000e34cwrxwpd9x7","tag_id":"cjs60fpuk000634cwbpcdmj3h","_id":"cjs60fpuu000j34cwqvp7ed9g"},{"post_id":"cjs60fpug000334cw8jhgtlrm","tag_id":"cjs60fpuo000c34cwkyp5d1ps","_id":"cjs60fpv1000w34cwpftfyf0k"},{"post_id":"cjs60fpug000334cw8jhgtlrm","tag_id":"cjs60fput000i34cw58cr8doh","_id":"cjs60fpv2001034cwrn5yyn5t"},{"post_id":"cjs60fpug000334cw8jhgtlrm","tag_id":"cjs60fpux000o34cw21mhexsj","_id":"cjs60fpv3001434cw23a7mgdi"},{"post_id":"cjs60fpuk000734cwcl9j5wjj","tag_id":"cjs60fpv0000u34cwz9k73qfr","_id":"cjs60fpv7001c34cwj90bv4m2"},{"post_id":"cjs60fpuk000734cwcl9j5wjj","tag_id":"cjs60fpv3001234cwh9zd9d82","_id":"cjs60fpv7001f34cwkaqzmfpl"},{"post_id":"cjs60fpum000934cw3y7bb2vy","tag_id":"cjs60fpv0000u34cwz9k73qfr","_id":"cjs60fpv9001m34cwf5h3ry6z"},{"post_id":"cjs60fpum000934cw3y7bb2vy","tag_id":"cjs60fpuo000c34cwkyp5d1ps","_id":"cjs60fpva001p34cwegxkfio1"},{"post_id":"cjs60fpun000a34cwomlc1pj0","tag_id":"cjs60fpv9001l34cwq4wfd44p","_id":"cjs60fpve001z34cw9stv9n0s"},{"post_id":"cjs60fpun000a34cwomlc1pj0","tag_id":"cjs60fpva001r34cw3glimwdy","_id":"cjs60fpve002034cwnss2r34m"},{"post_id":"cjs60fpun000a34cwomlc1pj0","tag_id":"cjs60fpvb001u34cwzg56zsjg","_id":"cjs60fpve002234cwynb1e4mn"},{"post_id":"cjs60fpun000a34cwomlc1pj0","tag_id":"cjs60fpvc001w34cwvwdwrjgp","_id":"cjs60fpvf002334cwy39dllf5"},{"post_id":"cjs60fpun000a34cwomlc1pj0","tag_id":"cjs60fput000i34cw58cr8doh","_id":"cjs60fpvf002534cwifk8o7cy"},{"post_id":"cjs60fpus000f34cweapb71hb","tag_id":"cjs60fpvd001y34cw3yv9ayks","_id":"cjs60fpvf002634cw43dh540i"},{"post_id":"cjs60fpus000f34cweapb71hb","tag_id":"cjs60fpve002134cwo2y4sdp7","_id":"cjs60fpvg002834cwrpslj6tl"},{"post_id":"cjs60fpuv000k34cwt0p6k7ii","tag_id":"cjs60fpvf002434cwqt15lvti","_id":"cjs60fpvh002a34cwxug4ffmb"},{"post_id":"cjs60fpuv000k34cwt0p6k7ii","tag_id":"cjs60fpvg002734cw9djoe7xe","_id":"cjs60fpvh002b34cwkao7tcav"},{"post_id":"cjs60fpuw000l34cw8xrxmsfo","tag_id":"cjs60fpvg002934cwtvbyd96p","_id":"cjs60fpvh002d34cwt4umhpmv"},{"post_id":"cjs60fpux000p34cw5l27g9bw","tag_id":"cjs60fpvg002934cwtvbyd96p","_id":"cjs60fpvi002g34cwj6thz2y7"},{"post_id":"cjs60fpux000p34cw5l27g9bw","tag_id":"cjs60fpvi002e34cwtrdec1ov","_id":"cjs60fpvj002h34cw42e3sb4g"},{"post_id":"cjs60fpuy000r34cwhp29c9mp","tag_id":"cjs60fpvi002f34cwuvh606d1","_id":"cjs60fpvj002j34cwuoq25w46"},{"post_id":"cjs60fpv0000v34cw2rzerami","tag_id":"cjs60fpvj002i34cw8y3gzuia","_id":"cjs60fpvm002p34cwmqwb8dg5"},{"post_id":"cjs60fpv0000v34cw2rzerami","tag_id":"cjs60fpvj002k34cwr0wmb0mm","_id":"cjs60fpvm002q34cw2kwspko5"},{"post_id":"cjs60fpv0000v34cw2rzerami","tag_id":"cjs60fpvg002934cwtvbyd96p","_id":"cjs60fpvn002s34cw29ewh1w0"},{"post_id":"cjs60fpv0000v34cw2rzerami","tag_id":"cjs60fpvk002m34cwm1db0b2g","_id":"cjs60fpvn002t34cwfeggtu8s"},{"post_id":"cjs60fpv0000v34cw2rzerami","tag_id":"cjs60fpvc001w34cwvwdwrjgp","_id":"cjs60fpvo002v34cwrnhrld8t"},{"post_id":"cjs60fpv1000x34cw4mgah8uy","tag_id":"cjs60fpvm002o34cwqwv99drs","_id":"cjs60fpvp002x34cwyjdiozmv"},{"post_id":"cjs60fpv1000x34cw4mgah8uy","tag_id":"cjs60fpvn002r34cwjy8de2ce","_id":"cjs60fpvq002y34cw3xxi23z9"},{"post_id":"cjs60fpv1000x34cw4mgah8uy","tag_id":"cjs60fpvo002u34cwc95960m6","_id":"cjs60fpvq003034cw3nz2dwyv"},{"post_id":"cjs60fpv2001134cwtdeuovpm","tag_id":"cjs60fpvp002w34cw25m3jstu","_id":"cjs60fpvr003434cwo6erdwax"},{"post_id":"cjs60fpv2001134cwtdeuovpm","tag_id":"cjs60fpvq002z34cwcrtfxkty","_id":"cjs60fpvr003534cwmbaddt33"},{"post_id":"cjs60fpv2001134cwtdeuovpm","tag_id":"cjs60fpvq003134cwbn0g6q1y","_id":"cjs60fpvs003734cwki1pktnu"},{"post_id":"cjs60fpv2001134cwtdeuovpm","tag_id":"cjs60fpvi002f34cwuvh606d1","_id":"cjs60fpvs003834cwblq9xuw2"},{"post_id":"cjs60fpv3001534cwejpe4f07","tag_id":"cjs60fpvj002i34cw8y3gzuia","_id":"cjs60fpvt003c34cwjwvgopgh"},{"post_id":"cjs60fpv3001534cwejpe4f07","tag_id":"cjs60fpvr003634cw7r7ys3q8","_id":"cjs60fpvt003d34cwrhtmfrik"},{"post_id":"cjs60fpv3001534cwejpe4f07","tag_id":"cjs60fpvs003934cw18ilm3f1","_id":"cjs60fpvt003f34cwiwub52hd"},{"post_id":"cjs60fpv3001534cwejpe4f07","tag_id":"cjs60fpvi002f34cwuvh606d1","_id":"cjs60fpvt003g34cwt1zmpk6w"},{"post_id":"cjs60fpv5001834cw0f77bbg9","tag_id":"cjs60fpvs003b34cwjhx93lhf","_id":"cjs60fpvu003i34cw1jvwevv5"},{"post_id":"cjs60fpv5001834cw0f77bbg9","tag_id":"cjs60fpvt003e34cw8ebwou69","_id":"cjs60fpvu003j34cwuw0vaznm"},{"post_id":"cjs60fpv6001b34cwbyiu0gnp","tag_id":"cjs60fpvt003h34cwgbuxqoru","_id":"cjs60fpvu003l34cwb2zy4dki"},{"post_id":"cjs60fpv6001b34cwbyiu0gnp","tag_id":"cjs60fpvu003k34cwxyirb7ql","_id":"cjs60fpvu003m34cwt3rhqxgj"},{"post_id":"cjs60fpwb003n34cw2u7epae1","tag_id":"cjs60fpwd003q34cwwglpdapy","_id":"cjs60fpwh003y34cwwx9f96r2"},{"post_id":"cjs60fpwc003p34cwjf55ld5o","tag_id":"cjs60fpv0000u34cwz9k73qfr","_id":"cjs60fpwk004434cwcnn6g71b"},{"post_id":"cjs60fpwc003p34cwjf55ld5o","tag_id":"cjs60fpwg003x34cw86koj7xy","_id":"cjs60fpwk004634cwezela0k9"},{"post_id":"cjs60fpwd003r34cwinxi624m","tag_id":"cjs60fpwk004234cwxhmyyq4w","_id":"cjs60fpwl004934cwz2m89nqo"},{"post_id":"cjs60fpwd003r34cwinxi624m","tag_id":"cjs60fpvg002934cwtvbyd96p","_id":"cjs60fpwl004b34cw0fp30wmg"},{"post_id":"cjs60fpwe003s34cwaiu5jtjy","tag_id":"cjs60fpwk004734cwdjhnt2on","_id":"cjs60fpwl004d34cwqj2jye8g"},{"post_id":"cjs60fpwe003s34cwaiu5jtjy","tag_id":"cjs60fpvi002f34cwuvh606d1","_id":"cjs60fpwm004e34cw755nem1b"},{"post_id":"cjs60fpwf003v34cwh7e72jwt","tag_id":"cjs60fpv0000u34cwz9k73qfr","_id":"cjs60fpwm004h34cwh5wvi2x0"},{"post_id":"cjs60fpwf003v34cwh7e72jwt","tag_id":"cjs60fpwl004c34cw1zh1v1tp","_id":"cjs60fpwm004i34cwlovtju5r"},{"post_id":"cjs60fpwf003v34cwh7e72jwt","tag_id":"cjs60fpwm004f34cw0bl1zriy","_id":"cjs60fpwm004k34cwdfjelje5"},{"post_id":"cjs60fpwh003z34cwye6iiyy8","tag_id":"cjs60fpwm004g34cwdhzczzw8","_id":"cjs60fpwn004l34cwsh2z0pb3"},{"post_id":"cjs60fpwh003z34cwye6iiyy8","tag_id":"cjs60fpvu003k34cwxyirb7ql","_id":"cjs60fpwn004m34cwxvnr2t2w"},{"post_id":"cjs60fpwi004034cwanrv06yh","tag_id":"cjs60fpwm004j34cwnkaheadr","_id":"cjs60fpwn004n34cw8b6mff3l"},{"post_id":"cjs60fpxl004p34cwsjgnmqn9","tag_id":"cjs60fpwk004734cwdjhnt2on","_id":"cjs60fpxn004s34cwtfu703p0"},{"post_id":"cjs60fpxl004p34cwsjgnmqn9","tag_id":"cjs60fpvi002f34cwuvh606d1","_id":"cjs60fpxn004u34cwd60ytiz2"},{"post_id":"cjs60fpxk004o34cwg5dzzj7d","tag_id":"cjs60fpuo000c34cwkyp5d1ps","_id":"cjs60fpxo004x34cwi5na3ue1"},{"post_id":"cjs60fpxk004o34cwg5dzzj7d","tag_id":"cjs60fpxm004q34cwqlntrt5h","_id":"cjs60fpxo004z34cwb00nc4zk"},{"post_id":"cjs60fpxm004r34cwgzhh0ssj","tag_id":"cjs60fpuo000c34cwkyp5d1ps","_id":"cjs60fpxp005034cwxvf1wpbq"},{"post_id":"cjs60fpxm004r34cwgzhh0ssj","tag_id":"cjs60fpxo004w34cwy2apq6zq","_id":"cjs60fpxp005134cwkpjmhds9"}],"Tag":[{"name":"其它","_id":"cjs60fpuk000634cwbpcdmj3h"},{"name":"数论","_id":"cjs60fpuo000c34cwkyp5d1ps"},{"name":"组合数学","_id":"cjs60fput000i34cw58cr8doh"},{"name":"期望","_id":"cjs60fpux000o34cw21mhexsj"},{"name":"洛谷","_id":"cjs60fpv0000u34cwz9k73qfr"},{"name":"差分","_id":"cjs60fpv3001234cwh9zd9d82"},{"name":"SDOI","_id":"cjs60fpv9001l34cwq4wfd44p"},{"name":"2009","_id":"cjs60fpva001r34cw3glimwdy"},{"name":"离散化","_id":"cjs60fpvb001u34cwzg56zsjg"},{"name":"树状数组","_id":"cjs60fpvc001w34cwvwdwrjgp"},{"name":"状态压缩","_id":"cjs60fpvd001y34cw3yv9ayks"},{"name":"动态规划","_id":"cjs60fpve002134cwo2y4sdp7"},{"name":"NOIp","_id":"cjs60fpvf002434cwqt15lvti"},{"name":"2018","_id":"cjs60fpvg002734cw9djoe7xe"},{"name":"分块","_id":"cjs60fpvg002934cwtvbyd96p"},{"name":"块状分块","_id":"cjs60fpvi002e34cwtrdec1ov"},{"name":"NTT","_id":"cjs60fpvi002f34cwuvh606d1"},{"name":"HEOI","_id":"cjs60fpvj002i34cw8y3gzuia"},{"name":"2012","_id":"cjs60fpvj002k34cwr0wmb0mm"},{"name":"莫队","_id":"cjs60fpvk002m34cwm1db0b2g"},{"name":"网络流","_id":"cjs60fpvm002o34cwqwv99drs"},{"name":"最大流","_id":"cjs60fpvn002r34cwjy8de2ce"},{"name":"预留推进","_id":"cjs60fpvo002u34cwc95960m6"},{"name":"AHOI","_id":"cjs60fpvp002w34cw25m3jstu"},{"name":"HNOI","_id":"cjs60fpvq002z34cwcrtfxkty"},{"name":"2017","_id":"cjs60fpvq003134cwbn0g6q1y"},{"name":"TJOI","_id":"cjs60fpvr003634cw7r7ys3q8"},{"name":"2016","_id":"cjs60fpvs003934cw18ilm3f1"},{"name":"loli","_id":"cjs60fpvs003b34cwjhx93lhf"},{"name":"模拟赛","_id":"cjs60fpvt003e34cw8ebwou69"},{"name":"树链剖分","_id":"cjs60fpvt003h34cwgbuxqoru"},{"name":"LCT","_id":"cjs60fpvu003k34cwxyirb7ql"},{"name":"珂朵莉树","_id":"cjs60fpwd003q34cwwglpdapy"},{"name":"线段树","_id":"cjs60fpwg003x34cw86koj7xy"},{"name":"树套树","_id":"cjs60fpwk004234cwxhmyyq4w"},{"name":"FFT","_id":"cjs60fpwk004734cwdjhnt2on"},{"name":"题目组","_id":"cjs60fpwl004c34cw1zh1v1tp"},{"name":"毒瘤题","_id":"cjs60fpwm004f34cw0bl1zriy"},{"name":"Splay","_id":"cjs60fpwm004g34cwdhzczzw8"},{"name":"min_25筛","_id":"cjs60fpwm004j34cwnkaheadr"},{"name":"杜教筛","_id":"cjs60fpxm004q34cwqlntrt5h"},{"name":"类欧几里得","_id":"cjs60fpxo004w34cwy2apq6zq"}]}}