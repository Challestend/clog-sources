{"meta":{"title":"Chromium","subtitle":null,"description":"A juruo OIer from SD province.","author":"Challestend Rehtorbegnaro","url":"https://github.com/Challestend","root":"/"},"pages":[{"title":"","date":"2019-03-25T11:06:01.295Z","updated":"2019-03-25T11:06:01.295Z","comments":false,"path":"404.html","permalink":"https://github.com/Challestend/404.html","excerpt":"","text":"您可能访问了错误的网址 回到博客主页"},{"title":"关于","date":"2019-03-25T11:06:01.310Z","updated":"2019-03-25T11:06:01.310Z","comments":true,"path":"about/index.html","permalink":"https://github.com/Challestend/about/index.html","excerpt":"","text":"A juruo OIer from SD province. Studying in SLYZ. Find me on Luogu LibreOJ UniversalOJ NowCoder 51nod CodeForces GitHub"},{"title":"分类","date":"2019-03-25T11:06:01.310Z","updated":"2019-03-25T11:06:01.310Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/Challestend/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-25T11:06:01.310Z","updated":"2019-03-25T11:06:01.310Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/Challestend/tags/index.html","excerpt":"","text":""},{"title":"更新日志","date":"2019-04-10T09:12:47.796Z","updated":"2019-04-10T09:12:47.796Z","comments":true,"path":"log/index.html","permalink":"https://github.com/Challestend/log/index.html","excerpt":"","text":"直角，这是这篇blog的更新日志。 不过我不是一个考虑周全的人，之前9月份搭起博客时，我并没有考虑到这些。因而，之前的很多更新的具体时间已经无从知晓。 2018-09-27 建站。 （略） 2018-12-13 令theme-next-pace的加载进度条的颜色温和了一点。 将hexo-symbols-count-time的字数和时间统计替换成了精确数值。 减少了侧边栏和网易云外链的宽度。 2018-12-14 修复了在404页面点击「回到博客主页」会打开新标签页的问题。 2018-12-19 将字体改为了Arima Madurai。 2018-12-28 新增了访客计数。 2019-01-07 不知道什么时候字体炸了，然后xjb捣鼓了一波终于修好了。 2019-01-08 然后一大早发现它又炸了。告辞。不修了。然后传上去发现又好了。 2019-01-16 新增了代码折叠。 新增了SnoWY的blog。 更新了asuldb的blog地址。 字体又炸了。 2019-03-06 新增了ctz的blog。 点击鼠标时加入了一些奇怪的特效。 2019-03-16 把之前那些奇怪的特效删了，然后加入了一些更奇怪的。 换了个歌单。 2019-03-17 把歌单扔了。 blog的名字改成了Chromium（就是铬）。 开始更新潮语。 2019-03-18 因为Valine评论的用户名可以随便改，甚至可以用别人的名字评论，迫于机房惨案势力，换成了Gitalk评论。 虽然忘了说，不过代码折叠没了。 2019-03-29 真的不更潮语了。 To Be Continued"}],"posts":[{"title":"论一条咸鱼如何瞎搞「WC2015」未来程序","slug":"luogu-p4920-solving-notes","date":"2019-04-27T05:56:43.000Z","updated":"2019-04-27T11:14:20.482Z","comments":true,"path":"luogu-p4920-solving-notes/","link":"","permalink":"https://github.com/Challestend/luogu-p4920-solving-notes/","excerpt":"传送门 说不定还会持续更新？（","text":"传送门 说不定还会持续更新？（ 2019-04-26闲得没事翻到这道题了想试一试。 首先看到测试点1。 很明显的一个$a\\times b\\operatorname{mod}c$。 啊什么爆unsigned long long？Python了解一下（ 然后去看测试点2。 差不多能总结出这么一个规律来 a_{0}=1\\;\\;\\;\\;b_{0}=0\\;\\;\\;\\;c_{0}=0a_{n}=a_{n-1}+2b_{n-1}+c_{n-1}\\;\\;\\;\\;b_{n}=a_{n-1}+b_{n-1}\\;\\;\\;\\;c_{n}=a_{n-1}\\text{Ans}=a_{n}-2b_{n}+c_{n}然后手动打表 $n$ $a_{n}$ $b_{n}$ $c_{n}$ $0$ $1$ $0$ $0$ $1$ $1$ $1$ $1$ $2$ $4$ $2$ $1$ $3$ $9$ $6$ $4$ $4$ $25$ $15$ $9$ $5$ $64$ $40$ $25$ 然后发现$a_{n}=F_{n+1}^{2}$，于是推出$b_{n}=\\sum_{i=0}^{n}F_{i}^{2}$，$c_{n}=F_{n}^{2}$。 有一个结论是$\\sum_{i=0}^{n}F_{i}^{2}=F_{n}F_{n+1}$，证明也不难。于是就这样xjb写了个矩乘。 然后去看测试点3。 自然数$k$次方和，恩没难……等等四次方和是啥（ https://www.zybang.com/question/cd5fa7b364c5ac9f3194eac2525ae6aa.html 光速逃（ 然后去看测试点4。 如果把1看成黑点，0看成白点，type=0就是在遍历所有黑点对，直接一个$\\text{cnt}(\\text{cnt}-1)$解决。 type=1就是对于每个黑点，求出其到所有白点的曼哈顿距离的最小值，再求和。 不难想到枚举这个最小值，虽然复杂度很假但是数据随机啊（ 然后去看测试点5。 很明显的仅包含黑点的矩形的计数……等等，这不就是半个与或和吗（ 然后我就突然回想起来了，那道题WA成0分的记忆。 先把前4个点交上去看看吧。然后10+1+10+6=27。 诶我测试点4怎么6分啊……一看发现type=0写成了$\\cfrac{1}{2}\\text{cnt}(\\text{cnt}-1)$…… 关于测试点2……先放一放。 然后去看测试点6。 感觉不怎么会光速弃疗。 然后去看测试点7。 经过一番分析，我发现这是在求给定数独字典序最小的解，然后第$i$组数据输出前$i$行？（并不是） 打了个爆搜然后跑到死也只跑出来前三组。 哦不我连搜索都不会写了，我失败了:( 然后去看测试点8。 大致可以抽象成是给你7个点，每个点权值$w_{i}\\in[1,n]\\cap\\mathbb{N}$，再给你一些边，对于一条边$(x,y)$，必须要有$w_{x}\\lt w_{y}$，求方案数。 第1问给了一条链，很明显方案数就是$C_{n}^{7}$。 看到后9问好像十分麻烦，先跳过吧。 然后去看测试点9。 一上来一坨字符画一样的东西差点吓到我。 从VSCode右边的缩略图里能够很明显看出是一个人。 在仔细阅读了代码之后，我发现这是10道解答题。 然后……诶好像差不多该溜了。 2019-04-27一大早上被比我不知道强到哪里去了的asuldb安利了一道看上去很吓人的题。 继续来搞这道提答。 答上了测试点9的前两问，然后去看测试点10……？？！！ 这是什么鬼东西怎么这么一大坨子函数…… 一开始没看源文件大小，后来一看发现竟然有1000+KB。 吓得我电脑都卡了。 发现本质上是让求_()这个函数的调用次数。于是我就让这个函数返回1，其他函数返回它调用的所有函数的返回值之和。 然后……算是勉强凑出来前3问，5行左右。 一交……诶我后两个点怎么还RE了？ 不会是我没交4和5的.out文件吧……然后发现还真是，补上去两个空文件之后评测结果正常了，10+1+10+10+0+0+0+1+2+5=39。 然后发现测试点7实际上是将整个数独压成一行复读$i$遍。（好像也不是） 6，8，9，10四个点挣扎了一会还是弃疗了。 回去看测试点5……想到反正数据随机，写了一个稍微优化了一点的暴力。 然后改了改测试点2。一交发现什么变化都没有。 luogu又出锅了？这么想着又交了一遍，然后还是什么变化都没有。 // 以上内容差不多是以回忆的形式写下来的。接下来差不多是边调题边写（ 然后发现我测试点5的二维前缀和写错了（ 仔细一推测试点2发现 \\begin{aligned} \\text{Ans}&=F_{n+1}^{2}-2\\sum_{i=0}^{n}F_{i}^{2}+F_{n}^{2}\\\\ &=F_{n+1}^{2}-2F_{n+1}F_{n}+F_{n}^{2}\\\\ &=F_{n-1}^{2} \\end{aligned}但是就算这样也不应该WA啊……写了个暴力发现是因为偷懒矩阵没清空…… 然后再一交，10+10+10+10+10+0+0+1+2+5=58。 然后我突然有了一个想法，对于测试点10，我可以直接用一个std::map维护出源文件中的所有函数的值啊。 写了写一交……诶怎么还少了4分？ 一检查发现只是计算了调用次数，忘了再乘以那个___。 于是再一交，10+10+10+10+10+0+0+1+2+10=63。 回去看了看测试点7，感觉没救了，于是想搞一搞测试点9。 看到第4问的答案只有3个字符，直接搜于是搜出来一个$_$。 再像这样搜了一下第5问发现是we。 考虑到后面都是英文单词了于是把枚举的范围压缩到了a~z。 然后搜出了第6问是hold，第7问是these。 然后上百度一查发现这句话是we hold these truths to be self-evident。 那么还剩第3问那个人名……这种问题无解吧，尤其是对于我这种咸鱼来说。 于是一交，10+10+10+10+10+0+0+1+9+10=70。 简单推了一下测试点7，发现指数非常有规律，于是把系数扔到OEIS搜了一波。 虽然是找到了，但是公式也没有生成函数也没有什么也没有。 下面还给我来一行approved（ 弃疗。告辞。","categories":[{"name":"瞎搞","slug":"瞎搞","permalink":"https://github.com/Challestend/categories/瞎搞/"}],"tags":[{"name":"提交答案","slug":"提交答案","permalink":"https://github.com/Challestend/tags/提交答案/"}]},{"title":"「Luogu-P5178」公约数","slug":"luogu-p5176-solution","date":"2019-04-27T05:11:37.000Z","updated":"2019-04-27T05:57:22.854Z","comments":true,"path":"luogu-p5176-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p5176-solution/","excerpt":"传送门","text":"传送门 首先我们看到要求的这个式子……这什么鬼啊能做吗（ 冷静分析一波，我们可以根据括号里的两个加号将原式拆分成三个三重$\\sum$ \\begin{aligned} &\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k=1}^{p}(ij,ik,jk)\\cdot(i,j,k)\\cdot\\cfrac{(i,j)}{(i,k)\\cdot(j,k)}\\\\ +&\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k=1}^{p}(ij,ik,jk)\\cdot(i,j,k)\\cdot\\cfrac{(i,k)}{(i,j)\\cdot(j,k)}\\\\ +&\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k=1}^{p}(ij,ik,jk)\\cdot(i,j,k)\\cdot\\cfrac{(j,k)}{(i,j)\\cdot(i,k)} \\end{aligned}首先我们单独考虑第一个 \\begin{aligned} &\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k=1}^{p}(ij,ik,jk)\\cdot(i,j,k)\\cdot\\cfrac{(i,j)}{(i,k)\\cdot(j,k)}\\\\ =&\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k=1}^{p}(ij,(i,j)k)\\cdot((i,j),k)\\cdot\\cfrac{(i,j)}{(i,k)\\cdot(j,k)}\\\\ =&\\sum_{d=1}^{\\min(n,m)}\\sum_{x=1}^{\\lfloor\\tfrac{n}{d}\\rfloor}\\sum_{y=1}^{\\lfloor\\tfrac{m}{d}\\rfloor}[x\\perp y]\\sum_{k=1}^{p}(d^{2}xy,dk)\\cdot(d,k)\\cdot\\cfrac{d}{(dx,k)\\cdot(dy,k)}\\\\ =&\\sum_{d=1}^{\\min(n,m)}\\sum_{x=1}^{\\lfloor\\tfrac{n}{d}\\rfloor}\\sum_{y=1}^{\\lfloor\\tfrac{m}{d}\\rfloor}[x\\perp y]\\sum_{k=1}^{p}d^{2}\\cdot(d,k)\\cdot\\cfrac{(dxy,k)}{(dx,k)\\cdot(dy,k)}\\\\ \\end{aligned}考虑将$d,x,y,k$写成唯一分解形式，然后对于第$i$小的质数$c_{i}$，它在四个数中的指数分别是$r_{d,i},r_{x,i},r_{y,i},r_{k,i}$，那么 \\begin{aligned} =&\\sum_{d=1}^{\\min(n,m)}\\sum_{x=1}^{\\lfloor\\tfrac{n}{d}\\rfloor}\\sum_{y=1}^{\\lfloor\\tfrac{m}{d}\\rfloor}[x\\perp y]\\sum_{k=1}^{p}d^{2}\\prod_{i=1}c_{i}^{\\min(r_{d,i},r_{k,i})+\\min(r_{d,i}+r_{x,i}+r_{y,i},r_{k,i})-\\min(r_{d,i}+r_{x,i},r_{k,i})-\\min(r_{d,i}+r_{y,i},r_{k,i})} \\end{aligned}因为$x\\perp y$，$r_{x,i}$和$r_{y,i}$中必定有一个为$0$，带入整理后我们得到 \\begin{aligned} =&\\sum_{d=1}^{\\min(n,m)}\\sum_{x=1}^{\\lfloor\\tfrac{n}{d}\\rfloor}\\sum_{y=1}^{\\lfloor\\tfrac{m}{d}\\rfloor}[x\\perp y]\\sum_{k=1}^{p}d^{2}\\\\ =&p\\sum_{i=1}^{n}\\sum_{j=1}^{m}(i,j)^{2} \\end{aligned}对剩下的两个三重$\\sum$也进行类似的化简，最后我们得到答案就是 p\\sum_{i=1}^{n}\\sum_{j=1}^{m}(i,j)^{2}+m\\sum_{i=1}^{n}\\sum_{j=1}^{p}(i,j)^{2}+n\\sum_{i=1}^{m}\\sum_{j=1}^{p}(i,j)^{2}","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"}]},{"title":"「JSOI2015」染色问题","slug":"bzoj4487-solution","date":"2019-04-26T10:27:53.000Z","updated":"2019-04-26T10:53:10.384Z","comments":true,"path":"bzoj4487-solution/","link":"","permalink":"https://github.com/Challestend/bzoj4487-solution/","excerpt":"传送门 sto asuldb orz","text":"传送门 sto asuldb orz 我们平时遇到的一维容斥大概长这样 F_{i}=\\sum_{x=i}^{n}C_{x}^{i}G_{x}\\Leftrightarrow G_{i}=\\sum_{x=i}^{n}(-1)^{x-i}C_{x}^{i}F_{x}如果说遇到高维容斥，我们只需要一维一维地解决掉即可。 但实际上，我们是可以总结出一个$k$维容斥的式子的 F_{i_{1},i_{2},\\cdots,i_{k}}=\\sum_{x_{1}=i_{1}}^{n_{1}}\\sum_{x_{2}=i_{2}}^{n_{2}}\\cdots\\sum_{x_{k}=i_{k}}^{n_{k}}\\left(\\prod_{j=1}^{k}C_{x_{j}}^{i_{j}}\\right)G_{x_{1},x_{2},\\cdots,x_{k}}\\Leftrightarrow G_{i_{1},i_{2},\\cdots,i_{k}}=\\sum_{x_{1}=i_{1}}^{n_{1}}\\sum_{x_{2}=i_{2}}^{n_{2}}\\cdots\\sum_{x_{k}=i_{k}}^{n_{k}}\\left(\\prod_{j=1}^{k}(-1)^{x_{j}-i_{j}}C_{x_{j}}^{i_{j}}\\right)F_{x_{1},x_{2},\\cdots,x_{k}}没错，这道题就是一个三维容斥的大板子。 我们令至少$i$行$j$列为空，至少$k$种颜色未出现的方案数为$F_{i,j,k}$，我们有 F_{i,j,k}=C_{n}^{i}C_{m}^{j}C_{c}^{k}(c-k+1)^{(n-i)(m-j)}话又说回来了这个东西应该是会算重啊（ 恰有$i$行$j$列为空，恰有$k$种颜色未出现的方案数为$G_{i,j,k}$，自然 F_{i,j,k}=\\sum_{x=i}^{n}\\sum_{y=j}^{m}\\sum_{z=k}^{c}C_{x}^{i}C_{y}^{j}C_{z}^{k}G_{x,y,z}\\begin{aligned} G_{i,j,k}&=\\sum_{x=i}^{n}\\sum_{y=j}^{m}\\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{x}^{i}C_{y}^{j}C_{z}^{k}F_{x,y,z}\\\\ &=\\sum_{x=i}^{n}\\sum_{y=j}^{m}\\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{x}^{i}C_{y}^{j}C_{z}^{k}C_{n}^{x}C_{m}^{y}C_{c}^{z}(c-z+1)^{(n-x)(m-y)}\\\\ &=C_{n}^{i}C_{m}^{j}C_{c}^{k}\\sum_{x=i}^{n}\\sum_{y=j}^{m}\\sum_{z=k}^{c}(-1)^{x-i+y-j+z-k}C_{n-i}^{x-i}C_{m-j}^{y-j}C_{c-k}^{z-k}(c-z+1)^{(n-x)(m-y)}\\\\ &=C_{n}^{i}C_{m}^{j}C_{c}^{k}\\sum_{x=0}^{n-i}\\sum_{y=0}^{m-j}\\sum_{z=0}^{c-k}(-1)^{x+y+z}C_{n-i}^{x}C_{m-j}^{y}C_{c-k}^{z}(c-k-z+1)^{(n-i-x)(m-j-y)}\\ \\end{aligned}我们要求的答案就是$G_{0,0,0}$，简单整理一下就是 \\sum_{x=0}^{n}\\sum_{y=0}^{m}\\sum_{z=0}^{c}(-1)^{x+y+z}C_{n}^{x}C_{m}^{y}C_{c}^{z}(c-z+1)^{(n-x)(m-y)}然后你问我为什么要写一篇blog？闲得没事干（ 代码瞎写的就不贴了（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"容斥","slug":"容斥","permalink":"https://github.com/Challestend/tags/容斥/"}]},{"title":"「NOI2016」循环之美","slug":"luogu-p1587-solution","date":"2019-04-14T09:16:32.000Z","updated":"2019-04-14T13:02:53.765Z","comments":true,"path":"luogu-p1587-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p1587-solution/","excerpt":"突然被wzx安利的一道题。 传送门 wzx的题解","text":"突然被wzx安利的一道题。 传送门 wzx的题解 通过查阅fuge的题解，我们发现我们要求的式子是 \\sum_{i=1}^{n}\\sum_{j=1}^{m}[i\\perp j][j\\perp k]$[i\\perp j]$保证了这是一个最简分数从而不会算重，$[j\\perp k]$保证了这是一个纯循环小数。 首先关于$[1,n]$中与某个常数$k$互质的数的数量，我们有一个结论 \\sum_{i=1}^{n}[i\\perp k]=\\sum_{i=1}^{n}\\sum_{x|i,x|k}\\mu(x)=\\sum_{x|k}\\lfloor\\cfrac{n}{x}\\rfloor\\mu(x)然后大力整理 \\begin{aligned} \\sum_{i=1}^{n}\\sum_{j=1}^{m}[i\\perp j][j\\perp k]&=\\sum_{j=1}^{m}[j\\perp k]\\sum_{i=1}^{n}[i\\perp j]\\\\ &=\\sum_{j=1}^{m}[j\\perp k]\\sum_{x|j}\\lfloor\\cfrac{n}{x}\\rfloor\\mu(x)\\\\ &=\\sum_{x=1}^{m}\\lfloor\\cfrac{n}{x}\\rfloor\\mu(x)\\sum_{x|j}[j\\perp k]\\\\ &=\\sum_{x=1}^{m}\\lfloor\\cfrac{n}{x}\\rfloor\\mu(x)\\sum_{j=1}^{\\tfrac{m}{x}}[jx\\perp k]\\\\ &=\\sum_{x=1}^{m}[x\\perp k]\\lfloor\\cfrac{n}{x}\\rfloor\\mu(x)\\sum_{j=1}^{\\tfrac{m}{x}}[j\\perp k]\\\\ &=\\sum_{x=1}^{m}[x\\perp k]\\lfloor\\cfrac{n}{x}\\rfloor\\mu(x)\\sum_{y|k}\\lfloor\\cfrac{m}{xy}\\rfloor\\mu(y) \\end{aligned}这道题有一个突破口在于，$k$的范围很小，只有$2000$，从而$d(k)$的范围会更小，这就使得我们能够暴力枚举$k$的约数来计算第二个$\\sum$。 观察第一个$\\sum$，我们发现，套上一层整除分块之后，我们需要计算的是 \\sum_{i=1}^{n}f(i)其中 f(n)=[n\\perp k]\\mu(n)考虑杜教筛，我们再找来一个函数 g(n)=[n\\perp k]把它们卷积 \\begin{aligned} (f\\times g)(n)&=\\sum_{d|n}f(d)g(\\cfrac{n}{d})\\\\ &=\\sum_{d|n}[d\\perp k][\\cfrac{n}{d}\\perp k]\\mu(d)\\\\ &=[n\\perp k]\\sum_{d|n}\\mu(d)\\\\ &=\\epsilon(n) \\end{aligned}然后就差不多了。 不过有一个问题，像这种对$n$和$m$同时整除分块的情况，不能用类似min_25的trick（$N\\leqslant\\sqrt{n}$时存到ans1[N]，否则存到ans2[n/N]），只能通过unordered_map或者Hash来记忆化。 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include&lt;cstdio&gt;#include&lt;tr1/unordered_map&gt;#define re register#define maxn 1000000#define min(a,b) ((a)&lt;=(b)?(a):(b))namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m,k;int d[50],f[maxn+1],g[maxn+1],mu[maxn+1],F[maxn+1];std::tr1::unordered_map&lt;int,long long&gt; ans;long long T(re int x)&#123; re long long res=0; for(re int i=1;i&lt;=d[0];++i) res+=1LL*(x/d[i])*mu[d[i]]; return res;&#125;long long S(re int N)&#123; if(N&lt;=maxn) return F[N]; if(ans.count(N)) return ans[N]; re long long res=1,lst=T(1); for(re int l=2,r;l&lt;=N;l=r+1)&#123; r=N/(N/l); re long long tmp=T(r); res-=S(N/l)*(tmp-lst); lst=tmp; &#125; return ans[N]=res;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); cltstream::read(k); for(re int i=1;i&lt;=k;++i) if(k%i==0) d[++d[0]]=i; mu[1]=F[1]=1; for(re int i=2;i&lt;=maxn;++i)&#123; if(!f[i])&#123; g[++g[0]]=i; mu[i]=-1; F[i]=-(k%i!=0); &#125; for(re int j=1;j&lt;=g[0]&amp;&amp;i*g[j]&lt;=maxn;++j)&#123; f[i*g[j]]=1; if(i%g[j])&#123; mu[i*g[j]]=mu[i]*mu[g[j]]; F[i*g[j]]=F[i]*F[g[j]]; &#125; else break; &#125; &#125; for(re int i=1;i&lt;=maxn;++i) F[i]+=F[i-1]; re long long res=0,lst=0; for(re int l=1,r;l&lt;=n&amp;&amp;l&lt;=m;l=r+1)&#123; r=min(n/(n/l),m/(m/l)); re long long tmp=S(r); res+=(n/l)*T(m/l)*(tmp-lst); lst=tmp; &#125; cltstream::write(res); clop(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"}]},{"title":"FWT抄袭笔记","slug":"fwt-learning-notes","date":"2019-04-11T02:28:42.000Z","updated":"2019-04-12T09:53:06.228Z","comments":true,"path":"fwt-learning-notes/","link":"","permalink":"https://github.com/Challestend/fwt-learning-notes/","excerpt":"看到坐在我左边的dalao在学FWT。 想着二轮前学一些很酷很炫很失败的算法，于是来背一下学一下吧。 抄袭来源。","text":"看到坐在我左边的dalao在学FWT。 想着二轮前学一些很酷很炫很失败的算法，于是来背一下学一下吧。 抄袭来源。 引入我们利用FFT可以在$O(n\\log n)$的时间复杂度内计算 H[k]=(F\\times G)[k]=\\sum_{i+j=k}F[i]G[j]假如说我们把这个式子变一变 H[k]=(F\\vee G)[k]=\\sum_{i\\vee j=k}F[i]G[j]H[k]=(F\\wedge G)[k]=\\sum_{i\\wedge j=k}F[i]G[j]H[k]=(F\\oplus G)[k]=\\sum_{i\\oplus j=k}F[i]G[j]其中$\\vee$指按位或，$\\wedge$指按位与，$\\oplus$指按位异或。 我们还是希望能够在$O(n\\log n)$的时间复杂度内计算出答案。 这种时候我们就需要FWT（快速沃尔什变换，Fast Walsh–Hadamard Transformation）了。 在FFT中，我们先计算出了$F$和$G$的点值多项式，然后将对应位直接相乘得到了$F\\times G$的点值多项式，最后还原回了$F\\times G$。 类似地，我们可不可以试着计算出两个多项式$F^{\\prime},G^{\\prime}$，使得 (F\\times G)^{\\prime}=F^{\\prime}\\cdot G^{\\prime}当然可以啊不然还怎么会有FWT（ 一些约定对于两个向量$A$和$B$，我们令 (A,B)=(A[0],A[1],\\cdots,B[0],B[1],\\cdots)设$F$的项数为$2^{t}$。为了方便，我们将其看做一个$2^{t}$维向量 (F[0],F[1],\\cdots,F[2^{t}-1])然后我们定义 F_{0}=(F[0],F[1],\\cdots,F[2^{t-1}-1])F_{1}=(F[2^{t-1}],F[2^{t-1}+1],\\cdots,F[2^{t}-1])正变换按位或定义 F^{\\prime}=\\begin{cases} &(F_{0}^{\\prime},F_{1}^{\\prime}+F_{0}^{\\prime})\\;\\;\\;\\;\\;\\;\\;\\;&(t\\gt 0)\\\\ &F&(t=0) \\end{cases}我们发现 F^{\\prime}[i]=\\sum_{j\\vee i=i}F[j]$t=0$时这十分显然，我们来考虑$t\\gt 0$时的情况。 首先很明显的一点是$j\\vee i=i\\Leftrightarrow j\\subseteq i$，也就是说$j$是$i$的子集。 对于$F_{1}$中的一个下标$i$，我们在$F_{1}$左边接上$F_{0}$后，这个$i$就多了一个$2^{t-1}$。 之前$i$的每一个子集$j$，也同样多了一个$2^{t-1}$，它们产生的贡献已经被统计在了$F_{1}^{\\prime}[i]$内。 那么去掉这个$2^{t-1}$，我们还有$j\\subseteq i+2^{t-1}$，这部分其实就是$F_{0}^{\\prime}[i]$的值。 据此，我们就有 \\begin{aligned} F^{\\prime}\\cdot G^{\\prime}[i]&=\\left(\\sum_{j\\subseteq i}F[j]\\right)\\left(\\sum_{k\\subseteq i}G[k]\\right)\\\\ &=\\sum_{j\\vee k\\subseteq i}F[j]G[k]\\\\ &=\\sum_{l\\subseteq i}\\sum_{j\\vee k=l}F[j]G[k]\\\\ &=\\sum_{l\\subseteq i}(F\\vee G)[l]\\\\ &=(F\\vee G)^{\\prime}[i] \\end{aligned}按位与定义 F^{\\prime}=\\begin{cases} &(F_{0}^{\\prime}+F_{1}^{\\prime},F_{1}^{\\prime})\\;\\;\\;\\;\\;\\;\\;\\;&(t\\gt 0)\\\\ &F&(t=0) \\end{cases}它具有类似的性质 F^{\\prime}[i]=\\sum_{j\\wedge i=i}F[j](F\\wedge G)^{\\prime}=F^{\\prime}\\cdot G^{\\prime}证明略。 按位异或定义 F^{\\prime}=\\begin{cases} &(F_{0}^{\\prime}+F_{1}^{\\prime},F_{0}^{\\prime}-F_{1}^{\\prime})\\;\\;\\;\\;\\;\\;\\;\\;&(t\\gt 0)\\\\ &F&(t=0) \\end{cases}然后我们发现按位异或并没有像上面一样的和子集相关的性质。因此我们需要通过一些其他方式来证明它的正确性。 首先 (F+G)^{\\prime}=F^{\\prime}+G^{\\prime}如果$F$和$G$都只有一项，这十分显然。 否则 \\begin{aligned} F^{\\prime}+G^{\\prime}&=(F_{0}^{\\prime}+F_{1}^{\\prime},F_{0}^{\\prime}-F_{1}^{\\prime})+(G_{0}^{\\prime}+G_{1}^{\\prime},G_{0}^{\\prime}-G_{1}^{\\prime})\\\\ &=(F_{0}^{\\prime}+G_{0}^{\\prime}+F_{1}^{\\prime}+G_{1}^{\\prime},F_{0}^{\\prime}+G_{0}^{\\prime}-F_{1}^{\\prime}-G_{1}^{\\prime})\\\\ &=((F+G)_{0}^{\\prime}+(F+G)_{1}^{\\prime},(F+G)_{0}^{\\prime}-(F+G)_{1}^{\\prime})\\\\ &=(F+G)^{\\prime} \\end{aligned}(F\\oplus G)^{\\prime}=F^{\\prime}\\cdot G^{\\prime}这个不会证，告辞。 逆变换就是把刚刚算出来的$F^{\\prime}$变回$F$。 F=\\begin{cases} &F^{\\prime}&(t=0)\\\\ &\\begin{cases} &(F_{0},F_{1}-F_{0})&(\\vee)\\\\ &(F_{0}-F_{1},F_{1})&(\\wedge)\\\\ &(\\cfrac{F_{0}+F_{1}}{2},\\cfrac{F_{0}-F_{1}}{2})\\;\\;\\;\\;\\;\\;\\;\\;&(\\oplus) \\end{cases}\\;\\;\\;\\;\\;\\;\\;\\;&(t\\gt 0) \\end{cases}啥意思啊看不懂啊（ 然后您就可以切掉这道板子题了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;cstdio&gt;#define re register#define maxn 17#define mod 998244353namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n;int F[1&lt;&lt;maxn][3],G[1&lt;&lt;maxn][3];#define FWT(F,tp) &#123;\\ for(re int p=1;p&lt;n;p&lt;&lt;=1)\\ for(re int i=0;i&lt;n;i+=p&lt;&lt;1)\\ for(re int j=i;j&lt;i+p;++j)&#123;\\ F[j+p][0]=!tp?(F[j+p][0]+F[j][0])%mod:(F[j+p][0]-F[j][0]+mod)%mod;\\ F[j][1]=!tp?(F[j][1]+F[j+p][1])%mod:(F[j][1]-F[j+p][1]+mod)%mod;\\ re int x=F[j][2],y=F[j+p][2];\\ F[j][2]=(x+y)%mod;\\ F[j+p][2]=(x-y+mod)%mod;\\ if(tp)&#123;\\ F[j][2]=499122177LL*F[j][2]%mod;\\ F[j+p][2]=499122177LL*F[j+p][2]%mod;\\ &#125;\\ &#125;\\&#125;int main()&#123; cltstream::read(n); n=1&lt;&lt;n; for(re int i=0;i&lt;n;++i)&#123; cltstream::read(F[i][0]); F[i][1]=F[i][2]=F[i][0]; &#125; for(re int i=0;i&lt;n;++i)&#123; cltstream::read(G[i][0]); G[i][1]=G[i][2]=G[i][0]; &#125; FWT(F,0); FWT(G,0); for(re int j=0;j&lt;3;++j) for(re int i=0;i&lt;n;++i) F[i][j]=1LL*F[i][j]*G[i][j]%mod; FWT(F,1); for(re int j=0;j&lt;3;++j) for(re int i=0;i&lt;n;++i) cltstream::write(F[i][j],i&lt;n-1?32:10); clop(); return 0;&#125; 单位元我们知道FFT中的单位元多项式是$F(x)=1$，类似地，FWT是否也拥有这样的一个单位元呢？ 当然是有的。 对于按位或和按位异或来说，它们的单位元是 (1,0,\\cdots,0,0)对于按位与来说，它的单位元是 (0,0,\\cdots,0,1)求逆既然有了单位元，我们就不禁会想……这东西能求逆吗？ 大概……能吧。 以下所有运算在模$998244353$意义下进行。 按位或给定一个多项式$F$，让你求出一个多项式$G$，使得 F\\vee G=(1,0,\\cdots,0,0)首先我们需要知道 F\\vee G=(F_{0}\\vee G_{0},F_{0}\\vee G_{1}+F_{1}\\vee G_{0}+F_{1}\\vee G_{1})注意到左半部分和右半部分的下标有一个重要区别就是从右往左第$t$位是否为$1$。 如果某个下标和右半部分的某个下标进行了按位或，它的第$t$位一定是$1$，那么它就跑到右半部分去了。 否则，即两个左半部分的下标进行了按位或，这种情况结果还是在左半部分。 然后我们就可以往下推了 \\begin{aligned} F_{0}\\vee G_{1}+F_{1}\\vee G_{0}+F_{1}\\vee G_{1}&=0\\\\ (F_{0}+F_{1})\\vee G_{1}&=-F_{1}\\vee G_{0}\\\\ G_{1}&=-F_{1}\\vee G_{0}\\vee (F_{0}+F_{1})^{-1} \\end{aligned}边界条件$G[0]=F[0]^{-1}$。 大致代码如下 123456789101112131415161718192021void Inv(re int* F,re int* G,re int n)&#123; if(n==1) G[0]=cltpow(F[0],mod-2); else&#123; int tmp1[1&lt;&lt;maxn],tmp2[1&lt;&lt;maxn]; Inv(F,G,n&gt;&gt;1); for(re int i=0;i&lt;(n&gt;&gt;1);++i) tmp1[i]=F[i]+F[(n&gt;&gt;1)+i]; Inv(tmp1,tmp2,n&gt;&gt;1); FWT(F+(n&gt;&gt;1),n&gt;&gt;1,0); FWT(G,n&gt;&gt;1,0); FWT(tmp2,n&gt;&gt;1,0); for(re int i=0;i&lt;(n&gt;&gt;1);++i) tmp2[i]=1LL*F[(n&gt;&gt;1)+i]*G[i]%mod*tmp2[i]%mod; FWT(F+(n&gt;&gt;1),n&gt;&gt;1,1); FWT(G,n&gt;&gt;1,1); FWT(tmp2,n&gt;&gt;1,1); for(re int i=0;i&lt;(n&gt;&gt;1);++i) G[(n&gt;&gt;1)+i]=(mod-tmp2[i])%mod; &#125;&#125; 时间复杂度非常显然是$O(n^{2}2^{n})$。 按位与给定一个多项式$F$，让你求出一个多项式$G$，使得 F\\wedge G=(0,0,\\cdots,0,1)我们可以用类似的过程得到如下结论 F\\wedge G=(F_{0}\\wedge G_{0}+F_{0}\\wedge G_{1}+F_{1}\\wedge G_{0},F_{1}\\wedge G_{1})G_{0}=-F_{0}\\wedge G_{1}\\wedge (F_{0}+F_{1})^{-1}按位异或给定一个多项式$F$，让你求出一个多项式$G$，使得 F\\oplus G=(1,0,\\cdots,0,0)首先我们有 F\\oplus G=(F_{0}\\oplus G_{0}+F_{1}\\oplus G_{1},F_{0}\\oplus G_{1}+F_{1}\\oplus G_{0})也就是说 F_{0}\\oplus G_{0}+F_{1}\\oplus G_{1}=\\epsilonF_{0}\\oplus G_{1}+F_{1}\\oplus G_{0}=0将上面两个式子相加、相减，得到 (F_{0}+F_{1})\\oplus(G_{0}+G_{1})=\\epsilon(F_{0}-F_{1})\\oplus(G_{0}-G_{1})=\\epsilon于是 G_{0}=\\cfrac{(F_{0}+F_{1})^{-1}+(F_{0}-F_{1})^{-1}}{2}G_{1}=\\cfrac{(F_{0}+F_{1})^{-1}-(F_{0}-F_{1})^{-1}}{2}时间复杂度$O(n2^{n})$。 这就没了？并不是。 如果您按照上面的式子写好程序，然后往里面输入 1221 2 3 4 这样一组数据，您会发现您的程序给出的结果并不正确。 那么原因是什么呢？是我们式子推错了吗？ 输出一下中间的运算过程，我们发现，在中间有一步，我们计算$(2,2)^{-1}$时，需要用到$(0)^{-1}$。 显然它不存在，但是同样显然的是，如果$(2,2)^{-1}$存在，那么这个过程不应该出现这样的问题。 所以说原因就是，$(2,2)^{-1}$，或者更进一步地，$(1,2,3,4)^{-1}$不存在。 子集卷积让我来看看有没有点进去看完题面一脸懵逼地关闭标签页的。 这道题是让我们求这个东西 h_{R}=\\sum_{S\\vee T=R,S\\wedge T=\\varnothing}f_{S}g_{T}这比我们之前看到的卷积拥有更加严格的要求，$S\\wedge T=\\varnothing$，很明显，这是在提示我们抄题解。 我们定义 F_{i,S}=\\begin{cases} &f_{S}\\;\\;\\;\\;\\;\\;\\;\\;&(|S|=i)\\\\ &0&(|S|\\neq i) \\end{cases}G_{i,S}=\\begin{cases} &g_{S}\\;\\;\\;\\;\\;\\;\\;\\;&(|S|=i)\\\\ &0&(|S|\\neq i) \\end{cases}H_{i,S}=\\begin{cases} &h_{S}\\;\\;\\;\\;\\;\\;\\;\\;&(|S|=i)\\\\ &0&(|S|\\neq i) \\end{cases}然后我们从小到大枚举$i$，计算 H_{i}=\\sum_{j=0}^{i}F_{j}\\vee G_{i-j}为了理解这个式子，我们先将其展开 H_{i,R}=\\sum_{j=0}^{i}\\sum_{S\\vee T=R}F_{j,S}G_{i-j,T}根据定义，$F_{i,S}$和$G_{i,S}$有值当且仅当$|S|=i$，因此这就相当于 H_{i,R}=\\sum_{S\\vee T=R,|S|+|T|=i}F_{|S|,S}G_{|T|,T}因为$S$和$T$可能会有交集，从而$i\\gt |R|$时$H_{i,R}$也可能有值，这是不符合定义的，因此（如果有必要的话）我们需要手动清空。 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#define re register#define maxn 20#define mod 1000000009namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,N;int cnt[1&lt;&lt;maxn],F[maxn+1][1&lt;&lt;maxn],G[maxn+1][1&lt;&lt;maxn],H[maxn+1][1&lt;&lt;maxn];inline void FWT(re int* F,re int tp)&#123; for(re int p=1;p&lt;N;p&lt;&lt;=1) for(re int i=0;i&lt;N;i+=p&lt;&lt;1) for(re int j=i;j&lt;i+p;++j) F[j+p]=!tp?(F[j+p]+F[j])%mod:(F[j+p]-F[j]+mod)%mod;&#125;int main()&#123; cltstream::read(n); N=1&lt;&lt;n; for(re int i=1;i&lt;N;++i) cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); for(re int i=0;i&lt;N;++i) cltstream::read(F[cnt[i]][i]); for(re int i=0;i&lt;N;++i) cltstream::read(G[cnt[i]][i]); for(re int i=0;i&lt;=n;++i)&#123; FWT(F[i],0); FWT(G[i],0); for(re int j=0;j&lt;=i;++j) for(re int S=0;S&lt;N;++S) H[i][S]=(H[i][S]+1LL*F[j][S]*G[i-j][S]%mod)%mod; FWT(H[i],1); for(re int S=0;S&lt;N;++S) cnt[S]==i||(H[i][S]=0); &#125; for(re int i=0;i&lt;N;++i) cltstream::write(H[cnt[i]][i],32); clop(); return 0;&#125; 例题","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"FWT","slug":"FWT","permalink":"https://github.com/Challestend/tags/FWT/"}]},{"title":"「SDOI2019R1游记」僕らは泥を這いつくばるもの","slug":"sdoi2019r1-notes","date":"2019-04-09T00:31:53.000Z","updated":"2019-04-11T07:28:12.573Z","comments":true,"path":"sdoi2019r1-notes/","link":"","permalink":"https://github.com/Challestend/sdoi2019r1-notes/","excerpt":"被强大无比且随手吊打我的shzr催更了，于是诚惶诚恐赶来写这篇游记。","text":"被强大无比且随手吊打我的shzr催更了，于是诚惶诚恐赶来写这篇游记。 Day -X经过讨论，我们机房研究出了以下两个堪称完美的战术，若能施加实际行动，定能令SLYZ省选大获全胜： 让潮子分身，在每一位dalao（如rqy、ckw等）身边分别派一个，然后潮他们，他们就炸了。 让潮子在厕所蹲着，每看到有选手上厕所，等他上到一半跑到他背后，潮之曰「你稳了」，他就炸了。 这都什么鬼东西（ Day -2「省选快到了，我想回家休息休息。」 像这样理直气壮地请假回家颓废了。 Day 0下午12：30从学校坐车走，等到了济南已经是大概16：00了。 到了宾馆loli让我们自由组合。然后mhr学长主动邀请我住一个房间。 我直接就答应了。 晚上晚上出去吃饭的时候，潮子一直在潮。 就比如说钦定wzx的SAM没有了A，只剩下了一些奇怪的东西一道题都A不动了。 可惜绝大部分名言已经失传了。 这可真是糟糕，OI文学界的一大损失啊。 Day 1就算没有解压密码也是可以看压缩包内部的文件有哪些的。 然后就看到了T3有16个样例有点方。 解压密码直接一坨乱码。龙虾选手表示解压体验(?)极差。 T1诶怎么感觉有点像超级钢琴啊。 但是因为我超级钢琴只会ST表+堆，想了想发现这题不能这么做。 好吧，暴力60分先安排上。 出了考场发现人均A掉T1。 T2字符串（ 不难想到这么一个做法：对于这$n_{a}+n_{b}$个串每一个建一个点，如果$A$类串$x$支配$B$类串$y$，或者$B$类串$x$是$A$类串$y$的前缀，从$x$向$y$连边。最后整张图有环就是$-1$，没有D个P就出来了。 然后暴力建图。莫名其妙能有60分。 T3写作传统题读作提交答案题。 考场上只想出来了1_998244353的12分。 然后出考场被各路dalao吊打。 关于测试点8-16，一开始我的想法是给出两个数$x,y$，有一个长度为$x$的区间从左向右扫过$[1,y]$这个区间。 但实际上是$[x,y]$这个区间内每个数的性质。想到这一点后面的一些数据范围比较小的点就没啥问题了。 但是数据范围比较大的点怎么办？ 打一些比较小的表（ 标程70KB了一下。 下午首先是讲评。 没有抢到座位于是只能站着。 因为非常吵什么也听不清。 印象比较深的是讲到T3突然一阵掌声。 然后回到宾馆快乐地颓废。 晚上集体不想出去吃于是点了肯德基，然后……诶诶诶你们什么时候吃完的太快了吧（ Day 2T1看到题目名我还以为是网络流。 然后我就在想有没有网络流计数这种操作。 大概是没有吧。 打了个爆搜结果还炸了。 T2看上去好神仙啊。 考场上写了45分的状压枚举子集。 结果一出考场听说人均75，就我不会链的贪心和$O(n^{2})$的做法，自毙了。 T3想写一写$L=n$或$k=1$的情况。 到最后发现什么也不会，只想到了$L=n$且$k=1$的情况。喜提8分。 但是最后测出来好像是12分来着？没仔细看。 下午因为有人要回去所以讲评提前了半小时。 虽然说抢到了一个座位可是今天比昨天还吵真的什么也听不见了。 T3标程887行了解一下（ 结果接我们回东营的车咕了大概有一个多小时吧，最后得有20：30才到家。 晚上当然是回家……啊什么明天就正常上课啦？咕了！ 总结最后60+60+12+0+45+12=189。 随便抓只猴子就比我考的高/kk","categories":[{"name":"游记","slug":"游记","permalink":"https://github.com/Challestend/categories/游记/"}],"tags":[{"name":"SDOI","slug":"SDOI","permalink":"https://github.com/Challestend/tags/SDOI/"},{"name":"2019","slug":"2019","permalink":"https://github.com/Challestend/tags/2019/"}]},{"title":"伯努利数失败笔记","slug":"bernoulli-number-learning-notes","date":"2019-03-31T01:33:49.000Z","updated":"2019-04-01T02:20:42.790Z","comments":true,"path":"bernoulli-number-learning-notes/","link":"","permalink":"https://github.com/Challestend/bernoulli-number-learning-notes/","excerpt":"「クールでまばゆいばかりのアルゴリズムを学ばないでください、それはうまく検索することが最も重要です。」 ——loli 以上，我失败了（ 前半部分的抄袭来源。","text":"「クールでまばゆいばかりのアルゴリズムを学ばないでください、それはうまく検索することが最も重要です。」 ——loli 以上，我失败了（ 前半部分的抄袭来源。 定义伯努利数$B_{n}$具有如下性质： \\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]自然数幂和我们定义 S(n,k)=\\sum_{i=0}^{n-1}i^{k}T(n,k)=\\cfrac{1}{k+1}\\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}我们希望证明$S(n,k)=T(n,k)$。 在这里，我们采用一种名为「强归纳法」（或者「完全归纳法」）的方法。具体来说，假设我们已经对于任意的$0\\leqslant j\\lt k$，证明了$S(n,j)=T(n,j)$成立，利用这个结论推出$S(n,k)=T(n,k)$成立。 当$k=0$时 S(n,k)=nT(n,k)=C_{1}^{0}B_{0}n因为我们有 C_{1}^{0}B_{0}=[0=0]=1从而$S(n,k)=T(n,k)$成立。 当$k\\gt 0$时 S(n,k+1)=\\sum_{i=0}^{n-1}i^{k+1}\\begin{aligned} S(n,k+1)+n^{k+1}&=\\sum_{i=0}^{n-1}(i+1)^{k+1}\\\\ &=\\sum_{i=0}^{n-1}\\sum_{j=0}^{k+1}C_{k+1}^{j}i^{j}\\\\ &=\\sum_{j=0}^{k+1}C_{k+1}^{j}\\sum_{i=0}^{n-1}i^{j}\\\\ &=\\sum_{j=0}^{k+1}C_{k+1}^{j}S(n,j)\\\\ &=\\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)+C_{k+1}^{k+1}S(n,k+1) \\end{aligned}注意到$C_{k+1}^{k+1}=1$，我们就能得到 n^{k+1}=\\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)因为我们已经对于任意的$0\\leqslant j\\lt k$，证明了$S(n,j)=T(n,j)$成立，我们就可以将上式进一步变形 \\begin{aligned} n^{k+1}&=\\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)\\\\ &=\\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)\\\\ &=\\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)+C_{k+1}^{k}T(n,k)-C_{k+1}^{k}T(n,k)\\\\ &=\\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)-C_{k+1}^{k}T(n,k) \\end{aligned}接下来，如果我们能够证明 n^{k+1}=\\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)自然就能得出$S(n,k)=T(n,k)$。 愉快地推式子 \\begin{aligned} \\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\\sum_{j=0}^{k}C_{k+1}^{j}\\cfrac{1}{j+1}\\sum_{i=0}^{j}C_{j+1}^{i}B_{i}n^{j-i+1}\\\\ &=\\sum_{j=0}^{k}C_{k+1}^{j}\\cfrac{1}{j+1}\\sum_{i=0}^{j}C_{j+1}^{j-i}B_{j-i}n^{i+1}\\\\ &=\\sum_{j=0}^{k}C_{k+1}^{j}\\cfrac{1}{j+1}\\sum_{i=0}^{j}C_{j+1}^{i+1}B_{j-i}n^{i+1}\\\\ &=\\sum_{j=0}^{k}C_{k+1}^{j}\\cfrac{1}{j+1}\\sum_{i=0}^{j}\\cfrac{j+1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\\\ &=\\sum_{j=0}^{k}C_{k+1}^{j}\\sum_{i=0}^{j}\\cfrac{1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\\\ &=\\sum_{i=0}^{j}\\cfrac{1}{i+1}\\sum_{j=i}^{k}C_{k+1}^{j}C_{j}^{i}B_{j-i}n^{i+1}\\\\ &=\\sum_{i=0}^{j}\\cfrac{1}{i+1}\\sum_{j=i}^{k}C_{k+1}^{i}C_{k-i+1}^{j-i}B_{j-i}n^{i+1}\\\\ &=\\sum_{i=0}^{j}\\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j} \\end{aligned}上面的第二个等号是将后面的那个$\\sum$倒过来（$i\\rightarrow j-i$）求和。 返回本页面最上端之后，我们回想起伯努利数还有个这么个性质 \\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]于是 \\begin{aligned} \\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\\sum_{i=0}^{j}\\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\\\\ &=\\sum_{i=0}^{j}\\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}[i=k]\\\\ &=\\cfrac{1}{k+1}C_{k+1}^{k}n^{k+1}\\\\ &=n^{k+1} \\end{aligned}\\text{QED}诶刚才我干了些什么来着哦我好像是证明了这么一个东西 \\sum_{i=0}^{n-1}i^{k}=\\cfrac{1}{k+1}\\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}如何求伯努利数根据题解，我们知道伯努利数的生成函数是 \\cfrac{x}{e^{x}-1}=\\cfrac{x}{\\sum\\limits_{i=1}^{+\\infty}\\cfrac{x^{i}}{i!}}=\\cfrac{1}{\\sum\\limits_{i=0}^{+\\infty}\\cfrac{x^{i}}{(i+1)!}}例题「Luogu-P3711」仓鼠的数学题\\begin{aligned} \\sum_{i=0}^{n}a_{i}\\sum_{j=0}^{x}j^{i}&=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{i=0}^{n}a_{i}\\sum_{j=0}^{x-1}j^{i}\\\\ &=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{i=0}^{n}\\cfrac{a_{i}}{i+1}\\sum_{j=0}^{i}C_{i+1}^{j}B_{j}x^{i-j+1}\\\\ &=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{i=0}^{n}\\cfrac{a_{i}}{i+1}\\sum_{j=0}^{i}C_{i+1}^{i-j}B_{i-j}x^{j+1}\\\\ &=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{i=0}^{n}\\cfrac{a_{i}}{i+1}\\sum_{j=0}^{i}\\cfrac{(i+1)!}{(i-j)!(j+1)!}B_{i-j}x^{j+1}\\\\ &=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{i=0}^{n}i!a_{i}\\sum_{j=0}^{i}\\cfrac{1}{(j+1)!}\\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\\\ &=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{j=0}^{n}\\cfrac{1}{(j+1)!}\\sum_{i=j}^{n}i!a_{i}\\cfrac{B_{i-j}}{(i-j)!}x^{j+1} \\end{aligned}定义 F(x)=\\sum_{i=0}^{n}(n-i)!a_{n-i}x^{i}B(x)=\\sum_{i=0}^{n}\\cfrac{B_{i}}{i!}x^{i}那么 \\begin{aligned} \\sum_{i=0}^{n}a_{i}\\sum_{j=0}^{x}j^{i}&=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{j=0}^{n}\\cfrac{1}{(j+1)!}\\sum_{i=j}^{n}i!a_{i}\\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\\\ &=\\sum_{i=0}^{n}a_{i}x^{i}+\\sum_{j=0}^{n}\\cfrac{FB[n-j]}{(j+1)!}x^{j+1} \\end{aligned}","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"伯努利数","slug":"伯努利数","permalink":"https://github.com/Challestend/tags/伯努利数/"}]},{"title":"「AT987」高橋君","slug":"at987-solution","date":"2019-03-29T10:47:10.000Z","updated":"2019-03-29T10:58:55.974Z","comments":true,"path":"at987-solution/","link":"","permalink":"https://github.com/Challestend/at987-solution/","excerpt":"传送门 Luogu 第一道AtCoder的题解。 联动一波asuldb。","text":"传送门 Luogu 第一道AtCoder的题解。 联动一波asuldb。 「啊这题怎么做啊。看起来好难啊。不会啊。」 「我们来蒙一个做法吧。比如说就莫队了！」 \\sum_{i=0}^{m+1}C_{n}^{i}=\\sum_{i=0}^{m}C_{n}^{i}+C_{n}^{m+1}\\sum_{i=0}^{m}C_{n+1}^{i}=\\sum_{i=0}^{m}(C_{n}^{i}+C_{n}^{i-1})=\\sum_{i=0}^{m}C_{n}^{i}+\\sum_{i=0}^{m-1}C_{n}^{i-1}=2\\sum_{i=0}^{m}C_{n}^{i}-C_{n}^{m}这是左右端点向右移动的情况。向左移动就反过来。 就这样。 但是不知道为什么奇偶性排序会WA。 好短啊QAQ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define re register#define maxn 100000#define mod 1000000007#define id(a) (a/sq+1)#define C(n,m) (1LL*fac[n]*inv[m]%mod*inv[n-m]%mod)namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,sq;int fac[maxn+1],inv[maxn+1];struct Query&#123; int t,l,r;&#125;;Query q[maxn+1];int ans[maxn+1];inline bool operator&lt;(re Query p1,re Query p2)&#123; return id(p1.l)==id(p2.l)?p1.r&lt;p2.r:p1.l&lt;p2.l;&#125;int main()&#123; fac[0]=inv[0]=fac[1]=inv[1]=1; for(re int i=2;i&lt;=maxn;++i) inv[i]=(mod-1LL*mod/i*inv[mod%i]%mod)%mod; for(re int i=2;i&lt;=maxn;++i)&#123; fac[i]=1LL*fac[i-1]*i%mod; inv[i]=1LL*inv[i-1]*inv[i]%mod; &#125; cltstream::read(n); sq=maxn/sqrt(n); for(re int i=1;i&lt;=n;++i)&#123; q[i].t=i; cltstream::read(q[i].r); cltstream::read(q[i].l); &#125; std::sort(q+1,q+n+1); re int L=0,R=0,res=1; for(re int i=1;i&lt;=n;++i)&#123; for(;R&lt;q[i].r;res=(2*res-C(R,L)+mod)%mod,++R); for(;R&gt;q[i].r;--R,res=inv[2]*(res+C(R,L))%mod); for(;L&lt;q[i].l;++L,res=(res+C(R,L))%mod); for(;L&gt;q[i].l;res=(res-C(R,L)+mod)%mod,--L); ans[q[i].t]=res; &#125; for(re int i=1;i&lt;=n;++i) cltstream::write(ans[i],10); clop(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://github.com/Challestend/tags/组合数学/"},{"name":"莫队","slug":"莫队","permalink":"https://github.com/Challestend/tags/莫队/"},{"name":"玄学","slug":"玄学","permalink":"https://github.com/Challestend/tags/玄学/"}]},{"title":"后缀数组自闭笔记","slug":"suffix-array-learning-notes","date":"2019-03-25T09:34:10.000Z","updated":"2019-03-26T11:03:37.481Z","comments":true,"path":"suffix-array-learning-notes/","link":"","permalink":"https://github.com/Challestend/suffix-array-learning-notes/","excerpt":"省选前最后两周。同时也是退役前最后两周。 在wzx的鼓动下开了字符串。 然后自闭了。","text":"省选前最后两周。同时也是退役前最后两周。 在wzx的鼓动下开了字符串。 然后自闭了。 以下，我们约定，$S_{l,r}$表示字符串$S$下标为$[l,r]$的子串，下标从$1$开始。超过串长的部分用小于其他所有字符的空字符填充。 后缀排序std::sort（光速逃 不过std::sort也是可以做的（ 我们发现，这种做法的瓶颈在于比较两个后缀的大小。我们可以二分+Hash求出它们的最长公共前缀的长度，然后比较这个前缀后一个字符的大小。这么做的时间复杂度是$O(n\\log^{2}n)$的。 但是没什么用（ 然后我们就需要用到后缀数组（Suffix Array）了。 SA一共有四种构建方式，分别是$O(n\\log n)$的倍增，$O(n)$的DC3和SA-IS，以及$O(1)$的潮爷排序。但是后三种太高端了我都不会（ 假设对于每一个位置$i$，我们已经按照$S_{i,i+k-1}$的大小排好了序，并且有了一个排名。我们以$i$的排名为第一关键字，$i+k$的排名为第二关键字，排一遍序，整个字符串就被按照$S_{i,i+2k-1}$的大小排好了序。当所有位置的排名都不同时，说明整个过程可以结束了。 但是问题来了，排一遍序不是$O(n\\log n)$的吗（ 我们有基数排序啊（ 123456789101112131415161718192021222324252627282930313233343536373839404142// s[i]：原字符串// fst[i]：后缀i的第一关键字// snd[i]：第二关键字排名为i的后缀// tak[i]：桶// sa[i]：排名为i的后缀// 一开始时以首字符为第一关键字，位置为第二关键字排序for(re int i=1;i&lt;=n;++i) ++tak[fst[i]=s[i]];for(re int i=1;i&lt;=122;++i) tak[i]+=tak[i-1]; // 处理桶内前缀和，用来求出第一关键字为i的后缀的最大可能排名for(re int i=n;i&gt;=1;--i) sa[tak[fst[i]]--]=i; // 第一关键字相同时，第二关键字排名越大总排名越大，因此倒序枚举 // 因为第二关键字是位置，所以snd[i]=ifor(re int mx=122,k=1;;k&lt;&lt;=1)&#123; re int cnt=0; for(re int i=n-k+1;i&lt;=n;++i) snd[++cnt]=i; // (n-k,n]的这些后缀没有第二关键字，因此排名最靠前 for(re int i=1;i&lt;=n;++i) if(sa[i]&gt;k) snd[++cnt]=sa[i]-k; for(re int i=1;i&lt;=mx;++i) tak[i]=0; for(re int i=1;i&lt;=n;++i) ++tak[fst[i]]; for(re int i=1;i&lt;=mx;++i) tak[i]+=tak[i-1]; for(re int i=n;i&gt;=1;--i) sa[tak[fst[snd[i]]]--]=snd[i]; for(re int i=1;i&lt;=n;++i) snd[i]=fst[i]; // 因为要生成下一轮排序时的第一关键字，把fst里的信息先扔到snd里 for(re int i=1;i&lt;=n;++i) fst[sa[i]]=fst[sa[i-1]]+(snd[sa[i]]!=snd[sa[i-1]]||snd[sa[i]+k]!=snd[sa[i-1]+k]); // 如果当前后缀与前一个后缀相同则共用排名，否则+1 if(fst[sa[n]]==n) break; else mx=fst[sa[n]];&#125; 看上去非常的绕（ 最后直接输出sa数组即可。 rnk数组rnk[i]表示排名为$i$的后缀。 不难发现rnk[sa[i]]=sa[rnk[i]]=i。 het数组大概算是SA的重点。 令lcp(x,y)表示$x,y$两个后缀的最长公共前缀（Longest Common Prefix）的长度。 het[i]就被定义为lcp(sa[i],sa[i-1])。het[1]=0。 不难发现lcp(x,z)=min(lcp(x,y),lcp(y,z))(x&lt;y&lt;z)，lcp(x,y)=min{lcp(i,i-1)}=min{het[i]}(rnk[x]&lt;i&lt;=rnk[y])。 那么问题来了，怎么求呢（ 首先我们是肯定不能暴力枚举的。 二分+Hash？太麻烦而且复杂度不够优秀（ SA的het数组有一个性质，就是het[rnk[i]]&gt;=het[rnk[i-1]]-1。 我们只考虑het[rnk[i-1]]&gt;0时的情况。 令k=sa[rnk[i-1]-1]，lcp(i-1,k)=het[rnk[i-1]]，又因为后缀$i$是后缀$i-1$删去首字符得到的，后缀$k+1$是后缀$k$删去首字符得到的，从而lcp(i,k+1)=het[rnk[i-1]]-1。 后缀$i-1$比后缀$k$大，删去首字符后，后缀$i$肯定也比后缀$k+1$大。根据lcp的性质我们有lcp(i,sa[rnk[i]-1])&gt;=lcp(i,k+1)，也即het[rnk[i]]&gt;=het[rnk[i-1]]-1。 利用这个性质，我们就可以在$O(n)$的时间复杂度内求出het数组了。 1234567for(re int i=1,j=0;i&lt;=n;++i) if(rnk[i]&gt;1)&#123; j-=!!j; re int pos=sa[rnk[i]-1]; for(;i+j&lt;=n&amp;&amp;pos+j&lt;=n&amp;&amp;s[i+j]==s[pos+j];++j); het[rnk[i]]=j; &#125; 然后SA就彻底建好了。没错就这么点东西（ 板子应用不同子串个数给定一个长度为$n$的字符串$S$，求其本质不同的子串的数量。 首先有一个很显然的结论是，如果一个字符串是$S$的子串，那么它一定是$S$的若干个排名连续的后缀的公共前缀。 对于排名为$1$和排名为$2$的两个后缀来说，它们一共有het[2]个公共前缀；排名为$2$和排名为$3$的两个后缀一共有het[3]个公共前缀…… 因此，$S$的不同子串个数就是它的所有子串个数，$\\cfrac{n(n+1)}{2}$，减去所有het的和。 最长公共子串给定$n$个字符串$S_{1},S_{2},\\cdots,S_{n}$，求它们的最长公共子串。 我们首先将这$n$个串拼在一起，中间插入特殊字符将相邻的两个串隔开。然后我们将每个串内部的字符染色，第$1$个串染成颜色$1$，第$2$个串染成颜色$2$，用尺取法找出sa[l],sa[l+1],...,sa[r]覆盖全部$n$种颜色的区间$[l,r]$，求出其中min{het[i]}(l&lt;i&lt;=r)的最大值即可。 模式串出现次数给定$n$个文本串和$m$个模式串，询问每个模式串在$n$个文本串中一共出现了多少次。 首先将所有文本串拼在一起。对于每一个模式串，如果我们能够找到这个长串的任意一个后缀$x$，使得其拥有这个模式串作为前缀，然后找到一个最小的$l$和一个最大的$r$，使得min{het[i]}(l&lt;i&lt;=rnk[x])和min{het[i]}(rnk[x]&lt;i&lt;=r)均大于等于该模式串长度，$r-l+1$就是答案。不难看出向两边取$\\min$这个操作具有单调性，因此我们可以二分。 但是问题来了，我们该怎么找到这个后缀啊。 一想，把模式串也接到文本串后就可以了。 那如果说模式串出现了互相包含的情况呢？ 我们可以再开一个数组col，col[i]表示sa[i]的首字符是否属于一个文本串。因为这个是静态的，直接一遍前缀和就行。 母串数量给定$n$个文本串和$m$个模式串，询问每个模式串在多少个文本串中出现过。也就是说，在同一个文本串中出现多次只记一次。 和上面一样，只不过是最后一步col[i]表示sa[i]的首字符所属的文本串的编号，对于每一个模式串，二分出区间后数一下颜色种类数。 课后习题自己找去吧（ 然后您就会发现字符串的题一道比一道神仙（","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://github.com/Challestend/tags/字符串/"},{"name":"SA","slug":"SA","permalink":"https://github.com/Challestend/tags/SA/"}]},{"title":"「Ynoi2014D2T2」人人本着正义之名","slug":"luogu-p5066-solution-not","date":"2019-03-19T07:57:35.000Z","updated":"2019-03-25T11:06:01.310Z","comments":true,"path":"luogu-p5066-solution-not/","link":"","permalink":"https://github.com/Challestend/luogu-p5066-solution-not/","excerpt":"传送门 一人血书放大常数Splay一条生路。","text":"传送门 一人血书放大常数Splay一条生路。 之前Ynoi2014唯一一道没公开的题。 写个$O(nm)$的暴力就有30了。 我们来分析一下操作$3,4,5,6$都在干些啥。 以操作$3$为例，如果在操作前，有一个位置的数字是$1$，它左边是一个$0$，操作完之后那个$0$就会变成$1$。除此之外不会再有其它改变。 仔细想象一下这个过程，我们发现这实际上是将操作区间内所有极长连续$1$的左端点向左扩展了$1$位，所有极长连续$0$的右端点向左收缩了$1$位。 操作$4,5,6$也是类似的。 那么我们写一棵珂朵莉树就可以获得50分了。 但实际上emmmmm……我的珂朵莉树可能和别人不一样（ 别人的珂朵莉树： 我的珂朵莉树： 那么满分做法？ 手写平衡树。没了。 虽然这么说，但是lxl都写了将近10KB（ 总体思路就是，手写平衡树维护所有极长连续段的长度，并不需要维护端点因为可以算出来，单独维护还麻烦。每个节点维护子树内极长连续$0$和$1$的数量、长度最小值，以及连续段的长度变化量（标记）。修改时判断一下如果最小值变成了$0$，那么就暴力重构。反正lxl说因为有前两个操作的存在这么做时间复杂度是对的。 首先有一个问题就是，这样做每个节点维护的必须要是极长连续段。想象一下，如果有两个相邻的节点值都是$1$，我们进行一次操作$3$或$4$，会发生什么？ 两个节点的长度都加了$1$。然后整个序列莫名其妙多出来$1$个数。再然后您就WA了。 然后就是各种各样乱七八糟的细节。虽然这么说但好像没什么可列举的了。 然后您按照上面的思路打完四五百行的代码之后交上去一看： 虽然说暴力重构的时间复杂度应该是对的，但是不难发现它常数大啊。 但是如果不重构，合并相邻的连续段就会变得非常麻烦。 结论就是这题不可写，散了吧散了吧。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"珂朵莉树","slug":"珂朵莉树","permalink":"https://github.com/Challestend/tags/珂朵莉树/"},{"name":"平衡树","slug":"平衡树","permalink":"https://github.com/Challestend/tags/平衡树/"},{"name":"毒瘤","slug":"毒瘤","permalink":"https://github.com/Challestend/tags/毒瘤/"}]},{"title":"来扯点多项式？","slug":"polynomial-triangle-function","date":"2019-03-17T03:06:25.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"polynomial-triangle-function/","link":"","permalink":"https://github.com/Challestend/polynomial-triangle-function/","excerpt":"在luogu上看到了多项式三角函数/反三角函数的板子。 不过还没加进公共题库，没人交，于是不敢交（ 于是来口胡一波吧。","text":"在luogu上看到了多项式三角函数/反三角函数的板子。 不过还没加进公共题库，没人交，于是不敢交（ 于是来口胡一波吧。 三角函数总之就是求$\\sin F(x)$，$\\cos F(x)$，其他的三角函数都可以用这两个凑出来因此不需要单独讨论。 虽然说我们也有$\\cos x=\\sin(x+\\cfrac{\\pi}{2})$，但是问题来了，模意义下怎么表示$\\pi$（ 首先我们有欧拉公式 e^{ix}=\\cos x+i\\sin x于是 e^{iF}=\\cos F+i\\sin F根据定义，$i^{2}\\equiv -1\\equiv 998244352\\pmod{998244353}$。而$998244352$是模$998244353$的二次剩余，说人话就是这样的$i$是存在的。 但是问题来了，我们该怎么分离$\\sin$和$\\cos$？ 我们还需要有 e^{i(-F)}=\\cos F-i\\sin F很明显地 \\sin F=\\cfrac{e^{iF}-e^{i(-F)}}{2i}\\cos F=\\cfrac{e^{iF}+e^{i(-F)}}{2}反三角函数求$\\arcsin F(x)$，$\\arccos F(x)$。 我们令答案的多项式为$G(x)$。 我们都知道 \\sin^{2}x+\\cos^{2}x=1于是知道了$\\sin G$或者是$\\cos G$，我们就可以推出另一项，然后再根据 e^{iG}=\\cos G+i\\sin GG=\\cfrac{\\ln(\\cos G+i\\sin G)}{i}就可以算出$G$了。 那么$\\arctan F(x)$？ \\sin^{2}G+\\cos^{2}G=1因为$\\tan G$有意义，所以$\\cos G\\neq0$。 \\tan^{2}G+1=\\sec^{2}G\\cos G=\\cfrac{1}{\\sqrt{\\tan^{2}G+1}}但是看着就麻烦（ Updated on 2019-03-18 上面这种做法大概不是正解，因为这样需要对一个常数项不是$1$，最低次非零系数也不是$1$的多项式求平方根，很明显这需要二次剩余，而且我不会。 考虑倍增。 \\sin G_{0}-F\\equiv 0\\pmod{x^{t}}\\sin G-F\\equiv 0\\pmod{x^{2t}}G\\equiv G_{0}-\\cfrac{\\sin G_{0}-F}{(\\sin G_{0}-F)^{\\prime}}\\equiv G_{0}-\\cfrac{\\sin G_{0}-F}{\\cos G_{0}}\\pmod{x^{2t}}然后是$\\arccos$。 G\\equiv G_{0}-\\cfrac{\\cos G_{0}-F}{(\\cos G_{0}-F)^{\\prime}}\\equiv G_{0}+\\cfrac{\\cos G_{0}-F}{\\sin G_{0}}\\pmod{x^{2t}}然后是$\\arctan$。不过我不怎么会求导$\\tan$（ \\begin{aligned} (\\tan x)^{\\prime}&=(\\cfrac{\\sin x}{\\cos x})^{\\prime}\\\\ &=\\cfrac{(\\sin x)^{\\prime}}{\\cos x}+\\sin x(\\cfrac{1}{\\cos x})^{\\prime}\\\\ &=1+\\tan^{2}x \\end{aligned}G\\equiv G_{0}-\\cfrac{\\tan G_{0}-F}{(\\tan G_{0}-F)^{\\prime}}\\equiv G_{0}+\\cfrac{\\tan G_{0}-F}{1+\\tan^{2} G_{0}}\\pmod{x^{2t}}这大概不能写（ 多项式GCD/LCM既然多项式能够整除和取模，那么GCD和LCM一定也是可以算的吧！ ……应该可以吧（","categories":[{"name":"瞎扯","slug":"瞎扯","permalink":"https://github.com/Challestend/categories/瞎扯/"}],"tags":[{"name":"多项式","slug":"多项式","permalink":"https://github.com/Challestend/tags/多项式/"},{"name":"三角函数","slug":"三角函数","permalink":"https://github.com/Challestend/tags/三角函数/"}]},{"title":"生成函数学习笔记","slug":"generating-function-learning-notes","date":"2019-03-15T03:34:27.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"generating-function-learning-notes/","link":"","permalink":"https://github.com/Challestend/generating-function-learning-notes/","excerpt":"又被wzx吊打了QAQ 来写一篇生成函数吧QAQ 本文全部内容抄袭自这篇blog和这篇blog","text":"又被wzx吊打了QAQ 来写一篇生成函数吧QAQ 本文全部内容抄袭自这篇blog和这篇blog 定义一个数列$\\{a_{0},a_{1},\\cdots,a_{n}\\}$的生成函数$f(x)$被定义为 f(x)=\\sum_{i=0}^{n}a_{i}x^{i}就这样（ 封闭表达式但是这个形式比较玄乎，不便于我们推式子。特别是当我们需要求一个无穷数列的生成函数时。于是我们希望能够进一步化简。 比如说，当$a_{n}=c^{n}$，即这个数列是$\\{1,c,c^{2},\\cdots\\}$时，它的生成函数是 f(x)=\\sum_{i=0}^{n}c^{i}x^{i}=\\cfrac{1-(cx)^{n+1}}{1-cx}就是一个简单地等比数列求和。很明显，当$x\\in(-1,1)$时，如果$n$趋向于正无穷大，则上式等于$\\cfrac{1}{1-cx}$。 我们现在来分析一下斐波那契数列的生成函数。 \\begin{aligned} F(x)&=\\sum_{i=0}^{n}F_{i}x^{i}\\\\ &=\\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i} \\end{aligned}为了方便，我们定义当$n\\lt 0$时，$F_{n}=0$。 然后我们发现$F_{1}=F_{0}+F_{-1}=0+0=0$，于是我们再加上一项$[i=1]$。 \\begin{aligned} F(x)&=\\sum_{i=0}^{n}(F_{i-1}+F_{i-2}+[i=1])x^{i}\\\\ &=x+\\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\\\\ &=x+x\\sum_{i=0}^{n}F_{i-1}x^{i-1}+x^{2}\\sum_{i=0}^{n}F_{i-2}x^{i-2}\\\\ &=x+xF(x)+x^{2}F(x) \\end{aligned}于是 F(x)=\\cfrac{x}{1-x-x^{2}}通项公式斐波那契数那么问题来了，我们闲着没事求这个生成函数有什么用啊。 求通项公式。 我们知道形如$a_{n}=c^{n}$的数列的生成函数等于$\\cfrac{1}{1-cx}$，我们可以试着将$\\cfrac{x}{1-x-x^{2}}$分解成两个类似形式的分式的和。 设 1-x-x^{2}=(1-ax)(1-bx)\\begin{cases} &a+b=1\\\\ &ab=-1 \\end{cases} \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\begin{cases} &a=\\cfrac{1+\\sqrt{5}}{2}\\\\ &b=\\cfrac{1-\\sqrt{5}}{2} \\end{cases}再设 \\cfrac{c}{1-\\cfrac{1+\\sqrt{5}}{2}x}+\\cfrac{d}{1-\\cfrac{1-\\sqrt{5}}{2}x}=\\cfrac{x}{(1-\\cfrac{1+\\sqrt{5}}{2}x)(1-\\cfrac{1-\\sqrt{5}}{2}x)}\\cfrac{c}{1-\\cfrac{1+\\sqrt{5}}{2}x}+\\cfrac{d}{1-\\cfrac{1-\\sqrt{5}}{2}x}=\\cfrac{c-\\cfrac{1-\\sqrt{5}}{2}cx+d-\\cfrac{1+\\sqrt{5}}{2}dx}{(1-\\cfrac{1+\\sqrt{5}}{2}x)(1-\\cfrac{1-\\sqrt{5}}{2}x)}于是 c-\\cfrac{1-\\sqrt{5}}{2}cx+d-\\cfrac{1+\\sqrt{5}}{2}dx=x等式右边没有常数项，因此$c+d$应当是$0$。再继续接下去，我们得到 \\begin{cases} &c=\\cfrac{1}{\\sqrt{5}}\\\\ &d=-\\cfrac{1}{\\sqrt{5}} \\end{cases}于是 \\begin{aligned} F(x)&=\\cfrac{1}{\\sqrt{5}}\\cfrac{1}{1-\\cfrac{1+\\sqrt{5}}{2}x}-\\cfrac{1}{\\sqrt{5}}\\cfrac{1}{1-\\cfrac{1-\\sqrt{5}}{2}x}\\\\ &=\\sum_{i=0}^{n}\\cfrac{1}{\\sqrt{5}}\\left(\\cfrac{1+\\sqrt{5}}{2}\\right)^{i}x^{i}-\\sum_{i=0}^{n}\\cfrac{1}{\\sqrt{5}}\\left(\\cfrac{1-\\sqrt{5}}{2}\\right)^{i}x^{i}\\\\ &=\\sum_{i=0}^{n}\\cfrac{1}{\\sqrt{5}}\\left(\\left(\\cfrac{1+\\sqrt{5}}{2}\\right)^{i}-\\left(\\cfrac{1-\\sqrt{5}}{2}\\right)^{i}\\right)x^{i} \\end{aligned}结论就是 F_{n}=\\cfrac{1}{\\sqrt{5}}\\left(\\left(\\cfrac{1+\\sqrt{5}}{2}\\right)^{n}-\\left(\\cfrac{1-\\sqrt{5}}{2}\\right)^{n}\\right)卡特兰数\\begin{aligned} F(x)&=\\sum_{i=0}^{n}C_{i}x^{i}\\\\ &=\\sum_{i=0}^{n}\\left(\\sum_{j=0}^{i-1}C_{j}C_{i-j-1}+[i=0]\\right)x^{i}\\\\ &=1+\\sum_{i=0}^{n}\\left(\\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\\right)x^{i}\\\\ &=1+x\\sum_{i=0}^{n}\\left(\\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\\right)x^{i-1}\\\\ &=1+xF^{2}(x) \\end{aligned}于是 xF^{2}(x)-F(x)+1=0F(x)=\\cfrac{1\\pm\\sqrt{1-4x}}{2x}2xF(x)=1\\pm\\sqrt{1-4x}当$x=0$时 2\\times 0\\times 1=1\\pm1因此根号前应该取负。至此我们得到 F(x)=\\cfrac{1-\\sqrt{1-4x}}{2x}那么通项公式呢？ 根据一个我抄过来的广义二项式定理，我们有 \\begin{aligned} \\sqrt{1-4x}&=1+\\sum_{i=1}^{n}\\cfrac{(-1)^{i-1}}{i2^{2i-1}}C_{2i-2}^{i-1}(-4x)^{i}\\\\ &=1+2\\sum_{i=1}^{n}\\cfrac{(-1)^{2i-1}}{i}C_{2i-2}^{i-1}x^{i}\\\\ &=1-2\\sum_{i=1}^{n}\\cfrac{1}{i}C_{2i-2}^{i-1}x^{i} \\end{aligned}\\begin{aligned} F(x)&=\\cfrac{1-\\sqrt{1-4x}}{2x}\\\\ &=\\sum_{i=1}^{n}\\cfrac{1}{i}C_{2i-2}^{i-1}x^{i-1}\\\\ &=\\sum_{i=0}^{n}\\cfrac{1}{i+1}C_{2i}^{i}x^{i} \\end{aligned}于是 C_{n}=\\cfrac{1}{n+1}C_{2n}^{n}默慈金数等会默慈金数是个什么鬼？（ 默慈金数一般记为$M_{n}$，被定义为在均匀分布在一个圆上的$n$个有编号的点之间连出彼此不相交的弦的方案数。一根弦也不连也是一种方案。 M_{0}=1M_{n}=M_{n-1}+\\sum_{i=0}^{n-2}M_{i}M_{n-i-2}\\begin{aligned} F(x)&=\\sum_{i=0}^{n}M_{i}x^{i}\\\\ &=\\sum_{i=0}^{n}\\left(M_{i-1}+\\sum_{j=0}^{i-2}M_{j}M_{i-j-2}+[i=0]\\right)x^{i}\\\\ &=1+\\sum_{i=0}^{n}\\left(M_{i-1}+\\sum_{j=0}^{i-2}M_{j}M_{i-j-2}\\right)x^{i}\\\\ &=1+xF(x)+x^{2}F^{2}(x) \\end{aligned}于是 x^{2}F^{2}(x)+(x-1)F(x)+1=0F(x)=\\cfrac{1-x\\pm\\sqrt{1-2x-3x^{2}}}{2x^{2}}总之根号前应该取负（ \\begin{aligned} F(x)&=\\cfrac{1-x-\\sqrt{1-2x-3x^{2}}}{2x^{2}}\\\\ &=\\cfrac{2-2x-2\\sqrt{1-2x-3x^{2}}}{4x^{2}}\\\\ &=\\cfrac{(1+x)-2\\sqrt{(1+x)(1-3x)}+(1-3x)}{4x^{2}}\\\\ &=\\cfrac{(\\sqrt{1+x}-\\sqrt{1-3x})^{2}}{4x^{2}} \\end{aligned}woc这什么鬼东西溜了溜了。 留作课后习题，哪位dalao推出来了让我%一%（ 例题「TJOI2015」概率论首先很明显，互不同构的二叉树一共$C_{n}$棵，其中$C_{n}$是卡特兰数。现在我们希望求出这些二叉树的叶子结点总数，我们记为$F_{n}$。不难发现 F_{0}=0F_{1}=1F_{n}=2\\sum_{i=0}^{n-1}C_{i}F_{n-i-1}+[i=1]\\begin{aligned} F(x)&=\\sum_{i=0}^{n}F_{i}x^{i}\\\\ &=\\sum_{i=0}^{n}\\left(2\\sum_{j=0}^{i-1}C_{j}F_{i-j-1}+[i=1]\\right)x^{i}\\\\ &=x+2\\sum_{i=0}^{n}\\left(\\sum_{j=0}^{i-1}C_{j}F_{i-j-1}\\right)x^{i}\\\\ &=x+2xCF(x) \\end{aligned}于是 F(x)=\\cfrac{x}{1-2xC(x)}其中$C(x)$是卡特兰数的生成函数，我们知道它的值是$\\cfrac{1-\\sqrt{1-4x}}{2x}$，所以说 F(x)=\\cfrac{x}{\\sqrt{1-4x}}然后我又不会了（ (xC(x))^{\\prime}=\\cfrac{1}{\\sqrt{1-4x}}=\\cfrac{F(x)}{x}(xC(x))^{\\prime}=\\sum_{i=0}^{n}(i+1)C_{i}x^{i}\\cfrac{F(x)}{x}=\\sum_{i=0}^{n}F_{i}x^{i-1}=\\sum_{i=-1}^{n}F_{i+1}x^{i}我们就得到 iC_{i-1}=F_{i}于是 \\begin{aligned} \\text{Ans}&=\\cfrac{F_{n}}{C_{n}}\\\\ &=\\cfrac{nC_{n-1}}{C_{n}}\\\\ &=\\cfrac{C_{2n-2}^{n-1}}{\\cfrac{1}{n+1}C_{2n}^{n}}\\\\ &=\\cfrac{\\cfrac{(2n-2)!}{(n-1)!(n-1)!}}{\\cfrac{(2n)!}{n!(n+1)!}}\\\\ &=\\cfrac{(2n-2)!n!(n+1)!}{(n-1)!(n-1)!(2n)!}\\\\ &=\\cfrac{n(n+1)}{2(2n-1)} \\end{aligned}「国家集训队」整数的lqp拆分其实这道题我几个月前推出来了一个$O(n^{2})$的式子（ 如果记答案为$G_{n}$，我们有 G_{n}=\\sum_{i=0}^{n}F_{i}G_{n-i}其中$F_{n}$是斐波那契数。为了方便，我们强行定义$G_{0}=1$。 \\begin{aligned} G(x)&=\\sum_{i=0}^{n}G_{i}x^{i}\\\\ &=\\sum_{i=0}^{n}\\left(\\sum_{j=0}^{i}F_{j}G_{i-j}+[i=0]\\right)x^{i}\\\\ &=1+\\sum_{i=0}^{n}\\left(\\sum_{j=0}^{i}F_{j}G_{i-j}\\right)x^{i}\\\\ &=1+FG(x) \\end{aligned}其中$F(x)$是斐波那契数的生成函数。于是 G(x)=\\cfrac{1}{1-F(x)}=\\cfrac{1-x-x^{2}}{1-2x-x^{2}}=1+\\cfrac{x}{1-2x-x^{2}}多出来的那个$1$是$G_{0}$，可以无视掉。 设 (1-ax)(1-bx)=1-2x-x^{2}（中间过程略） \\begin{cases} &a=1+\\sqrt{2}\\\\ &b=1-\\sqrt{2} \\end{cases}再设 \\cfrac{c}{1-(1+\\sqrt{2})x}+\\cfrac{d}{1-(1-\\sqrt{2})x}=\\cfrac{x}{1-2x-x^{2}}（中间过程略$\\times 2$） \\begin{cases} &c=\\cfrac{1}{2\\sqrt{2}}\\\\ &d=-\\cfrac{1}{2\\sqrt{2}} \\end{cases}于是 \\begin{aligned} G(x)&=1+\\cfrac{1}{2\\sqrt{2}}\\cfrac{1}{1-(1+\\sqrt{2})x}-\\cfrac{1}{2\\sqrt{2}}\\cfrac{1}{1-(1-\\sqrt{2})x}\\\\ &=1+\\sum_{i=0}^{n}\\cfrac{1}{2\\sqrt{2}}\\left((1+\\sqrt{2})^{i}-(1-\\sqrt{2})^{i}\\right)x^{i} \\end{aligned}最终结论就是 G_{n}=\\cfrac{(1+\\sqrt{2})^{n}-(1-\\sqrt{2})^{n}}{2\\sqrt{2}}根据暴力枚举，我们得出$\\sqrt{2}\\equiv 59713600\\pmod{10^{9}+7}$。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"生成函数","slug":"生成函数","permalink":"https://github.com/Challestend/tags/生成函数/"}]},{"title":"「Luogu-P4705」Van♂游戏","slug":"luogu-p4705-solution","date":"2019-03-12T11:49:47.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p4705-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p4705-solution/","excerpt":"下个月就要省选了我还在颓怕不是要凉 然后再一翻wzx的blog发现他更新频率快到爆炸 大概这就是神吧 啊啊我好菜啊，不过还是来抄篇题解吧 传送门","text":"下个月就要省选了我还在颓怕不是要凉 然后再一翻wzx的blog发现他更新频率快到爆炸 大概这就是神吧 啊啊我好菜啊，不过还是来抄篇题解吧 传送门 令$\\text{Ans}[t]$表示$t$次价值： \\begin{aligned} \\text{Ans}[t]&=\\sum_{i=1}^{n}\\sum_{j=1}^{m}(a_{i}+b_{j})^{t}\\\\ &=\\sum_{i=1}^{n}\\sum_{j=1}^{m}\\sum_{k=0}^{t}C_{t}^{k}a_{i}^{k}b_{j}^{t-k}\\\\ &=t!\\sum_{k=0}^{t}\\cfrac{\\sum a_{i}^{k}}{k!}\\cfrac{\\sum b_{j}^{t-k}}{(t-k)!} \\end{aligned}然后我们看到了$\\sum a_{i}^{k}$这种东西，要算的话时间复杂度至少要是$O(nt)$的（ 从这里往下是抄的题解。 定义 F(x)=\\prod_{i=1}^{n}(a_{i}x+1)\\begin{aligned} G(x)&=\\ln F(x)\\\\ &=\\ln\\prod_{i=1}^{n}(a_{i}x+1)\\\\ &=\\sum_{i=1}^{n}\\ln(a_{i}x+1) \\end{aligned}我们先来考虑如何求出$F$。定义$Q_{i}$为从$\\{a_{n}\\}$中选出$i$个数相乘，这样的所有方案结果的总和，且$Q_{0}=1$。我们有 F(x)=\\sum_{i=0}^{n}Q_{i}x^{i}然后分治。假设我们现在已经求出了$[l,mid]$上的$Q_{L,0},Q_{L,1},\\cdots,Q_{L,mid-l+1}$和$(mid,r]$上的$Q_{R,0},Q_{R,1},\\cdots,Q_{R,r-mid}$，不难发现 Q_{i}=\\sum_{j=0}^{i}Q_{L,j}Q_{R,i-j}这部分的时间复杂度为$O(n\\log^{2}n)$。 然后我们将$G$在$1$这个位置泰勒展开。先回忆一下泰勒展开的式子 g(x)=\\sum\\limits_{i=1}^{+\\infty}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i\\ln^{(n)}(x)=(-1)^{n-1}(n-1)!x^{-n}\\begin{aligned} G(x)&=\\sum_{i=1}^{n}\\ln(a_{i}x+1)\\\\ &=\\sum_{i=1}^{n}\\sum_{j=1}^{+\\infty}\\cfrac{\\ln^{(j)}(1)}{j!}a_{i}^{j}x^{j}\\\\ &=\\sum_{i=1}^{n}\\sum_{j=1}^{+\\infty}\\cfrac{(-1)^{j-1}(j-1)!1^{-j}}{j!}a_{i}^{j}x^{j}\\\\ &=\\sum_{i=1}^{n}\\sum_{j=1}^{+\\infty}\\cfrac{(-1)^{j-1}}{j}a_{i}^{j}x^{j}\\\\ &=\\sum_{j=1}^{+\\infty}\\cfrac{(-1)^{j-1}}{j}\\left(\\sum_{i=1}^{n}a_{i}^{j}\\right)x^{j} \\end{aligned} 令人窒息（ 然后这道题就做出来了（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include&lt;cstdio&gt;#define re register#define maxn 524288#define mod 998244353#define swap(a,b) a^=b,b^=a,a^=bnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m,t;int unit[2][24],rev[maxn+1],inv[maxn+1]=&#123;1,1&#125;;int A[maxn+1],B[maxn+1],F[maxn+1],G[maxn+1],tmp1[maxn+1],tmp2[maxn+1];inline int cltpow(re int x,re int y)&#123; re int res=1; for(;y;)&#123; if(y&amp;1) res=1LL*res*x%mod; x=1LL*x*x%mod; y&gt;&gt;=1; &#125; return res;&#125;inline void NTT(re int* F,re int n,re int tp)&#123; for(re int i=0;i&lt;n;++i) if(i&lt;(rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?(n&gt;&gt;1):0))) swap(F[i],F[rev[i]]); for(re int k=1,p=1;p&lt;n;++k,p&lt;&lt;=1) for(re int i=0;i&lt;n;i+=p&lt;&lt;1) for(re int j=i,tmp=1;j&lt;i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod)&#123; re int x=F[j],y=1LL*F[j+p]*tmp%mod; F[j]=(x+y)%mod; F[j+p]=(x-y+mod)%mod; &#125; re int v=cltpow(n,tp*(mod-2)); for(re int i=0;i&lt;n;++i) F[i]=1LL*F[i]*v%mod;&#125;inline void Inv(re int* F,re int* G,re int n)&#123; re int N=1; for(;N&lt;n;N&lt;&lt;=1); N&lt;&lt;=1; for(re int i=0;i&lt;N;++i) G[i]=0; G[0]=cltpow(F[0],mod-2); for(re int i=1,j=4;i&lt;n;i&lt;&lt;=1,j&lt;&lt;=1)&#123; NTT(G,j,0); for(re int k=0;k&lt;(i&lt;&lt;1);++k) tmp1[k]=F[k]; for(re int k=(i&lt;&lt;1);k&lt;j;++k) tmp1[k]=0; NTT(tmp1,j,0); for(re int k=0;k&lt;j;++k) G[k]=(2-1LL*tmp1[k]*G[k]%mod+mod)*G[k]%mod; NTT(G,j,1); for(re int k=(i&lt;&lt;1);k&lt;j;++k) G[k]=0; &#125; for(re int i=n;i&lt;N;++i) G[i]=0;&#125;inline void Ln(re int* F,re int* G,re int n)&#123; re int N=1; for(;N&lt;n;N&lt;&lt;=1); N&lt;&lt;=1; for(re int i=1;i&lt;n;++i) G[i-1]=1LL*F[i]*i%mod; G[n-1]=0; for(re int i=n;i&lt;N;++i) G[i]=0; NTT(G,N,0); Inv(F,tmp2,n); NTT(tmp2,N,0); for(re int i=0;i&lt;N;++i) G[i]=1LL*G[i]*tmp2[i]%mod; NTT(G,N,1); for(re int i=n-1;i&gt;=1;--i) G[i]=1LL*G[i-1]*inv[i]%mod; G[0]=0; for(re int i=n;i&lt;N;++i) G[i]=0;&#125;void calc(re int* P,re int l,re int r)&#123; if(l&lt;r)&#123; re int mid=(l+r)&gt;&gt;1,N=1; calc(P,l,mid); calc(P,mid+1,r); for(;N&lt;r-l+2;N&lt;&lt;=1); F[0]=1; for(re int i=1;i&lt;=mid-l+1;++i) F[i]=P[l+i-1]; for(re int i=mid-l+2;i&lt;N;++i) F[i]=0; NTT(F,N,0); G[0]=1; for(re int i=1;i&lt;=r-mid;++i) G[i]=P[mid+i]; for(re int i=r-mid+1;i&lt;N;++i) G[i]=0; NTT(G,N,0); for(re int i=0;i&lt;N;++i) F[i]=1LL*F[i]*G[i]%mod; NTT(F,N,1); for(re int i=1;i&lt;=r-l+1;++i) P[l+i-1]=F[i]; &#125;&#125;int main()&#123; unit[0][23]=cltpow(3,119); unit[1][23]=cltpow(332748118,119); for(re int i=0;i&lt;2;++i) for(re int j=22;j&gt;=0;--j) unit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod; for(re int i=2;i&lt;=maxn;++i) inv[i]=(mod-1LL*mod/i*inv[mod%i]%mod)%mod; cltstream::read(n); cltstream::read(m); A[0]=1; for(re int i=1;i&lt;=n;++i) cltstream::read(A[i]); B[0]=1; for(re int i=1;i&lt;=m;++i) cltstream::read(B[i]); cltstream::read(t); calc(A,1,n); calc(B,1,m); Ln(A,F,t+1); Ln(B,G,t+1); F[0]=n; for(re int i=1,j=1;i&lt;=t;j=1LL*j*(mod-inv[i])%mod,++i) F[i]=1LL*F[i]*j%mod; G[0]=m; for(re int i=1,j=1;i&lt;=t;j=1LL*j*(mod-inv[i])%mod,++i) G[i]=1LL*G[i]*j%mod; re int N=1; for(;N&lt;(t&lt;&lt;1|1);N&lt;&lt;=1); for(re int i=t+1;i&lt;N;++i) F[i]=G[i]=0; NTT(F,N,0); NTT(G,N,0); for(re int i=0;i&lt;N;++i) F[i]=1LL*F[i]*G[i]%mod; NTT(F,N,1); N=cltpow(1LL*n*m%mod,mod-2); for(re int i=1,j=N;i&lt;=t;++i,j=1LL*j*i%mod) cltstream::write(1LL*F[i]*j%mod,10); clop(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"}]},{"title":"「网络流学习笔记Part II」总之XJB写点啥（","slug":"network-flow-learning-notes-pt2","date":"2019-02-21T09:37:23.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"network-flow-learning-notes-pt2/","link":"","permalink":"https://github.com/Challestend/network-flow-learning-notes-pt2/","excerpt":"Part I大概是这篇。 去郑州的时候讲的网络流部分。 什么你说游记？咕咕咕。","text":"Part I大概是这篇。 去郑州的时候讲的网络流部分。 什么你说游记？咕咕咕。 一种似乎没有名字的二元组模型简化版你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个三元组（虽然说不是标题说的二元组不过不要在意这些细节），每一个三元组形如$(x,y,c)$，意思是如果$x$和$y$两个任务在不同的机器上完成需要额外付出$c$的代价。你需要完成这$n$个任务，并最小化代价和。 我们都知道最小割=最大流。因此在一些题目中，如果无法将问题抽象成最大流问题，我们可以试着抽象成最小割问题。 对于任务$i$，连边$(S,i,a_{i}),(i,T,b_{i})$。对于一个三元组$(x,y,c)$，连边$(x,y,c),(y,x,c)$。 割断$(S,i,a_{i})$意味着任务$i$在第一台机器上完成，割断$(i,T,b_{i})$意味着任务$i$在第二台机器上完成。 首先很明显的是，同时割断$(S,i,a_{i})$和$(i,T,b_{i})$一定不是最优的决策。因此一个任务只会在一台机器上被完成。 对于一个三元组$(x,y,c)$，如果我们同时割断$(S,x,a_{x})$和$(S,y,a_{y})$，$S$与$T$直接就断开了，这样我们的代价是$a_{x}+a_{y}$。同时割断$(x,T,b_{x})$和$(y,T,b_{y})$也是类似的。 如果说我们同时割断$(S,x,a_{x})$和$(y,T,b_{y})$，图上仍存在$\\{(S,y,a_{y}),(y,x,c),(x,T,b_{x})\\}$这样一条路径，我们还需要割断$(y,x,c)$，这样我们的代价是$a_{x}+b_{y}+c$。同时割断$(x,T,b_{x})$和$(S,y,a_{y})$也是类似的。 一般化你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个六元组，每一个六元组形如$(x,y,c_{1},c_{2},c_{3},c_{4})$，意思是你需要为$x$和$y$这两个任务付出一些额外代价： 如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{1}$。 如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{2}$。 如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{3}$。 如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{4}$。 你需要完成这$n$个任务，并最小化代价和。 首先仍然是连边$(S,i,a_{i}),(i,T,b_{i})$。对于每一个六元组，连边$(S,x,A),(S,y,B),(x,T,C),(y,T,D),(x,y,E),(y,x,F)$。我们发现 如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,x,A),(S,y,B)$，付出$A+B$的代价。 如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(x,T,C),(y,T,D)$，付出$C+D$的代价。 如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(S,x,A),(y,T,D),(y,x,F)$，付出$A+D+F$的代价。 如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,y,B),(x,T,C),(x,y,E)$，付出$B+C+E$的代价。 因此我们列出如下的方程组 \\begin{cases} &A+B=c_{1}&(1)\\\\ &C+D=c_{2}&(2)\\\\ &A+D+F=c_{3}\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;&(3)\\\\ &B+C+E=c_{4}&(4) \\end{cases}因为我们要将问题转化成最大流问题，首先想到，我们要有$A,B,C,D,E,F\\geqslant 0$。注意到，$(S,x,A)$和$(x,T,C)$中有且仅有一条边会出现在最小割集中，因此我们可以将$A$和$C$同时加上一个数，求出最小割后在答案中减去。$B$和$D$也可以类似处理。 需要注意的是，$E$和$F$不能被这样处理，因为我们不能确定它们在答案中产生了几次贡献。 $(3)+(4)-(1)-(2)$，我们得到 E+F=c_{3}+c_{4}-c_{1}-c_{2}定义$K=c_{3}+c_{4}-c_{1}-c_{2}$，当$K\\geqslant 0$时它有意义，我们直接令$E=F=\\cfrac{K}{2}$即可。 剩下的四个量随便给几个值，好算就行。 其实就算$K\\lt 0$有时也是可以做的，但是我太菜了不会（ 因为太菜了所以没有图（ 例题「国家集训队」happiness题目要求最大化总收益，我们可以先将所有数取相反数，然后最小化总代价。 令位置$i$选文的单独收益是$a_{i}$，选理的单独收益是$b_{i}$，连边$(S,i,-a_{i}),(i,T,-b_{i})$。 考虑一对相邻的位置，他们都选文的额外收益是$v_{1}$，都选理的额外收益是$v_{2}$，列出方程组 \\begin{cases} &A+B=-v_{1}\\\\ &C+D=-v_{2}\\\\ &A+D+E=0\\\\ &B+C+E=0 \\end{cases} \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\begin{cases} &A=-\\cfrac{v_{1}}{2}\\\\ &B=-\\cfrac{v_{1}}{2}\\\\ &C=-\\cfrac{v_{2}}{2}\\\\ &D=-\\cfrac{v_{2}}{2}\\\\ &E=\\cfrac{v_{1}+v_{2}}{2} \\end{cases}为了避免浮点数，我们把上面所有边的容量乘以$2$，包括$(S,i,-a_{i}),(i,T,-b_{i})$，最后再除回来。 然后，为了避免负数，我们将$A,B,C,D$加上$v_{1}+v_{2}$，把边$(S,i,-2a_{i}),(i,T,-2b_{i})$的容量加上$2a_{i}+2b_{i}$，最后再减回来。 总结一下就是，对于一个位置$i$，连边$(S,i,2b_{i}),(i,T,2a_{i})$。对于一对相邻位置$x,y$，连边$(S,x,v_{2}),(S,y,v_{2}),(x,T,v_{1}),(y,T,v_{1}),(x,y,v_{1}+v_{2}),(y,x,v_{1}+v_{2})$。 \\text{Ans}=\\sum(a_{i}+b_{i})+\\sum(v_{1}+v_{2})-\\cfrac{\\text{MinCut}(S,T)}{2}但是我的代码不知道为什么写炸了（ 反正这个式子应该是没问题的（ 那么告辞吧（ 闭合子图定义对于一个有向图$G$，它的一个闭合子图指的是一个顶点集合$V$，满足$V\\subset G$，且 \\forall u\\in V\\wedge(u,v)\\in G,v\\in V其中$|V|$最大的$V$被称为$G$的最大闭合子图。 如果$G$中的点有点权，$\\sum_{u\\in V}w(u)$最大的$V$被称为$G$的最大权闭合子图。 解法首先，我们还是需要将所有点权取相反数，转为求最小权闭合子图。 对于$G$中的一个点$x$，割断与$S$之间的边表示$x\\notin V$，割断与$T$之间的边表示$x\\in V$。对于$G$中的一条边$(x,y)$，如果$x\\in V$，那么一定有$y\\in V$。我们可以认为，如果令$x\\in V$，$y\\notin V$，需要付出$+\\infty$的代价。由此列出方程组 \\begin{cases} &A+B=0\\\\ &C+D=-w(x)-w(y)\\\\ &A+D+F=-w(x)\\\\ &B+C+E=-w(y)+\\infty \\end{cases} \\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\;\\; \\begin{cases} &A=0\\\\ &B=0\\\\ &C=-w(x)\\\\ &D=-w(y)\\\\ &E=+\\infty\\\\ &F=0 \\end{cases}于是，去掉所有容量为$0$的边，我们得到$(x,T,-w(x)),(y,T,-w(y)),(x,y,+\\infty)$这三条边。如果$w(x)\\geqslant 0$，我们需要把边$(S,x,0),(x,T,-w(x))$的容量都加上$w(x)$，相当于是把$(x,T,-w(x))$换成了$(S,x,w(x))$。 总结一下就是，对于原图中的一个正权点$x$，连边$(S,x,w(x))$，对于原图中的一个负权点$x$，连边$(x,T,-w(x))$。对于原图中的一条边$(x,y)$，连边$(x,y,+\\infty)$。 \\text{Ans}=\\sum_{w(x)\\geqslant 0}w(x)-\\text{MinCut}(S,T)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://github.com/Challestend/tags/网络流/"}]},{"title":"「Luogu-P3613」睡觉困难综合征","slug":"luogu-p3613-solution","date":"2019-02-15T11:25:37.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p3613-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p3613-solution/","excerpt":"传送门","text":"传送门 xjb扯以前刚学树剖时看到这题感觉好神仙啊没法做啊。 然后现在学了LCT过来一看，这不就一水题（ xjb写了棵LCT一交。 emmmmmm…… 然后改的时候才发现全是细节错误，LCT的部分动都没动一下（ 就比如说，下面是我第一次交的程序的主程序部分。 12345678910111213141516171819202122232425262728293031for(re int i=1;i&lt;=m;++i)&#123; int opt,x,y; cltstream::read(opt); cltstream::read(x); cltstream::read(y); if(opt==1)&#123; int z; //我都不知道我当时是怎么想的（ cltstream::read(z); split(mempool+x,mempool+y); re unsigned long long ans0=(mempool+y)-&gt;ans0,ans1=(mempool+y)-&gt;ans1,ans=0; for(re int j=k-1;j&gt;=0;--j) if(((ans0&gt;&gt;j)&amp;1)&gt;=((ans1&gt;&gt;j)&amp;1)||z&lt;(1&lt;&lt;j)) //甚至忘了用1ULL（ ans^=ans0&amp;(1&lt;&lt;j); else&#123; z-=1&lt;&lt;j; ans^=ans1&amp;(1&lt;&lt;j); &#125; cltstream::write(ans,10); &#125; else&#123; unsigned long long z; cltstream::read(z); access(mempool+x); (mempool+x)-&gt;tp=y; (mempool+x)-&gt;val=z; (mempool+y)-&gt;pushUp(); //？？？ &#125;&#125; 然后我Splay节点的内部信息甚至开成了unsigned，excuse me？？？ 不这个东西这不是我写的（ 真正的题解首先LCT。 不过首先的首先您还是要先做了这道题。 每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。 我们记这两个值为ans0和ans1。 左子树和节点本身的信息很好维护。 而关于右子树，看上去我们没办法迅速求出把到现在为止的ans0和ans1扔进去跑一遍的结果。 但是注意到这些都是按位运算，位与位之间不互相影响。 我们可以对于ans0中是$1$的那些位，提取出rc-&gt;ans1的对应位，对于ans0中是$0$的那些位，提取出rc-&gt;ans0的对应位。 然后ans1也类似处理就行了。 123456789101112131415161718192021222324struct SplayNode&#123; SplayNode *ftr,*lc,*rc; int tp,rev; unsigned val,ans0,ans1; inline unsigned long long apply(unsigned long long x)&#123; return tp==1?(x&amp;val):tp==2?(x|val):(x^val); &#125; /*...*/ inline void pushUp()&#123; ans0=0,ans1=-1; if(lc!=NULL)&#123; ans0=lc-&gt;ans0; ans1=lc-&gt;ans1; &#125; ans0=apply(ans0),ans1=apply(ans1); if(rc!=NULL)&#123; ans0=(ans0&amp;rc-&gt;ans1)|((~ans0)&amp;rc-&gt;ans0); ans1=(ans1&amp;rc-&gt;ans1)|((~ans1)&amp;rc-&gt;ans0); &#125; &#125;&#125;; 但是还有一个问题是，LCT在连边和提取路径时需要makeRoot，也就是说需要区间翻转。 但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。 那么提前维护好就行了。提前维护好sna0和sna1，表示把$0$和$-1$反过来跑一遍的结果。 然后就没了。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"https://github.com/Challestend/tags/树链剖分/"},{"name":"LCT","slug":"LCT","permalink":"https://github.com/Challestend/tags/LCT/"}]},{"title":"「年轻人，你渴望力量吗？」","slug":"min-25-sieve-learning-notes","date":"2019-02-13T13:41:39.000Z","updated":"2019-04-14T09:49:49.351Z","comments":true,"path":"min-25-sieve-learning-notes/","link":"","permalink":"https://github.com/Challestend/min-25-sieve-learning-notes/","excerpt":"标题来自某学长安利min_25筛的方式（","text":"标题来自某学长安利min_25筛的方式（ 概述我们知道，杜教筛可以在$O(n^{\\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。 但是现在我们希望更快。于是我们有了min_25筛（ 以下，我们约定$p$是一个质数。$\\mathbb{P}_{i}$表示第$i$小的质数，$\\mathbb{P}_{0}=0$。$\\text{minp}(n)$表示$n$最小的质因数，$\\text{minp}(1)=0$。 现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质： $f(p)$是一个可以快速求前缀和的完全积性函数，或者能用多个这样的函数运算得到。 $f(p^{k})$可以快速求，大概$O(k)$以内就可以。 第一部分我们要对每一个$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，求出 \\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)定义 F(x,y)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}\\vee\\text{minp}(i)\\gt\\mathbb{P}_{y}]f^{\\prime}(i)也就是把所有质数和最小质因数大于$\\mathbb{P}_y$的合数全部当成质数代入$f^{\\prime}$求值并求和。不难发现 F(x,+\\infty)=\\sum_{i=1}^{x}[i\\in\\mathbb{P}]f(i)我们回忆一下埃式筛法的运行过程。 筛完$k$次后，我们除去了最小质因数小于等于$\\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\\mathbb{P}_k$的合数。 可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\\prime}$的值的和。 首先，第$y$次筛掉的最小的数很明显是$\\mathbb{P}_{y}^{2}$，如果$\\mathbb{P}_{y}^{2}\\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。 也因此，筛质数筛到$\\sqrt{n}$即可。 否则，即$\\mathbb{P}_{y}^{2}\\leqslant x$，我们将所有数除以$\\mathbb{P}_{y}$，之前所有最小质因数等于$\\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\\mathbb{P}_{y}$的数。 又因为$f^{\\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\\prime}(\\cfrac{z}{\\mathbb{P}_{y}})f^{\\prime}(\\mathbb{P}_{y})$计算$f^{\\prime}(z)$。 那么看起来 F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)$包含了三类数的$f^{\\prime}$的值： 大于等于$\\mathbb{P}_{y}$的质数。 最小质因数大于等于$\\mathbb{P}_{y}$（大于$\\mathbb{P}_{y-1}$）的合数。 小于$\\mathbb{P}_{y}$的质数。 但是很明显第三类数不能被除去，因此实际上 F(x,y)=F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)综上所述 F(x,y)=\\begin{cases} &F(x,y-1)-f^{\\prime}(\\mathbb{P}_{y})\\left(F(\\lfloor\\cfrac{n}{\\mathbb{P}_{y}}\\rfloor,y-1)-\\sum\\limits_{i=1}^{y-1}f^{\\prime}(\\mathbb{P}_{i})\\right)\\;\\;&(\\mathbb{P}_{y}^{2}\\leqslant x)\\\\ &F(x,y-1)&(\\mathbb{P}_{y}^{2}\\gt x) \\end{cases}初值为 F(x,0)=\\sum_{i=2}^{x}f^{\\prime}(i)注意到第二维只与$y-1$有关，我们可以滚掉。 还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。 因为$x=\\lfloor\\cfrac{n}{i}\\rfloor(i\\in\\mathbb{N}\\cap[1,n])$，这样的$x$最多只有$2\\sqrt{n}$个，我们可以离散化存储。 具体实现细节我说不清，看代码吧（ 123456789101112131415161718192021222324252627282930313233cltstream::read(n);sq=sqrt(n);for(re int i=2;i&lt;=sq;++i)&#123; if(!f[i])&#123; g[++g[0]]=i; fsum[g[0]]=fsum[g[0]-1]+/**/; //注释处应填f`(i) &#125; for(re int j=1;j&lt;=g[0]&amp;&amp;i*g[j]&lt;=sq;++j)&#123; f[i*g[j]]=1; if(!(i%g[j])) break; &#125;&#125;m=0;for(re int l=1,r;l&lt;=n;r=n/(n/l),l=r+1)&#123; w[++m]=n/l; //编号对应的离散化前的值 F[m]=/**/; //注释处应填\\sum_&#123;t=2&#125;^&#123;w[m]&#125;f`(t) if(w[m]&lt;=sq) id1[w[m]]=m; else id2[n/w[m]]=m; //分段存储值对应的编号，这样数组只需要开到sqrt&#123;n&#125;&#125;for(re int j=1;j&lt;=g[0];++j) for(re int i=1;i&lt;=m&amp;&amp;w[i]&gt;=g[j]*g[j];++i)&#123; //w[i]&gt;=g[j]*g[j]，所以w[i]/g[j]&gt;=g[j] re int id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])]; F[i]-=/**/*(F[id]-fsum[j-1]); //注释处应填f`(g[j]) &#125; 这一部分的时间复杂度已被证明是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。然而看上去很奇怪（ 第二部分在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。 定义 S(x,y)=\\sum_{i=1}^{x}[\\text{minp}(i)\\geqslant\\mathbb{P}_{y}]f(i)也就是所有最小质因数大于等于$\\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。 首先我们需要统计所有质数的贡献，也就是$F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})$。 关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。 \\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)但是还有一个问题是$S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)$中不包括$f(1)$，因此$f(\\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来 \\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)于是 S(x,y)=F(x,+\\infty)-\\sum\\limits_{i=1}^{y-1}f(\\mathbb{P}_{i})+\\sum_{i=y}^{\\mathbb{P}_{i}^{2}\\leqslant n}\\sum_{j=1}^{\\mathbb{P}_{i}^{j+1}\\leqslant n}\\left(f(\\mathbb{P}_{i}^{j})S(\\lfloor\\cfrac{x}{\\mathbb{P}_{i}^{j}}\\rfloor,i+1)+f(\\mathbb{P}_{i}^{j+1})\\right)然后暴力搜，记忆化都不需要，时间复杂度还是$O(\\cfrac{n^{\\tfrac{3}{4}}}{\\log n})$。就很神奇（ 12345678910111213int S(re int x,re int y)&#123; if(x&lt;=1||g[y]&gt;x) return 0; else&#123; re int id=x&lt;=sq?id1[x]:id2[n/x]; re int res=F[id]-fsum[y-1]; for(re int i=y;i&lt;=g[0]&amp;&amp;g[i]*g[i]&lt;=x;++i) for(re int p=g[i];p*g[i]&lt;=x;p*=g[i]) res+=/*1*/*S(x/p,i+1)+/*2*/; //1处应填f(p)，2处应填f(p*g[i]) return res; &#125;&#125; 「Luogu-P4213」「模板」杜教筛（Sum）首先我们有 \\varphi(p)=\\text{id}(p)-1\\mu(p)=-1然后$\\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。 说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register#define maxn 50000namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int t,n,sq,m;int f[maxn+1],g[maxn+1],w[(maxn&lt;&lt;1)+1],id1[maxn+1],id2[maxn+1];int prmcnt[maxn+1],prmCnt[(maxn&lt;&lt;1)+1];long long prmsum[maxn+1],prmSum[(maxn&lt;&lt;1)+1];long long getPhi(re int x,re int y)&#123; if(x&lt;=1||g[y]&gt;x) return 0; else&#123; re int id=x&lt;=sq?id1[x]:id2[n/x]; re long long res=(prmSum[id]-prmCnt[id])-(prmsum[y-1]-prmcnt[y-1]); for(re int i=y;i&lt;=g[0]&amp;&amp;1LL*g[i]*g[i]&lt;=x;++i) for(re int p=g[i];1LL*p*g[i]&lt;=x;p*=g[i]) res+=1LL*p/g[i]*(g[i]-1)*getPhi(x/p,i+1)+1LL*p*(g[i]-1); return res; &#125;&#125;int getMu(re int x,re int y)&#123; if(x&lt;=1||g[y]&gt;x) return 0; else&#123; re int id=x&lt;=sq?id1[x]:id2[n/x]; re int res=prmcnt[y-1]-prmCnt[id]; for(re int i=y;i&lt;=g[0]&amp;&amp;1LL*g[i]*g[i]&lt;=x;++i) res-=getMu(x/g[i],i+1); return res; &#125;&#125;int main()&#123; for(re int i=2;i&lt;=maxn;++i)&#123; if(!f[i])&#123; g[++g[0]]=i; prmcnt[g[0]]=prmcnt[g[0]-1]+1; prmsum[g[0]]=prmsum[g[0]-1]+i; &#125; for(re int j=1;j&lt;=g[0]&amp;&amp;1LL*i*g[j]&lt;=maxn;++j)&#123; f[i*g[j]]=1; if(!(i%g[j])) break; &#125; &#125; cltstream::read(t); for(;t;--t)&#123; cltstream::read(n); sq=sqrt(n); m=0; for(re int l=1,r;l&lt;=n;r=n/(n/l),l=r+1)&#123; w[++m]=n/l; prmCnt[m]=w[m]-1; prmSum[m]=1LL*(w[m]-1)*(w[m]+2)/2; if(w[m]&lt;=sq) id1[w[m]]=m; else id2[n/w[m]]=m; &#125; for(re int j=1;j&lt;=g[0];++j) for(re int i=1;i&lt;=m&amp;&amp;w[i]&gt;=1LL*g[j]*g[j];++i)&#123; re int id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])]; prmCnt[i]-=prmCnt[id]-prmcnt[j-1]; prmSum[i]-=1LL*g[j]*(prmSum[id]-prmsum[j-1]); &#125; cltstream::write(getPhi(n,1)+1,32); cltstream::write(getMu(n,1)+1,10); &#125; clop(); return 0;&#125; 上为min_25筛，下为杜教筛。 min_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说 「LOJ6053」简单的函数总结一下这个函数： f(1)=1f\\left(\\prod_{i=1}^{N}p_{i}^{r_{i}}\\right)=\\prod_{i=1}^{N}(p_{i}\\otimes r_{i})其中$\\otimes$表示按位异或。 按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（ 注意到 f(p)=p\\otimes 1=\\begin{cases} &p+1\\;\\;&(p=2)\\\\ &p-1\\;\\;&(p\\gt 2) \\end{cases}我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。 然后还是要用min_25筛的前半部分筛出$\\text{id}$和$1$，其实和上面的$\\varphi$没多大区别就是加了点细节（ 好像这种能随便看代码的OJ可以直接扔个提交记录。 「UOJ188」Sanrd次大质因数和。 其实这个题面有点考阅读的。 但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。说好的只能筛积性函数呢（ 我们来分析一下min_25筛的运行过程。 调用到$S(x,y)$时，剩下的最小质因数大于等于$\\mathbb{P}_{y}$的数中，只有质数与$\\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\\mathbb{P}_{y-1}$的数。这部分可以直接算。 关于次大质因数大于$\\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\\mathbb{P}_{i}^{j})$，手动加。 123456789101112long long S(re long long n,re long long x,re int y)&#123; if(x&lt;=1||g[y]&gt;x) return 0; else&#123; re int k=id[x&lt;=sq?x:n/x+sq]; re long long res=(y&gt;1?g[y-1]:0)*(prmCnt[k]-y+1); for(re int i=y;i&lt;=g[0]&amp;&amp;1LL*g[i]*g[i]&lt;=x;++i) for(re long long p=g[i];p*g[i]&lt;=x;p*=g[i]) res+=S(n,x/p,i+1)+g[i]; return res; &#125;&#125; 提交记录。 一道比一道神仙，像我这种菜鸡只能抄题解了（ 课后习题 「LOJ572」「LibreOJ Round #11」Misaka Network与求和 「SP34096」DIVCNTK - Counting Divisors (general) 「SP19985」GCDEX2 - GCD Extreme (hard) 「SP19975」APS2 - Amazing Prime Sequence (hard) 其它文献 https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096 https://www.cnblogs.com/zhoushuyu/p/9187319.html https://www.cnblogs.com/cjyyb/p/10169190.html","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"min_25筛","slug":"min-25筛","permalink":"https://github.com/Challestend/tags/min-25筛/"}]},{"title":"动态树学习笔记","slug":"link-cut-tree-learning-notes","date":"2019-01-21T02:57:11.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"link-cut-tree-learning-notes/","link":"","permalink":"https://github.com/Challestend/link-cut-tree-learning-notes/","excerpt":"24号要出去学习，趁现在先自己xjb学点啥。","text":"24号要出去学习，趁现在先自己xjb学点啥。 基本概念首先我们有一道模板题。 我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。 这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\\log^{2}n)$。 但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。 很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。 实链剖分一般被称为LCT，全称Link-Cat Tree Linear Challestend Transformation Link-Cut Tree，也就是动态树。 与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。 为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质： 每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。 每个节点属于且仅属于一棵Splay。 如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。 不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。 以下图片来自https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。 我们来看这样一棵树 其中粗线表示实边，虚线表示虚边。 它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。 当然这并不是唯一的。 为了方便，我先放出我Splay的代码实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct SplayNode&#123; SplayNode *ftr,*ls,*rs; int val,sum,rev; inline int isRoot()&#123; return ftr==NULL||(ftr-&gt;ls!=this&amp;&amp;ftr-&gt;rs!=this); //判断一个节点是否是原森林中的一棵树的树根 &#125; inline void reverse()&#123; std::swap(ls,rs); rev^=1; &#125; inline void pushDown()&#123; if(rev)&#123; if(ls!=NULL) ls-&gt;reverse(); if(rs!=NULL) rs-&gt;reverse(); rev=0; &#125; &#125; inline void pushUp()&#123; sum=val; if(ls!=NULL) sum^=ls-&gt;sum; if(rs!=NULL) sum^=rs-&gt;sum; &#125;&#125;;SplayNode mempool[maxn+1];inline void rotate(re SplayNode* p)&#123; re SplayNode* q=p-&gt;ftr; q-&gt;pushDown(); p-&gt;pushDown(); p-&gt;ftr=q-&gt;ftr; if(p-&gt;ftr!=NULL)&#123; if(p-&gt;ftr-&gt;ls==q) p-&gt;ftr-&gt;ls=p; if(p-&gt;ftr-&gt;rs==q) p-&gt;ftr-&gt;rs=p; &#125; if(q-&gt;rs==p)&#123; q-&gt;rs=p-&gt;ls; if(q-&gt;rs!=NULL) q-&gt;rs-&gt;ftr=q; p-&gt;ls=q; q-&gt;ftr=p; &#125; else&#123; q-&gt;ls=p-&gt;rs; if(q-&gt;ls!=NULL) q-&gt;ls-&gt;ftr=q; p-&gt;rs=q; q-&gt;ftr=p; &#125; q-&gt;pushUp(); p-&gt;pushUp();&#125;inline void splay(re SplayNode* p)&#123;//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可 for(;!p-&gt;isRoot();rotate(p)) if(!p-&gt;ftr-&gt;isRoot()) rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);&#125; access首先我们有一个基本操作 1void access(SplayNode*) 首先有一个问题是，这个单词怎么读？ /ək&#39;ses/？不不不应该是/&#39;ækses/。 如果您有兴趣，可以在这里看看自己以前都读错了多少单词（ 这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。 我们来看看这个函数的具体过程。还是上面的例子，现在我们调用access(N)，整棵树会变成这样 虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（ 首先我们调用splay(N)，令$\\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。 向上找到$\\text{N}$的父亲$\\text{I}$，调用splay(I)，回收$\\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\\text{N}$，然后$\\text{N}$就成了$\\text{I}$的实儿子了。 然后继续向上，找到$\\text{I}$的父亲$\\text{H}$，调用splay(H)，并令$\\text{H}$的右儿子指针指向$\\text{I}$。 最后一步，找到$\\text{H}$的父亲$\\text{A}$，调用splay(A)，并令$\\text{A}$的右儿子指针指向$\\text{H}$。 然后我们看到，$\\text{N}$和$\\text{A}$到了同一颗Splay中，完成任务，返回。 代码实现： 1234567891011121314inline void access(re SplayNode* p)&#123; splay(p); p-&gt;pushDown(); p-&gt;rs=NULL; p-&gt;pushUp(); for(re SplayNode* q=p;q-&gt;ftr!=NULL;q=q-&gt;ftr)&#123; splay(q-&gt;ftr); q-&gt;ftr-&gt;pushDown(); q-&gt;ftr-&gt;rs=q; q-&gt;ftr-&gt;pushUp(); &#125; splay(p); //据说闲着没事瞎转转有利于摊开时间复杂度（&#125; findRoot有了access，我们就可以随心所欲的瞎搞了。比如说 1SplayNode* findRoot(SplayNode*) 返回给定节点所在的树的树根，也就是调用完access后它所在的实链上深度最小的节点。 因为access的最后自带了一个splay，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。 123456inline SplayNode* findRoot(re SplayNode* p)&#123; access(p); for(;p-&gt;ls!=NULL;p=p-&gt;ls); splay(p); return p;&#125; makeRoot &amp;&amp; split现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。 不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用access(x)，然后考虑翻转$x$的子树之后会发生什么。 access结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。 那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次access(y)就可以把它抽出来。 我们实现下面两个函数 1void makeRoot(SplayNode*) 令给定节点成为树根。 1void split(SplayNode*,SplayNode*) 抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。 123456789inline void makeRoot(re SplayNode* p)&#123; access(p); p-&gt;reverse();&#125;inline void split(re SplayNode* p,re SplayNode* q)&#123; makeRoot(p); access(q);&#125; link我们需要实现函数 1void link(SplayNode*,SplayNode*) 在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。 思路很简单。假设我们指定$x$和$y$两个节点，首先调用makeRoot(x)，然后检查findRoot(y)的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即findRoot(y)==x，说明两个节点联通，直接返回。 12345inline void link(re SplayNode* p,re SplayNode* q)&#123; makeRoot(p); if(findRoot(q)!=p) p-&gt;ftr=q;&#125; cut我们需要实现函数 1void cut(SplayNode*,SplayNode*) 切断给定的两个节点之间的边。不存在就什么也不做。 需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用makeRoot(x)，此时$y$应该是$x$的右儿子，并且它不能有左儿子。 1234567inline void cut(re SplayNode* p,re SplayNode* q)&#123; makeRoot(p); if(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==NULL)&#123; q-&gt;ftr=p-&gt;rs=NULL; p-&gt;pushUp(); &#125;&#125; 把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。 完整板子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define re register#define maxn 300000namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125; template &lt;typename _tp&gt; inline void swap(_tp&amp; x,_tp&amp; y)&#123; _tp z=x; x=y; y=z; &#125;&#125;struct LinkCutTree&#123; struct SplayNode&#123; SplayNode *ftr,*ls,*rs; int val,sum,rev; inline int isRoot()&#123; return ftr==NULL||(ftr-&gt;ls!=this&amp;&amp;ftr-&gt;rs!=this); &#125; inline void reverse()&#123; std::swap(ls,rs); rev^=1; &#125; inline void pushDown()&#123; if(rev)&#123; if(ls!=NULL) ls-&gt;reverse(); if(rs!=NULL) rs-&gt;reverse(); rev=0; &#125; &#125; inline void pushUp()&#123; sum=val; if(ls!=NULL) sum^=ls-&gt;sum; if(rs!=NULL) sum^=rs-&gt;sum; &#125; &#125;; SplayNode mempool[maxn+1]; inline void rotate(re SplayNode* p)&#123; re SplayNode* q=p-&gt;ftr; q-&gt;pushDown(); p-&gt;pushDown(); p-&gt;ftr=q-&gt;ftr; if(p-&gt;ftr!=NULL)&#123; if(p-&gt;ftr-&gt;ls==q) p-&gt;ftr-&gt;ls=p; if(p-&gt;ftr-&gt;rs==q) p-&gt;ftr-&gt;rs=p; &#125; if(q-&gt;rs==p)&#123; q-&gt;rs=p-&gt;ls; if(q-&gt;rs!=NULL) q-&gt;rs-&gt;ftr=q; p-&gt;ls=q; q-&gt;ftr=p; &#125; else&#123; q-&gt;ls=p-&gt;rs; if(q-&gt;ls!=NULL) q-&gt;ls-&gt;ftr=q; p-&gt;rs=q; q-&gt;ftr=p; &#125; q-&gt;pushUp(); p-&gt;pushUp(); &#125; inline void splay(re SplayNode* p)&#123; for(;!p-&gt;isRoot();rotate(p)) if(!p-&gt;ftr-&gt;isRoot()) rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p); &#125; inline void build(re int n)&#123; for(re int i=1;i&lt;=n;++i)&#123; re SplayNode* p=mempool+i; p-&gt;ftr=p-&gt;ls=p-&gt;rs=NULL; cltstream::read(p-&gt;val); p-&gt;sum=p-&gt;val; p-&gt;rev=0; &#125; &#125; inline void access(re SplayNode* p)&#123; splay(p); p-&gt;pushDown(); p-&gt;rs=NULL; p-&gt;pushUp(); for(re SplayNode* q=p;q-&gt;ftr!=NULL;q=q-&gt;ftr)&#123; splay(q-&gt;ftr); q-&gt;ftr-&gt;pushDown(); q-&gt;ftr-&gt;rs=q; q-&gt;ftr-&gt;pushUp(); &#125; splay(p); &#125; inline SplayNode* findRoot(re SplayNode* p)&#123; access(p); for(;p-&gt;ls!=NULL;p=p-&gt;ls); splay(p); return p; &#125; inline void makeRoot(re SplayNode* p)&#123; access(p); p-&gt;reverse(); &#125; inline void split(re SplayNode* p,re SplayNode* q)&#123; makeRoot(p); access(q); &#125; inline void link(re SplayNode* p,re SplayNode* q)&#123; makeRoot(p); if(findRoot(q)!=p) p-&gt;ftr=q; &#125; inline void cut(re SplayNode* p,re SplayNode* q)&#123; makeRoot(p); if(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==NULL)&#123; q-&gt;ftr=p-&gt;rs=NULL; p-&gt;pushUp(); &#125; &#125; inline int queryPathXorSum(re int x,re int y)&#123; split(mempool+x,mempool+y); return (mempool+y)-&gt;sum; &#125; inline void createEdge(re int x,re int y)&#123; link(mempool+x,mempool+y); &#125; inline void destoryEdge(re int x,re int y)&#123; cut(mempool+x,mempool+y); &#125; inline void modifyVertice(re int x,re int y)&#123; splay(mempool+x); (mempool+x)-&gt;val=y; (mempool+x)-&gt;pushUp(); &#125; void printTree(re SplayNode* p)&#123; if(p!=NULL)&#123; p-&gt;pushDown(); printTree(p-&gt;ls); printf( \"%d(%d,%d,%d)\\n\", p-mempool, p-&gt;ftr!=NULL?p-&gt;ftr-mempool:-1, p-&gt;ls!=NULL?p-&gt;ls-mempool:-1, p-&gt;rs!=NULL?p-&gt;rs-mempool:-1 ); printTree(p-&gt;rs); &#125; &#125;&#125;;int n,m;LinkCutTree QAQ;int main()&#123;\\ cltstream::read(n); cltstream::read(m); QAQ.build(n); for(re int i=1;i&lt;=m;++i)&#123; int opt,x,y; cltstream::read(opt); cltstream::read(x); cltstream::read(y); switch(opt)&#123; case 0: cltstream::write(QAQ.queryPathXorSum(x,y),10); break; case 1: QAQ.createEdge(x,y); break; case 2: QAQ.destoryEdge(x,y); break; case 3: QAQ.modifyVertice(x,y); break; &#125; &#125; clop(); return 0;&#125; 是不是感觉很好写呢（ 用LCT维护子树信息咕咕咕。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"https://github.com/Challestend/tags/LCT/"},{"name":"Splay","slug":"Splay","permalink":"https://github.com/Challestend/tags/Splay/"}]},{"title":"2019-01-20：loli的两场模拟赛的题解","slug":"lolioi-2019-01-20-solutions","date":"2019-01-20T09:43:14.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"lolioi-2019-01-20-solutions/","link":"","permalink":"https://github.com/Challestend/lolioi-2019-01-20-solutions/","excerpt":"今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。 上午记为D1，下午记为D2。","text":"今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。 上午记为D1，下午记为D2。 D1T1 简 - simple给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。 $n\\leqslant 100000$。 不予置评。 T2 单 - single给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义 b_{u}=\\sum_{i=1}^{n}dist(u,i)a_{i}还会给你一个$\\text{tp}$，$\\text{tp}=0$时给你$\\{a_{n}\\}$让你求$\\{b_{n}\\}$，$\\text{tp}=1$时给你$\\{b_{n}\\}$让你求$\\{a_{n}\\}$。多组数据。 $n\\leqslant 100000,T\\leqslant 5$。 $\\text{tp}=0$时就是一个简单的树形DP。 $\\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（ 他给的题解我也没看懂（ 我就打了$\\text{tp}=0$的$30$分。 T3 题 - problem有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。 关于$S$，首先会给你一个$\\text{tp}$，然后$S$如下定义 S=\\begin{cases} &\\{(x,y)\\mid x,y\\in\\mathbb{Z}\\}\\;\\;&(\\text{tp}=0)\\\\ &\\{(x,y)\\mid x\\in\\mathbb{N},y=0\\}&(\\text{tp}=1)\\\\ &\\{(x,y)\\mid xy=0\\}&(\\text{tp}=2)\\\\ &\\{(x,y)\\mid x,y\\in\\mathbb{N}\\}&(\\text{tp}=3) \\end{cases}$n\\leqslant 100000$，$n\\equiv 0\\pmod{2}$，$\\text{tp}\\in\\{0,1,2,3\\}$。特殊地，当$\\text{tp}=2$时$n\\leqslant 1000$。 四合一数论提答（ 很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。 $\\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此 \\text{Ans}=(2n)!\\sum_{i=0}^{n}\\cfrac{1}{i!i!(n-i)!(n-i)!}$\\text{tp}=1$直接卡特兰数。 $\\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。 如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP f[x]=\\sum_{i=1}^{x}f[x-i]\\cfrac{(2i)!}{i!i!}其实如果改一下模数的话这个东西可以用NTT优化到$O(n\\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（ $\\text{tp}=3$大概是$\\text{tp}=0$与$\\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是 \\begin{aligned} \\text{Ans}&=\\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\\\ &=\\sum_{i=0}^{n}\\cfrac{(2n)!}{(2i)!(2(n-i))!}\\left(\\cfrac{(2i)!}{i!i!}-\\cfrac{(2i)!}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\\right)\\\\ &=(2n)!\\sum_{i=0}^{n}\\left(\\cfrac{1}{i!i!}-\\cfrac{1}{(i+1)!(i-1)!}\\right)\\left(\\cfrac{1}{(n-i)!(n-i)!}-\\cfrac{1}{(n-i+1)!(n-i-1)!}\\right) \\end{aligned}于是愉快地$230$直接rank1（ 话说wzx打了$240$分的啊……然而炸成$210$（ D2T1 印章 - seal给你一张$n\\times m$的纸，上面有些格子要印墨水。你有一个$r\\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。 $n,m,r,c\\leqslant 1000,T\\leqslant 10$。 首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个bitset瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（ 拿了$60$就跑（ T2 多边形 - polygon一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。 这是一个$0-4$边形 这是一个$1-4$边形 这是一个$2-4$边形 给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。 $0\\leqslant k\\leqslant 10^{6},3\\leqslant n\\leqslant 10^{9}$。 告辞（ 彻底放弃治疗（ T3 扔球 - ball给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。 所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\\{a_{n}\\}$的期望逆序对数量。四舍五入保留两位小数。 如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。 $n\\leqslant 500000,0.4\\leqslant p\\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\\Sigma|S_{i}|\\leqslant 500000$。 从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。 套个树状数组就行。 但是等会，$a_{x}=y$的概率怎么算啊。 首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是 \\begin{aligned} \\lim_{n\\rightarrow+\\infty}\\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\\\ &=\\cfrac{p}{1-(1-p)^{|S_{x}|}} \\end{aligned}那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为 \\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}最后总分只有$160$，被$190$分的wzx吊着打（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"loli","slug":"loli","permalink":"https://github.com/Challestend/tags/loli/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://github.com/Challestend/tags/模拟赛/"}]},{"title":"「HEOI2016/TJOI2016」求和","slug":"luogu-p4091-solution","date":"2019-01-17T03:28:06.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p4091-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p4091-solution/","excerpt":"传送门 感觉最近意志消沉啥也不想干，于是继续来颓blog（","text":"传送门 感觉最近意志消沉啥也不想干，于是继续来颓blog（ 仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（ 首先我们知道如果$n\\gt m$，$S(n,m)=0$。于是我们将原式写成 \\sum_{i=0}^{n}\\sum_{j=0}^{n}2^{j}j!S(i,j)=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)第二类斯特林数有一个通项公式，它长这样 S(n,m)=\\cfrac{1}{m!}\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现 F(n,m,k)=C(m,k)(m-k)^{n}然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现 G(n,m)=\\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。 然后我们继续推式子 \\begin{aligned} \\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}S(i,j)&=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\\\ &=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\cfrac{1}{j!}\\sum_{k=0}^{j}(-1)^{k}\\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\\\ &=\\sum_{j=0}^{n}2^{j}j!\\sum_{i=0}^{n}\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\\\ &=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i} \\end{aligned}我们看到右边就是一个等比数列求和，于是 \\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!(j-k)!}\\sum_{i=0}^{n}(j-k)^{i}=\\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}定义 F[i]=\\cfrac{(-1)^{i}}{i!}右边的等比数列求和比较麻烦，我们需要一些特判。 G[i]=\\begin{cases} &1&(i=0)\\\\ &n+1&(i=1)\\\\ &\\cfrac{i^{n+1}-1}{i!(i-1)}\\;\\;&(i>1) \\end{cases}然后我们就有 \\sum_{j=0}^{n}2^{j}j!\\sum_{k=0}^{j}\\cfrac{(-1)^{k}}{k!}\\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\\sum_{j=0}^{n}2^{j}j!(F\\times G)[j]这么一想前几天的我还只会暴力二项式定理展开（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"},{"name":"HEOI","slug":"HEOI","permalink":"https://github.com/Challestend/tags/HEOI/"},{"name":"TJOI","slug":"TJOI","permalink":"https://github.com/Challestend/tags/TJOI/"},{"name":"2016","slug":"2016","permalink":"https://github.com/Challestend/tags/2016/"}]},{"title":"有上下界的网络流问题与预留推进学习笔记","slug":"something-about-network-flow-learning-notes","date":"2019-01-14T13:18:08.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"something-about-network-flow-learning-notes/","link":"","permalink":"https://github.com/Challestend/something-about-network-flow-learning-notes/","excerpt":"感觉最近好颓啊（ 这是一篇正在咕咕咕的blog。","text":"感觉最近好颓啊（ 这是一篇正在咕咕咕的blog。 无源汇有上下界可行流我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\\text{upper}(e)-\\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令 w(u)=\\sum_{v\\in V,(v,u)\\in E}\\text{lower}((v,u))-\\sum_{v\\in V,(u,v)\\in E}\\text{lower}((u,v)) 如果$w(u)=0$，说明我们不需要对点$u$做出调整。 如果$w(u)\\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。 如果$w(u)\\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。 然后直接跑一边从源点到汇点的最大流即可。 需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。 否则，我们就已经构造出了一组可行解。 有源汇有上下界最大流这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。 我们可以从汇点到源点连一条流量上界为$+\\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。 需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。 当然，求解可行流时无解的话，整个问题无解。 有源汇有上下界最小流还没看懂，先咕着。 最高标号预流推进（HLPP-Highest Label Preflow Pushing？）还没看懂，先咕着。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"https://github.com/Challestend/tags/网络流/"},{"name":"最大流","slug":"最大流","permalink":"https://github.com/Challestend/tags/最大流/"},{"name":"预留推进","slug":"预留推进","permalink":"https://github.com/Challestend/tags/预留推进/"}]},{"title":"类欧几里得算法学习笔记","slug":"similar-euclid-algorithm-learning-notes","date":"2019-01-10T05:37:33.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"similar-euclid-algorithm-learning-notes/","link":"","permalink":"https://github.com/Challestend/similar-euclid-algorithm-learning-notes/","excerpt":"其实我也不知道这个算法的英文名是啥（ 我就yy出来一个「Similar Euclid Algorithm」（","text":"其实我也不知道这个算法的英文名是啥（ 我就yy出来一个「Similar Euclid Algorithm」（ 给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出 \\sum_{i=0}^{n}i^{k_{1}}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{k_{2}}\\pmod{1000000007}$n,a,b,c\\leqslant 10^{9}$，$k_{1}+k_{2}\\leqslant 10$。 太难了，告辞（ 所以我们现在来研究简单一点的。 给你四个非负整数$n,a,b,c$，你需要求出 \\begin{aligned} f(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\ g(n,a,b,c)&\\equiv\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\ h(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\pmod{998244353} \\end{aligned}$n,a,b,c\\leqslant 10^{9}$，$10^{5}$组询问。 传送门 于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。 首先考虑$f(n,a,b,c)$，假设$a\\geqslant c\\vee b\\geqslant c$ \\begin{aligned} f(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\ &=\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\\\ &=f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor \\end{aligned}也就是说，我们只需要重点关注$a\\lt c\\wedge b\\lt c$时的情况即可。我们令$m=\\lfloor\\cfrac{an+b}{c}\\rfloor$，然后继续往下推 \\begin{aligned} f(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\sum_{j=1}^{m}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\leqslant ai+b\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\geqslant cj+c-b\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\geqslant\\cfrac{cj+c-b}{a}\\right]\\\\ \\end{aligned}然后我们发现，我们可能需要在$\\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。 考虑转换一下思路。既然$cj+c\\leqslant ai+b$，我们就有$cj+c\\lt ai+b+1$，然后再往下 \\begin{aligned} f(n,a,b,c)&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\lt ai+b+1\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\gt cj+c-b-1\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\\\\ &=\\sum_{j=0}^{m-1}\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\ &=mn-\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\ &=mn-f(m-1,c,c-b-1,a) \\end{aligned}然后我们看到，这个函数它递归了！ 注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\\log a$次，时间复杂度就是$O(\\log a)$了。 然后考虑$g(n,a,b,c)$。 $a\\geqslant c\\vee b\\geqslant c$： \\begin{aligned} g(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\left(i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor+i\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\ &=\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\\\ &=g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor \\end{aligned}$a\\lt c\\wedge b\\lt c$，当然$m$还是$\\lfloor\\cfrac{an+b}{c}\\rfloor$： \\begin{aligned} g(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\sum_{j=1}^{m}i\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}i\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right] \\end{aligned}我们可以把上面这个式子理解成$\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor$且$\\leqslant n$的所有自然数之和，于是差分一下我们得到 \\begin{aligned} g(n,a,b,c)&=\\sum_{j=0}^{m-1}\\left(\\cfrac{n(n+1)}{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\ &=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\ &=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a) \\end{aligned}我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。 $a\\geqslant c\\vee b\\geqslant c$： \\begin{aligned} h(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\ &=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)^{2}\\\\ &=\\sum_{i=0}^{n}\\left( \\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2} +i^{2}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +\\lfloor\\cfrac{b}{c}\\rfloor^{2} +2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +2\\lfloor\\cfrac{b}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor \\right)\\\\ &= \\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2} +\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\\\\& +2\\lfloor\\cfrac{a}{c}\\rfloor\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +2\\lfloor\\cfrac{b}{c}\\rfloor\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor \\\\ &= h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\& +\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2} +n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor \\end{aligned}您绝对想象不到上面这一坨子东西的$\\TeX$源码长什么样（ $a\\lt c\\wedge b\\lt c$： \\begin{aligned} h(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\ &=\\sum_{i=0}^{n}\\sum_{j=1}^{m^{2}}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[c^{2}j+c^{2}\\lt a^{2}i^{2}+2abi+b^{2}+1\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[i\\gt\\sqrt{\\lfloor\\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\\rfloor}\\right] \\end{aligned} 然后我们发现推不下去了。 不过办法总是有的。首先我们有一个看起来没啥用的式子 x^{2}=2\\sum_{i=1}^{n}i-x套进去 \\begin{aligned} h(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\ &=\\sum_{i=0}^{n}\\left(2\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right)\\\\ &=2\\sum_{i=0}^{n}\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=2\\sum_{j=1}^{m}j\\sum_{i=0}^{n}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]-f(n,a,b,c)\\\\ &=2\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^{n}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]-f(n,a,b,c)\\\\ &=2\\sum_{j=0}^{m-1}(j+1)\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)-f(n,a,b,c)\\\\ &=m(m+1)n-2\\sum_{j=0}^{m-1}j\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-2\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-f(n,a,b,c)\\\\ &=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\\ \\end{aligned}然后我们看到它奇迹般地递归了！ 我们来总结一下。 f(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases} &f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\ &mn-f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c) \\end{cases}g(n,a,b,c)=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases} &g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\ &\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c) \\end{cases}h(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}=\\begin{cases} &h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\& +\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2} +n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\\;\\; &(a\\geqslant c\\vee b\\geqslant c)\\\\ &m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\\lt c\\wedge b\\lt c) \\end{cases}但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样： f(n,a,b,c)=\\begin{cases} &\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(n=0)\\\\ &(n+1)\\lfloor\\cfrac{b}{c}\\rfloor&(a=0) \\end{cases}g(n,a,b,c)=\\begin{cases} &0\\;\\;&(n=0)\\\\ &\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor&(a=0) \\end{cases}h(n,a,b,c)=\\begin{cases} &\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(n=0)\\\\ &(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(a=0) \\end{cases}另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#define re register#define mod 998244353namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int t,a,b,c,n,I2=499122177,I6=166374059;struct Query&#123; int f,g,h; Query(re int _f,re int _g,re int _h)&#123; f=_f; g=_g; h=_h; &#125;&#125;;inline Query query(re int a,re int b,re int c,re int n)&#123; if(!n)&#123; b/=c; return Query(b,0,1LL*b*b%mod); &#125; if(!a)&#123; b/=c; return Query(1LL*(n+1)*b%mod,1LL*n*(n+1)%mod*I2%mod*b%mod,1LL*(n+1)*b%mod*b%mod); &#125; if(a&gt;=c||b&gt;=c)&#123; re Query res=query(a%c,b%c,c,n); a/=c, b/=c; return Query( (res.f+1LL*n*(n+1)%mod*I2%mod*a%mod+1LL*(n+1)*b%mod)%mod, (res.g+1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod+1LL*n*(n+1)%mod*I2%mod*b%mod)%mod, (res.h+2LL*a*res.g%mod+2LL*b*res.f%mod +1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod*a%mod +1LL*(n+1)*b%mod*b%mod+1LL*n*(n+1)%mod*a%mod*b%mod)%mod ); &#125; else&#123; re int m=(1LL*a*n+b)/c; re Query res=query(c,c-b-1,a,m-1); re int tmp=((1LL*m*n%mod-res.f)%mod+mod)%mod; return Query( tmp, ((1LL*m*n%mod*(n+1)%mod-res.h-res.f)%mod+mod)*I2%mod, ((1LL*m*(m+1)%mod*n%mod-2LL*res.g%mod-2LL*res.f%mod-tmp)%mod+mod)%mod ); &#125;&#125;int main()&#123; cltstream::read(t); for(;t;--t)&#123; cltstream::read(n); cltstream::read(a); cltstream::read(b); cltstream::read(c); Query ans=query(a,b,c,n); cltstream::write(ans.f,32); cltstream::write(ans.h,32); cltstream::write(ans.g,10); &#125; clop(); return 0;&#125; 那么问题来了，这个东西有什么用啊。 没啥用（ 其他的模板题我就不举了，我们来看一下这样一道题。 看到推平操作我们可以直接往珂朵莉树上想了。 那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息l,r,L,R,a,b，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\\sum_{i=L}^{R}ai\\operatorname{mod}b$颗石头。注意这里的l,r,L,R一定不要搞混，我就是因为这样WA了整整四遍（。 这三个样例一定是故意的。 然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样： \\sum_{i=L}^{R}ai\\operatorname{mod}b=\\sum_{i=L}^{R}\\left(ai-\\lfloor\\cfrac{ai}{b}\\rfloor b\\right)=\\cfrac{(R+L)(R-L+1)}{2}-\\sum_{i=0}^{R}\\lfloor\\cfrac{ai}{b}\\rfloor b+\\sum_{i=0}^{L-1}\\lfloor\\cfrac{ai}{b}\\rfloor b直接一波板子套上去。 还有就是，这么算的话中间量会爆long long，我们可以考虑用__int128_t来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以 123#ifdef ONLINE_JUDGE #define int __int128_t#endif 然后把一些没必要用或者是不能用__int128_t的改成signed即可。 代码还是有必要贴一下的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;set&gt;#define re register#define _it std::set&lt;node&gt;::iterator#ifdef ONLINE_JUDGE #define int __int128_t#endifnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; signed sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; signed digit[50]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m;inline int simEuc(re int n,re int a,re int b,re int c)&#123; if(!n) return b/c; if(!a) return (n+1)*(b/c); if(a&gt;=c||b&gt;=c)&#123; re int res=simEuc(n,a%c,b%c,c); return res+n*(n+1)*(a/c)/2+(n+1)*(b/c); &#125; else&#123; re int m=(a*n+b)/c; return m*n-simEuc(m-1,c,c-b-1,a); &#125;&#125;struct node&#123; int l,r,L,R,a,b,sum; node(re int _l,re int _r,re int _L,re int _R,re int _a,re int _b)&#123; l=_l; r=_r; L=_L; R=_R; a=_a; b=_b; sum=(R+L)*(R-L+1)*a/2-simEuc(R,a,0,b)*b+simEuc(L-1,a,0,b)*b; &#125;&#125;;std::set&lt;node&gt; s;inline bool operator&lt;(re node p1,re node p2)&#123; return p1.l&lt;p2.l;&#125;inline _it split(re int pos)&#123; re _it it=s.lower_bound(node(pos,0,1,0,0,1)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; else&#123; --it; re int l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b; s.erase(it); s.insert(node(l,pos-1,L,L+pos-l-1,a,b)); return s.insert(node(pos,r,L+pos-l,R,a,b)).first; &#125;&#125;inline void modifyStone(re int l,re int r,re int a,re int b)&#123; re _it itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(node(l,r,1,r-l+1,a,b));&#125;inline int queryStone(re int l,re int r)&#123; re _it itr=split(r+1),itl=split(l); re int res=0; for(;itl!=itr;res+=itl-&gt;sum,++itl); return res;&#125;signed main()&#123; cltstream::read(n); cltstream::read(m); s.insert(node(1,n,1,0,0,1)); for(re int i=1;i&lt;=m;++i)&#123; re int opt,l,r,a,b; cltstream::read(opt); cltstream::read(l); cltstream::read(r); if(opt==1)&#123; cltstream::read(a); cltstream::read(b); modifyStone(l,r,a,b); &#125; else cltstream::write(queryStone(l,r),10); &#125; clop(); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"类欧几里得","slug":"类欧几里得","permalink":"https://github.com/Challestend/tags/类欧几里得/"}]},{"title":"「HEOI2012」采花","slug":"luogu-p4113-solution","date":"2019-01-07T11:05:03.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p4113-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p4113-solution/","excerpt":"传送门 Taduro的题解 sto Taduro orz","text":"传送门 Taduro的题解 sto Taduro orz 首先，读完题一定有人要跳出来喊「莫队！」。 莫队！ 然后再一看数据范围 对于$100\\%$的数据，$1\\leqslant c\\leqslant n,m\\leqslant 2\\times 10^{6}$。 笑容逐渐消失。 然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了，树状数组什么时候有这种操作了。 首先这个样例比较菜，我们手造一个： 11 6 2 4 2 3 6 2 首先我们维护一个nxt数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的nxt差不多长这样： i $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ nxt[i] $0$ $7$ $5$ $0$ $8$ $0$ $0$ $0$ 然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。 然后我们还需要一个数组ans，对于每一种颜色，我们令其在指针所在位置及其之后的部分中第二次出现的位置的ans为$1$。 i $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ 因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。 不难发现，此时$\\sum_{i=1}^{x}ans[i]$就是询问1 x的答案。 需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的ans置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。 这个时候nxt数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。 让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）： i $\\underline{1}$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ i $1$ $\\underline{2}$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ i $1$ $2$ $\\underline{3}$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ ${\\color{red}6}$ $2$ $4$ $2$ $3$ ${\\color{red}6}$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ ${\\color{red}0}$ $0$ i $1$ $2$ $3$ $\\underline{4}$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ ${\\color{red}2}$ $4$ ${\\color{red}2}$ $3$ $6$ ${\\color{red}2}$ ans[i] $0$ $0$ $0$ $0$ ${\\color{red}0}$ $0$ $0$ ${\\color{red}1}$ 对于一次询问l r，我们将指针移动到l这个位置之后查询$\\sum_{i=l}^{r}ans[i]$即可。 代码就不贴了，其实我还没写（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://github.com/Challestend/tags/树状数组/"},{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"},{"name":"HEOI","slug":"HEOI","permalink":"https://github.com/Challestend/tags/HEOI/"},{"name":"2012","slug":"2012","permalink":"https://github.com/Challestend/tags/2012/"},{"name":"莫队","slug":"莫队","permalink":"https://github.com/Challestend/tags/莫队/"}]},{"title":"「AHOI2017/HNOI2017」礼物","slug":"luogu-p3723-solution","date":"2019-01-04T03:14:12.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p3723-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p3723-solution/","excerpt":"传送门","text":"传送门 首先我们要有一个简单粗暴的暴力。 \\min\\limits_{x=0}^{n-1}\\min\\limits_{c_{1}=0,c_{2}=0}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\\%n}-c_{2})^{2}因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。 \\min\\limits_{x=0}^{n-1}\\min\\limits_{c=-m}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}我们仔细观察一下那个$\\Sigma$。 \\begin{aligned} &\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}\\\\ =&\\sum\\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\\%n}+2cA_{i}-2cB_{(i+x)\\%n})\\\\ =&\\sum\\limits_{i=0}^{n-1}A_{i}^{2}+\\sum\\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\\sum\\limits_{i=0}^{n-1}A_{i}-\\sum\\limits_{i=0}^{n-1}B_{i})-2\\sum\\limits_{i=0}^{n-1}A_{i}B_{(i+x)\\%n} \\end{aligned}首先$\\Sigma A_{i}^{2}$和$\\Sigma B_{i}^{2}$可以看成是常数项。 $nc^{2}+2c(\\Sigma A_{i}-\\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\\Sigma A_{i}-\\Sigma B_{i})$，我们知道它在$c=-\\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\\lfloor -\\cfrac{k}{n}\\rfloor$和$c=\\lceil -\\cfrac{k}{n}\\rceil$两者都代入原式，然后取较小值。 然后我们想要求出$\\Sigma A_{i}B_{(i+x)\\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。 \\sum\\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\\sum\\limits_{i=0}^{x-1}A_{i-x+n}B_{i}然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。 然后一想，我们可以倒过来搞啊。 定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成 \\begin{aligned} &\\sum\\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\\sum\\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\\\ =&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1} \\end{aligned}然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register#define maxn 131072#define mod 998244353#define max(a,b) ((a)&gt;=(b)?(a):(b))#define min(a,b) ((a)&lt;=(b)?(a):(b))#define swap(a,b) a^=b,b^=a,a^=bnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m,ans,k,mx;int unit[2][24],rev[maxn+1],A[maxn+1],B[maxn+1],C[maxn+1],D[maxn+1];inline int cltpow(re int x,re int y)&#123; re int res=1; for(;y;)&#123; if(y&amp;1) res=1LL*res*x%mod; x=1LL*x*x%mod; y&gt;&gt;=1; &#125; return res;&#125;inline void NTT(re int* F,re int n,re int tp)&#123; for(re int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(F[i],F[rev[i]]); for(re int k=1,p=1;p&lt;n;++k,p&lt;&lt;=1) for(re int i=0;i&lt;n;i+=p&lt;&lt;1) for(re int j=i,tmp=1;j&lt;i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod)&#123; re int x=F[j],y=1LL*F[j+p]*tmp%mod; F[j]=(x+y)%mod; F[j+p]=(x-y+mod)%mod; &#125; re int v=cltpow(n,tp*(mod-2)); for(re int i=0;i&lt;n;++i) F[i]=1LL*F[i]*v%mod;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); for(re int i=0;i&lt;n;++i)&#123; cltstream::read(A[i]); ans+=A[i]*A[i]; k+=A[i]; C[n-1-i]=A[i]; &#125; for(re int i=0;i&lt;n;++i)&#123; cltstream::read(B[i]); ans+=B[i]*B[i]; k-=B[i]; D[n-1-i]=B[i]; &#125; ans+=min(n*floor(1.0*k/n)*floor(1.0*k/n)-2*k*floor(1.0*k/n),n*ceil(1.0*k/n)*ceil(1.0*k/n)-2*k*ceil(1.0*k/n)); unit[0][23]=cltpow(3,119); unit[1][23]=cltpow(332748118,119); for(re int i=0;i&lt;2;++i) for(re int j=22;j&gt;=0;--j) unit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod; for(m=1;m&lt;n;m&lt;&lt;=1); m&lt;&lt;=1; for(re int i=0;i&lt;m;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?(m&gt;&gt;1):0); NTT(A,m,0); NTT(B,m,0); NTT(C,m,0); NTT(D,m,0); for(re int i=0;i&lt;m;++i)&#123; A[i]=1LL*A[i]*D[i]%mod; B[i]=1LL*B[i]*C[i]%mod; &#125; NTT(A,m,1); NTT(B,m,1); mx=A[n-1]; for(re int i=1;i&lt;n;++i) mx=max(mx,A[n-1-i]+B[i-1]); cltstream::write(ans-=2*mx); clop(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"AHOI","slug":"AHOI","permalink":"https://github.com/Challestend/tags/AHOI/"},{"name":"HNOI","slug":"HNOI","permalink":"https://github.com/Challestend/tags/HNOI/"},{"name":"2017","slug":"2017","permalink":"https://github.com/Challestend/tags/2017/"},{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"}]},{"title":"「Luogu-P5162」WD与积木","slug":"luogu-p5162-solution","date":"2019-01-02T08:43:53.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p5162-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p5162-solution/","excerpt":"9102年的第一篇blog。 传送门","text":"9102年的第一篇blog。 传送门 大概算是我用NTT切的第一道非模板题。 其实本来应该是这道。不过调不出来了弃了。 首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。 首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程： G[n]=\\sum\\limits_{i=0}^{n}C_{n}^{i}G[n-i]但是这样对吗？ 代入$n=0$我们发现 G[0]=C_{0}^{0}G[0]=G[0] 注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。 那然后$G[0]$应该等于几？ G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1所以说$G[0]=1$。 如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。 再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开 G[n]=n!\\sum\\limits_{i=0}^{n}\\cfrac{1}{i!}\\times\\cfrac{G[n-i]}{(n-i)!}定义 H[n]=\\begin{cases} &0&(n=0)\\\\ &\\cfrac{1}{n!}\\;\\;&(n>1) \\end{cases}G[n]=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{G[n-i]}{(n-i)!}注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义 G^{\\prime}[n]=\\cfrac{G[n]}{n!}就可以得到 \\begin{aligned} G^{\\prime}[n]&=\\sum\\limits_{i=0}^{n}H[i]\\times G^{\\prime}[n-i]\\\\ G^{\\prime}&=G^{\\prime}H+1 \\end{aligned}注意不要忘了$+1$。因为很明显地$G^{\\prime}H[0]=0$，而$G^{\\prime}[0]=1$。 然后我们就有 G^{\\prime}=\\cfrac{1}{1-H}然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。 首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此 F[n]=G[n]+\\sum\\limits_{i=0}^{n}C_{n}^{i}F[n-i]然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（ \\begin{aligned} F[n]&=G[n]+n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]}{(n-i)!}\\\\ &=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\\\ F^{\\prime}[n]&=\\cfrac{F[n]}{n!}\\\\ &=\\sum\\limits_{i=0}^{n}H[i]\\times(F^{\\prime}[n-i]+G^{\\prime}[n-i])\\\\ F^{\\prime}&=H(F^{\\prime}+G^{\\prime}) \\end{aligned}不过这次我们就不需要$+1$了。 解上面的方程，我们得到 F^{\\prime}=\\cfrac{HG^{\\prime}}{1-H}=\\cfrac{G^{\\prime}}{(1-H)^{2}}然后我们总结一下 H[n]=\\begin{cases} &0&(n=0)\\\\ &\\cfrac{1}{n!}\\;\\;&(n>1) \\end{cases}G^{\\prime}=\\cfrac{1}{1-H}F^{\\prime}=\\cfrac{G^{\\prime}}{(1-H)^{2}}最后的答案，也就是$n$块积木的期望层数，就是$\\cfrac{F[n]}{G[n]}$。然后不难发现$\\cfrac{F^{\\prime}[n]}{G^{\\prime}[n]}=\\cfrac{F[n]}{G[n]}$。 我就是不贴代码（ 反正会的应该都能写出来了吧（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"}]},{"title":"「多项式学习笔记Part II」多项式的进阶操作","slug":"polynomial-learning-notes-pt2","date":"2018-12-20T08:58:39.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"polynomial-learning-notes-pt2/","link":"","permalink":"https://github.com/Challestend/polynomial-learning-notes-pt2/","excerpt":"以下，如果不特别声明，则所有运算在模$998244353$意义下进行。","text":"以下，如果不特别声明，则所有运算在模$998244353$意义下进行。 接下来的前置知识泰勒展开说实话，其实我也不是很能理解这个东西（ 我就凭感觉xjb扯了（ 现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。 我们令 g(x)=\\sum\\limits_{i=0}^{n}g[i](x-x_{0})^{i}我们想要让$x\\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。 我们先考虑$0$阶，也就是原函数。因为$x\\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有 g[0]=f(x_{0})然后是$1$阶 g^{\\prime}(x)=\\sum\\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\\prime}(x_{0})再然后是$2$阶 g^{\\prime\\prime}(x)=\\sum\\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\\prime\\prime}(x_{0})最后是$3$阶 g^{\\prime\\prime\\prime}(x)=\\sum\\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\\prime\\prime\\prime}(x_{0})我们发现$g[n]$有如下的规律 g[n]=\\cfrac{f^{(n)}(x_{0})}{n!}综上所述 g(x)=\\sum\\limits_{i=0}^{n}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i应该吧（ 多项式牛顿迭代考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得 F(G(x))\\equiv 0\\pmod{x^{n}}我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得 F(G_{0})\\equiv 0\\pmod{x^{t}}我们希望求出一个$G$使得 F(G)\\equiv 0\\pmod{x^{2t}}我们将$F$在$G_{0}$这里进行泰勒展开： \\begin{aligned} F(G)&=F(G_{0})\\\\ &+F^{\\prime}(G_{0})(G-G_{0})\\\\ &+\\cfrac{F^{\\prime\\prime}(G_{0})}{2}(G-G_{0})^{2}\\\\ &+\\cdots\\end{aligned}注意到 \\begin{aligned} F(G)-F(G_{0})&\\equiv 0\\pmod{x^{t}}\\\\ G-G_{0}&\\equiv 0\\pmod{x^{t}} \\end{aligned}也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有 \\begin{aligned} F(G)&\\equiv F(G_{0})+F^{\\prime}(G_{0})(G-G_{0})\\pmod{x^{2t}}\\\\ F^{\\prime}(G_{0})G&\\equiv F^{\\prime}(G_{0})G_{0}-F(G_{0})\\pmod{x^{2t}}\\\\ G&\\equiv G_{0}-\\cfrac{F(G_{0})}{F^{\\prime}(G_{0})}\\pmod{x^{2t}} \\end{aligned}然后我们就一直倍增，倍增到$t\\geqslant n$为止，此时$G_{0}$即为所求多项式。 多项式求逆给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 F(x)\\times G(x)\\equiv 1\\pmod{x^{n}}假设我们已经求出了$G_{0}$使得 F\\times G_{0}\\equiv 1\\pmod{x^{t}}我们希望找到一个$G$使得 F\\times G\\equiv 1\\pmod{x^{2t}}据说能用牛顿迭代推，然而我不会（ 考虑正常一点的方式，虽然说还是倍增。 \\begin{aligned} F\\times G-F\\times G_{0}&\\equiv 0\\pmod{x^{t}}\\\\ G-G_{0}&\\equiv 0\\pmod{x^{t}}\\\\ (G-G_{0})^{2}&\\equiv 0\\pmod{x^{2t}}\\\\ G^{2}-2GG_{0}+G_{0}^{2}&\\equiv 0\\pmod{x^{2t}} \\end{aligned}两边同时乘$F$ \\begin{aligned} G-2G_{0}+FG_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\\\\ G&\\equiv 2G_{0}-FG_{0}^{2}\\pmod{x^{2t}} \\end{aligned}边界条件也很明显，就是当$t=1$时，$G[0]\\equiv F[0]^{-1}$。 说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（ 关于代码……现在还不是时候（ 后面有一道超级综合题在等着我们（ 多项式对数函数给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 G(x)\\equiv\\ln F(x)\\pmod{x^{n}}对上式两边求导 G^{\\prime}\\equiv F^{\\prime}\\ln^{\\prime}F\\pmod{x^{n}}又因为 \\ln^{\\prime}x=\\frac{1}{x}我们就得到 G^{\\prime}\\equiv\\cfrac{F^{\\prime}}{F}\\pmod{x^{n}}求导+求逆+不定积分即可。 多项式指数函数超级综合题来了。 给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 G(x)\\equiv e^{F(x)}\\pmod{x^{n}}首先 \\ln G-F\\equiv 0\\pmod{x^{n}}我们把$F$看成是常数项，定义函数 A(G)=\\ln G-FA^{\\prime}(G)=\\ln^{\\prime}G=\\cfrac{1}{G}套牛顿迭代 \\begin{aligned} G&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\ &\\equiv G_{0}(1-\\ln G_{0}+F)\\pmod{x^{2t}} \\end{aligned}然后把以上提到的所有板子全都复制过来就行了（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cstdio&gt;#include&lt;cstring&gt;#define re register#define maxn 524288#define mod 998244353#define swap(a,b) a^=b,b^=a,a^=bnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout) #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n;int unit[2][24],rev[maxn+1],inv[maxn+1]=&#123;0,1&#125;,F[maxn+1],G[maxn+1],tmp1[maxn+1],tmp2[maxn+1],tmp3[maxn+1],tmp4[maxn+1];inline int cltpow(re int x,re int y)&#123; re int res=1; for(;y;)&#123; if(y&amp;1) res=1LL*res*x%mod; x=1LL*x*x%mod; y&gt;&gt;=1; &#125; return res;&#125;inline void NTT(re int* F,re int n,re int tp)&#123; for(re int i=0;i&lt;n;++i) if(i&lt;(rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?(n&gt;&gt;1):0))) swap(F[i],F[rev[i]]); for(re int k=1,p=1;p&lt;n;++k,p&lt;&lt;=1) for(re int i=0;i&lt;n;i+=p&lt;&lt;1) for(re int j=i,tmp=1;j&lt;i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod)&#123; re int x=F[j],y=1LL*F[j+p]*tmp%mod; F[j]=(x+y)%mod; F[j+p]=(x-y+mod)%mod; &#125; re int v=cltpow(n,tp*(mod-2)); for(re int i=0;i&lt;n;++i) F[i]=1LL*F[i]*v%mod;&#125;inline void Inv(re int* F,re int* G,re int n)&#123; G[0]=cltpow(F[0],mod-2); for(re int i=1,j=4;i&lt;n;i&lt;&lt;=1,j&lt;&lt;=1)&#123; for(re int k=0;k&lt;(i&lt;&lt;1);++k) tmp1[k]=F[k]; NTT(tmp1,j,0); NTT(G,j,0); for(re int k=0;k&lt;j;++k) G[k]=(2-1LL*tmp1[k]*G[k]%mod+mod)*G[k]%mod; NTT(G,j,1); for(re int k=(i&lt;&lt;1);k&lt;j;++k) G[k]=0; for(re int k=0;k&lt;j;++k) tmp1[k]=0; &#125;&#125;inline void Ln(re int* F,re int* G,re int n)&#123; for(re int i=1;i&lt;n;++i) G[i-1]=1LL*F[i]*i%mod; Inv(F,tmp2,n); re int N=1; for(;N&lt;n;N&lt;&lt;=1); N&lt;&lt;=1; NTT(G,N,0); NTT(tmp2,N,0); for(re int i=0;i&lt;N;++i) G[i]=1LL*G[i]*tmp2[i]%mod; NTT(G,N,1); for(re int i=n-1;i&gt;=1;--i) G[i]=1LL*G[i-1]*inv[i]%mod; G[0]=0; for(re int i=n;i&lt;N;++i) G[i]=0; for(re int i=0;i&lt;N;++i) tmp2[i]=0;&#125;inline void Exp(re int* F,re int* G,re int n)&#123; G[0]=1; for(re int i=1,j=2;i&lt;(n&lt;&lt;1);i&lt;&lt;=1,j&lt;&lt;=1)&#123; Ln(G,tmp3,i); for(re int k=0;k&lt;i;++k) tmp4[k]=F[k]; NTT(tmp3,j,0); NTT(tmp4,j,0); NTT(G,j,0); for(re int k=0;k&lt;j;++k) G[k]=((1LL-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod; NTT(G,j,1); for(re int k=0;k&lt;j;++k) tmp3[k]=tmp4[k]=0; &#125;&#125;int main()&#123; unit[0][23]=cltpow(3,119); unit[1][23]=cltpow(332748118,119); for(re int i=0;i&lt;2;++i) for(re int j=22;j&gt;=0;--j) unit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod; for(re int i=2;i&lt;=maxn;++i) inv[i]=(mod-1LL*mod/i*inv[mod%i]%mod)%mod; cltstream::read(n); for(re int i=0;i&lt;n;++i) cltstream::read(F[i]); Exp(F,G,n); for(re int i=0;i&lt;n;++i) cltstream::write(G[i],i&lt;n-1?32:-1); clop(); return 0;&#125; 多项式开平方根给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 G^{2}(x)\\equiv F(x)\\pmod{x^{n}}牛顿迭代吼啊！ A(G)=G^{2}-FA^{\\prime}(G)=2G\\begin{aligned} G&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\ &\\equiv G_{0}-\\cfrac{G_{0}^{2}-F}{2G_{0}}\\\\ &\\equiv\\cfrac{G_{0}^{2}+F}{2G_{0}}\\\\ &=\\cfrac{1}{2}(G_{0}+\\cfrac{F}{G_{0}})\\pmod{x^{2t}} \\end{aligned}复制粘贴吼啊！ 我刚才都学了些啥破玩意一道例题。 Remote Judge。 这是读题前的我： 这是读题后的我： 这是知道了这题正解是多项式开平方根后的我： 我……我怕不是学了个假的多项式哦（ 厚颜无耻地抄题解（ 首先我们搞出生成函数（然而并不是很懂） G(x)=\\sum\\limits_{i=0}^{m}G[i]x^{i}其中 G[i]=[i\\in\\{c_{1},c_{2},\\cdots,c_{n}\\}]定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有 F[0]=1F[x]=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。 然后是一些神仙操作 \\begin{aligned} F[x]&=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]\\\\ &=\\sum\\limits_{i=0}^{x}G[i]F^{2}[x-i]\\\\ &=(GF^{2})[x] \\end{aligned}令人窒息（ 然后我们就有 GF^{2}+1=F但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。 于是解上面这个一元二次方程，我们得到 F=\\cfrac{1\\pm\\sqrt{1-4G}}{2G}但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\\mp\\sqrt{1-4G})$，然后化简一波 F=\\cfrac{2}{1\\mp\\sqrt{1-4G}}如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\\cfrac{2}{2}=1$。综上所述 F=\\cfrac{2}{1+\\sqrt{1-4G}}本来接下来应该有代码实现的，但是我拒绝咕咕咕。 其实是调不出来了（","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"},{"name":"FFT","slug":"FFT","permalink":"https://github.com/Challestend/tags/FFT/"}]},{"title":"「多项式学习笔记Part I」最基本的多项式乘法","slug":"polynomial-learning-notes-pt1","date":"2018-12-19T12:23:01.000Z","updated":"2019-03-27T03:38:27.672Z","comments":true,"path":"polynomial-learning-notes-pt1/","link":"","permalink":"https://github.com/Challestend/polynomial-learning-notes-pt1/","excerpt":"最近正好月考，然而并不想去月考，于是来颓blog吧。","text":"最近正好月考，然而并不想去月考，于是来颓blog吧。 给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\\times G)(x)$的各项系数。$n,m\\leqslant 10^{6}$。 我们不妨将$F(x)$的$i$次项系数记为$F[i]$ F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}G(x)=\\sum\\limits_{i=0}^{m-1}G[i]x^{i}(F\\times G)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}(F\\times G)[k]=\\sum\\limits_{0\\leqslant i","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"},{"name":"FFT","slug":"FFT","permalink":"https://github.com/Challestend/tags/FFT/"}]},{"title":"关于最优化分块时间复杂度的研究报告","slug":"sqrt-decomposition-complexity-optimization","date":"2018-12-19T12:19:18.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"sqrt-decomposition-complexity-optimization/","link":"","permalink":"https://github.com/Challestend/sqrt-decomposition-complexity-optimization/","excerpt":"最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。","text":"最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。 假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\\text{A}x+\\text{B}y$。根据均值不等式 \\cfrac{1}{2}(x+y)\\geqslant\\sqrt{xy}我们有 \\text{A}x+\\text{B}y\\geqslant2\\sqrt{\\text{AB}n}当且仅当$x=\\sqrt{\\cfrac{\\text{B}}{\\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\\sqrt{\\text{AB}n})$。 以上。","categories":[{"name":"研究报告","slug":"研究报告","permalink":"https://github.com/Challestend/categories/研究报告/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"}]},{"title":"「未来算法Episode I」严格根号分块实现树套树","slug":"future-algorithm-ep1","date":"2018-12-08T11:55:00.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"future-algorithm-ep1/","link":"","permalink":"https://github.com/Challestend/future-algorithm-ep1/","excerpt":"分块天下第一！！！！！！！！！","text":"分块天下第一！！！！！！！！！ 我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。 我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。 先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。 然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\\operatorname{log}n)$的。 那我们就在外层套个树状数组，把修改$O(n\\operatorname{log}n)$查询$O(\\operatorname{log}n)$均摊成全部$O(\\operatorname{log}^{2}n)$。 然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。 考虑无敌的分块。 一般我们想到的分块就是在块内维护std::set。这样操作$3$可以做到$O(\\operatorname{log}\\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\\sqrt{n}\\operatorname{log}\\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\\operatorname{log}10^{9}\\sqrt{n}\\operatorname{log}\\sqrt{n})$。 然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。 我们来看一下Shadowice1984dalao在他的另一篇题解中做出的评价： 这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\\text{log}$之内。 但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\\sqrt{n})$而不是$O(\\operatorname{log}n)$，这意味着分块其实和$\\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\\text{log}$来，这在强调常数的根号算法中绝对是致命的。 我也是从这位dalao的blog里看到了严格根号分块实现树套树这种未来算法。 主要思想其实不难理解，既然分块和$\\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。 定义cnt1[i][j]表示前$i$个块内有多少个元素的值在第$j$个块内，cnt2[i][j]表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\\sqrt{n})$的。 然后我们来分析每个操作该怎么实现： 首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。 还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组tmp1和tmp2来保存边角块的信息。 直接$O(\\sqrt{n})$暴力重构两个cnt就好。 需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内从后往前扫，找到答案直接退出。否则还是从后往前扫所有值域块，找到第一个非空的块然后进去找。 操作$4$换个方向即可。 综上所述，该算法的时间复杂度为$O((n+m)\\sqrt{n}+m\\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\\operatorname{log}^{2}n)\\approx 12183043$。看起来好像比不过树套树，实际上开个$\\text{O}2$跑得比谁都快，正如一开始那张图所示。 不过代码写出来有点长的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register#define maxn 50000#define maxm 50000#define maxs 230#define max(a,b) ((a)&gt;=(b)?(a):(b))#define min(a,b) ((a)&lt;=(b)?(a):(b))#define lowbit(a) ((a)&amp;(-(a)))namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout) #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m,sq1,sq2;int id1[maxn+1],id2[maxn+maxm+1],p[maxn+maxm+1];int a[maxn+1],opt[maxm+1][4];int cnt1[maxs+1][(maxs&lt;&lt;1)+1],cnt2[maxs+1][maxn+maxm+1],tmp1[(maxs&lt;&lt;1)+1],tmp2[maxn+maxm+1];int main()&#123; cltstream::read(n); cltstream::read(m); for(;(sq1+1)*(sq1+1)&lt;=n;++sq1); for(re int i=1;i&lt;=n;++i)&#123; id1[i]=(i-1)/sq1+1; cltstream::read(a[i]); p[++p[0]]=a[i]; &#125; for(re int i=1;i&lt;=m;++i)&#123; cltstream::read(opt[i][0]); cltstream::read(opt[i][1]); cltstream::read(opt[i][2]); if(opt[i][0]!=3) cltstream::read(opt[i][3]); else p[++p[0]]=opt[i][2]; &#125; std::sort(p+1,p+p[0]+1); p[0]=std::unique(p+1,p+p[0]+1)-p-1; for(;(sq2+1)*(sq2+1)&lt;=p[0];++sq2); for(re int i=1;i&lt;=p[0];++i) id2[i]=(i-1)/sq2+1; for(re int i=1;i&lt;=n;++i)&#123; a[i]=std::lower_bound(p+1,p+p[0]+1,a[i])-p; ++cnt1[id1[i]][id2[a[i]]]; ++cnt2[id1[i]][a[i]]; &#125; for(re int i=1;i&lt;=id1[n];++i)&#123; for(re int j=1;j&lt;=id2[p[0]];++j) cnt1[i][j]+=cnt1[i-1][j]; for(re int j=1;j&lt;=p[0];++j) cnt2[i][j]+=cnt2[i-1][j]; &#125; for(re int i=1;i&lt;=m;++i)&#123; re int l,r,x,ans=0; switch(opt[i][0])&#123; case 1: l=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j) ans+=(a[j]&lt;x); for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j) ans+=(a[j]&lt;x); for(re int j=1;j&lt;id2[x];++j) ans+=cnt1[id1[r]-1][j]-cnt1[id1[l]][j]; for(re int j=(id2[x]-1)*sq2+1;j&lt;x;++j) ans+=cnt2[id1[r]-1][j]-cnt2[id1[l]][j]; &#125; else for(re int j=l;j&lt;=r;++j) ans+=(a[j]&lt;x); cltstream::write(ans+1,10); break; case 2: l=opt[i][1],r=opt[i][2],x=opt[i][3]; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=1;;++j) if(x&gt;cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]) x-=cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]; else&#123; for(re int k=(j-1)*sq2+1;k&lt;=j*sq2;++k) if(x&gt;cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]) x-=cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]; else&#123; cltstream::write(p[k],10); break; &#125; break; &#125; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; else&#123; for(re int j=l;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=1;;++j) if(x&gt;tmp1[j]) x-=tmp1[j]; else&#123; for(re int k=(j-1)*sq2+1;k&lt;=j*sq2;++k) if(x&gt;tmp2[k]) x-=tmp2[k]; else&#123; cltstream::write(p[k],10); break; &#125; break; &#125; for(re int j=l;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; break; case 3: l=opt[i][1],x=std::lower_bound(p+1,p+p[0]+1,opt[i][2])-p; for(re int j=id1[l];j&lt;=id1[n];++j)&#123; --cnt1[j][id2[a[l]]]; ++cnt1[j][id2[x]]; --cnt2[j][a[l]]; ++cnt2[j][x]; &#125; a[l]=x; break; case 4: l=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x-1;j&gt;=(id2[x]-1)*sq2+1&amp;&amp;!ans;--j) if(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j]) ans=j; for(re int j=id2[x]-1;j&gt;=1&amp;&amp;!ans;--j) if(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]) for(re int k=j*sq2;k&gt;=(j-1)*sq2+1&amp;&amp;!ans;--k) if(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]) ans=k; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; else&#123; for(re int j=l;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x-1;j&gt;=(id2[x]-1)*sq2+1&amp;&amp;!ans;--j) if(tmp2[j]) ans=j; for(re int j=id2[x]-1;j&gt;=1&amp;&amp;!ans;--j) if(tmp1[j]) for(re int k=j*sq2;k&gt;=(j-1)*sq2+1&amp;&amp;!ans;--k) if(tmp2[k]) ans=k; for(re int j=l;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; cltstream::write(ans?p[ans]:-2147483647,10); break; case 5: l=opt[i][1],r=opt[i][2],x=std::upper_bound(p+1,p+p[0]+1,opt[i][3])-p-1; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x+1;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j) if(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j]) ans=j; for(re int j=id2[x]+1;j&lt;=id2[p[0]]&amp;&amp;!ans;++j) if(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]) for(re int k=(j-1)*sq2+1;k&lt;=j*sq2&amp;&amp;!ans;++k) if(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]) ans=k; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; else&#123; for(re int j=l;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x+1;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j) if(tmp2[j]) ans=j; for(re int j=id2[x]+1;j&lt;=id2[p[0]]&amp;&amp;!ans;++j) if(tmp1[j]) for(re int k=(j-1)*sq2+1;k&lt;=j*sq2&amp;&amp;!ans;++k) if(tmp2[k]) ans=k; for(re int j=l;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; cltstream::write(ans?p[ans]:2147483647,10); &#125; &#125; clop(); return 0;&#125; 我还没写啥呢咋就$12\\text{KB}$了（ 这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（","categories":[{"name":"未来算法","slug":"未来算法","permalink":"https://github.com/Challestend/categories/未来算法/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"},{"name":"树套树","slug":"树套树","permalink":"https://github.com/Challestend/tags/树套树/"}]},{"title":"一些乱七八糟的数论","slug":"number-theory-learning-notes","date":"2018-11-29T06:41:17.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"number-theory-learning-notes/","link":"","permalink":"https://github.com/Challestend/number-theory-learning-notes/","excerpt":"最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。 抄袭来源参考文献： 铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演 浅谈杜教筛 铃悬的数学小讲堂——杜教筛","text":"最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。 抄袭来源参考文献： 铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演 浅谈杜教筛 铃悬的数学小讲堂——杜教筛 数论函数定义与相关性质数论函数就是定义域为$\\mathbb{N}^{+}$的函数。 两个数论函数相加，就是简单地把函数值相加。 (f+g)(n)=f(n)+g(n)数乘也是类似的。 (\\alpha f)(n)=\\alpha f(n)点积也是类似的。 (f\\cdot g)(n)=f(n)g(n)好像没啥用。 在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的： (f\\times g)(n)=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})或者说： (f\\times g)(n)=\\sum\\limits_{ij=n}f(i)g(j)它具有以下的一些性质： 交换律，即$f\\times g=g\\times f$。 这很明显。 结合律，即$(f\\times g)\\times h=f\\times(g\\times h)$。 \\begin{aligned} ((f\\times g)\\times h)(n)&=\\sum\\limits_{ij=n}(\\sum\\limits_{kl=i}f(k)g(l))h(j)\\\\ &=\\sum\\limits_{ijk=n}f(i)g(j)h(k) \\end{aligned}\\begin{aligned} (f\\times(g\\times h))(n)&=\\sum\\limits_{ij=n}f(i)(\\sum\\limits_{kl=j}g(k)h(l))\\\\ &=\\sum\\limits_{ijk=n}f(i)g(j)h(k) \\end{aligned}分配率，即$(f+g)\\times h=f\\times h+g\\times h$。 \\begin{aligned} ((f+g)\\times h)(n)&=\\sum\\limits_{ij=n}(f+g)(i)h(j)\\\\ &=\\sum\\limits_{ij=n}f(i)h(j)+g(i)h(j)\\\\ &=(f\\times h)(n)+(g\\times h)(n) \\end{aligned}单位元为$\\epsilon(n)=[n=1]$，$f\\times\\epsilon =f$。 这也很明显。 对于任意一个满足$f(1)\\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\\times g=\\epsilon$。这时我们称$g$是$f$的逆。 我们可以这样定义一个函数的逆： g(n)=\\cfrac{\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})}{f(1)}这样我们就有 \\begin{aligned} (f\\times g)(n)&=\\sum_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\ &=f(1)g(n)+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\ &=\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\ &=\\epsilon(n) \\end{aligned}积性函数与完全积性函数如果一个数论函数$f$满足 \\forall x,y\\in\\mathbb{N}^{+}\\wedge x\\perp y\\;\\;f(xy)=f(x)f(y)我们就说$f$是一个积性函数。 特别的，如果上式去掉$x\\perp y$仍成立，则称$f$是一个完全积性函数。 很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\\times n)=f(1)\\times f(n)=f(n)$。 常见的完全积性函数有$\\epsilon,id^{k}$。$\\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。 常见的积性函数有$\\varphi,d,\\sigma$。$\\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\\sigma(n)$的值分别等于$n$的约数个数和约数和。 关于$\\varphi$的积性，我并不会证（ 我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设 n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有 d(n)=\\prod\\limits_{i=1}^{N}(r_{i}+1)我们再假设有一个$m$，且 m=\\prod\\limits_{i=1}^{M}q_{i}^{s_{i}}如果说$n\\perp m$，肯定有 \\forall i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z}\\;\\;p_{i}\\neq q_{j}于是我们就有 nm=(\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}})(\\prod\\limits_{j=1}^{M}q_{j}^{s_{j}})\\begin{aligned} d(nm)&=(\\prod\\limits_{i=1}^{N}(r_{i}+1))(\\prod\\limits_{j=1}^{M}(s_{j}+1))\\\\ &=d(n)d(m) \\end{aligned}不妨再反过来考虑。如果说$n\\not\\perp m$，那么一定存在一对$(i,j)(i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\\neq d(n)d(m)$。 我们再来分析$\\sigma$的积性。还是设 n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\\in [0,r_{i}]\\cap\\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是 \\prod\\limits_{i=1}^{N}\\sum\\limits_{j=0}^{r_{i}}p_{i}^{j}这正是$\\sigma(n)$的值。 接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。 现在我们来分析，两个积性函数的卷积是否也是积性函数。虽然说都这么问了肯定就是了。 \\begin{aligned} (f\\times g)(n)(f\\times g)(m)&=(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\ &=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(i)g(\\cfrac{n}{i})f(j)g(\\cfrac{m}{j})\\\\ &=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(ij)g(\\cfrac{nm}{ij})\\\\ &=\\sum\\limits_{k\\mid nm}f(k)g(\\cfrac{nm}{k})\\\\ &=(f\\times g)(nm) \\end{aligned}关于上面的第四个等号。时刻注意$n\\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。 再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。 设有一个积性函数$f$，它的逆是$g$。 当$nm=1$时，$g(1)=1$。 当$nm&gt;1$时，我们假设对于任意$n^{\\prime}m^{\\prime}&lt;nm$，都有$g(n^{\\prime}m^{\\prime})=g(n^{\\prime})g(m^{\\prime})$。此时 \\begin{aligned} g(nm)&=-\\sum\\limits_{k\\mid nm,k\\neq 1}f(k)g(\\cfrac{nm}{k})\\\\ &=-\\sum\\limits_{i\\mid n,j\\mid m,ij\\neq 1}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\ &=g(n)g(m)-\\sum\\limits_{i\\mid n,j\\mid m}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\ &=g(n)g(m)-(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\ &=g(n)g(m)-\\epsilon(n)\\epsilon(m)\\\\ &=g(n)g(m) \\end{aligned}其实上面这些全都是抄来的（ 莫比乌斯反演正向反演定义$\\mu$为$1$的逆。也就是说，$\\mu\\times 1=\\epsilon$。 如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义： 首先地，$\\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\\mu(n)=(-1)^{k}$。否则，$\\mu(n)=0$。 那么，这两种定义等价吗？ 考虑到$\\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成 n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}我们就有 \\mu(n)=\\prod\\limits_{i=1}^{N}\\mu(p_{i}^{r_{i}})因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。 设有一个质数$p$。不难发现 \\mu(p)=-\\mu(1)=-1\\mu(p^{2})=-\\mu(1)-\\mu(p)=-1+1=0\\mu(p^{3})=-\\mu(1)-\\mu(p)-\\mu(p^{2})=-1+1+0=0\\vdots至此，不难看出上文给出的两种定义是等价的。 那么这个东西有什么用呢？ 我们设 F(n)=\\sum\\limits_{i\\mid n}f(i)或者等价地说，$F=f\\times 1$。我们可以得到 \\begin{aligned} F&=f\\times 1\\\\ F\\times\\mu&=f\\times 1\\times\\mu\\\\ F\\times\\mu&=f \\end{aligned}像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说 f(n)=\\sum\\limits_{i\\mid n}F(i)\\mu(\\cfrac{n}{i})反向反演有些时候我们还需要用到像下面这样反过来的莫比乌斯反演 F(n)=\\sum\\limits_{n\\mid d}f(d)⇔f(n)=\\sum\\limits_{n\\mid d}F(d)\\mu(\\cfrac{d}{n})我们可以定义一种新的运算 (f\\otimes g)(n)=\\sum\\limits_{n\\mid d}f(d)g(\\cfrac{d}{n})我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有 F=f\\otimes 1⇔F\\otimes\\mu=f于是就有了上面的反向反演。 Updated on 2018-12-03 例题……还是算了吧（ 发现反演常用的套路都忘的差不多了，还是别丢人了（ 杜教筛实现与模板题接下来才是主要内容。 现在，我们要求一个积性函数的前$n$项和。$n\\leqslant 10^{10}$。 我们定义 S(n)=\\sum\\limits_{i=1}^{n}f(i)再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。 \\begin{aligned} \\sum_{i=1}^{n}(f\\times g)(i)&=\\sum_{i=1}^{n}\\sum_{j\\mid i}f(j)g(\\cfrac{i}{j})\\\\ &=\\sum_{i=1}^{n}g(i)\\sum_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\ &=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor) \\end{aligned}然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（ 因为$g$也是积性函数，有$g(1)=1$，所以 \\begin{aligned} S(n)&=g(1)S(n)\\\\ &=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\\\\ &=\\sum_{i=1}^{n}(f\\times g)(i)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor) \\end{aligned}就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。 如果说我们选择的$g$可以让我们迅速地求出$f\\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。 关于后面的$g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。 我们来分析一下$\\lfloor\\cfrac{n}{i}\\rfloor$。如果$1\\leqslant i\\leqslant\\sqrt{n}$，因为$i$只有$\\sqrt{n}$种不同的取值，$\\lfloor\\cfrac{n}{i}\\rfloor$同样也只有$\\sqrt{n}$种不同的取值。如果$\\sqrt{n}&lt;i\\leqslant n$，$1\\leqslant\\lfloor\\cfrac{n}{i}\\rfloor&lt;\\sqrt{n}$，又因为要向下取整，自然也只有$\\sqrt{n}$种不同的取值。如果我们能够把$\\lfloor\\cfrac{n}{i}\\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\\sqrt{n})$。 大体代码如下： 1234for(re int l=1,r;l&lt;=n;l=r+1)&#123; r=n/(n/l); //......&#125; 关于$r$的这个上界是怎么来的，我并不会证（ 这样一来，要计算$S(n)$，我们需要调用所有的$\\lfloor\\cfrac{n}{x}\\rfloor$，分别是$\\lfloor\\cfrac{n}{1}\\rfloor,\\lfloor\\cfrac{n}{2}\\rfloor,\\cdots,\\lfloor\\cfrac{n}{\\sqrt{n}}\\rfloor,\\sqrt{n},\\sqrt{n}-1,\\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\\sqrt{n})$的。那么这样一来，总体的时间复杂度就是 \\begin{aligned} O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{i}+\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})&=O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})\\\\ &=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{x}\\rfloor}dx)\\\\ &=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\cfrac{n}{x}}dx)\\\\ &=O(2n^{\\frac{1}{2}}(n^{\\frac{1}{4}}-1))\\\\ &=O(n^{\\frac{3}{4}}) \\end{aligned}因为相比之下$\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor}$很明显要大一些，我们就可以将$\\sqrt{i}$舍去。然后去掉取整符号并用积分近似。 这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\\cfrac{n}{\\sqrt{m}})$，当$m=n^{\\frac{2}{3}}$时取得最小值$O(n^{\\frac{2}{3}})$。 举个例子，就比如说我们要求 \\sum\\limits_{i=1}^{n}\\varphi(i)我们取$f=\\varphi,g=1$，这样根据$\\varphi$的性质，$f\\times g=id$。不难看出$g$与$f\\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样： 1234567891011121314151617181920long long getSum(int n)&#123; if(n&lt;=maxn) return phi[n]; //phi是提前线性筛好的前缀和 if(ans.count(n)) return ans[n]; //ans用来实现记忆化的哈希表，比如说unordered_map re long long res=1LL*n*(n+1)&gt;&gt;1; //f*g的前缀和 for(re int l=2,r;l&lt;=n;l=r+1)&#123; //注意要从2开始 r=n/(n/l); res-=(r-l+1)*getSum(n/l); //r-l+1是g的前缀和 //像这样递归+记忆化求解f的前缀和 &#125; return ans[n]=res; //返回的时候不要忘记存一下 //就比如说我就忘过一次（&#125; 以及，不用哈希表也是可以的。因为我们查询的数都是形如$\\lfloor\\cfrac{n}{x}\\rfloor$的，当这个值大于$n^{\\frac{2}{3}}$，即$x&lt;n^{\\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令ans[x]表示$S(\\lfloor\\cfrac{n}{x}\\rfloor)$。具体代码我就不写了（ 再举个例子，求 \\sum\\limits_{i=1}^{n}\\mu(i)取$f=\\mu,g=1,f\\times g=\\epsilon$。代码和上面差不多。 如果您理解了上面两个函数，这道模板题您就可以切了。 其他题「Luogu-P3768」简单的数学题快乐地推式子： \\begin{aligned} \\sum\\limits_{i=1}^{n}i\\sum\\limits_{j=1}^{n}j\\text{gcd}(i,j)&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j[i\\perp j]\\\\ &=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\ &=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}x^{2}\\mu(x)\\text{Sum}^{2}(\\lfloor\\cfrac{n}{dx}\\rfloor)\\\\ &=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\sum\\limits_{j\\mid i}j\\mu(\\cfrac{i}{j})\\\\ &=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\varphi(i) \\end{aligned}其中 \\text{Sum}(n)=\\sum\\limits_{i=1}^{n}i最后一步是因为 \\begin{aligned} id\\times\\mu&=\\varphi\\times 1\\times\\mu\\\\ &=\\varphi\\times\\epsilon\\\\ &=\\varphi \\end{aligned}理解不了上面的式子的话就多看看吧（ 不难发现我们是要求$f(n)=n^{2}\\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？ 枚举瞎蒙（ 考虑$g(n)=n^{2}$。 \\begin{aligned} (f\\times g)(n)&=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\ &=\\sum\\limits_{i\\mid n}i^{2}\\varphi(i)\\cfrac{n^{2}}{i^{2}}\\\\ &=n^{2}\\sum\\limits_{i\\mid n}\\varphi(i)\\\\ &=n^{3} \\end{aligned}其实我都不知道我当时是怎么想到这种操作的（ 然后就和上面一样了。 「Luogu-U18201」分析矿洞不知道从哪翻出来的题（ 是某场个人邀请赛的$\\text{T}1$，从某种意义上也能看出那场比赛有多么神仙。 \\begin{aligned} \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\varphi(\\text{gcd}^{2}(i,j))&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[i\\perp j]\\\\ &=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\ &=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(x)\\lfloor\\cfrac{n}{dx}\\rfloor^{2}\\\\ &=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}\\varphi(j^{2})\\mu(\\cfrac{i}{j})\\\\ &=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}j\\varphi(j)\\mu(\\cfrac{i}{j}) \\end{aligned}设$f_1(n)=n\\varphi(n),f_2(n)=\\mu(n)$，考虑筛$f=f_1\\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\\times g$的前缀和。一种较优的方案是，令$g=1$，$f\\times g=(id\\cdot\\varphi)\\times\\mu\\times 1=id\\cdot\\varphi$，这样，我们还需要筛出$f_1(n)=n\\varphi(n)$的前缀和。 怎么办？ 再套一层杜教筛！ 然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（ 以及，像这种$n$爆了int的，一定要注意经常取模。因为这个WA了好几次（ 最后，源文件$17\\text{KB}​$祭，blog翻页祭。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://github.com/Challestend/tags/杜教筛/"}]},{"title":"「NOIp2018游记」夢の終わるところ","slug":"noip-2018-notes","date":"2018-11-09T01:40:45.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"noip-2018-notes/","link":"","permalink":"https://github.com/Challestend/noip-2018-notes/","excerpt":"€€£：禁赛警告。","text":"€€£：禁赛警告。 Day 0自从一周前放假回来以后，我就开始一颓不振： 明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废，同时看着其他dalao随手切神仙题。然后我看到yemdalao写了一篇NOIp2018禁赛记游记，想着禁赛真有趣，我就写下了这篇游记。 其他dalao都在机房补文化课而我在颓blog（ 于是，此处以下，Updated on 2018-11-12。 Updated on 2018-11-14 看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。 但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃 中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。 然后一抽考场发现是外校，赛前先rp--。 然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（ 下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（ 除那之外就没啥了，算是颓了一个下午。 晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（ 试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。 反正板子是不可能打炸的，这辈子都不可能的。 因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。 Day 1早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。 然后一打开E盘发现被清了，只有题目。 Day1的解压密码是不是就我一个人不懂啊（ 那么于是，到了8：30，我点开今天的题目，定神一看…… T1智障单调栈，有不开数组的做法，不过我懒得细想了，反正score+=100。 T2稍微想一想不难想到完全背包，score+=100。 T3神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。 估分100+100+25=225。 出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（ 前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（ 那我可真是太菜了（ 下午日常发呆，然后晚上是快乐的颓废时间。 中午买的零食一个下午就全吃完了（ Day 2早上莫名起不来，然后就没吃早饭。 这次我东西是真的带全了（ Day2的解压密码依然不懂，然后是今天的题目： T1NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。 现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点std::sort一遍。然后维护一个邻接矩阵处理断边（ 为什么不直接用邻接矩阵呢（ T2神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（ T3究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。 估分100+65+44=204（不存在的，肯定比这个低）。 这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧…… 不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（ 好像其他dalao们都有这样那样乱七八糟的地方出锅了啊…… 下午请假回家开心地颓废。 Extra Notes果然是等到NOIp结束后才更新的。 以及，我比较菜，第一次写游记，写的可能一定很菜，所以……算了，告辞。 Updated on 2018-11-26 好像有些晚的更新。 出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（ 具体成绩差不多是100+100+20+100+65+36=421。 以上。","categories":[{"name":"游记","slug":"游记","permalink":"https://github.com/Challestend/categories/游记/"}],"tags":[{"name":"NOIp","slug":"NOIp","permalink":"https://github.com/Challestend/tags/NOIp/"},{"name":"2018","slug":"2018","permalink":"https://github.com/Challestend/tags/2018/"}]},{"title":"「Luogu-P5009」毒瘤分块题","slug":"luogu-p5009-solution","date":"2018-11-08T00:04:22.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p5009-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p5009-solution/","excerpt":"传送门","text":"传送门 从来没做过这么毒瘤的题qaq 就算看了题解现在还是一脸懵逼qaq 首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq 对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\\prime$使得$v_i^\\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\\prime$，然后查询的时候我们就可以直接返回$v_i^\\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\\prime=v_i-t_1xb_i$。 需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\\Sigma v_i^\\prime+t\\Sigma (a_i+x+z)(b_i+y)=\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$，即$\\Sigma v_i^\\prime=\\Sigma v_i-tz\\Sigma (b_i+y)$。 不过，上式中$tz\\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\\Sigma b_i$，考虑到每层节点的$\\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\\Sigma v_i+=B\\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。 然后是毒瘤的下推标记。 123456addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];//就是上面这句qaq现在还是一脸懵逼qaqA[son]+=A[father];B[son]+=B[father];adda[son]+=adda[father];addb[son]+=addf[father]; 其实我也不知道我上面在扯些啥，所以以下是代码，反正应该没人能看懂我的清奇写法（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;cstdio&gt;#define re register#define maxn 200005#define maxm 200005#define mod 100000007namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout) #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m;int sumv[(maxn&lt;&lt;2)+1],suma[(maxn&lt;&lt;2)+1],sumb[(maxn&lt;&lt;2)+1],sump[(maxn&lt;&lt;2)+1];int A[(maxn&lt;&lt;2)+1],B[(maxn&lt;&lt;2)+1];int addv[(maxn&lt;&lt;2)+1],adda[(maxn&lt;&lt;2)+1],addb[(maxn&lt;&lt;2)+1];inline void pushDown(int cur,int ln,int rn)&#123; sumv[cur&lt;&lt;1]=(sumv[cur&lt;&lt;1]+1LL*A[cur]*suma[cur&lt;&lt;1]%mod)%mod; sumv[cur&lt;&lt;1]=(sumv[cur&lt;&lt;1]+1LL*B[cur]*sumb[cur&lt;&lt;1]%mod)%mod; sumv[cur&lt;&lt;1]=(sumv[cur&lt;&lt;1]+1LL*ln*addv[cur]%mod)%mod; sump[cur&lt;&lt;1]=(sump[cur&lt;&lt;1]+1LL*adda[cur]*sumb[cur&lt;&lt;1]%mod)%mod; sump[cur&lt;&lt;1]=(sump[cur&lt;&lt;1]+1LL*addb[cur]*suma[cur&lt;&lt;1]%mod)%mod; sump[cur&lt;&lt;1]=(sump[cur&lt;&lt;1]+1LL*adda[cur]*addb[cur]%mod*ln%mod)%mod; suma[cur&lt;&lt;1]=(suma[cur&lt;&lt;1]+1LL*ln*adda[cur]%mod)%mod; sumb[cur&lt;&lt;1]=(sumb[cur&lt;&lt;1]+1LL*ln*addb[cur]%mod)%mod; addv[cur&lt;&lt;1]=(addv[cur&lt;&lt;1]+1LL*A[cur]*adda[cur&lt;&lt;1]%mod)%mod; addv[cur&lt;&lt;1]=(addv[cur&lt;&lt;1]+1LL*B[cur]*addb[cur&lt;&lt;1]%mod)%mod; addv[cur&lt;&lt;1]=(addv[cur&lt;&lt;1]+addv[cur])%mod; A[cur&lt;&lt;1]=(A[cur&lt;&lt;1]+A[cur])%mod; B[cur&lt;&lt;1]=(B[cur&lt;&lt;1]+B[cur])%mod; adda[cur&lt;&lt;1]=(adda[cur&lt;&lt;1]+adda[cur])%mod; addb[cur&lt;&lt;1]=(addb[cur&lt;&lt;1]+addb[cur])%mod; sumv[cur&lt;&lt;1|1]=(sumv[cur&lt;&lt;1|1]+1LL*A[cur]*suma[cur&lt;&lt;1|1]%mod)%mod; sumv[cur&lt;&lt;1|1]=(sumv[cur&lt;&lt;1|1]+1LL*B[cur]*sumb[cur&lt;&lt;1|1]%mod)%mod; sumv[cur&lt;&lt;1|1]=(sumv[cur&lt;&lt;1|1]+1LL*rn*addv[cur]%mod)%mod; sump[cur&lt;&lt;1|1]=(sump[cur&lt;&lt;1|1]+1LL*adda[cur]*sumb[cur&lt;&lt;1|1]%mod)%mod; sump[cur&lt;&lt;1|1]=(sump[cur&lt;&lt;1|1]+1LL*addb[cur]*suma[cur&lt;&lt;1|1]%mod)%mod; sump[cur&lt;&lt;1|1]=(sump[cur&lt;&lt;1|1]+1LL*adda[cur]*addb[cur]%mod*rn%mod)%mod; suma[cur&lt;&lt;1|1]=(suma[cur&lt;&lt;1|1]+1LL*rn*adda[cur]%mod)%mod; sumb[cur&lt;&lt;1|1]=(sumb[cur&lt;&lt;1|1]+1LL*rn*addb[cur]%mod)%mod; addv[cur&lt;&lt;1|1]=(addv[cur&lt;&lt;1|1]+1LL*A[cur]*adda[cur&lt;&lt;1|1]%mod)%mod; addv[cur&lt;&lt;1|1]=(addv[cur&lt;&lt;1|1]+1LL*B[cur]*addb[cur&lt;&lt;1|1]%mod)%mod; addv[cur&lt;&lt;1|1]=(addv[cur&lt;&lt;1|1]+addv[cur])%mod; A[cur&lt;&lt;1|1]=(A[cur&lt;&lt;1|1]+A[cur])%mod; B[cur&lt;&lt;1|1]=(B[cur&lt;&lt;1|1]+B[cur])%mod; adda[cur&lt;&lt;1|1]=(adda[cur&lt;&lt;1|1]+adda[cur])%mod; addb[cur&lt;&lt;1|1]=(addb[cur&lt;&lt;1|1]+addb[cur])%mod; A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=0;&#125;inline void pushUp(int cur)&#123; sumv[cur]=(sumv[cur&lt;&lt;1]+sumv[cur&lt;&lt;1|1])%mod; suma[cur]=(suma[cur&lt;&lt;1]+suma[cur&lt;&lt;1|1])%mod; sumb[cur]=(sumb[cur&lt;&lt;1]+sumb[cur&lt;&lt;1|1])%mod; sump[cur]=(sump[cur&lt;&lt;1]+sump[cur&lt;&lt;1|1])%mod;&#125;void build(int cur,int l,int r)&#123; if(l==r)&#123; cltstream::read(sumv[cur]); cltstream::read(suma[cur]); cltstream::read(sumb[cur]); sumv[cur]=(sumv[cur]%mod+mod)%mod; suma[cur]=(suma[cur]%mod+mod)%mod; sumb[cur]=(sumb[cur]%mod+mod)%mod; sump[cur]=1LL*suma[cur]*sumb[cur]%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; build(cur&lt;&lt;1,l,mid); build(cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;int query(int L,int R,int t,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R) return (sumv[cur]+1LL*t*sump[cur]%mod)%mod; else&#123; int mid=(l+r)&gt;&gt;1,res=0; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) res=(res+query(L,R,t,cur&lt;&lt;1,l,mid))%mod; if(R&gt;mid) res=(res+query(L,R,t,cur&lt;&lt;1|1,mid+1,r))%mod; return res; &#125;&#125;void modifyV(int L,int R,int x,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; sumv[cur]=(sumv[cur]+1LL*(r-l+1)*x%mod)%mod; addv[cur]=(addv[cur]+x)%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) modifyV(L,R,x,cur&lt;&lt;1,l,mid); if(R&gt;mid) modifyV(L,R,x,cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;void modifyA(int L,int R,int t,int x,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; sumv[cur]=(sumv[cur]+(-1LL*x*t%mod*sumb[cur]%mod+mod)%mod)%mod; suma[cur]=(suma[cur]+1LL*(r-l+1)*x%mod)%mod; sump[cur]=(sump[cur]+1LL*sumb[cur]*x%mod)%mod; B[cur]=(B[cur]+(-1LL*x*t%mod+mod)%mod)%mod; addv[cur]=(addv[cur]+(-1LL*x*t%mod*addb[cur]%mod+mod)%mod)%mod; adda[cur]=(adda[cur]+x)%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) modifyA(L,R,t,x,cur&lt;&lt;1,l,mid); if(R&gt;mid) modifyA(L,R,t,x,cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;void modifyB(int L,int R,int t,int x,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; sumv[cur]=(sumv[cur]+(-1LL*x*t%mod*suma[cur]%mod+mod)%mod)%mod; sumb[cur]=(sumb[cur]+1LL*(r-l+1)*x%mod)%mod; sump[cur]=(sump[cur]+1LL*suma[cur]*x%mod)%mod; A[cur]=(A[cur]+(-1LL*x*t%mod+mod)%mod)%mod; addv[cur]=(addv[cur]+(-1LL*x*t%mod*adda[cur]%mod+mod)%mod)%mod; addb[cur]=(addb[cur]+x)%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) modifyB(L,R,t,x,cur&lt;&lt;1,l,mid); if(R&gt;mid) modifyB(L,R,t,x,cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); build(1,1,n); for(re int i=1;i&lt;=m;++i)&#123; int opt,t,l,r,x; cltstream::read(opt); cltstream::read(t); cltstream::read(l); cltstream::read(r); switch(opt)&#123; case 1: cltstream::write(query(l,r,t,1,1,n),10); break; case 2: cltstream::read(x); modifyA(l,r,t,(x%mod+mod)%mod,1,1,n); break; case 3: cltstream::read(x); modifyB(l,r,t,(x%mod+mod)%mod,1,1,n); break; case 4: cltstream::read(x); modifyV(l,r,(x%mod+mod)%mod,1,1,n); break; &#125; &#125; clop(); return 0;&#125; 大概是我太菜了不适合做这种毒瘤题吧qaq 距 在NOIp2018爆零 还剩 1 天。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"},{"name":"线段树","slug":"线段树","permalink":"https://github.com/Challestend/tags/线段树/"}]},{"title":"状态压缩动态规划学习笔记","slug":"status-compression-learning-notes","date":"2018-10-24T13:24:05.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"status-compression-learning-notes/","link":"","permalink":"https://github.com/Challestend/status-compression-learning-notes/","excerpt":"把标签和分类连在一起读就是标题了（ 好像上一篇珂朵莉树学习笔记也是这样（ 马上就要复赛了，但反正我已经退役预定了来颓blog吧。","text":"把标签和分类连在一起读就是标题了（ 好像上一篇珂朵莉树学习笔记也是这样（ 马上就要复赛了，但反正我已经退役预定了来颓blog吧。 首先我们来看一道例题，「USACO06NOV」玉米田Corn Fields。 首先，我们想到定义f[i][...]表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……f[i][0/1]...(省略10个[0/1])...[0/1]，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。 但是等等……$13$维的状态…… 注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。 于是，现在我们定义f[i][S]表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义a[i]表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。valid[S]表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。a[i]在读入时就可以处理出来，至于valid[S]，我们可以通过这样的一个循环处理出来： 12for(re int i=1;i&lt;(1&lt;&lt;m);++i) valid[i]=valid[i&gt;&gt;1]&amp;(~(i&amp;(i&gt;&gt;1)&amp;1)); 用人话来讲就是[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]。 在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0。 123456789for(re int i=0;i&lt;(1&lt;&lt;m);++i) if((i|a[1])==a[1]&amp;&amp;valid[i]) f[1][i]=1;for(re int i=2;i&lt;=n;++i) for(re int j=0;j&lt;(1&lt;&lt;m);++j) if((j|a[i])==a[i]&amp;&amp;valid[j]) for(re int k=0;k&lt;(1&lt;&lt;m);++k) if((k|a[i-1])==a[i-1]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==0) (f[i][j]+=f[i-1][k])%=mod; 粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个if剪掉，因而实际运行跑得比谁都快（ 为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，「NOI2001」炮兵阵地。 因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用f[i][S1][S2]表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录a[i]和valid[S]，不过，这次valid[s]的预处理过程差不多是这样： 12for(re int i=1;i&lt;(1&lt;&lt;m);++i)&#123; valid[i]=(i&amp;1)?valid[i&gt;&gt;3]&amp;((~i)&gt;&gt;2)&amp;((~i)&gt;&gt;1):valid[i&gt;&gt;1]; 看起来有些非常复杂，用人话来讲就是……诶我当时是不是写错了（ ……不好像又没写错…… 好吧没写错。 如果$S$的最后一位是$1$，则[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]，否则[S是否合法]=[S&gt;&gt;1是否合法]。 因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理： 12for(re int i=1;i&lt;(1&lt;&lt;m);++i) cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); 转移过程如下： 12345678910111213for(re int i=0;i&lt;(1&lt;&lt;m);++i) if((i|a[1])==a[1]&amp;&amp;valid[i]) for(re int j=0;j&lt;(1&lt;&lt;m);++j) if((j|a[2])==a[2]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==0) f[2][i][j]=cnt[i]+cnt[j];for(re int i=3;i&lt;=n;++i) for(re int j=0;j&lt;(1&lt;&lt;m);++j) if((j|a[i-2])==a[i-2]&amp;&amp;valid[j]) for(re int k=0;k&lt;(1&lt;&lt;m);++k) if((k|a[i-1])==a[i-1]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==0) for(re int l=0;l&lt;(1&lt;&lt;m);++l) if((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==0&amp;&amp;(l&amp;k)==0) f[i][k][l]=max(f[i][k][l],f[i-1][j][k]+cnt[l]); 时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\\text{won’t TLE})$（ 我们再来看一个状压的应用，「SP3953」MMINPAID - Paid Roads，或者您也可以反正我就是在洛谷上提交。 大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义dis[u][S]为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。 这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。 我是不会说我把impossible打成Impossible然后交上去WA了一发的（ 一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\\leqslant 20$，就很有可能是状压题或者也有可能是神仙剪枝题。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。 以上，我觉得我的状压讲的差不多了（","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"状态压缩","slug":"状态压缩","permalink":"https://github.com/Challestend/tags/状态压缩/"},{"name":"动态规划","slug":"动态规划","permalink":"https://github.com/Challestend/tags/动态规划/"}]},{"title":"珂朵莉树学习笔记","slug":"chtholly-tree-learning-notes","date":"2018-10-13T13:13:09.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"chtholly-tree-learning-notes/","link":"","permalink":"https://github.com/Challestend/chtholly-tree-learning-notes/","excerpt":"还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。 话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。 总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。","text":"还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。 话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。 总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。 我们先来看一道毒瘤例题，「CF896C」Willem, Chtholly and Seniorious。 如果只看前三个操作的话，虽然我不会写也没写过，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？ 这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于std::set的暴力数据结构，虽然您也可以手写一颗平衡树，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话： 珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。 那么怎么推平呢？不急，我们慢慢讲。 珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体： 1234567891011121314151617struct node&#123; int l,r; mutable long long val; //这里的mutable是为了让我们在之后的修改过程中可以修改val的值 node(int _l,int _r=-1,long long _val=-1)&#123; //调用时_r或_val不填的话默认-1，为了后面split时方便 l=_l; r=_r; val=_val; &#125;&#125;;std::set&lt;node&gt; s;inline bool operator&lt;(node p,node q)&#123; return p.l&lt;q.l;&#125; 然后我们就可以初始化了。对于这道题，我们可以像这样初始化： 12for(re int i=1;i&lt;=n;++i) s.insert(node(i,i,rnd()%maxval+1)); 初始化完了？ 初始化完了。 然后就是珂朵莉树的核心操作之一， 1std::&lt;set&gt;::iterator split(int pos) 作用是分离出一个左端点为pos的区间并返回它的迭代器。它的具体实现如下： 1234567891011121314151617#define _it std::set&lt;node&gt;::iterator//上面这句手打非常麻烦，建议宏定义inline _it split(int pos)&#123; _it it=std::lower_bound(s.begin(),s.end(),node(pos)); //找第一个左端点大于等于pos的区间 if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; //如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器 --it; //否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内 int l=it-&gt;l,r=it-&gt;r; long long val=it-&gt;val; s.erase(it); s.insert(node(l,pos-1,val)); return s.insert(node(pos,r,val)).first; //将区间[l,r]删除，并插入区间[l,pos)和[pos,r]&#125; 虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。 insert函数的返回值类型是std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了，因此我们需要加个.first。 std::set内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\\operatorname{log}n)$的。 然后是一个同样很核心的操作， 1void assign(int l,int r,int x) 将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下： 123456789inline void assign(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); //注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内 //后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器 s.erase(itl,itr); //将[itl,itr)内所有区间删除 s.insert(node(l,r,x)); //用一个大区间取代它们&#125; 这就完了？ 这就完了。 assign操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得set的大小迅速减小，并最终趋于$\\operatorname{log}n$。本题的操作二就只需调用一次assign(l,r,x)即可。 然后是剩下的三个操作，一个比一个暴力。 操作一，一个一个区间地拿出来加。 12345inline void IntervalAdd(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); for(re _it p=itl;p!=itr;++p) p-&gt;val+=x;&#125; 就这么几行？ 就这么几行。 操作三，把所有区间取出来，然后直接调用std::sort。 12345678910111213inline long long IntervalXth(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); vec.clear(); for(re _it p=itl;p!=itr;++p) vec.push_back(std::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+1)); std::sort(vec.begin(),vec.end()); for(re unsigned i=0;i&lt;vec.size();++i)&#123; x-=vec[i].second; if(x&lt;=0) return vec[i].first; &#125; return 0;&#125; 操作四，暴力快速幂。 1234567inline int IntervalXpow(int l,int r,int x,int y)&#123; _it itr=split(r+1),itl=split(l); int res=0; for(re _it p=itl;p!=itr;++p) res=(1LL*res+1LL*(p-&gt;r-p-&gt;l+1)*cltpow(p-&gt;val%y,x,y)%y)%y; return res;&#125; 您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？ 这是我在CodeForces上的提交记录： 这是我之前提到的那位不愿意透露姓名的珂学家的跑得最快的一次提交记录： 珂幻.jpg 因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了「CF915E」Physical Education Lessons，然而…… Updated on 2018-11-01 后来我卡了卡常数过了…… 以及，删掉了某些内容（ 于是，接下来是珂朵莉树的完整板子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#define re register#define maxn 100000#define _it std::set&lt;node&gt;::iteratornamespace cltstream&#123; #ifdef ONLINE_JUDGE #define size 1048576 char str[size+1],*head=str,*tail=str; inline char gc()&#123; if(head==tail)&#123; tail=(head=str)+fread(str,1,size,stdin); if(head==tail) return EOF; &#125; return *head++; &#125; #undef size #else #define gc getchar #endif template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=' ')&#123; if(x&lt;0) putchar(45),x=-x; if(!x) putchar(48); else&#123; int digit[20]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];putchar(digit[digit[0]--]^48)); &#125; putchar(text); &#125;&#125;int n,m,seed,maxval;struct node&#123; int l,r; mutable long long val; node(int _l,int _r=-1,long long _val=-1)&#123; l=_l; r=_r; val=_val; &#125;&#125;;std::set&lt;node&gt; s;std::vector&lt;std::pair&lt;long long,int&gt; &gt; vec;inline int rnd()&#123; int res=seed; seed=(7LL*seed+13)%1000000007; return res;&#125;inline void swap(int&amp; l,int&amp; r)&#123; int tmp=l; l=r; r=tmp;&#125;int cltpow(int x,int y,int mod)&#123; if(y==1) return x; int res=cltpow(x,y&gt;&gt;1,mod); res=1LL*res*res%mod; if(y&amp;1) res=1LL*res*x%mod; return res;&#125;inline bool operator&lt;(node p,node q)&#123; return p.l&lt;q.l;&#125;inline _it split(int pos)&#123; _it it=std::lower_bound(s.begin(),s.end(),node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; --it; int l=it-&gt;l,r=it-&gt;r; long long val=it-&gt;val; s.erase(it); s.insert(node(l,pos-1,val)); return s.insert(node(pos,r,val)).first;&#125;inline void IntervalAdd(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); for(re _it p=itl;p!=itr;++p) p-&gt;val+=x;&#125;inline void IntervalAssign(int l,int r,int x)&#123;//就是之前提到的assign _it itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(node(l,r,x));&#125;inline long long IntervalXth(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); vec.clear(); for(re _it p=itl;p!=itr;++p) vec.push_back(std::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+1)); std::sort(vec.begin(),vec.end()); for(re unsigned i=0;i&lt;vec.size();++i)&#123; x-=vec[i].second; if(x&lt;=0) return vec[i].first; &#125; return 0;&#125;inline int IntervalXpow(int l,int r,int x,int y)&#123; _it itr=split(r+1),itl=split(l); int res=0; for(re _it p=itl;p!=itr;++p) res=(1LL*res+1LL*(p-&gt;r-p-&gt;l+1)*cltpow(p-&gt;val%y,x,y)%y)%y; return res;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); cltstream::read(seed); cltstream::read(maxval); for(re int i=1;i&lt;=n;++i) s.insert(node(i,i,rnd()%maxval+1)); for(re int i=1;i&lt;=m;++i)&#123; int opt=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1,x,y; if(l&gt;r) swap(l,r); switch(opt)&#123; case 1: x=rnd()%maxval+1; IntervalAdd(l,r,x); break; case 2: x=rnd()%maxval+1; IntervalAssign(l,r,x); break; case 3: x=rnd()%(r-l+1)+1; cltstream::write(IntervalXth(l,r,x),'\\n'); break; case 4: x=rnd()%maxval+1; y=rnd()%maxval+1; cltstream::write(IntervalXpow(l,r,x,y),'\\n'); break; &#125; &#125; return 0;&#125; 以上。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"珂朵莉树","slug":"珂朵莉树","permalink":"https://github.com/Challestend/tags/珂朵莉树/"}]},{"title":"「SDOI2009」虔诚的墓主人","slug":"luogu-p2154-solution","date":"2018-10-12T03:28:50.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p2154-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p2154-solution/","excerpt":"传送门","text":"传送门 几个月前某学姐给我推荐的毒瘤题之一。然而我直到现在也只切掉两道，我真是太菜了。 首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是 C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}考虑到墓地不能和常青树重合，又有$k\\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为 C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\\sum\\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})怎么快速地查询与修改后面那个$\\Sigma$所涉及到的值？树状数组啊当然如果您非要写些乱七八糟的数据结构也没人拦着您。 坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。 1234567891011121314#include&lt;cstdio&gt;struct NOIp&#123; unsigned long long RP,score;&#125;;NOIp NOIp2018;int main()&#123; for(;;)&#123; NOIp2018.RP++; NOIp2018.score++; &#125; return 0;&#125; 以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊但是我实在是太菜了qaq。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"组合数学","slug":"组合数学","permalink":"https://github.com/Challestend/tags/组合数学/"},{"name":"SDOI","slug":"SDOI","permalink":"https://github.com/Challestend/tags/SDOI/"},{"name":"2009","slug":"2009","permalink":"https://github.com/Challestend/tags/2009/"},{"name":"离散化","slug":"离散化","permalink":"https://github.com/Challestend/tags/离散化/"},{"name":"树状数组","slug":"树状数组","permalink":"https://github.com/Challestend/tags/树状数组/"}]},{"title":"「Luogu-P4900」食堂","slug":"luogu-p4900-solution","date":"2018-10-04T04:11:18.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p4900-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p4900-solution/","excerpt":"传送门","text":"传送门 闲着没事写篇题解（ 简单来说，就是要求 \\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\pmod{998244353}其中$\\lbrace x\\rbrace$表示取$x$的小数部分。 稍加思索，我们不难发现 \\begin{aligned} &\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\\\ \\equiv&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\\\ \\equiv&\\sum\\limits_{i=1}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}-\\sum\\limits_{i=1}^{A-1}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1} \\pmod{998244353} \\end{aligned}因此，我们只需要关注下式的值 \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\pmod{998244353}我们可以参考一下这道题 在这道题中，我们定义了 f(x)=\\sum\\limits_{i=1}^{n}x\\%i首先，如果不考虑$x\\%i=0$的情况，我们有 x\\%i=(x-1)\\%i+1f(x)=f(x-1)+n如果$x\\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此 f(x)=f(x-1)+n-\\sigma(x)我们可以类似地定义 g(x)=\\sum\\limits_{i=1}^{n}x\\%i\\times i^{-1}\\pmod{998244353}h(x)=\\sum\\limits_{i\\mid x}i\\times i^{-1}\\equiv\\sum\\limits_{i\\mid x}1\\equiv d(x)\\pmod{998244353}从而我们有 g(x)\\equiv g(x-1)+\\sum\\limits_{i=1}^{n}i^{-1}-d(x)\\pmod{998244353}然而我们需要的是 \\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}其中 ans(x)=\\sum\\limits_{i=1}^{x}x\\%i\\times i^{-1}\\pmod{998244353}不难发现当$i&lt;j$时$i\\%j=i$，从而 \\begin{aligned} &g(x)-ans(x)\\\\ \\equiv&\\sum\\limits_{i=x+1}^{n}x\\%i\\times i^{-1}\\\\ \\equiv&\\sum\\limits_{i=x+1}^{n}x\\times i^{-1} \\pmod{998244353} \\end{aligned}最终，我们得到 ans(x)\\equiv g(x)-x\\sum\\limits_{i=x+1}^{n}i^{-1}\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\equiv\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"}]},{"title":"「Luogu-P3924」康娜的线段树","slug":"luogu-p3924-solution","date":"2018-09-29T08:20:16.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-p3924-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p3924-solution/","excerpt":"传送门","text":"传送门 读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围： 对于$70\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{5}$。 对于$100\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{6}$。 也就是说，上述做法最多只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。 Updated on 2018-10-09 不好意思时间复杂度算错了我太菜了。 但反正线段树需要卡常才能过（ 我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。 定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。 稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。 以及，最后一句话。 这道题卡精度。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"},{"name":"差分","slug":"差分","permalink":"https://github.com/Challestend/tags/差分/"}]},{"title":"「Luogu-T47720」孤立元","slug":"luogu-t47720-solution","date":"2018-09-27T06:29:56.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"luogu-t47720-solution/","link":"","permalink":"https://github.com/Challestend/luogu-t47720-solution/","excerpt":"传送门","text":"传送门 自己出的第一道毒瘤数论题。 对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\\notin B$且$i+1\\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为 \\frac{\\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式 \\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\\frac{m(n+1)(n-m)}{n(n-1)} Updated on 2018-10-10 之前公式写错了，分子上的$m$全都漏掉了（ 以及，我们还可以将上式继续整理： \\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}以及，顺便测试了一下新的快读板子，然后发现#ifdef真没用也可能是我太菜了（ Updated on 2018-10-16 好吧我当时并不会用#ifdef（ 以及，标程经过一系列丧心病狂的卡常卡到了$1861\\text{ms}$，最慢的一个点只跑了$300\\text{ms}$不到。截至本日，另外两个切掉这道题的$\\text{dalao}$最慢的一个点也只跑了$400\\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？所以说为什么我当初在本地测的时候平均每个点$500\\text{ms}$，是我们机房的电脑太菜了吗（ 于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。 但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://github.com/Challestend/tags/组合数学/"},{"name":"期望","slug":"期望","permalink":"https://github.com/Challestend/tags/期望/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-27T05:41:19.000Z","updated":"2019-03-25T11:06:01.295Z","comments":true,"path":"hello-world/","link":"","permalink":"https://github.com/Challestend/hello-world/","excerpt":"","text":"总算是搞出来了一个自己觉得海星的blog……","categories":[{"name":"未分类","slug":"未分类","permalink":"https://github.com/Challestend/categories/未分类/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/Challestend/tags/其它/"}]}]}