{"meta":{"title":"空を喰らう幽霊塔","subtitle":"どうか醜いくらいに美しい愛で、この心を抉ってくれよ。","description":"A juruo OIer from SD province.","author":"Challestend Rehtorbegnaro","url":"https://github.com/Challestend"},"pages":[{"title":"","date":"2018-12-19T12:17:59.692Z","updated":"2018-12-19T12:17:59.692Z","comments":false,"path":"404.html","permalink":"https://github.com/Challestend/404.html","excerpt":"","text":"您可能访问了错误的网址 回到博客主页"},{"title":"关于","date":"2018-12-12T11:50:25.678Z","updated":"2018-12-12T11:50:25.678Z","comments":false,"path":"about/index.html","permalink":"https://github.com/Challestend/about/index.html","excerpt":"","text":"A juruo OIer from SD province. Studying in SLYZ. Find me on Luogu LibreOJ NowCoder CodeForces GitHub"},{"title":"更新日志","date":"2018-12-12T11:47:51.000Z","updated":"2019-01-08T03:08:09.786Z","comments":true,"path":"log/index.html","permalink":"https://github.com/Challestend/log/index.html","excerpt":"","text":"直角，这是这篇blog的更新日志。 不过我不是一个考虑周全的人，之前9月份搭起博客时，我并没有考虑到这些。因而，之前的很多更新的具体时间已经无从知晓。 2018-09-27 建站。 （略） 2018-12-13 令theme-next-pace的加载进度条的颜色温和了一点。 将hexo-symbols-count-time的字数和时间统计替换成了精确数值。 减少了侧边栏和网易云外链的宽度。 2018-12-14 修复了在404页面点击「回到博客主页」会打开新标签页的问题。 2018-12-19 将字体改为了Arima Madurai。 2018-12-28 新增了访客计数。 2019-01-07 不知道什么时候字体炸了，然后xjb捣鼓了一波终于修好了。 2019-01-08 然后一大早发现它又炸了。告辞。不修了。然后传上去发现又好了。 To Be Continued"},{"title":"分类","date":"2018-10-11T00:14:04.000Z","updated":"2018-12-12T11:50:34.445Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/Challestend/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-09T01:57:40.000Z","updated":"2018-12-12T11:50:44.607Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/Challestend/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"类欧几里得算法学习笔记","slug":"similar-euclid-algorithm-learning-notes","date":"2019-01-10T05:37:33.000Z","updated":"2019-01-10T09:49:05.658Z","comments":true,"path":"similar-euclid-algorithm-learning-notes/","link":"","permalink":"https://github.com/Challestend/similar-euclid-algorithm-learning-notes/","excerpt":"其实我也不知道这个算法的英文名是啥（ 我就yy出来一个「Similar Euclid Algorithm」（","text":"其实我也不知道这个算法的英文名是啥（ 我就yy出来一个「Similar Euclid Algorithm」（ 给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出 \\sum_{i=0}^{n}i^{k_{1}}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{k_{2}}\\pmod{1000000007}$n,a,b,c\\leqslant 10^{9}$，$k_{1}+k_{2}\\leqslant 10$。 太难了，告辞（ 所以我们现在来研究简单一点的。 给你四个非负整数$n,a,b,c$，你需要求出 \\begin{aligned} f(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\ g(n,a,b,c)&\\equiv\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\pmod{998244353}\\\\ h(n,a,b,c)&\\equiv\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\pmod{998244353} \\end{aligned}$n,a,b,c\\leqslant 10^{9}$，$10^{5}$组询问。 传送门 于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。 首先考虑$f(n,a,b,c)$，假设$a\\geqslant c\\vee b\\geqslant c$ \\begin{aligned} f(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\ &=\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\\\ &=f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor \\end{aligned}也就是说，我们只需要重点关注$a\\lt c\\wedge b\\lt c$时的情况即可。我们令$m=\\lfloor\\cfrac{an+b}{c}\\rfloor$，然后继续往下推 \\begin{aligned} f(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\sum_{j=1}^{m}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\leqslant ai+b\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\geqslant cj+c-b\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\geqslant\\cfrac{cj+c-b}{a}\\right]\\\\ \\end{aligned}然后我们发现，我们可能需要在$\\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。 考虑转换一下思路。既然$cj+c\\leqslant ai+b$，我们就有$cj+c\\lt ai+b+1$，然后再往下 \\begin{aligned} f(n,a,b,c)&=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[cj+c\\lt ai+b+1\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[ai\\gt cj+c-b-1\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]\\\\ &=\\sum_{j=0}^{m-1}\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\ &=mn-\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\ &=mn-f(m-1,c,c-b-1,a) \\end{aligned}然后我们看到，这个函数它递归了！ 注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\\log a$次，时间复杂度就是$O(\\log a)$了。 然后考虑$g(n,a,b,c)$。 $a\\geqslant c\\vee b\\geqslant c$： \\begin{aligned} g(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\left(i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i^{2}\\lfloor\\cfrac{a}{c}\\rfloor+i\\lfloor\\cfrac{b}{c}\\rfloor\\right)\\\\ &=\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\\\ &=g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor \\end{aligned}$a\\lt c\\wedge b\\lt c$，当然$m$还是$\\lfloor\\cfrac{an+b}{c}\\rfloor$： \\begin{aligned} g(n,a,b,c)&=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=\\sum_{i=0}^{n}\\sum_{j=1}^{m}i\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m-1}i\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right] \\end{aligned}我们可以把上面这个式子理解成$\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor$且$\\leqslant n$的所有自然数之和，于是差分一下我们得到 \\begin{aligned} g(n,a,b,c)&=\\sum_{j=0}^{m-1}\\left(\\cfrac{n(n+1)}{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)\\\\ &=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor^{2}-\\cfrac{1}{2}\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\\\ &=\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a) \\end{aligned}我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。 $a\\geqslant c\\vee b\\geqslant c$： \\begin{aligned} h(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\ &=\\sum_{i=0}^{n}\\left(\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor+i\\lfloor\\cfrac{a}{c}\\rfloor+\\lfloor\\cfrac{b}{c}\\rfloor\\right)^{2}\\\\ &=\\sum_{i=0}^{n}\\left( \\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2} +i^{2}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +\\lfloor\\cfrac{b}{c}\\rfloor^{2} +2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +2\\lfloor\\cfrac{b}{c}\\rfloor\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +2i\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor \\right)\\\\ &= \\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor^{2} +\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}\\\\& +2\\lfloor\\cfrac{a}{c}\\rfloor\\sum_{i=0}^{n}i\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +2\\lfloor\\cfrac{b}{c}\\rfloor\\sum_{i=0}^{n}\\lfloor\\cfrac{(a\\operatorname{mod}c)i+(b\\operatorname{mod}c)}{c}\\rfloor +n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor \\\\ &= h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\& +\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2} +n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor \\end{aligned}您绝对想象不到上面这一坨子东西的$\\TeX$源码长什么样（ $a\\lt c\\wedge b\\lt c$： \\begin{aligned} h(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\ &=\\sum_{i=0}^{n}\\sum_{j=1}^{m^{2}}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[c^{2}j+c^{2}\\lt a^{2}i^{2}+2abi+b^{2}+1\\right]\\\\ &=\\sum_{i=0}^{n}\\sum_{j=0}^{m^{2}-1}\\left[i\\gt\\sqrt{\\lfloor\\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\\rfloor}\\right] \\end{aligned} 然后我们发现推不下去了。 不过办法总是有的。首先我们有一个看起来没啥用的式子 x^{2}=2\\sum_{i=1}^{n}i-x套进去 \\begin{aligned} h(n,a,b,c)&=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}\\\\ &=\\sum_{i=0}^{n}\\left(2\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right)\\\\ &=2\\sum_{i=0}^{n}\\sum_{j=1}^{\\lfloor\\tfrac{ai+b}{c}\\rfloor}j-\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor\\\\ &=2\\sum_{j=1}^{m}j\\sum_{i=0}^{n}\\left[j\\leqslant\\lfloor\\cfrac{ai+b}{c}\\rfloor\\right]-f(n,a,b,c)\\\\ &=2\\sum_{j=0}^{m-1}(j+1)\\sum_{i=0}^{n}\\left[i\\gt\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right]-f(n,a,b,c)\\\\ &=2\\sum_{j=0}^{m-1}(j+1)\\left(n-\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor\\right)-f(n,a,b,c)\\\\ &=m(m+1)n-2\\sum_{j=0}^{m-1}j\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-2\\sum_{j=0}^{m-1}\\lfloor\\cfrac{cj+c-b-1}{a}\\rfloor-f(n,a,b,c)\\\\ &=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\\ \\end{aligned}然后我们看到它奇迹般地递归了！ 我们来总结一下。 f(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases} &f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{a}{c}\\rfloor+(n+1)\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\ &mn-f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c) \\end{cases}g(n,a,b,c)=\\sum_{i=0}^{n}i\\lfloor\\cfrac{ai+b}{c}\\rfloor=\\begin{cases} &g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)+\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor+\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(a\\geqslant c\\vee b\\geqslant c)\\\\ &\\cfrac{mn(n+1)}{2}-\\cfrac{1}{2}h(m-1,c,c-b-1,a)-\\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\\lt c\\wedge b\\lt c) \\end{cases}h(n,a,b,c)=\\sum_{i=0}^{n}\\lfloor\\cfrac{ai+b}{c}\\rfloor^{2}=\\begin{cases} &h(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{a}{c}\\rfloor g(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c) +2\\lfloor\\cfrac{b}{c}\\rfloor f(n,a\\operatorname{mod}c,b\\operatorname{mod}c,c)\\\\& +\\cfrac{n(n+1)(2n+1)}{6}\\lfloor\\cfrac{a}{c}\\rfloor^{2} +(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2} +n(n+1)\\lfloor\\cfrac{a}{c}\\rfloor\\lfloor\\cfrac{b}{c}\\rfloor\\;\\; &(a\\geqslant c\\vee b\\geqslant c)\\\\ &m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\\lt c\\wedge b\\lt c) \\end{cases}但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样： f(n,a,b,c)=\\begin{cases} &\\lfloor\\cfrac{b}{c}\\rfloor\\;\\;&(n=0)\\\\ &(n+1)\\lfloor\\cfrac{b}{c}\\rfloor&(a=0) \\end{cases}g(n,a,b,c)=\\begin{cases} &0\\;\\;&(n=0)\\\\ &\\cfrac{n(n+1)}{2}\\lfloor\\cfrac{b}{c}\\rfloor&(a=0) \\end{cases}h(n,a,b,c)=\\begin{cases} &\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(n=0)\\\\ &(n+1)\\lfloor\\cfrac{b}{c}\\rfloor^{2}&(a=0) \\end{cases}另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;cstdio&gt;#define re register#define mod 998244353namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int t,a,b,c,n,I2=499122177,I6=166374059;struct Query&#123; int f,g,h; Query(re int _f,re int _g,re int _h)&#123; f=_f; g=_g; h=_h; &#125;&#125;;inline Query query(re int a,re int b,re int c,re int n)&#123; if(!n)&#123; b/=c; return Query(b,0,1LL*b*b%mod); &#125; if(!a)&#123; b/=c; return Query(1LL*(n+1)*b%mod,1LL*n*(n+1)%mod*I2%mod*b%mod,1LL*(n+1)*b%mod*b%mod); &#125; if(a&gt;=c||b&gt;=c)&#123; re Query res=query(a%c,b%c,c,n); a/=c, b/=c; return Query( (res.f+1LL*n*(n+1)%mod*I2%mod*a%mod+1LL*(n+1)*b%mod)%mod, (res.g+1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod+1LL*n*(n+1)%mod*I2%mod*b%mod)%mod, (res.h+2LL*a*res.g%mod+2LL*b*res.f%mod +1LL*n*(n+1)%mod*(2*n+1)%mod*I6%mod*a%mod*a%mod +1LL*(n+1)*b%mod*b%mod+1LL*n*(n+1)%mod*a%mod*b%mod)%mod ); &#125; else&#123; re int m=(1LL*a*n+b)/c; re Query res=query(c,c-b-1,a,m-1); re int tmp=((1LL*m*n%mod-res.f)%mod+mod)%mod; return Query( tmp, ((1LL*m*n%mod*(n+1)%mod-res.h-res.f)%mod+mod)*I2%mod, ((1LL*m*(m+1)%mod*n%mod-2LL*res.g%mod-2LL*res.f%mod-tmp)%mod+mod)%mod ); &#125;&#125;int main()&#123; cltstream::read(t); for(;t;--t)&#123; cltstream::read(n); cltstream::read(a); cltstream::read(b); cltstream::read(c); Query ans=query(a,b,c,n); cltstream::write(ans.f,32); cltstream::write(ans.h,32); cltstream::write(ans.g,10); &#125; clop(); return 0;&#125; 那么问题来了，这个东西有什么用啊。 没啥用（ 其他的模板题我就不举了，我们来看一下这样一道题。 看到推平操作我们可以直接往珂朵莉树上想了。 那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息l,r,L,R,a,b，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\\sum_{i=L}^{R}ai\\operatorname{mod}b$颗石头。注意这里的l,r,L,R一定不要搞混，我就是因为这样WA了整整四遍（。 这三个样例一定是故意的。 然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样： \\sum_{i=L}^{R}ai\\operatorname{mod}b=\\sum_{i=L}^{R}\\left(ai-\\lfloor\\cfrac{ai}{b}\\rfloor b\\right)=\\cfrac{(R+L)(R-L+1)}{2}-\\sum_{i=0}^{R}\\lfloor\\cfrac{ai}{b}\\rfloor b+\\sum_{i=0}^{L-1}\\lfloor\\cfrac{ai}{b}\\rfloor b直接一波板子套上去。 还有就是，这么算的话中间量会爆long long，我们可以考虑用__int128_t来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以 123#ifdef ONLINE_JUDGE #define int __int128_t#endif 然后把一些没必要用或者是不能用__int128_t的改成signed即可。 代码还是有必要贴一下的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;set&gt;#define re register#define _it std::set&lt;node&gt;::iterator#ifdef ONLINE_JUDGE #define int __int128_t#endifnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; signed sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; signed digit[50]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m;inline int simEuc(re int n,re int a,re int b,re int c)&#123; if(!n) return b/c; if(!a) return (n+1)*(b/c); if(a&gt;=c||b&gt;=c)&#123; re int res=simEuc(n,a%c,b%c,c); return res+n*(n+1)*(a/c)/2+(n+1)*(b/c); &#125; else&#123; re int m=(a*n+b)/c; return m*n-simEuc(m-1,c,c-b-1,a); &#125;&#125;struct node&#123; int l,r,L,R,a,b,sum; node(re int _l,re int _r,re int _L,re int _R,re int _a,re int _b)&#123; l=_l; r=_r; L=_L; R=_R; a=_a; b=_b; sum=(R+L)*(R-L+1)*a/2-simEuc(R,a,0,b)*b+simEuc(L-1,a,0,b)*b; &#125;&#125;;std::set&lt;node&gt; s;inline bool operator&lt;(re node p1,re node p2)&#123; return p1.l&lt;p2.l;&#125;inline _it split(re int pos)&#123; re _it it=s.lower_bound(node(pos,0,1,0,0,1)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; else&#123; --it; re int l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b; s.erase(it); s.insert(node(l,pos-1,L,L+pos-l-1,a,b)); return s.insert(node(pos,r,L+pos-l,R,a,b)).first; &#125;&#125;inline void modifyStone(re int l,re int r,re int a,re int b)&#123; re _it itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(node(l,r,1,r-l+1,a,b));&#125;inline int queryStone(re int l,re int r)&#123; re _it itr=split(r+1),itl=split(l); re int res=0; for(;itl!=itr;res+=itl-&gt;sum,++itl); return res;&#125;signed main()&#123; cltstream::read(n); cltstream::read(m); s.insert(node(1,n,1,0,0,1)); for(re int i=1;i&lt;=m;++i)&#123; re int opt,l,r,a,b; cltstream::read(opt); cltstream::read(l); cltstream::read(r); if(opt==1)&#123; cltstream::read(a); cltstream::read(b); modifyStone(l,r,a,b); &#125; else cltstream::write(queryStone(l,r),10); &#125; clop(); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"类欧几里得","slug":"类欧几里得","permalink":"https://github.com/Challestend/tags/类欧几里得/"}]},{"title":"「HEOI2012」采花","slug":"luogu-p4113-solution","date":"2019-01-07T11:05:03.000Z","updated":"2019-01-08T13:37:23.485Z","comments":true,"path":"luogu-p4113-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p4113-solution/","excerpt":"传送门 Taduro的题解 sto Taduro orz","text":"传送门 Taduro的题解 sto Taduro orz 首先，读完题一定有人要跳出来喊「莫队！」。 莫队！ 然后再一看数据范围 对于$100\\%$的数据，$1\\leqslant c\\leqslant n,m\\leqslant 2\\times 10^{6}$。 笑容逐渐消失。 然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了，树状数组什么时候有这种操作了。 首先这个样例比较菜，我们手造一个： 11 6 2 4 2 3 6 2 首先我们维护一个nxt数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的nxt差不多长这样： i $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ nxt[i] $0$ $7$ $5$ $0$ $8$ $0$ $0$ $0$ 然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。 然后我们还需要一个数组ans，对于每一种颜色，我们令其在指针所在位置及其之后的部分中第二次出现的位置的ans为$1$。 i $1$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ 因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。 不难发现，此时$\\sum_{i=1}^{x}ans[i]$就是询问1 x的答案。 需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的ans置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。 这个时候nxt数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。 让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）： i $\\underline{1}$ $2$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ i $1$ $\\underline{2}$ $3$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ $2$ $4$ $2$ $3$ $6$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ $1$ $0$ i $1$ $2$ $\\underline{3}$ $4$ $5$ $6$ $7$ $8$ c[i] $1$ ${\\color{red}6}$ $2$ $4$ $2$ $3$ ${\\color{red}6}$ $2$ ans[i] $0$ $0$ $0$ $0$ $1$ $0$ ${\\color{red}0}$ $0$ i $1$ $2$ $3$ $\\underline{4}$ $5$ $6$ $7$ $8$ c[i] $1$ $6$ ${\\color{red}2}$ $4$ ${\\color{red}2}$ $3$ $6$ ${\\color{red}2}$ ans[i] $0$ $0$ $0$ $0$ ${\\color{red}0}$ $0$ $0$ ${\\color{red}1}$ 对于一次询问l r，我们将指针移动到l这个位置之后查询$\\sum_{i=l}^{r}ans[i]$即可。 代码就不贴了，其实我还没写（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"https://github.com/Challestend/tags/树状数组/"},{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"},{"name":"HEOI","slug":"HEOI","permalink":"https://github.com/Challestend/tags/HEOI/"},{"name":"2012","slug":"2012","permalink":"https://github.com/Challestend/tags/2012/"},{"name":"莫队","slug":"莫队","permalink":"https://github.com/Challestend/tags/莫队/"}]},{"title":"「AHOI2017/HNOI2017」礼物","slug":"luogu-p3723-solution","date":"2019-01-04T03:14:12.000Z","updated":"2019-01-04T05:41:42.114Z","comments":true,"path":"luogu-p3723-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p3723-solution/","excerpt":"传送门","text":"传送门 首先我们要有一个简单粗暴的暴力。 \\min\\limits_{x=0}^{n-1}\\min\\limits_{c_{1}=0,c_{2}=0}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\\%n}-c_{2})^{2}因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。 \\min\\limits_{x=0}^{n-1}\\min\\limits_{c=-m}^{m}\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}我们仔细观察一下那个$\\Sigma$。 \\begin{aligned} &\\sum\\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\\%n}+c)^{2}\\\\ =&\\sum\\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\\%n}+2cA_{i}-2cB_{(i+x)\\%n})\\\\ =&\\sum\\limits_{i=0}^{n-1}A_{i}^{2}+\\sum\\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\\sum\\limits_{i=0}^{n-1}A_{i}-\\sum\\limits_{i=0}^{n-1}B_{i})-2\\sum\\limits_{i=0}^{n-1}A_{i}B_{(i+x)\\%n} \\end{aligned}首先$\\Sigma A_{i}^{2}$和$\\Sigma B_{i}^{2}$可以看成是常数项。 $nc^{2}+2c(\\Sigma A_{i}-\\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\\Sigma A_{i}-\\Sigma B_{i})$，我们知道它在$c=-\\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\\lfloor -\\cfrac{k}{n}\\rfloor$和$c=\\lceil -\\cfrac{k}{n}\\rceil$两者都代入原式，然后取较小值。 然后我们想要求出$\\Sigma A_{i}B_{(i+x)\\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。 \\sum\\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\\sum\\limits_{i=0}^{x-1}A_{i-x+n}B_{i}然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。 然后一想，我们可以倒过来搞啊。 定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成 \\begin{aligned} &\\sum\\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\\sum\\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\\\ =&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1} \\end{aligned}然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。 以下是代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include&lt;cstdio&gt;#include&lt;cmath&gt;#define re register#define maxn 131072#define mod 998244353#define max(a,b) ((a)&gt;=(b)?(a):(b))#define min(a,b) ((a)&lt;=(b)?(a):(b))#define swap(a,b) a^=b,b^=a,a^=bnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m,ans,k,mx;int unit[2][24],rev[maxn+1],A[maxn+1],B[maxn+1],C[maxn+1],D[maxn+1];inline int cltpow(re int x,re int y)&#123; re int res=1; for(;y;)&#123; if(y&amp;1) res=1LL*res*x%mod; x=1LL*x*x%mod; y&gt;&gt;=1; &#125; return res;&#125;inline void NTT(re int* F,re int n,re int tp)&#123; for(re int i=0;i&lt;n;++i) if(i&lt;rev[i]) swap(F[i],F[rev[i]]); for(re int k=1,p=1;p&lt;n;++k,p&lt;&lt;=1) for(re int i=0;i&lt;n;i+=p&lt;&lt;1) for(re int j=i,tmp=1;j&lt;i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod)&#123; re int x=F[j],y=1LL*F[j+p]*tmp%mod; F[j]=(x+y)%mod; F[j+p]=(x-y+mod)%mod; &#125; re int v=cltpow(n,tp*(mod-2)); for(re int i=0;i&lt;n;++i) F[i]=1LL*F[i]*v%mod;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); for(re int i=0;i&lt;n;++i)&#123; cltstream::read(A[i]); ans+=A[i]*A[i]; k+=A[i]; C[n-1-i]=A[i]; &#125; for(re int i=0;i&lt;n;++i)&#123; cltstream::read(B[i]); ans+=B[i]*B[i]; k-=B[i]; D[n-1-i]=B[i]; &#125; ans+=min(n*floor(1.0*k/n)*floor(1.0*k/n)-2*k*floor(1.0*k/n),n*ceil(1.0*k/n)*ceil(1.0*k/n)-2*k*ceil(1.0*k/n)); unit[0][23]=cltpow(3,119); unit[1][23]=cltpow(332748118,119); for(re int i=0;i&lt;2;++i) for(re int j=22;j&gt;=0;--j) unit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod; for(m=1;m&lt;n;m&lt;&lt;=1); m&lt;&lt;=1; for(re int i=0;i&lt;m;++i) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?(m&gt;&gt;1):0); NTT(A,m,0); NTT(B,m,0); NTT(C,m,0); NTT(D,m,0); for(re int i=0;i&lt;m;++i)&#123; A[i]=1LL*A[i]*D[i]%mod; B[i]=1LL*B[i]*C[i]%mod; &#125; NTT(A,m,1); NTT(B,m,1); mx=A[n-1]; for(re int i=1;i&lt;n;++i) mx=max(mx,A[n-1-i]+B[i-1]); cltstream::write(ans-=2*mx); clop(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"},{"name":"AHOI","slug":"AHOI","permalink":"https://github.com/Challestend/tags/AHOI/"},{"name":"HNOI","slug":"HNOI","permalink":"https://github.com/Challestend/tags/HNOI/"},{"name":"2017","slug":"2017","permalink":"https://github.com/Challestend/tags/2017/"}]},{"title":"「Luogu-P5162」WD与积木","slug":"luogu-p5162-solution","date":"2019-01-02T08:43:53.000Z","updated":"2019-01-04T04:29:34.785Z","comments":true,"path":"luogu-p5162-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p5162-solution/","excerpt":"9102年的第一篇blog。 传送门","text":"9102年的第一篇blog。 传送门 大概算是我用NTT切的第一道非模板题。 其实本来应该是这道。不过调不出来了弃了。 首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。 首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程： G[n]=\\sum\\limits_{i=0}^{n}C_{n}^{i}G[n-i]但是这样对吗？ 代入$n=0$我们发现 G[0]=C_{0}^{0}G[0]=G[0] 注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。 那然后$G[0]$应该等于几？ G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1所以说$G[0]=1$。 如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。 再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开 G[n]=n!\\sum\\limits_{i=0}^{n}\\cfrac{1}{i!}\\times\\cfrac{G[n-i]}{(n-i)!}定义 H[n]=\\begin{cases} &0&(n=0)\\\\ &\\cfrac{1}{n!}\\;\\;&(n>1) \\end{cases}G[n]=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{G[n-i]}{(n-i)!}注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义 G^{\\prime}[n]=\\cfrac{G[n]}{n!}就可以得到 \\begin{aligned} G^{\\prime}[n]&=\\sum\\limits_{i=0}^{n}H[i]\\times G^{\\prime}[n-i]\\\\ G^{\\prime}&=G^{\\prime}H+1 \\end{aligned}注意不要忘了$+1$。因为很明显地$G^{\\prime}H[0]=0$，而$G^{\\prime}[0]=1$。 然后我们就有 G^{\\prime}=\\cfrac{1}{1-H}然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。 首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此 F[n]=G[n]+\\sum\\limits_{i=0}^{n}C_{n}^{i}F[n-i]然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（ \\begin{aligned} F[n]&=G[n]+n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]}{(n-i)!}\\\\ &=n!\\sum\\limits_{i=0}^{n}H[i]\\times\\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\\\ F^{\\prime}[n]&=\\cfrac{F[n]}{n!}\\\\ &=\\sum\\limits_{i=0}^{n}H[i]\\times(F^{\\prime}[n-i]+G^{\\prime}[n-i])\\\\ F^{\\prime}&=H(F^{\\prime}+G^{\\prime}) \\end{aligned}不过这次我们就不需要$+1$了。 解上面的方程，我们得到 F^{\\prime}=\\cfrac{HG^{\\prime}}{1-H}=\\cfrac{G^{\\prime}}{(1-H)^{2}}然后我们总结一下 H[n]=\\begin{cases} &0&(n=0)\\\\ &\\cfrac{1}{n!}\\;\\;&(n>1) \\end{cases}G^{\\prime}=\\cfrac{1}{1-H}F^{\\prime}=\\cfrac{G^{\\prime}}{(1-H)^{2}}最后的答案，也就是$n$块积木的期望层数，就是$\\cfrac{F[n]}{G[n]}$。然后不难发现$\\cfrac{F^{\\prime}[n]}{G^{\\prime}[n]}=\\cfrac{F[n]}{G[n]}$。 我就是不贴代码（ 反正会的应该都能写出来了吧（","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"}]},{"title":"题目组试题选讲","slug":"timuzu-solutions","date":"2018-12-26T12:17:22.000Z","updated":"2018-12-29T04:37:58.357Z","comments":true,"path":"timuzu-solutions/","link":"","permalink":"https://github.com/Challestend/timuzu-solutions/","excerpt":"先宣传一波团队。","text":"先宣传一波团队。 「T47720」孤立元已有题解。 「T53537」营救元首能看出五彩斑斓的世界来吗？ 没错就是JF切了这道题以后根号上脑搞了这么一个东西。 不过这道题相对之下有点麻烦的，因为你需要维护两个tag，一个处理减，一个处理推平。而且求前驱的时候不能值域分块，然后就只能套set。 详细点说的话，就是每个块维护最大值和最小值。操作$1$可以选择枚举所有大于$k$的数，然后减去$k$；也可以枚举所有小于等于$k$的数，加上$k$之后整个块打上一个减$k$的标记，标记这个块内的所有数都被减去了$k$。哪个运算量少就选哪个。 操作$2$就先查询最小值（这个都会吧），然后散块直接改，整块打个标记就好，标记这个块内的所有数都被改成了另一个数。 操作$3$就不必多说了，散块暴力找，整块lower_bound。 不过说实话，写起来挺麻烦的。也懒得看以前我写的代码了，直接贴出来吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294#include&lt;cstdio&gt;#include&lt;set&gt;#define re register#define maxn 100000#define maxm 100000#define maxblock 320#define maxval 200000#define mod 998244353#define max(a,b) ((a)&gt;=(b)?(a):(b))#define min(a,b) ((a)&lt;=(b)?(a):(b))namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout; int outcnt=0; inline void pc(char c)&#123; if(c==-1) fwrite(cltout,1,outcnt,stdout); else&#123; if(outcnt==size)&#123; fwrite(cltout,1,size,stdout); oh=cltout; outcnt=0; &#125; *oh++=c; ++outcnt; &#125; &#125; #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=' ')&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; pc(text); &#125;&#125;int n,m,size;int a[maxn+1],id[maxn+1];int val[maxn+1],f[maxn+1];int pos[maxblock+1][maxval+1];int maxv[maxblock+1],minv[maxblock+1],tag[maxblock+1],sam[maxblock+1];std::set&lt;int&gt; s[maxblock+1];int find(int x)&#123; return f[x]==x?x:f[x]=find(f[x]);&#125;inline void init(int x)&#123; maxv[x]=-2e9; minv[x]=2e9; for(re int i=(x-1)*size+1;i&lt;=x*size&amp;&amp;i&lt;=n;++i) if(!pos[x][a[i]])&#123; val[i]=a[i]; f[i]=i; pos[x][a[i]]=i; maxv[x]=max(maxv[x],a[i]); minv[x]=min(minv[x],a[i]); s[x].insert(a[i]); &#125; else f[i]=pos[x][a[i]];&#125;inline void destory(int x)&#123; for(re int i=(x-1)*size+1;i&lt;=x*size&amp;&amp;i&lt;=n;++i)&#123; a[i]=sam[x]?sam[x]:val[find(i)]+tag[x]; pos[x][val[i]]=0; &#125; tag[x]=sam[x]=0; s[x].clear();&#125;inline void solve(int x,int y)&#123; if(sam[x])&#123; if(sam[x]&gt;y) sam[x]-=y; return; &#125; if(maxv[x]-(y-tag[x])&lt;=(y-tag[x])-minv[x]+1)&#123; for(re int i=(y-tag[x])+1;i&lt;=maxv[x];++i) if(pos[x][i])&#123; s[x].erase(i); if(!pos[x][i-y])&#123; val[pos[x][i]]-=y; pos[x][i-y]=pos[x][i]; s[x].insert(i-y); &#125; else if(pos[x][i]&gt;pos[x][i-y]) f[pos[x][i]]=pos[x][i-y]; else&#123; f[pos[x][i-y]]=pos[x][i]; pos[x][i-y]=pos[x][i]; val[pos[x][i-y]]-=y; &#125; pos[x][i]=0; &#125; &#125; else&#123; for(re int i=(y-tag[x]);i&gt;=minv[x];--i) if(pos[x][i])&#123; s[x].erase(i); if(!pos[x][i+y])&#123; val[pos[x][i]]+=y; pos[x][i+y]=pos[x][i]; s[x].insert(i+y); &#125; else if(pos[x][i]&gt;pos[x][i+y]) f[pos[x][i]]=pos[x][i+y]; else&#123; f[pos[x][i+y]]=pos[x][i]; pos[x][i+y]=pos[x][i]; val[pos[x][i+y]]+=y; &#125; pos[x][i]=0; &#125; tag[x]-=y; &#125; minv[x]=*s[x].begin(); std::set&lt;int&gt;::iterator it=s[x].end(); --it; maxv[x]=*it;&#125;inline void IntervalCut(int l,int r,int x)&#123; int L=id[l],R=id[r]; destory(L); for(re int i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i) if(a[i]&gt;x) a[i]-=x; init(L); for(re int i=L+1;i&lt;=R-1;++i) solve(i,x); if(L&lt;R)&#123; destory(R); for(re int i=(R-1)*size+1;i&lt;=r;++i) if(a[i]&gt;x) a[i]-=x; init(R); &#125;&#125;inline void IntervalAssignToMin(int l,int r)&#123; int L=id[l],R=id[r],res=2e9; destory(L); for(re int i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i) res=min(res,a[i]); for(re int i=L+1;i&lt;=R-1;++i) res=min(res,sam[i]?sam[i]:minv[i]+tag[i]); if(L&lt;R)&#123; destory(R); for(re int i=(R-1)*size+1;i&lt;=r;++i) res=min(res,a[i]); &#125; for(re int i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i) a[i]=res; init(L); for(re int i=L+1;i&lt;=R-1;++i) sam[i]=res; if(L&lt;R)&#123; for(re int i=(R-1)*size+1;i&lt;=r;++i) a[i]=res; init(R); &#125;&#125;inline void IntervalPre(int l,int r,int x)&#123; int L=id[l],R=id[r],p=0,res=-2e9; if(sam[L])&#123; if(sam[L]&lt;x&amp;&amp;sam[L]&gt;res)&#123; p=l; res=sam[L]; &#125; &#125; else for(re int i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i) if(val[find(i)]+tag[L]&lt;x&amp;&amp;val[find(i)]+tag[L]&gt;res)&#123; p=i; res=val[f[i]]+tag[L]; &#125; for(re int i=L+1;i&lt;=R-1;++i) if(sam[i])&#123; if(sam[i]&lt;x&amp;&amp;sam[i]&gt;res)&#123; p=(i-1)*size+1; res=sam[i]; &#125; &#125; else&#123; std::set&lt;int&gt;::iterator it=s[i].lower_bound(x-tag[i]); if(it!=s[i].begin())&#123; --it; if(*it+tag[i]&lt;x&amp;&amp;*it+tag[i]&gt;res)&#123; p=pos[i][*it]; res=*it+tag[i]; &#125; &#125; &#125; if(L&lt;R)&#123; if(sam[R])&#123; if(sam[R]&lt;x&amp;&amp;sam[R]&gt;res)&#123; p=(R-1)*size+1; res=sam[R]; &#125; &#125; else for(re int i=(R-1)*size+1;i&lt;=r;++i) if(val[find(i)]+tag[R]&lt;x&amp;&amp;val[find(i)]+tag[R]&gt;res)&#123; p=i; res=val[f[i]]+tag[R]; &#125; &#125; if(p) cltstream::write(p,'\\n'); else&#123; cltstream::pc('G'); cltstream::pc('R'); cltstream::pc('E'); cltstream::pc('A'); cltstream::pc('T'); cltstream::pc(10); &#125;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); for(re int i=1;i&lt;=n;++i) cltstream::read(a[i]); for(;(size+1)*(size+1)&lt;=n;++size); for(re int i=1;(i-1)*size+1&lt;=n;++i)&#123; init(i); for(re int j=(i-1)*size+1;j&lt;=i*size&amp;&amp;j&lt;=n;++j) id[j]=i; &#125; for(re int i=1;i&lt;=m;++i)&#123; int opt,l,r,x; cltstream::read(opt); cltstream::read(l); cltstream::read(r); switch(opt)&#123; case 1: cltstream::read(x); IntervalCut(l,r,x); break; case 2: IntervalAssignToMin(l,r); break; case 3: cltstream::read(x); IntervalPre(l,r,x); break; &#125; &#125; for(re int i=1;i&lt;=n;++i) (a[0]+=sam[id[i]]?sam[id[i]]:val[find(i)]+tag[id[i]])%=mod; cltstream::write(a[0],'\\n'); cltstream::pc(-1); return 0;&#125; 「T53987」ZJF日记最短路计数+次短路求解。 其实这才应该是签到题啊，然而当初却被排到了T3。不是很懂（ 不过话说回来其实题面写的很好啊。 sto 多弗桃 orz 关于SPFA他死了。 「T56269」选择性失忆sto SnoWY orz 才刚学了几个月就出这种神仙题，把我这种从初中就开始学OI的菜鸡吊起来打（ 首先我们看到要最小化第$k+1$大的边权。二分？那么问题就转化成了找一条路径，使得其中恰有$k$条边的边权小于某个给定数值。 emmmmmm……这是什么鬼（ 总之二分大概不大可行。然后我觉得我扯不下去了，直接讲正解吧（ 构造一张$k+1$层的分层图。如果说我们在某一层有一条边从$u$到$v$，边权是$w$，我们就从这一层的$u$，向下一层的$v$连一条$0$权边。然后从最上层的$1$开始跑最短路，路径长度定义为边权最大值，跑到最下层的$n$。然后dis[最下层的n]就是答案。 那么为什么这样做可行？假设说我们现在跑出了最上层的$n$的dis。现在我们将$n$下压一层，我们肯定会在之前边权最大的那一条边处跨越至下层。这样这条边的边权减为$0$，相当于是说被过滤掉了。不难想象出，如果我们下压$k$层到最底层，边权前$k$大的边就都被过滤掉了，这时路径上的边权最大值就是一开始的$k+1$大。 相信各位应该都会了，我就不贴代码了。 然后还是要%SnoWY。 「T62117」复习这是一道被线段树踩爆了的分块题。 每个块内维护总和、正数数量和绝对值最小的负数的绝对值。 每次加的时候，散块还是暴力重构，整块就判断一下绝对值最小的负数加完会不会变号，会就重构。 因为保证$k$非负，每个数最多变号一次，也就是说最多重构$n$次，时间复杂度$O(n\\sqrt{n})$。 代码太丢人了不贴了。 「T64137」「魔板」线段树 2这是一道丧心病狂的卡时空块状分块题。 关于块状分块请看这里。 反正也没啥可说的，就是写起来麻烦，我就简单讲一下这题背后的故事吧。 首先一开始我们定的时空限制是$1\\text{s}/4\\text{MB}$。然而还是放跑了空间复杂度足够优秀的线段树。然后一气之下删了fread，把空间限制改到$2\\text{MB}$，并把时间限制改到$850\\text{ms}$。然后有神仙通过将线段树的多个叶子结点合并起来的方法又水过去了。最后空间直接卡到了现在的$1.5\\text{MB}$。然后最后两个点询问加到$2\\times 10^{6}$，并塞入大量单点操作，才算把该卡的都卡掉了。 顺便第一次写计分脚本祭。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"},{"name":"毒瘤题","slug":"毒瘤题","permalink":"https://github.com/Challestend/tags/毒瘤题/"},{"name":"题目组","slug":"题目组","permalink":"https://github.com/Challestend/tags/题目组/"}]},{"title":"关于块状分块的研究报告","slug":"block-decomposition","date":"2018-12-24T02:27:06.000Z","updated":"2018-12-29T05:58:09.513Z","comments":true,"path":"block-decomposition/","link":"","permalink":"https://github.com/Challestend/block-decomposition/","excerpt":"该文章已被加密","text":"输入密码继续阅读 Incorrect Password! No content to display! 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","categories":[{"name":"研究报告","slug":"研究报告","permalink":"https://github.com/Challestend/categories/研究报告/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"},{"name":"块状分块","slug":"块状分块","permalink":"https://github.com/Challestend/tags/块状分块/"}]},{"title":"「多项式学习笔记Part II」多项式的进阶操作","slug":"polynomial-learning-notes-pt2","date":"2018-12-20T08:58:39.000Z","updated":"2018-12-23T03:26:13.483Z","comments":true,"path":"polynomial-learning-notes-pt2/","link":"","permalink":"https://github.com/Challestend/polynomial-learning-notes-pt2/","excerpt":"以下，如果不特别声明，则所有运算在模$998244353$意义下进行。","text":"以下，如果不特别声明，则所有运算在模$998244353$意义下进行。 接下来的前置知识泰勒展开说实话，其实我也不是很能理解这个东西（ 我就凭感觉xjb扯了（ 现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。 我们令 g(x)=\\sum\\limits_{i=0}^{n}g[i](x-x_{0})^{i}我们想要让$x\\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。 我们先考虑$0$阶，也就是原函数。因为$x\\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有 g[0]=f(x_{0})然后是$1$阶 g^{\\prime}(x)=\\sum\\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\\prime}(x_{0})再然后是$2$阶 g^{\\prime\\prime}(x)=\\sum\\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\\prime\\prime}(x_{0})最后是$3$阶 g^{\\prime\\prime\\prime}(x)=\\sum\\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\\prime\\prime\\prime}(x_{0})我们发现$g[n]$有如下的规律 g[n]=\\cfrac{f^{(n)}(x_{0})}{n!}综上所述 g(x)=\\sum\\limits_{i=0}^{n}\\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i应该吧（ 多项式牛顿迭代考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得 F(G(x))\\equiv 0\\pmod{x^{n}}我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得 F(G_{0})\\equiv 0\\pmod{x^{t}}我们希望求出一个$G$使得 F(G)\\equiv 0\\pmod{x^{2t}}我们将$F$在$G_{0}$这里进行泰勒展开： \\begin{aligned} F(G)&=F(G_{0})\\\\ &+F^{\\prime}(G_{0})(G-G_{0})\\\\ &+\\cfrac{F^{\\prime\\prime}(G_{0})}{2}(G-G_{0})^{2}\\\\ &+\\cdots\\end{aligned}注意到 \\begin{aligned} F(G)-F(G_{0})&\\equiv 0\\pmod{x^{t}}\\\\ G-G_{0}&\\equiv 0\\pmod{x^{t}} \\end{aligned}也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有 \\begin{aligned} F(G)&\\equiv F(G_{0})+F^{\\prime}(G_{0})(G-G_{0})\\pmod{x^{2t}}\\\\ F^{\\prime}(G_{0})G&\\equiv F^{\\prime}(G_{0})G_{0}-F(G_{0})\\pmod{x^{2t}}\\\\ G&\\equiv G_{0}-\\cfrac{F(G_{0})}{F^{\\prime}(G_{0})}\\pmod{x^{2t}} \\end{aligned}然后我们就一直倍增，倍增到$t\\geqslant n$为止，此时$G_{0}$即为所求多项式。 多项式求逆给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 F(x)\\times G(x)\\equiv 1\\pmod{x^{n}}假设我们已经求出了$G_{0}$使得 F\\times G_{0}\\equiv 1\\pmod{x^{t}}我们希望找到一个$G$使得 F\\times G\\equiv 1\\pmod{x^{2t}}据说能用牛顿迭代推，然而我不会（ 考虑正常一点的方式，虽然说还是倍增。 \\begin{aligned} F\\times G-F\\times G_{0}&\\equiv 0\\pmod{x^{t}}\\\\ G-G_{0}&\\equiv 0\\pmod{x^{t}}\\\\ (G-G_{0})^{2}&\\equiv 0\\pmod{x^{2t}}\\\\ G^{2}-2GG_{0}+G_{0}^{2}&\\equiv 0\\pmod{x^{2t}} \\end{aligned}两边同时乘$F$ \\begin{aligned} G-2G_{0}+FG_{0}^{2}&\\equiv 0\\pmod{x^{2t}}\\\\ G&\\equiv 2G_{0}-FG_{0}^{2}\\pmod{x^{2t}} \\end{aligned}边界条件也很明显，就是当$t=1$时，$G[0]\\equiv F[0]^{-1}$。 说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（ 关于代码……现在还不是时候（ 后面有一道超级综合题在等着我们（ 多项式对数函数给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 G(x)\\equiv\\ln F(x)\\pmod{x^{n}}对上式两边求导 G^{\\prime}\\equiv F^{\\prime}\\ln^{\\prime}F\\pmod{x^{n}}又因为 \\ln^{\\prime}x=\\frac{1}{x}我们就得到 G^{\\prime}\\equiv\\cfrac{F^{\\prime}}{F}\\pmod{x^{n}}求导+求逆+不定积分即可。 多项式指数函数超级综合题来了。 给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 G(x)\\equiv e^{F(x)}\\pmod{x^{n}}首先 \\ln G-F\\equiv 0\\pmod{x^{n}}我们把$F$看成是常数项，定义函数 A(G)=\\ln G-FA^{\\prime}(G)=\\ln^{\\prime}G=\\cfrac{1}{G}套牛顿迭代 \\begin{aligned} G&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\ &\\equiv G_{0}(1-\\ln G_{0}+F)\\pmod{x^{2t}} \\end{aligned}然后把以上提到的所有板子全都复制过来就行了（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include&lt;cstdio&gt;#include&lt;cstring&gt;#define re register#define maxn 524288#define mod 998244353#define swap(a,b) a^=b,b^=a,a^=bnamespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout) #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n;int unit[2][24],rev[maxn+1],inv[maxn+1]=&#123;0,1&#125;,F[maxn+1],G[maxn+1],tmp1[maxn+1],tmp2[maxn+1],tmp3[maxn+1],tmp4[maxn+1];inline int cltpow(re int x,re int y)&#123; re int res=1; for(;y;)&#123; if(y&amp;1) res=1LL*res*x%mod; x=1LL*x*x%mod; y&gt;&gt;=1; &#125; return res;&#125;inline void NTT(re int* F,re int n,re int tp)&#123; for(re int i=0;i&lt;n;++i) if(i&lt;(rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)?(n&gt;&gt;1):0))) swap(F[i],F[rev[i]]); for(re int k=1,p=1;p&lt;n;++k,p&lt;&lt;=1) for(re int i=0;i&lt;n;i+=p&lt;&lt;1) for(re int j=i,tmp=1;j&lt;i+p;++j,tmp=1LL*tmp*unit[tp][k]%mod)&#123; re int x=F[j],y=1LL*F[j+p]*tmp%mod; F[j]=(x+y)%mod; F[j+p]=(x-y+mod)%mod; &#125; re int v=cltpow(n,tp*(mod-2)); for(re int i=0;i&lt;n;++i) F[i]=1LL*F[i]*v%mod;&#125;inline void Inv(re int* F,re int* G,re int n)&#123; G[0]=cltpow(F[0],mod-2); for(re int i=1,j=4;i&lt;n;i&lt;&lt;=1,j&lt;&lt;=1)&#123; for(re int k=0;k&lt;(i&lt;&lt;1);++k) tmp1[k]=F[k]; NTT(tmp1,j,0); NTT(G,j,0); for(re int k=0;k&lt;j;++k) G[k]=(2-1LL*tmp1[k]*G[k]%mod+mod)*G[k]%mod; NTT(G,j,1); for(re int k=(i&lt;&lt;1);k&lt;j;++k) G[k]=0; for(re int k=0;k&lt;j;++k) tmp1[k]=0; &#125;&#125;inline void Ln(re int* F,re int* G,re int n)&#123; for(re int i=1;i&lt;n;++i) G[i-1]=1LL*F[i]*i%mod; Inv(F,tmp2,n); re int N=1; for(;N&lt;n;N&lt;&lt;=1); N&lt;&lt;=1; NTT(G,N,0); NTT(tmp2,N,0); for(re int i=0;i&lt;N;++i) G[i]=1LL*G[i]*tmp2[i]%mod; NTT(G,N,1); for(re int i=n-1;i&gt;=1;--i) G[i]=1LL*G[i-1]*inv[i]%mod; G[0]=0; for(re int i=n;i&lt;N;++i) G[i]=0; for(re int i=0;i&lt;N;++i) tmp2[i]=0;&#125;inline void Exp(re int* F,re int* G,re int n)&#123; G[0]=1; for(re int i=1,j=2;i&lt;(n&lt;&lt;1);i&lt;&lt;=1,j&lt;&lt;=1)&#123; Ln(G,tmp3,i); for(re int k=0;k&lt;i;++k) tmp4[k]=F[k]; NTT(tmp3,j,0); NTT(tmp4,j,0); NTT(G,j,0); for(re int k=0;k&lt;j;++k) G[k]=((1LL-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod; NTT(G,j,1); for(re int k=0;k&lt;j;++k) tmp3[k]=tmp4[k]=0; &#125;&#125;int main()&#123; unit[0][23]=cltpow(3,119); unit[1][23]=cltpow(332748118,119); for(re int i=0;i&lt;2;++i) for(re int j=22;j&gt;=0;--j) unit[i][j]=1LL*unit[i][j+1]*unit[i][j+1]%mod; for(re int i=2;i&lt;=maxn;++i) inv[i]=(mod-1LL*mod/i*inv[mod%i]%mod)%mod; cltstream::read(n); for(re int i=0;i&lt;n;++i) cltstream::read(F[i]); Exp(F,G,n); for(re int i=0;i&lt;n;++i) cltstream::write(G[i],i&lt;n-1?32:-1); clop(); return 0;&#125; 多项式开平方根给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得 G^{2}(x)\\equiv F(x)\\pmod{x^{n}}牛顿迭代吼啊！ A(G)=G^{2}-FA^{\\prime}(G)=2G\\begin{aligned} G&\\equiv G_{0}-\\cfrac{A(G_{0})}{A{^\\prime}(G_{0})}\\\\ &\\equiv G_{0}-\\cfrac{G_{0}^{2}-F}{2G_{0}}\\\\ &\\equiv\\cfrac{G_{0}^{2}+F}{2G_{0}}\\\\ &=\\cfrac{1}{2}(G_{0}+\\cfrac{F}{G_{0}})\\pmod{x^{2t}} \\end{aligned}复制粘贴吼啊！ 我刚才都学了些啥破玩意一道例题。 Remote Judge。 这是读题前的我： 这是读题后的我： 这是知道了这题正解是多项式开平方根后的我： 我……我怕不是学了个假的多项式哦（ 厚颜无耻地抄题解（ 首先我们搞出生成函数（然而并不是很懂） G(x)=\\sum\\limits_{i=0}^{m}G[i]x^{i}其中 G[i]=[i\\in\\{c_{1},c_{2},\\cdots,c_{n}\\}]定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有 F[0]=1F[x]=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。 然后是一些神仙操作 \\begin{aligned} F[x]&=\\sum\\limits_{i=0}^{x}G[i]\\sum\\limits_{j=0}^{x-i}F[j]F[x-i-j]\\\\ &=\\sum\\limits_{i=0}^{x}G[i]F^{2}[x-i]\\\\ &=(GF^{2})[x] \\end{aligned}令人窒息（ 然后我们就有 GF^{2}+1=F但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。 于是解上面这个一元二次方程，我们得到 F=\\cfrac{1\\pm\\sqrt{1-4G}}{2G}但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\\mp\\sqrt{1-4G})$，然后化简一波 F=\\cfrac{2}{1\\mp\\sqrt{1-4G}}如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\\cfrac{2}{2}=1$。综上所述 F=\\cfrac{2}{1+\\sqrt{1-4G}}本来接下来应该有代码实现的，但是我拒绝咕咕咕。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"},{"name":"FFT","slug":"FFT","permalink":"https://github.com/Challestend/tags/FFT/"}]},{"title":"「多项式学习笔记Part I」最基本的多项式乘法","slug":"polynomial-learning-notes-pt1","date":"2018-12-19T12:23:01.000Z","updated":"2018-12-25T00:58:11.054Z","comments":true,"path":"polynomial-learning-notes-pt1/","link":"","permalink":"https://github.com/Challestend/polynomial-learning-notes-pt1/","excerpt":"最近正好月考，然而并不想去月考，于是来颓blog吧。","text":"最近正好月考，然而并不想去月考，于是来颓blog吧。 给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\\times G)(x)$的各项系数。$n,m\\leqslant 10^{6}$。 我们不妨将$F(x)$的$i$次项系数记为$F[i]$ F(x)=\\sum\\limits_{i=0}^{n-1}F[i]x^{i}G(x)=\\sum\\limits_{i=0}^{m-1}G[i]x^{i}(F\\times G)(x)=\\sum\\limits_{i=0}^{n-1}\\sum\\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}(F\\times G)[k]=\\sum\\limits_{0\\leqslant i","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://github.com/Challestend/tags/NTT/"},{"name":"FFT","slug":"FFT","permalink":"https://github.com/Challestend/tags/FFT/"}]},{"title":"关于最优化分块时间复杂度的研究报告","slug":"sqrt-decomposition-complexity-optimization","date":"2018-12-19T12:19:18.000Z","updated":"2018-12-21T02:20:30.115Z","comments":true,"path":"sqrt-decomposition-complexity-optimization/","link":"","permalink":"https://github.com/Challestend/sqrt-decomposition-complexity-optimization/","excerpt":"最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。","text":"最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。 假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\\text{A}x+\\text{B}y$。根据均值不等式 \\cfrac{1}{2}(x+y)\\geqslant\\sqrt{xy}我们有 \\text{A}x+\\text{B}y\\geqslant2\\sqrt{\\text{AB}n}当且仅当$x=\\sqrt{\\cfrac{\\text{B}}{\\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\\sqrt{\\text{AB}n})$。 以上。","categories":[{"name":"研究报告","slug":"研究报告","permalink":"https://github.com/Challestend/categories/研究报告/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"}]},{"title":"「未来算法Episode I」严格根号分块实现树套树","slug":"future-algorithm-ep1","date":"2018-12-08T11:55:00.000Z","updated":"2018-12-19T12:08:11.478Z","comments":true,"path":"future-algorithm-ep1/","link":"","permalink":"https://github.com/Challestend/future-algorithm-ep1/","excerpt":"分块天下第一！！！！！！！！！","text":"分块天下第一！！！！！！！！！ 我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。 我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。 先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。 然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\\operatorname{log}n)$的。 那我们就在外层套个树状数组，把修改$O(n\\operatorname{log}n)$查询$O(\\operatorname{log}n)$均摊成全部$O(\\operatorname{log}^{2}n)$。 然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。 考虑无敌的分块。 一般我们想到的分块就是在块内维护std::set。这样操作$3$可以做到$O(\\operatorname{log}\\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\\sqrt{n}\\operatorname{log}\\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\\operatorname{log}10^{9}\\sqrt{n}\\operatorname{log}\\sqrt{n})$。 然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。 我们来看一下Shadowice1984dalao在他的另一篇题解中做出的评价： 这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\\text{log}$之内。 但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\\sqrt{n})$而不是$O(\\operatorname{log}n)$，这意味着分块其实和$\\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\\text{log}$来，这在强调常数的根号算法中绝对是致命的。 我也是从这位dalao的blog里看到了严格根号分块实现树套树这种未来算法。 主要思想其实不难理解，既然分块和$\\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。 定义cnt1[i][j]表示前$i$个块内有多少个元素的值在第$j$个块内，cnt2[i][j]表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\\sqrt{n})$的。 然后我们来分析每个操作该怎么实现： 首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。 还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组tmp1和tmp2来保存边角块的信息。 直接$O(\\sqrt{n})$暴力重构两个cnt就好。 需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内从后往前扫，找到答案直接退出。否则还是从后往前扫所有值域块，找到第一个非空的块然后进去找。 操作$4$换个方向即可。 综上所述，该算法的时间复杂度为$O((n+m)\\sqrt{n}+m\\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\\operatorname{log}^{2}n)\\approx 12183043$。看起来好像比不过树套树，实际上开个$\\text{O}2$跑得比谁都快，正如一开始那张图所示。 不过代码写出来有点长的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define re register#define maxn 50000#define maxm 50000#define maxs 230#define max(a,b) ((a)&gt;=(b)?(a):(b))#define min(a,b) ((a)&lt;=(b)?(a):(b))#define lowbit(a) ((a)&amp;(-(a)))namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout) #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m,sq1,sq2;int id1[maxn+1],id2[maxn+maxm+1],p[maxn+maxm+1];int a[maxn+1],opt[maxm+1][4];int cnt1[maxs+1][(maxs&lt;&lt;1)+1],cnt2[maxs+1][maxn+maxm+1],tmp1[(maxs&lt;&lt;1)+1],tmp2[maxn+maxm+1];int main()&#123; cltstream::read(n); cltstream::read(m); for(;(sq1+1)*(sq1+1)&lt;=n;++sq1); for(re int i=1;i&lt;=n;++i)&#123; id1[i]=(i-1)/sq1+1; cltstream::read(a[i]); p[++p[0]]=a[i]; &#125; for(re int i=1;i&lt;=m;++i)&#123; cltstream::read(opt[i][0]); cltstream::read(opt[i][1]); cltstream::read(opt[i][2]); if(opt[i][0]!=3) cltstream::read(opt[i][3]); else p[++p[0]]=opt[i][2]; &#125; std::sort(p+1,p+p[0]+1); p[0]=std::unique(p+1,p+p[0]+1)-p-1; for(;(sq2+1)*(sq2+1)&lt;=p[0];++sq2); for(re int i=1;i&lt;=p[0];++i) id2[i]=(i-1)/sq2+1; for(re int i=1;i&lt;=n;++i)&#123; a[i]=std::lower_bound(p+1,p+p[0]+1,a[i])-p; ++cnt1[id1[i]][id2[a[i]]]; ++cnt2[id1[i]][a[i]]; &#125; for(re int i=1;i&lt;=id1[n];++i)&#123; for(re int j=1;j&lt;=id2[p[0]];++j) cnt1[i][j]+=cnt1[i-1][j]; for(re int j=1;j&lt;=p[0];++j) cnt2[i][j]+=cnt2[i-1][j]; &#125; for(re int i=1;i&lt;=m;++i)&#123; re int l,r,x,ans=0; switch(opt[i][0])&#123; case 1: l=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j) ans+=(a[j]&lt;x); for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j) ans+=(a[j]&lt;x); for(re int j=1;j&lt;id2[x];++j) ans+=cnt1[id1[r]-1][j]-cnt1[id1[l]][j]; for(re int j=(id2[x]-1)*sq2+1;j&lt;x;++j) ans+=cnt2[id1[r]-1][j]-cnt2[id1[l]][j]; &#125; else for(re int j=l;j&lt;=r;++j) ans+=(a[j]&lt;x); cltstream::write(ans+1,10); break; case 2: l=opt[i][1],r=opt[i][2],x=opt[i][3]; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=1;;++j) if(x&gt;cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]) x-=cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]; else&#123; for(re int k=(j-1)*sq2+1;k&lt;=j*sq2;++k) if(x&gt;cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]) x-=cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]; else&#123; cltstream::write(p[k],10); break; &#125; break; &#125; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; else&#123; for(re int j=l;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=1;;++j) if(x&gt;tmp1[j]) x-=tmp1[j]; else&#123; for(re int k=(j-1)*sq2+1;k&lt;=j*sq2;++k) if(x&gt;tmp2[k]) x-=tmp2[k]; else&#123; cltstream::write(p[k],10); break; &#125; break; &#125; for(re int j=l;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; break; case 3: l=opt[i][1],x=std::lower_bound(p+1,p+p[0]+1,opt[i][2])-p; for(re int j=id1[l];j&lt;=id1[n];++j)&#123; --cnt1[j][id2[a[l]]]; ++cnt1[j][id2[x]]; --cnt2[j][a[l]]; ++cnt2[j][x]; &#125; a[l]=x; break; case 4: l=opt[i][1],r=opt[i][2],x=std::lower_bound(p+1,p+p[0]+1,opt[i][3])-p; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x-1;j&gt;=(id2[x]-1)*sq2+1&amp;&amp;!ans;--j) if(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j]) ans=j; for(re int j=id2[x]-1;j&gt;=1&amp;&amp;!ans;--j) if(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]) for(re int k=j*sq2;k&gt;=(j-1)*sq2+1&amp;&amp;!ans;--k) if(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]) ans=k; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; else&#123; for(re int j=l;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x-1;j&gt;=(id2[x]-1)*sq2+1&amp;&amp;!ans;--j) if(tmp2[j]) ans=j; for(re int j=id2[x]-1;j&gt;=1&amp;&amp;!ans;--j) if(tmp1[j]) for(re int k=j*sq2;k&gt;=(j-1)*sq2+1&amp;&amp;!ans;--k) if(tmp2[k]) ans=k; for(re int j=l;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; cltstream::write(ans?p[ans]:-2147483647,10); break; case 5: l=opt[i][1],r=opt[i][2],x=std::upper_bound(p+1,p+p[0]+1,opt[i][3])-p-1; if(id1[l]&lt;id1[r])&#123; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x+1;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j) if(cnt2[id1[r]-1][j]-cnt2[id1[l]][j]+tmp2[j]) ans=j; for(re int j=id2[x]+1;j&lt;=id2[p[0]]&amp;&amp;!ans;++j) if(cnt1[id1[r]-1][j]-cnt1[id1[l]][j]+tmp1[j]) for(re int k=(j-1)*sq2+1;k&lt;=j*sq2&amp;&amp;!ans;++k) if(cnt2[id1[r]-1][k]-cnt2[id1[l]][k]+tmp2[k]) ans=k; for(re int j=l;j&lt;=id1[l]*sq1;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; for(re int j=(id1[r]-1)*sq1+1;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; else&#123; for(re int j=l;j&lt;=r;++j)&#123; ++tmp1[id2[a[j]]]; ++tmp2[a[j]]; &#125; for(re int j=x+1;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j) if(tmp2[j]) ans=j; for(re int j=id2[x]+1;j&lt;=id2[p[0]]&amp;&amp;!ans;++j) if(tmp1[j]) for(re int k=(j-1)*sq2+1;k&lt;=j*sq2&amp;&amp;!ans;++k) if(tmp2[k]) ans=k; for(re int j=l;j&lt;=r;++j)&#123; --tmp1[id2[a[j]]]; --tmp2[a[j]]; &#125; &#125; cltstream::write(ans?p[ans]:2147483647,10); &#125; &#125; clop(); return 0;&#125; 我还没写啥呢咋就$12\\text{KB}$了（ 这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（","categories":[{"name":"未来算法","slug":"未来算法","permalink":"https://github.com/Challestend/categories/未来算法/"}],"tags":[{"name":"分块","slug":"分块","permalink":"https://github.com/Challestend/tags/分块/"},{"name":"树套树","slug":"树套树","permalink":"https://github.com/Challestend/tags/树套树/"}]},{"title":"一些乱七八糟的数论","slug":"number-theory-learning-notes","date":"2018-11-29T06:41:17.000Z","updated":"2018-12-19T12:13:00.250Z","comments":true,"path":"number-theory-learning-notes/","link":"","permalink":"https://github.com/Challestend/number-theory-learning-notes/","excerpt":"最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。 抄袭来源参考文献： 铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演 浅谈杜教筛 铃悬的数学小讲堂——杜教筛","text":"最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。 抄袭来源参考文献： 铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演 浅谈杜教筛 铃悬的数学小讲堂——杜教筛 数论函数定义与相关性质数论函数就是定义域为$\\mathbb{N}^{+}$的函数。 两个数论函数相加，就是简单地把函数值相加。 (f+g)(n)=f(n)+g(n)数乘也是类似的。 (\\alpha f)(n)=\\alpha f(n)点积也是类似的。 (f\\cdot g)(n)=f(n)g(n)好像没啥用。 在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的： (f\\times g)(n)=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})或者说： (f\\times g)(n)=\\sum\\limits_{ij=n}f(i)g(j)它具有以下的一些性质： 交换律，即$f\\times g=g\\times f$。 这很明显。 结合律，即$(f\\times g)\\times h=f\\times(g\\times h)$。 \\begin{aligned} ((f\\times g)\\times h)(n)&=\\sum\\limits_{ij=n}(\\sum\\limits_{kl=i}f(k)g(l))h(j)\\\\ &=\\sum\\limits_{ijk=n}f(i)g(j)h(k) \\end{aligned}\\begin{aligned} (f\\times(g\\times h))(n)&=\\sum\\limits_{ij=n}f(i)(\\sum\\limits_{kl=j}g(k)h(l))\\\\ &=\\sum\\limits_{ijk=n}f(i)g(j)h(k) \\end{aligned}分配率，即$(f+g)\\times h=f\\times h+g\\times h$。 \\begin{aligned} ((f+g)\\times h)(n)&=\\sum\\limits_{ij=n}(f+g)(i)h(j)\\\\ &=\\sum\\limits_{ij=n}f(i)h(j)+g(i)h(j)\\\\ &=(f\\times h)(n)+(g\\times h)(n) \\end{aligned}单位元为$\\epsilon(n)=[n=1]$，$f\\times\\epsilon =f$。 这也很明显。 对于任意一个满足$f(1)\\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\\times g=\\epsilon$。这时我们称$g$是$f$的逆。 我们可以这样定义一个函数的逆： g(n)=\\cfrac{\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})}{f(1)}这样我们就有 \\begin{aligned} (f\\times g)(n)&=\\sum_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\ &=f(1)g(n)+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\ &=\\epsilon(n)-\\sum\\limits_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})+\\sum_{i\\mid n,i\\neq 1}f(i)g(\\cfrac{n}{i})\\\\ &=\\epsilon(n) \\end{aligned}积性函数与完全积性函数如果一个数论函数$f$满足 \\forall x,y\\in\\mathbb{N}^{+}\\wedge x\\perp y\\;\\;f(xy)=f(x)f(y)我们就说$f$是一个积性函数。 特别的，如果上式去掉$x\\perp y$仍成立，则称$f$是一个完全积性函数。 很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\\times n)=f(1)\\times f(n)=f(n)$。 常见的完全积性函数有$\\epsilon,id^{k}$。$\\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。 常见的积性函数有$\\varphi,d,\\sigma$。$\\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\\sigma(n)$的值分别等于$n$的约数个数和约数和。 关于$\\varphi$的积性，我并不会证（ 我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设 n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有 d(n)=\\prod\\limits_{i=1}^{N}(r_{i}+1)我们再假设有一个$m$，且 m=\\prod\\limits_{i=1}^{M}q_{i}^{s_{i}}如果说$n\\perp m$，肯定有 \\forall i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z}\\;\\;p_{i}\\neq q_{j}于是我们就有 nm=(\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}})(\\prod\\limits_{j=1}^{M}q_{j}^{s_{j}})\\begin{aligned} d(nm)&=(\\prod\\limits_{i=1}^{N}(r_{i}+1))(\\prod\\limits_{j=1}^{M}(s_{j}+1))\\\\ &=d(n)d(m) \\end{aligned}不妨再反过来考虑。如果说$n\\not\\perp m$，那么一定存在一对$(i,j)(i\\in [1,N]\\cap\\mathbb{Z},j\\in [1,M]\\cap\\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\\neq d(n)d(m)$。 我们再来分析$\\sigma$的积性。还是设 n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\\in [0,r_{i}]\\cap\\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是 \\prod\\limits_{i=1}^{N}\\sum\\limits_{j=0}^{r_{i}}p_{i}^{j}这正是$\\sigma(n)$的值。 接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。 现在我们来分析，两个积性函数的卷积是否也是积性函数。虽然说都这么问了肯定就是了。 \\begin{aligned} (f\\times g)(n)(f\\times g)(m)&=(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\ &=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(i)g(\\cfrac{n}{i})f(j)g(\\cfrac{m}{j})\\\\ &=\\sum\\limits_{i\\mid n}\\sum\\limits_{j\\mid m}f(ij)g(\\cfrac{nm}{ij})\\\\ &=\\sum\\limits_{k\\mid nm}f(k)g(\\cfrac{nm}{k})\\\\ &=(f\\times g)(nm) \\end{aligned}关于上面的第四个等号。时刻注意$n\\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。 再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。 设有一个积性函数$f$，它的逆是$g$。 当$nm=1$时，$g(1)=1$。 当$nm&gt;1$时，我们假设对于任意$n^{\\prime}m^{\\prime}&lt;nm$，都有$g(n^{\\prime}m^{\\prime})=g(n^{\\prime})g(m^{\\prime})$。此时 \\begin{aligned} g(nm)&=-\\sum\\limits_{k\\mid nm,k\\neq 1}f(k)g(\\cfrac{nm}{k})\\\\ &=-\\sum\\limits_{i\\mid n,j\\mid m,ij\\neq 1}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\ &=g(n)g(m)-\\sum\\limits_{i\\mid n,j\\mid m}f(i)f(j)g(\\cfrac{n}{i})g(\\cfrac{m}{j})\\\\ &=g(n)g(m)-(\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i}))(\\sum\\limits_{j\\mid m}f(j)g(\\cfrac{m}{j}))\\\\ &=g(n)g(m)-\\epsilon(n)\\epsilon(m)\\\\ &=g(n)g(m) \\end{aligned}其实上面这些全都是抄来的（ 莫比乌斯反演正向反演定义$\\mu$为$1$的逆。也就是说，$\\mu\\times 1=\\epsilon$。 如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义： 首先地，$\\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\\mu(n)=(-1)^{k}$。否则，$\\mu(n)=0$。 那么，这两种定义等价吗？ 考虑到$\\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成 n=\\prod\\limits_{i=1}^{N}p_{i}^{r_{i}}我们就有 \\mu(n)=\\prod\\limits_{i=1}^{N}\\mu(p_{i}^{r_{i}})因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。 设有一个质数$p$。不难发现 \\mu(p)=-\\mu(1)=-1\\mu(p^{2})=-\\mu(1)-\\mu(p)=-1+1=0\\mu(p^{3})=-\\mu(1)-\\mu(p)-\\mu(p^{2})=-1+1+0=0\\vdots至此，不难看出上文给出的两种定义是等价的。 那么这个东西有什么用呢？ 我们设 F(n)=\\sum\\limits_{i\\mid n}f(i)或者等价地说，$F=f\\times 1$。我们可以得到 \\begin{aligned} F&=f\\times 1\\\\ F\\times\\mu&=f\\times 1\\times\\mu\\\\ F\\times\\mu&=f \\end{aligned}像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说 f(n)=\\sum\\limits_{i\\mid n}F(i)\\mu(\\cfrac{n}{i})反向反演有些时候我们还需要用到像下面这样反过来的莫比乌斯反演 F(n)=\\sum\\limits_{n\\mid d}f(d)⇔f(n)=\\sum\\limits_{n\\mid d}F(d)\\mu(\\cfrac{d}{n})我们可以定义一种新的运算 (f\\otimes g)(n)=\\sum\\limits_{n\\mid d}f(d)g(\\cfrac{d}{n})我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有 F=f\\otimes 1⇔F\\otimes\\mu=f于是就有了上面的反向反演。 Updated on 2018-12-03 例题……还是算了吧（ 发现反演常用的套路都忘的差不多了，还是别丢人了（ 杜教筛实现与模板题接下来才是主要内容。 现在，我们要求一个积性函数的前$n$项和。$n\\leqslant 10^{10}$。 我们定义 S(n)=\\sum\\limits_{i=1}^{n}f(i)再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。 \\begin{aligned} \\sum_{i=1}^{n}(f\\times g)(i)&=\\sum_{i=1}^{n}\\sum_{j\\mid i}f(j)g(\\cfrac{i}{j})\\\\ &=\\sum_{i=1}^{n}g(i)\\sum_{j=1}^{\\lfloor\\frac{n}{i}\\rfloor}f(j)\\\\ &=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor) \\end{aligned}然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（ 因为$g$也是积性函数，有$g(1)=1$，所以 \\begin{aligned} S(n)&=g(1)S(n)\\\\ &=\\sum_{i=1}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)\\\\ &=\\sum_{i=1}^{n}(f\\times g)(i)-\\sum_{i=2}^{n}g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor) \\end{aligned}就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。 如果说我们选择的$g$可以让我们迅速地求出$f\\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。 关于后面的$g(i)S(\\lfloor\\cfrac{n}{i}\\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。 我们来分析一下$\\lfloor\\cfrac{n}{i}\\rfloor$。如果$1\\leqslant i\\leqslant\\sqrt{n}$，因为$i$只有$\\sqrt{n}$种不同的取值，$\\lfloor\\cfrac{n}{i}\\rfloor$同样也只有$\\sqrt{n}$种不同的取值。如果$\\sqrt{n}&lt;i\\leqslant n$，$1\\leqslant\\lfloor\\cfrac{n}{i}\\rfloor&lt;\\sqrt{n}$，又因为要向下取整，自然也只有$\\sqrt{n}$种不同的取值。如果我们能够把$\\lfloor\\cfrac{n}{i}\\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\\sqrt{n})$。 大体代码如下： 1234for(re int l=1,r;l&lt;=n;l=r+1)&#123; r=n/(n/l); //......&#125; 关于$r$的这个上界是怎么来的，我并不会证（ 这样一来，要计算$S(n)$，我们需要调用所有的$\\lfloor\\cfrac{n}{x}\\rfloor$，分别是$\\lfloor\\cfrac{n}{1}\\rfloor,\\lfloor\\cfrac{n}{2}\\rfloor,\\cdots,\\lfloor\\cfrac{n}{\\sqrt{n}}\\rfloor,\\sqrt{n},\\sqrt{n}-1,\\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\\sqrt{n})$的。那么这样一来，总体的时间复杂度就是 \\begin{aligned} O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{i}+\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})&=O(\\sum\\limits_{i=1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor})\\\\ &=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\lfloor\\cfrac{n}{x}\\rfloor}dx)\\\\ &=O(\\int\\limits_{1}^{\\sqrt{n}}\\sqrt{\\cfrac{n}{x}}dx)\\\\ &=O(2n^{\\frac{1}{2}}(n^{\\frac{1}{4}}-1))\\\\ &=O(n^{\\frac{3}{4}}) \\end{aligned}因为相比之下$\\sqrt{\\lfloor\\cfrac{n}{i}\\rfloor}$很明显要大一些，我们就可以将$\\sqrt{i}$舍去。然后去掉取整符号并用积分近似。 这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\\cfrac{n}{\\sqrt{m}})$，当$m=n^{\\frac{2}{3}}$时取得最小值$O(n^{\\frac{2}{3}})$。 举个例子，就比如说我们要求 \\sum\\limits_{i=1}^{n}\\varphi(i)我们取$f=\\varphi,g=1$，这样根据$\\varphi$的性质，$f\\times g=id$。不难看出$g$与$f\\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样： 1234567891011121314151617181920long long getSum(int n)&#123; if(n&lt;=maxn) return phi[n]; //phi是提前线性筛好的前缀和 if(ans.count(n)) return ans[n]; //ans用来实现记忆化的哈希表，比如说unordered_map re long long res=1LL*n*(n+1)&gt;&gt;1; //f*g的前缀和 for(re int l=2,r;l&lt;=n;l=r+1)&#123; //注意要从2开始 r=n/(n/l); res-=(r-l+1)*getSum(n/l); //r-l+1是g的前缀和 //像这样递归+记忆化求解f的前缀和 &#125; return ans[n]=res; //返回的时候不要忘记存一下 //就比如说我就忘过一次（&#125; 以及，不用哈希表也是可以的。因为我们查询的数都是形如$\\lfloor\\cfrac{n}{x}\\rfloor$的，当这个值大于$n^{\\frac{2}{3}}$，即$x&lt;n^{\\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令ans[x]表示$S(\\lfloor\\cfrac{n}{x}\\rfloor)$。具体代码我就不写了（ 再举个例子，求 \\sum\\limits_{i=1}^{n}\\mu(i)取$f=\\mu,g=1,f\\times g=\\epsilon$。代码和上面差不多。 如果您理解了上面两个函数，这道模板题您就可以切了。 其他题「Luogu-P3768」简单的数学题快乐地推式子： \\begin{aligned} \\sum\\limits_{i=1}^{n}i\\sum\\limits_{j=1}^{n}j\\text{gcd}(i,j)&=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j[i\\perp j]\\\\ &=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}i\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}j\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\ &=\\sum\\limits_{d=1}^{n}d^{3}\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}x^{2}\\mu(x)\\text{Sum}^{2}(\\lfloor\\cfrac{n}{dx}\\rfloor)\\\\ &=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\sum\\limits_{j\\mid i}j\\mu(\\cfrac{i}{j})\\\\ &=\\sum\\limits_{i=1}^{n}\\text{Sum}^{2}(\\lfloor\\cfrac{n}{i}\\rfloor)i^{2}\\varphi(i) \\end{aligned}其中 \\text{Sum}(n)=\\sum\\limits_{i=1}^{n}i最后一步是因为 \\begin{aligned} id\\times\\mu&=\\varphi\\times 1\\times\\mu\\\\ &=\\varphi\\times\\epsilon\\\\ &=\\varphi \\end{aligned}理解不了上面的式子的话就多看看吧（ 不难发现我们是要求$f(n)=n^{2}\\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？ 枚举瞎蒙（ 考虑$g(n)=n^{2}$。 \\begin{aligned} (f\\times g)(n)&=\\sum\\limits_{i\\mid n}f(i)g(\\cfrac{n}{i})\\\\ &=\\sum\\limits_{i\\mid n}i^{2}\\varphi(i)\\cfrac{n^{2}}{i^{2}}\\\\ &=n^{2}\\sum\\limits_{i\\mid n}\\varphi(i)\\\\ &=n^{3} \\end{aligned}其实我都不知道我当时是怎么想到这种操作的（ 然后就和上面一样了。 「Luogu-U18201」分析矿洞不知道从哪翻出来的题（ 是某场个人邀请赛的$\\text{T}1$，从某种意义上也能看出那场比赛有多么神仙。 \\begin{aligned} \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{n}\\varphi(\\text{gcd}^{2}(i,j))&=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}[i\\perp j]\\\\ &=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{i=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{j=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\sum\\limits_{x\\mid i,x\\mid j}\\mu(x)\\\\ &=\\sum\\limits_{d=1}^{n}\\varphi(d^{2})\\sum\\limits_{x=1}^{\\lfloor\\frac{n}{d}\\rfloor}\\mu(x)\\lfloor\\cfrac{n}{dx}\\rfloor^{2}\\\\ &=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}\\varphi(j^{2})\\mu(\\cfrac{i}{j})\\\\ &=\\sum\\limits_{i=1}^{n}\\lfloor\\cfrac{n}{i}\\rfloor^{2}\\sum\\limits_{j\\mid i}j\\varphi(j)\\mu(\\cfrac{i}{j}) \\end{aligned}设$f_1(n)=n\\varphi(n),f_2(n)=\\mu(n)$，考虑筛$f=f_1\\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\\times g$的前缀和。一种较优的方案是，令$g=1$，$f\\times g=(id\\cdot\\varphi)\\times\\mu\\times 1=id\\cdot\\varphi$，这样，我们还需要筛出$f_1(n)=n\\varphi(n)$的前缀和。 怎么办？ 再套一层杜教筛！ 然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（ 以及，像这种$n$爆了int的，一定要注意经常取模。因为这个WA了好几次（ 最后，源文件$17\\text{KB}​$祭，blog翻页祭。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"杜教筛","slug":"杜教筛","permalink":"https://github.com/Challestend/tags/杜教筛/"}]},{"title":"自己的一些大胆的想法（持续更新）","slug":"poisonous-problems","date":"2018-11-14T03:02:21.000Z","updated":"2019-01-08T13:35:07.389Z","comments":true,"path":"poisonous-problems/","link":"","permalink":"https://github.com/Challestend/poisonous-problems/","excerpt":"自己闲得没事搞出来的一些毒瘤题。 不保证有解（","text":"自己闲得没事搞出来的一些毒瘤题。 不保证有解（ Problem 1Description定义一个从序列到序列的映射$\\text{LIS()}$。我们认为$\\text{LIS}(\\{ a_n\\})=\\{ f_n\\}$，当且仅当 \\forall 1\\leqslant i\\leqslant n\\;\\; f_i=\\begin{cases}&1&(i=1\\vee \\forall 1\\leqslant j","categories":[{"name":"未分类","slug":"未分类","permalink":"https://github.com/Challestend/categories/未分类/"}],"tags":[{"name":"毒瘤题","slug":"毒瘤题","permalink":"https://github.com/Challestend/tags/毒瘤题/"}]},{"title":"「NOIp2018游记」夢の終わるところ","slug":"noip-2018-notes","date":"2018-11-09T01:40:45.000Z","updated":"2018-12-19T12:05:09.580Z","comments":true,"path":"noip-2018-notes/","link":"","permalink":"https://github.com/Challestend/noip-2018-notes/","excerpt":"€€£：禁赛警告。","text":"€€£：禁赛警告。 Day 0自从一周前放假回来以后，我就开始一颓不振： 明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废，同时看着其他dalao随手切神仙题。然后我看到yemdalao写了一篇NOIp2018禁赛记游记，想着禁赛真有趣，我就写下了这篇游记。 其他dalao都在机房补文化课而我在颓blog（ 于是，此处以下，Updated on 2018-11-12。 Updated on 2018-11-14 看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。 但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃 中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。 然后一抽考场发现是外校，赛前先rp--。 然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（ 下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（ 除那之外就没啥了，算是颓了一个下午。 晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（ 试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。 反正板子是不可能打炸的，这辈子都不可能的。 因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。 Day 1早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。 然后一打开E盘发现被清了，只有题目。 Day1的解压密码是不是就我一个人不懂啊（ 那么于是，到了8：30，我点开今天的题目，定神一看…… T1智障单调栈，有不开数组的做法，不过我懒得细想了，反正score+=100。 T2稍微想一想不难想到完全背包，score+=100。 T3神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。 估分100+100+25=225。 出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（ 前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（ 那我可真是太菜了（ 下午日常发呆，然后晚上是快乐的颓废时间。 中午买的零食一个下午就全吃完了（ Day 2早上莫名起不来，然后就没吃早饭。 这次我东西是真的带全了（ Day2的解压密码依然不懂，然后是今天的题目： T1NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。 现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点std::sort一遍。然后维护一个邻接矩阵处理断边（ 为什么不直接用邻接矩阵呢（ T2神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（ T3究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。 估分100+65+44=204（不存在的，肯定比这个低）。 这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧…… 不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（ 好像其他dalao们都有这样那样乱七八糟的地方出锅了啊…… 下午请假回家开心地颓废。 Extra Notes果然是等到NOIp结束后才更新的。 以及，我比较菜，第一次写游记，写的可能一定很菜，所以……算了，告辞。 Updated on 2018-11-26 好像有些晚的更新。 出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（ 具体成绩差不多是100+100+20+100+65+36=421。 以上。","categories":[{"name":"游记","slug":"游记","permalink":"https://github.com/Challestend/categories/游记/"}],"tags":[{"name":"NOIp","slug":"NOIp","permalink":"https://github.com/Challestend/tags/NOIp/"},{"name":"2018","slug":"2018","permalink":"https://github.com/Challestend/tags/2018/"}]},{"title":"「Luogu-P5009」毒瘤分块题","slug":"luogu-p5009-solution","date":"2018-11-08T00:04:22.000Z","updated":"2018-12-12T02:05:04.885Z","comments":true,"path":"luogu-p5009-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p5009-solution/","excerpt":"传送门","text":"传送门 从来没做过这么毒瘤的题qaq 就算看了题解现在还是一脸懵逼qaq 首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq 对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\\prime$使得$v_i^\\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\\prime$，然后查询的时候我们就可以直接返回$v_i^\\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\\prime=v_i-t_1xb_i$。 需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\\Sigma v_i^\\prime+t\\Sigma (a_i+x+z)(b_i+y)=\\Sigma v_i+t\\Sigma (a_i+x)(b_i+y)$，即$\\Sigma v_i^\\prime=\\Sigma v_i-tz\\Sigma (b_i+y)$。 不过，上式中$tz\\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\\Sigma b_i$，考虑到每层节点的$\\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\\Sigma v_i+=B\\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。 然后是毒瘤的下推标记。 123456addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];//就是上面这句qaq现在还是一脸懵逼qaqA[son]+=A[father];B[son]+=B[father];adda[son]+=adda[father];addb[son]+=addf[father]; 其实我也不知道我上面在扯些啥，所以以下是代码，反正应该没人能看懂我的清奇写法（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include&lt;cstdio&gt;#define re register#define maxn 200005#define maxm 200005#define mod 100000007namespace cltstream&#123; #define size 1048576 char cltin[size+1],*ih=cltin,*it=cltin; inline char gc()&#123; #ifdef ONLINE_JUDGE if(ih==it)&#123; it=(ih=cltin)+fread(cltin,1,size,stdin); if(ih==it) return EOF; &#125; return *ih++; #else return getchar(); #endif &#125; char cltout[size+1],*oh=cltout,*ot=cltout+size; inline void pc(char c)&#123; if(oh==ot)&#123; fwrite(cltout,1,size,stdout); oh=cltout; &#125; *oh++=c; &#125; #define clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout) #undef size template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=-1)&#123; if(x&lt;0) pc(45),x=-x; if(!x) pc(48); else&#123; int digit[22]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];pc(digit[digit[0]--]^48)); &#125; if(text&gt;=0) pc(text); &#125;&#125;int n,m;int sumv[(maxn&lt;&lt;2)+1],suma[(maxn&lt;&lt;2)+1],sumb[(maxn&lt;&lt;2)+1],sump[(maxn&lt;&lt;2)+1];int A[(maxn&lt;&lt;2)+1],B[(maxn&lt;&lt;2)+1];int addv[(maxn&lt;&lt;2)+1],adda[(maxn&lt;&lt;2)+1],addb[(maxn&lt;&lt;2)+1];inline void pushDown(int cur,int ln,int rn)&#123; sumv[cur&lt;&lt;1]=(sumv[cur&lt;&lt;1]+1LL*A[cur]*suma[cur&lt;&lt;1]%mod)%mod; sumv[cur&lt;&lt;1]=(sumv[cur&lt;&lt;1]+1LL*B[cur]*sumb[cur&lt;&lt;1]%mod)%mod; sumv[cur&lt;&lt;1]=(sumv[cur&lt;&lt;1]+1LL*ln*addv[cur]%mod)%mod; sump[cur&lt;&lt;1]=(sump[cur&lt;&lt;1]+1LL*adda[cur]*sumb[cur&lt;&lt;1]%mod)%mod; sump[cur&lt;&lt;1]=(sump[cur&lt;&lt;1]+1LL*addb[cur]*suma[cur&lt;&lt;1]%mod)%mod; sump[cur&lt;&lt;1]=(sump[cur&lt;&lt;1]+1LL*adda[cur]*addb[cur]%mod*ln%mod)%mod; suma[cur&lt;&lt;1]=(suma[cur&lt;&lt;1]+1LL*ln*adda[cur]%mod)%mod; sumb[cur&lt;&lt;1]=(sumb[cur&lt;&lt;1]+1LL*ln*addb[cur]%mod)%mod; addv[cur&lt;&lt;1]=(addv[cur&lt;&lt;1]+1LL*A[cur]*adda[cur&lt;&lt;1]%mod)%mod; addv[cur&lt;&lt;1]=(addv[cur&lt;&lt;1]+1LL*B[cur]*addb[cur&lt;&lt;1]%mod)%mod; addv[cur&lt;&lt;1]=(addv[cur&lt;&lt;1]+addv[cur])%mod; A[cur&lt;&lt;1]=(A[cur&lt;&lt;1]+A[cur])%mod; B[cur&lt;&lt;1]=(B[cur&lt;&lt;1]+B[cur])%mod; adda[cur&lt;&lt;1]=(adda[cur&lt;&lt;1]+adda[cur])%mod; addb[cur&lt;&lt;1]=(addb[cur&lt;&lt;1]+addb[cur])%mod; sumv[cur&lt;&lt;1|1]=(sumv[cur&lt;&lt;1|1]+1LL*A[cur]*suma[cur&lt;&lt;1|1]%mod)%mod; sumv[cur&lt;&lt;1|1]=(sumv[cur&lt;&lt;1|1]+1LL*B[cur]*sumb[cur&lt;&lt;1|1]%mod)%mod; sumv[cur&lt;&lt;1|1]=(sumv[cur&lt;&lt;1|1]+1LL*rn*addv[cur]%mod)%mod; sump[cur&lt;&lt;1|1]=(sump[cur&lt;&lt;1|1]+1LL*adda[cur]*sumb[cur&lt;&lt;1|1]%mod)%mod; sump[cur&lt;&lt;1|1]=(sump[cur&lt;&lt;1|1]+1LL*addb[cur]*suma[cur&lt;&lt;1|1]%mod)%mod; sump[cur&lt;&lt;1|1]=(sump[cur&lt;&lt;1|1]+1LL*adda[cur]*addb[cur]%mod*rn%mod)%mod; suma[cur&lt;&lt;1|1]=(suma[cur&lt;&lt;1|1]+1LL*rn*adda[cur]%mod)%mod; sumb[cur&lt;&lt;1|1]=(sumb[cur&lt;&lt;1|1]+1LL*rn*addb[cur]%mod)%mod; addv[cur&lt;&lt;1|1]=(addv[cur&lt;&lt;1|1]+1LL*A[cur]*adda[cur&lt;&lt;1|1]%mod)%mod; addv[cur&lt;&lt;1|1]=(addv[cur&lt;&lt;1|1]+1LL*B[cur]*addb[cur&lt;&lt;1|1]%mod)%mod; addv[cur&lt;&lt;1|1]=(addv[cur&lt;&lt;1|1]+addv[cur])%mod; A[cur&lt;&lt;1|1]=(A[cur&lt;&lt;1|1]+A[cur])%mod; B[cur&lt;&lt;1|1]=(B[cur&lt;&lt;1|1]+B[cur])%mod; adda[cur&lt;&lt;1|1]=(adda[cur&lt;&lt;1|1]+adda[cur])%mod; addb[cur&lt;&lt;1|1]=(addb[cur&lt;&lt;1|1]+addb[cur])%mod; A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=0;&#125;inline void pushUp(int cur)&#123; sumv[cur]=(sumv[cur&lt;&lt;1]+sumv[cur&lt;&lt;1|1])%mod; suma[cur]=(suma[cur&lt;&lt;1]+suma[cur&lt;&lt;1|1])%mod; sumb[cur]=(sumb[cur&lt;&lt;1]+sumb[cur&lt;&lt;1|1])%mod; sump[cur]=(sump[cur&lt;&lt;1]+sump[cur&lt;&lt;1|1])%mod;&#125;void build(int cur,int l,int r)&#123; if(l==r)&#123; cltstream::read(sumv[cur]); cltstream::read(suma[cur]); cltstream::read(sumb[cur]); sumv[cur]=(sumv[cur]%mod+mod)%mod; suma[cur]=(suma[cur]%mod+mod)%mod; sumb[cur]=(sumb[cur]%mod+mod)%mod; sump[cur]=1LL*suma[cur]*sumb[cur]%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; build(cur&lt;&lt;1,l,mid); build(cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;int query(int L,int R,int t,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R) return (sumv[cur]+1LL*t*sump[cur]%mod)%mod; else&#123; int mid=(l+r)&gt;&gt;1,res=0; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) res=(res+query(L,R,t,cur&lt;&lt;1,l,mid))%mod; if(R&gt;mid) res=(res+query(L,R,t,cur&lt;&lt;1|1,mid+1,r))%mod; return res; &#125;&#125;void modifyV(int L,int R,int x,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; sumv[cur]=(sumv[cur]+1LL*(r-l+1)*x%mod)%mod; addv[cur]=(addv[cur]+x)%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) modifyV(L,R,x,cur&lt;&lt;1,l,mid); if(R&gt;mid) modifyV(L,R,x,cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;void modifyA(int L,int R,int t,int x,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; sumv[cur]=(sumv[cur]+(-1LL*x*t%mod*sumb[cur]%mod+mod)%mod)%mod; suma[cur]=(suma[cur]+1LL*(r-l+1)*x%mod)%mod; sump[cur]=(sump[cur]+1LL*sumb[cur]*x%mod)%mod; B[cur]=(B[cur]+(-1LL*x*t%mod+mod)%mod)%mod; addv[cur]=(addv[cur]+(-1LL*x*t%mod*addb[cur]%mod+mod)%mod)%mod; adda[cur]=(adda[cur]+x)%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) modifyA(L,R,t,x,cur&lt;&lt;1,l,mid); if(R&gt;mid) modifyA(L,R,t,x,cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;void modifyB(int L,int R,int t,int x,int cur,int l,int r)&#123; if(l&gt;=L&amp;&amp;r&lt;=R)&#123; sumv[cur]=(sumv[cur]+(-1LL*x*t%mod*suma[cur]%mod+mod)%mod)%mod; sumb[cur]=(sumb[cur]+1LL*(r-l+1)*x%mod)%mod; sump[cur]=(sump[cur]+1LL*suma[cur]*x%mod)%mod; A[cur]=(A[cur]+(-1LL*x*t%mod+mod)%mod)%mod; addv[cur]=(addv[cur]+(-1LL*x*t%mod*adda[cur]%mod+mod)%mod)%mod; addb[cur]=(addb[cur]+x)%mod; &#125; else&#123; int mid=(l+r)&gt;&gt;1; pushDown(cur,mid-l+1,r-mid); if(L&lt;=mid) modifyB(L,R,t,x,cur&lt;&lt;1,l,mid); if(R&gt;mid) modifyB(L,R,t,x,cur&lt;&lt;1|1,mid+1,r); pushUp(cur); &#125;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); build(1,1,n); for(re int i=1;i&lt;=m;++i)&#123; int opt,t,l,r,x; cltstream::read(opt); cltstream::read(t); cltstream::read(l); cltstream::read(r); switch(opt)&#123; case 1: cltstream::write(query(l,r,t,1,1,n),10); break; case 2: cltstream::read(x); modifyA(l,r,t,(x%mod+mod)%mod,1,1,n); break; case 3: cltstream::read(x); modifyB(l,r,t,(x%mod+mod)%mod,1,1,n); break; case 4: cltstream::read(x); modifyV(l,r,(x%mod+mod)%mod,1,1,n); break; &#125; &#125; clop(); return 0;&#125; 大概是我太菜了不适合做这种毒瘤题吧qaq 距 在NOIp2018爆零 还剩 1 天。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"},{"name":"线段树","slug":"线段树","permalink":"https://github.com/Challestend/tags/线段树/"}]},{"title":"状态压缩动态规划学习笔记","slug":"status-compression-learning-notes","date":"2018-10-24T13:24:05.000Z","updated":"2018-12-19T12:03:55.791Z","comments":true,"path":"status-compression-learning-notes/","link":"","permalink":"https://github.com/Challestend/status-compression-learning-notes/","excerpt":"把标签和分类连在一起读就是标题了（ 好像上一篇珂朵莉树学习笔记也是这样（ 马上就要复赛了，但反正我已经退役预定了来颓blog吧。","text":"把标签和分类连在一起读就是标题了（ 好像上一篇珂朵莉树学习笔记也是这样（ 马上就要复赛了，但反正我已经退役预定了来颓blog吧。 首先我们来看一道例题，「USACO06NOV」玉米田Corn Fields。 首先，我们想到定义f[i][...]表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……f[i][0/1]...(省略10个[0/1])...[0/1]，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。 但是等等……$13$维的状态…… 注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。 于是，现在我们定义f[i][S]表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义a[i]表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。valid[S]表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。a[i]在读入时就可以处理出来，至于valid[S]，我们可以通过这样的一个循环处理出来： 12for(re int i=1;i&lt;(1&lt;&lt;m);++i) valid[i]=valid[i&gt;&gt;1]&amp;(~(i&amp;(i&gt;&gt;1)&amp;1)); 用人话来讲就是[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]。 在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0。 123456789for(re int i=0;i&lt;(1&lt;&lt;m);++i) if((i|a[1])==a[1]&amp;&amp;valid[i]) f[1][i]=1;for(re int i=2;i&lt;=n;++i) for(re int j=0;j&lt;(1&lt;&lt;m);++j) if((j|a[i])==a[i]&amp;&amp;valid[j]) for(re int k=0;k&lt;(1&lt;&lt;m);++k) if((k|a[i-1])==a[i-1]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==0) (f[i][j]+=f[i-1][k])%=mod; 粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个if剪掉，因而实际运行跑得比谁都快（ 为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，「NOI2001」炮兵阵地。 因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用f[i][S1][S2]表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录a[i]和valid[S]，不过，这次valid[s]的预处理过程差不多是这样： 12for(re int i=1;i&lt;(1&lt;&lt;m);++i)&#123; valid[i]=(i&amp;1)?valid[i&gt;&gt;3]&amp;((~i)&gt;&gt;2)&amp;((~i)&gt;&gt;1):valid[i&gt;&gt;1]; 看起来有些非常复杂，用人话来讲就是……诶我当时是不是写错了（ ……不好像又没写错…… 好吧没写错。 如果$S$的最后一位是$1$，则[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]，否则[S是否合法]=[S&gt;&gt;1是否合法]。 因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理： 12for(re int i=1;i&lt;(1&lt;&lt;m);++i) cnt[i]=cnt[i&gt;&gt;1]+(i&amp;1); 转移过程如下： 12345678910111213for(re int i=0;i&lt;(1&lt;&lt;m);++i) if((i|a[1])==a[1]&amp;&amp;valid[i]) for(re int j=0;j&lt;(1&lt;&lt;m);++j) if((j|a[2])==a[2]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==0) f[2][i][j]=cnt[i]+cnt[j];for(re int i=3;i&lt;=n;++i) for(re int j=0;j&lt;(1&lt;&lt;m);++j) if((j|a[i-2])==a[i-2]&amp;&amp;valid[j]) for(re int k=0;k&lt;(1&lt;&lt;m);++k) if((k|a[i-1])==a[i-1]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==0) for(re int l=0;l&lt;(1&lt;&lt;m);++l) if((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==0&amp;&amp;(l&amp;k)==0) f[i][k][l]=max(f[i][k][l],f[i-1][j][k]+cnt[l]); 时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\\text{won’t TLE})$（ 我们再来看一个状压的应用，「SP3953」MMINPAID - Paid Roads，或者您也可以反正我就是在洛谷上提交。 大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义dis[u][S]为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。 这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。 我是不会说我把impossible打成Impossible然后交上去WA了一发的（ 一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\\leqslant 20$，就很有可能是状压题或者也有可能是神仙剪枝题。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。 以上，我觉得我的状压讲的差不多了（","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"状态压缩","slug":"状态压缩","permalink":"https://github.com/Challestend/tags/状态压缩/"},{"name":"动态规划","slug":"动态规划","permalink":"https://github.com/Challestend/tags/动态规划/"}]},{"title":"珂朵莉树学习笔记","slug":"chtholly-tree-learning-notes","date":"2018-10-13T13:13:09.000Z","updated":"2018-12-19T12:03:00.539Z","comments":true,"path":"chtholly-tree-learning-notes/","link":"","permalink":"https://github.com/Challestend/chtholly-tree-learning-notes/","excerpt":"还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。 话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。 总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。","text":"还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。 话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。 总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。 我们先来看一道毒瘤例题，「CF896C」Willem, Chtholly and Seniorious。 如果只看前三个操作的话，虽然我不会写也没写过，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？ 这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于std::set的暴力数据结构，虽然您也可以手写一颗平衡树，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话： 珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。 那么怎么推平呢？不急，我们慢慢讲。 珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体： 1234567891011121314151617struct node&#123; int l,r; mutable long long val; //这里的mutable是为了让我们在之后的修改过程中可以修改val的值 node(int _l,int _r=-1,long long _val=-1)&#123; //调用时_r或_val不填的话默认-1，为了后面split时方便 l=_l; r=_r; val=_val; &#125;&#125;;std::set&lt;node&gt; s;inline bool operator&lt;(node p,node q)&#123; return p.l&lt;q.l;&#125; 然后我们就可以初始化了。对于这道题，我们可以像这样初始化： 12for(re int i=1;i&lt;=n;++i) s.insert(node(i,i,rnd()%maxval+1)); 初始化完了？ 初始化完了。 然后就是珂朵莉树的核心操作之一， 1std::&lt;set&gt;::iterator split(int pos) 作用是分离出一个左端点为pos的区间并返回它的迭代器。它的具体实现如下： 1234567891011121314151617#define _it std::set&lt;node&gt;::iterator//上面这句手打非常麻烦，建议宏定义inline _it split(int pos)&#123; _it it=std::lower_bound(s.begin(),s.end(),node(pos)); //找第一个左端点大于等于pos的区间 if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; //如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器 --it; //否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内 int l=it-&gt;l,r=it-&gt;r; long long val=it-&gt;val; s.erase(it); s.insert(node(l,pos-1,val)); return s.insert(node(pos,r,val)).first; //将区间[l,r]删除，并插入区间[l,pos)和[pos,r]&#125; 虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。 insert函数的返回值类型是std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了，因此我们需要加个.first。 std::set内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\\operatorname{log}n)$的。 然后是一个同样很核心的操作， 1void assign(int l,int r,int x) 将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下： 123456789inline void assign(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); //注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内 //后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器 s.erase(itl,itr); //将[itl,itr)内所有区间删除 s.insert(node(l,r,x)); //用一个大区间取代它们&#125; 这就完了？ 这就完了。 assign操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得set的大小迅速减小，并最终趋于$\\operatorname{log}n$。本题的操作二就只需调用一次assign(l,r,x)即可。 然后是剩下的三个操作，一个比一个暴力。 操作一，一个一个区间地拿出来加。 12345inline void IntervalAdd(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); for(re _it p=itl;p!=itr;++p) p-&gt;val+=x;&#125; 就这么几行？ 就这么几行。 操作三，把所有区间取出来，然后直接调用std::sort。 12345678910111213inline long long IntervalXth(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); vec.clear(); for(re _it p=itl;p!=itr;++p) vec.push_back(std::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+1)); std::sort(vec.begin(),vec.end()); for(re unsigned i=0;i&lt;vec.size();++i)&#123; x-=vec[i].second; if(x&lt;=0) return vec[i].first; &#125; return 0;&#125; 操作四，暴力快速幂。 1234567inline int IntervalXpow(int l,int r,int x,int y)&#123; _it itr=split(r+1),itl=split(l); int res=0; for(re _it p=itl;p!=itr;++p) res=(1LL*res+1LL*(p-&gt;r-p-&gt;l+1)*cltpow(p-&gt;val%y,x,y)%y)%y; return res;&#125; 您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？ 这是我在CodeForces上的提交记录： 这是我之前提到的那位不愿意透露姓名的珂学家的跑得最快的一次提交记录： 珂幻.jpg 因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了「CF915E」Physical Education Lessons，然而…… Updated on 2018-11-01 后来我卡了卡常数过了…… 以及，删掉了某些内容（ 于是，接下来是珂朵莉树的完整板子。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;set&gt;#define re register#define maxn 100000#define _it std::set&lt;node&gt;::iteratornamespace cltstream&#123; #ifdef ONLINE_JUDGE #define size 1048576 char str[size+1],*head=str,*tail=str; inline char gc()&#123; if(head==tail)&#123; tail=(head=str)+fread(str,1,size,stdin); if(head==tail) return EOF; &#125; return *head++; &#125; #undef size #else #define gc getchar #endif template &lt;typename _tp&gt; inline void read(_tp&amp; x)&#123; int sn=1; char c=gc(); for(;c!=45&amp;&amp;(c&lt;48||c&gt;57)&amp;&amp;c!=EOF;c=gc()); if(c==45&amp;&amp;c!=EOF) sn=-1,c=gc(); for(x=0;c&gt;=48&amp;&amp;c&lt;=57&amp;&amp;c!=EOF;x=(x&lt;&lt;3)+(x&lt;&lt;1)+(c^48),c=gc()); x*=sn; &#125; template &lt;typename _tp&gt; inline void write(_tp x,char text=' ')&#123; if(x&lt;0) putchar(45),x=-x; if(!x) putchar(48); else&#123; int digit[20]; for(digit[0]=0;x;digit[++digit[0]]=x%10,x/=10); for(;digit[0];putchar(digit[digit[0]--]^48)); &#125; putchar(text); &#125;&#125;int n,m,seed,maxval;struct node&#123; int l,r; mutable long long val; node(int _l,int _r=-1,long long _val=-1)&#123; l=_l; r=_r; val=_val; &#125;&#125;;std::set&lt;node&gt; s;std::vector&lt;std::pair&lt;long long,int&gt; &gt; vec;inline int rnd()&#123; int res=seed; seed=(7LL*seed+13)%1000000007; return res;&#125;inline void swap(int&amp; l,int&amp; r)&#123; int tmp=l; l=r; r=tmp;&#125;int cltpow(int x,int y,int mod)&#123; if(y==1) return x; int res=cltpow(x,y&gt;&gt;1,mod); res=1LL*res*res%mod; if(y&amp;1) res=1LL*res*x%mod; return res;&#125;inline bool operator&lt;(node p,node q)&#123; return p.l&lt;q.l;&#125;inline _it split(int pos)&#123; _it it=std::lower_bound(s.begin(),s.end(),node(pos)); if(it!=s.end()&amp;&amp;it-&gt;l==pos) return it; --it; int l=it-&gt;l,r=it-&gt;r; long long val=it-&gt;val; s.erase(it); s.insert(node(l,pos-1,val)); return s.insert(node(pos,r,val)).first;&#125;inline void IntervalAdd(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); for(re _it p=itl;p!=itr;++p) p-&gt;val+=x;&#125;inline void IntervalAssign(int l,int r,int x)&#123;//就是之前提到的assign _it itr=split(r+1),itl=split(l); s.erase(itl,itr); s.insert(node(l,r,x));&#125;inline long long IntervalXth(int l,int r,int x)&#123; _it itr=split(r+1),itl=split(l); vec.clear(); for(re _it p=itl;p!=itr;++p) vec.push_back(std::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+1)); std::sort(vec.begin(),vec.end()); for(re unsigned i=0;i&lt;vec.size();++i)&#123; x-=vec[i].second; if(x&lt;=0) return vec[i].first; &#125; return 0;&#125;inline int IntervalXpow(int l,int r,int x,int y)&#123; _it itr=split(r+1),itl=split(l); int res=0; for(re _it p=itl;p!=itr;++p) res=(1LL*res+1LL*(p-&gt;r-p-&gt;l+1)*cltpow(p-&gt;val%y,x,y)%y)%y; return res;&#125;int main()&#123; cltstream::read(n); cltstream::read(m); cltstream::read(seed); cltstream::read(maxval); for(re int i=1;i&lt;=n;++i) s.insert(node(i,i,rnd()%maxval+1)); for(re int i=1;i&lt;=m;++i)&#123; int opt=rnd()%4+1,l=rnd()%n+1,r=rnd()%n+1,x,y; if(l&gt;r) swap(l,r); switch(opt)&#123; case 1: x=rnd()%maxval+1; IntervalAdd(l,r,x); break; case 2: x=rnd()%maxval+1; IntervalAssign(l,r,x); break; case 3: x=rnd()%(r-l+1)+1; cltstream::write(IntervalXth(l,r,x),'\\n'); break; case 4: x=rnd()%maxval+1; y=rnd()%maxval+1; cltstream::write(IntervalXpow(l,r,x,y),'\\n'); break; &#125; &#125; return 0;&#125; 以上。","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://github.com/Challestend/categories/学习笔记/"}],"tags":[{"name":"珂朵莉树","slug":"珂朵莉树","permalink":"https://github.com/Challestend/tags/珂朵莉树/"}]},{"title":"「SDOI2009」虔诚的墓主人","slug":"luogu-p2154-solution","date":"2018-10-12T03:28:50.000Z","updated":"2018-12-12T02:06:49.568Z","comments":true,"path":"luogu-p2154-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p2154-solution/","excerpt":"传送门","text":"传送门 几个月前某学姐给我推荐的毒瘤题之一。然而我直到现在也只切掉两道，我真是太菜了。 首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是 C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}考虑到墓地不能和常青树重合，又有$k\\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为 C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\\sum\\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})怎么快速地查询与修改后面那个$\\Sigma$所涉及到的值？树状数组啊当然如果您非要写些乱七八糟的数据结构也没人拦着您。 坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。 1234567891011121314#include&lt;cstdio&gt;struct NOIp&#123; unsigned long long RP,score;&#125;;NOIp NOIp2018;int main()&#123; for(;;)&#123; NOIp2018.RP++; NOIp2018.score++; &#125; return 0;&#125; 以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊但是我实在是太菜了qaq。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"SDOI","slug":"SDOI","permalink":"https://github.com/Challestend/tags/SDOI/"},{"name":"2009","slug":"2009","permalink":"https://github.com/Challestend/tags/2009/"},{"name":"离散化","slug":"离散化","permalink":"https://github.com/Challestend/tags/离散化/"},{"name":"树状数组","slug":"树状数组","permalink":"https://github.com/Challestend/tags/树状数组/"},{"name":"组合数学","slug":"组合数学","permalink":"https://github.com/Challestend/tags/组合数学/"}]},{"title":"「Luogu-P4900」食堂","slug":"luogu-p4900-solution","date":"2018-10-04T04:11:18.000Z","updated":"2018-12-12T02:04:37.245Z","comments":true,"path":"luogu-p4900-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p4900-solution/","excerpt":"传送门","text":"传送门 闲着没事写篇题解（ 简单来说，就是要求 \\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\pmod{998244353}其中$\\lbrace x\\rbrace$表示取$x$的小数部分。 稍加思索，我们不难发现 \\begin{aligned} &\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}\\lbrace\\frac{i}{j}\\rbrace\\\\ \\equiv&\\sum\\limits_{i=A}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\\\ \\equiv&\\sum\\limits_{i=1}^{B}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}-\\sum\\limits_{i=1}^{A-1}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1} \\pmod{998244353} \\end{aligned}因此，我们只需要关注下式的值 \\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\pmod{998244353}我们可以参考一下这道题 在这道题中，我们定义了 f(x)=\\sum\\limits_{i=1}^{n}x\\%i首先，如果不考虑$x\\%i=0$的情况，我们有 x\\%i=(x-1)\\%i+1f(x)=f(x-1)+n如果$x\\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此 f(x)=f(x-1)+n-\\sigma(x)我们可以类似地定义 g(x)=\\sum\\limits_{i=1}^{n}x\\%i\\times i^{-1}\\pmod{998244353}h(x)=\\sum\\limits_{i\\mid x}i\\times i^{-1}\\equiv\\sum\\limits_{i\\mid x}1\\equiv d(x)\\pmod{998244353}从而我们有 g(x)\\equiv g(x-1)+\\sum\\limits_{i=1}^{n}i^{-1}-d(x)\\pmod{998244353}然而我们需要的是 \\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}其中 ans(x)=\\sum\\limits_{i=1}^{x}x\\%i\\times i^{-1}\\pmod{998244353}不难发现当$i&lt;j$时$i\\%j=i$，从而 \\begin{aligned} &g(x)-ans(x)\\\\ \\equiv&\\sum\\limits_{i=x+1}^{n}x\\%i\\times i^{-1}\\\\ \\equiv&\\sum\\limits_{i=x+1}^{n}x\\times i^{-1} \\pmod{998244353} \\end{aligned}最终，我们得到 ans(x)\\equiv g(x)-x\\sum\\limits_{i=x+1}^{n}i^{-1}\\sum\\limits_{i=1}^{n}\\sum\\limits_{j=1}^{i}i\\%j\\times j^{-1}\\equiv\\sum\\limits_{i=1}^{n}ans(i)\\pmod{998244353}把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"},{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"}]},{"title":"「Luogu-P3924」康娜的线段树","slug":"luogu-p3924-solution","date":"2018-09-29T08:20:16.000Z","updated":"2018-12-19T12:01:29.650Z","comments":true,"path":"luogu-p3924-solution/","link":"","permalink":"https://github.com/Challestend/luogu-p3924-solution/","excerpt":"传送门","text":"传送门 读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围： 对于$70\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{5}$。 对于$100\\%$的数据，保证$1\\leqslant n,m\\leqslant 10^{6}$。 也就是说，上述做法最多只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。 Updated on 2018-10-09 不好意思时间复杂度算错了我太菜了。 但反正线段树需要卡常才能过（ 我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。 定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。 稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。 以及，最后一句话。 这道题卡精度。","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"https://github.com/Challestend/tags/洛谷/"},{"name":"差分","slug":"差分","permalink":"https://github.com/Challestend/tags/差分/"}]},{"title":"「Luogu-T47720」孤立元","slug":"luogu-t47720-solution","date":"2018-09-27T06:29:56.000Z","updated":"2018-12-29T04:37:49.951Z","comments":true,"path":"luogu-t47720-solution/","link":"","permalink":"https://github.com/Challestend/luogu-t47720-solution/","excerpt":"传送门","text":"传送门 自己出的第一道毒瘤数论题。 对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\\notin B$且$i+1\\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为 \\frac{\\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式 \\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\\frac{m(n+1)(n-m)}{n(n-1)} Updated on 2018-10-10 之前公式写错了，分子上的$m$全都漏掉了（ 以及，我们还可以将上式继续整理： \\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}以及，顺便测试了一下新的快读板子，然后发现#ifdef真没用也可能是我太菜了（ Updated on 2018-10-16 好吧我当时并不会用#ifdef（ 以及，标程经过一系列丧心病狂的卡常卡到了$1861\\text{ms}$，最慢的一个点只跑了$300\\text{ms}$不到。截至本日，另外两个切掉这道题的$\\text{dalao}$最慢的一个点也只跑了$400\\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？所以说为什么我当初在本地测的时候平均每个点$500\\text{ms}$，是我们机房的电脑太菜了吗（ 于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。 但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……","categories":[{"name":"题解","slug":"题解","permalink":"https://github.com/Challestend/categories/题解/"}],"tags":[{"name":"数论","slug":"数论","permalink":"https://github.com/Challestend/tags/数论/"},{"name":"组合数学","slug":"组合数学","permalink":"https://github.com/Challestend/tags/组合数学/"},{"name":"期望","slug":"期望","permalink":"https://github.com/Challestend/tags/期望/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-09-27T05:41:19.000Z","updated":"2019-01-08T13:34:14.276Z","comments":true,"path":"hello-world/","link":"","permalink":"https://github.com/Challestend/hello-world/","excerpt":"","text":"总算是搞出来了一个自己觉得海星的blog……","categories":[{"name":"未分类","slug":"未分类","permalink":"https://github.com/Challestend/categories/未分类/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/Challestend/tags/其它/"}]},{"title":"说在前面的话","slug":"announcement","date":"1899-11-29T16:00:00.000Z","updated":"2019-01-08T13:34:20.455Z","comments":true,"path":"announcement/","link":"","permalink":"https://github.com/Challestend/announcement/","excerpt":"在阅读这个菜鸡的blog之前，您需要知道的一些事情。","text":"在阅读这个菜鸡的blog之前，您需要知道的一些事情。 在有小标题的文章里，侧边栏的网易云外链会出锅。原因不明。 在撰写评论时，推荐您在「邮箱」一栏如实填写自己用于注册Gravatar的邮箱，使用您Gravatar上的头像。当然，如果您实在是懒得搞什么G啥玩意的，您也可以随便填点什么，我们会基于您填写的内容生成一个随机头像。但是无论如何不推荐留空。而且一定要保证满足邮箱的格式，即?*@?*.com。其中?*表示这里可以填任意多个字符，但不能是零个，而且不能包含一些奇怪的字符，包括但不限于/、.。","categories":[{"name":"未分类","slug":"未分类","permalink":"https://github.com/Challestend/categories/未分类/"}],"tags":[{"name":"其它","slug":"其它","permalink":"https://github.com/Challestend/tags/其它/"}]}]}