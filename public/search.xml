<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>一些乱七八糟的数论</title>
      <link href="/2018/11/29/number-theory-learning-notes/"/>
      <url>/2018/11/29/number-theory-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p><p><del>抄袭来源</del>参考文献：</p><ul><li><a href="https://lx-2003.blog.luogu.org/mobius-inversion" target="_blank" rel="noopener">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li><li><a href="https://www.luogu.org/blog/54745/dls-tql" target="_blank" rel="noopener">浅谈杜教筛</a></li></ul><a id="more"></a><h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><h2 id="定义与相关性质"><a href="#定义与相关性质" class="headerlink" title="定义与相关性质"></a>定义与相关性质</h2><p>数论函数就是定义域为$\mathbb{N}^{+}$的函数。</p><p>两个数论函数相加，就是简单地把函数值相加。</p><script type="math/tex; mode=display">(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p><script type="math/tex; mode=display">(\alpha f)(n)=\alpha f(n)</script><p><del>好像没啥用。</del></p><p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p><script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})</script><p>或者说：</p><script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p><p>交换律，即$f\times g=g\times f$。</p><p>这很明显。</p><p>结合律，即$(f\times g)\times h=f\times(g\times h)$。</p><script type="math/tex; mode=display">\begin{aligned}((f\times g)\times h)(n)&=\sum\limits_{ij=n}(\sum\limits_{kl=i}f(k)g(l))h(j)\\&=\sum\limits_{ijk=n}f(i)g(j)h(k)\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}(f\times(g\times h))(n)&=\sum\limits_{ij=n}f(i)(\sum\limits_{kl=j}g(k)h(l))\\&=\sum\limits_{ijk=n}f(i)g(j)h(k)\end{aligned}</script><p>分配率，即$(f+g)\times h=f\times h+g\times h$。</p><script type="math/tex; mode=display">\begin{aligned}((f+g)\times h)(n)&=\sum\limits_{ij=n}(f+g)(i)h(j)\\&=\sum\limits_{ij=n}f(i)h(j)+g(i)h(j)\\&=(f\times h)(n)+(g\times h)(n)\end{aligned}</script><p>单位元为$\epsilon(n)=[n=1]$，$f\times\epsilon =f$。</p><p>这也很明显。</p><p>对于任意一个满足$f(1)\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\times g=\epsilon$。这时我们称$g$是$f$的逆。</p><p>我们可以这样定义一个函数的逆：</p><script type="math/tex; mode=display">g(n)=\cfrac{\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum_{i\mid n}f(i)g(\cfrac{n}{i})\\&=f(1)g(n)+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\&=\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\&=\epsilon(n)\end{aligned}</script><h2 id="积性函数与完全积性函数"><a href="#积性函数与完全积性函数" class="headerlink" title="积性函数与完全积性函数"></a>积性函数与完全积性函数</h2><p>如果一个数论函数$f$满足</p><script type="math/tex; mode=display">\forall x,y\in\mathbb{N}^{+}\wedge x\perp y\;\;f(xy)=f(x)f(y)</script><p>我们就说$f$是一个积性函数。</p><p>特别的，如果上式去掉$x\perp y$仍成立，则称$f$是一个完全积性函数。</p><p>很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\times n)=f(1)\times f(n)=f(n)$。</p><p>常见的完全积性函数有$\epsilon,id^{k}$。$\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p><p>常见的积性函数有$\varphi,d,\sigma$。$\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\sigma(n)$的值分别等于$n$的约数个数和约数和。</p><p>关于$\varphi$的积性，我并不会证（</p><p>我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有</p><script type="math/tex; mode=display">d(n)=\prod\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个$m$，且</p><script type="math/tex; mode=display">m=\prod\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说$n\perp m$，肯定有</p><script type="math/tex; mode=display">\forall i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z}\;\;p_{i}\neq q_{j}</script><p>于是我们就有</p><script type="math/tex; mode=display">nm=(\prod\limits_{i=1}^{N}p_{i}^{r_{i}})(\prod\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type="math/tex; mode=display">\begin{aligned}d(nm)&=(\prod\limits_{i=1}^{N}(r_{i}+1))(\prod\limits_{j=1}^{M}(s_{j}+1))\\&=d(n)d(m)\end{aligned}</script><p>不妨再反过来考虑。如果说$n\not\perp m$，那么一定存在一对$(i,j)(i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\neq d(n)d(m)$。</p><p>我们再来分析$\sigma$的积性。还是设</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\in [0,r_{i}]\cap\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p><script type="math/tex; mode=display">\prod\limits_{i=1}^{N}\sum\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是$\sigma(n)$的值。</p><p>接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。</p><p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)(f\times g)(m)&=(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(i)g(\cfrac{n}{i})f(j)g(\cfrac{m}{j})\\&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(ij)g(\cfrac{nm}{ij})\\&=\sum\limits_{k\mid nm}f(k)g(\cfrac{nm}{k})\\&=(f\times g)(nm)\end{aligned}</script><p>关于上面的第四个等号。时刻注意$n\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。</p><p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p><p>设有一个积性函数$f$，它的逆是$g$。</p><p>当$nm=1$时，$g(1)=1$。</p><p>当$nm&gt;1$时，我们假设对于任意$n^{\prime}m^{\prime}&lt;nm$，都有$g(n^{\prime}m^{\prime})=g(n^{\prime})g(m^{\prime})$。此时</p><script type="math/tex; mode=display">\begin{aligned}g(nm)&=-\sum\limits_{k\mid nm,k\neq 1}f(k)g(\cfrac{nm}{k})\\&=-\sum\limits_{i\mid n,j\mid m,ij\neq 1}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\&=g(n)g(m)-\sum\limits_{i\mid n,j\mid m}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\&=g(n)g(m)-(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\&=g(n)g(m)-\epsilon(n)\epsilon(m)\\&=g(n)g(m)\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="正向反演"><a href="#正向反演" class="headerlink" title="正向反演"></a>正向反演</h2><p>定义$\mu$为$1$的逆。也就是说，$\mu\times 1=\epsilon$。</p><p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p><blockquote><p>首先地，$\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\mu(n)=(-1)^{k}$。否则，$\mu(n)=0$。</p></blockquote><p>那么，这两种定义等价吗？</p><p>考虑到$\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p><script type="math/tex; mode=display">\mu(n)=\prod\limits_{i=1}^{N}\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p><p>设有一个质数$p$。不难发现</p><script type="math/tex; mode=display">\mu(p)=-\mu(1)=-1</script><script type="math/tex; mode=display">\mu(p^{2})=-\mu(1)-\mu(p)=-1+1=0</script><script type="math/tex; mode=display">\mu(p^{3})=-\mu(1)-\mu(p)-\mu(p^{2})=-1+1+0=0</script><script type="math/tex; mode=display">\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p><p>那么这个东西有什么用呢？</p><p>我们设</p><script type="math/tex; mode=display">F(n)=\sum\limits_{i\mid n}f(i)</script><p>或者等价地说，$F=f\times 1$。我们可以得到</p><script type="math/tex; mode=display">\begin{aligned}F&=f\times 1\\F\times\mu&=f\times 1\times\mu\\F\times\mu&=f\end{aligned}</script><p>像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说</p><script type="math/tex; mode=display">f(n)=\sum\limits_{i\mid n}F(i)\mu(\cfrac{n}{i})</script><h2 id="反向反演"><a href="#反向反演" class="headerlink" title="反向反演"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p><script type="math/tex; mode=display">F(n)=\sum\limits_{n\mid d}f(d)⇔f(n)=\sum\limits_{n\mid d}F(d)\mu(\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p><script type="math/tex; mode=display">(f\otimes g)(n)=\sum\limits_{n\mid d}f(d)g(\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p><script type="math/tex; mode=display">F=f\otimes 1⇔F\otimes\mu=f</script><p>于是就有了上面的反向反演。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>反正都讲完了反演了，就顺便来道<a href="https://www.luogu.org/problemnew/show/P2522" target="_blank" rel="noopener">练习题</a>吧。</p><p>题目大意很简单，就是要求</p><script type="math/tex; mode=display">\sum\limits_{i=a}^{b}\sum\limits_{j=c}^{d}[(i,j)=k]</script><p>容斥一波我们得到</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{b}\sum\limits_{j=1}^{d}[(i,j)=k]-\sum\limits_{i=1}^{a-1}\sum\limits_{j=1}^{d}[(i,j)=k]-\sum\limits_{i=1}^{b}\sum\limits_{j=1}^{c-1}[(i,j)=k]+\sum\limits_{i=1}^{a-1}\sum\limits_{j=1}^{c-1}[(i,j)=k]</script><p>因此我们只需要关注下式的值</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{m}[(i,j)=k]</script><p>考虑到$(i,j)=k⇔\cfrac{i}{k}\perp\cfrac{j}{k}$，设$N=\lfloor\cfrac{n}{d}\rfloor$，$M=\lfloor\cfrac{m}{d}\rfloor$，我们可以进一步改写上式</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{M}[i\perp j]</script><p>定义</p><script type="math/tex; mode=display">f(d)=\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{M}[(i,j)=d]</script><script type="math/tex; mode=display">F(d)=\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{M}[d\mid (i,j)]</script><p>我们知道<script type="math/tex">d\mid (i,j)⇔d\mid i\wedge d\mid j</script>。在$[1,N]$中共有$\lfloor\cfrac{N}{d}\rfloor$个$d$的倍数，在$[1,M]$中共有$\lfloor\cfrac{M}{d}\rfloor$个$d$的倍数。因此我们得到</p><script type="math/tex; mode=display">F(d)=\lfloor\cfrac{N}{d}\rfloor\lfloor\cfrac{M}{d}\rfloor</script><p>同时，不难发现$F=f\otimes 1$，因此我们得到$f=F\otimes\mu$，即</p><script type="math/tex; mode=display">f(d)=\sum\limits_{d\mid x}F(x)\mu(\cfrac{x}{d})</script><script type="math/tex; mode=display">f(1)=\sum\limits_{i=1}^{min(N,M)}\lfloor\cfrac{N}{i}\rfloor\lfloor\cfrac{M}{i}\rfloor\mu(i)</script><p>这样一来，先线性筛出$\mu$，结合整除分块即可做到$O(\sqrt{n})$地求解了。</p><blockquote><p>累死我了（</p><p>这已经写了超过$10\text{KB}$了（</p><p>剩下的先咕了吧（</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己的一些大胆的想法（持续更新）</title>
      <link href="/2018/11/14/poison-problems/"/>
      <url>/2018/11/14/poison-problems/</url>
      
        <content type="html"><![CDATA[<p>自己闲得没事搞出来的一些毒瘤题。</p><p><del>不保证有解（</del></p><a id="more"></a><h1 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>定义一个从序列到序列的映射$\text{LIS()}$。我们认为$\text{LIS}(\{ a_n\})=\{ f_n\}$，当且仅当</p><script type="math/tex; mode=display">\forall 1\leqslant i\leqslant n\;\; f_i=\begin{cases}&1&(i=1\vee \forall 1\leqslant j<i\;\; a_j\geqslant a_i)\\&\max\limits_{1\leqslant j<i\wedge a_j<a_i}f_j+1&(\text{Otherwise})\\\end{cases}</script><p>给你一个长度为$n$的序列$\{ f_n\}$，你需要求出满足</p><script type="math/tex; mode=display">\text{LIS}(\{ a_n\})=\{ f_n\}\wedge\forall 1\leqslant i\leqslant n\;\; a_i\in [1,m]\cap\mathbb{Z}</script><p>的$\{ a_n\}$的数量，对$998244353$取模。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很明显地，我们有</p><script type="math/tex; mode=display">\forall 1\leqslant i<j\leqslant n\wedge f_i=f_j\;\;a_i\geqslant a_j</script><script type="math/tex; mode=display">\forall 1\leqslant i,j\leqslant n\wedge f_i<f_j\;\;a_i<a_j</script><p>我们可以考虑将$\{ f_n\}$中最大的数记为$k$，数$x$的出现次数记为$cnt_x$。然后将$[1,m]$划分成$k$个独立区间$[1,x_1],[x_1+1,x_2],\cdots,[x_{k-1}+1,m]$，在第$i$个区间内独立地选出$cnt_i$个数并统计组成的所有不上升序列的数量。</p><p>我们定义$\text{nisc}(\text{Non-Increasing Sequence Count})(n,m)$表示在$n$个互不相等且具有大小关系的元素中选出$m$个元素（没有必要互不相同）组成的本质不同的不上升序列的数量。</p><p>考虑$m=1$时的情况。此时每个元素被选中都可以组成不上升序列。我们令$f[i][j]$表示$m=i$且第一次选中的元素是$j$时的总方案数。很明显地，我们有</p><script type="math/tex; mode=display">\forall 1\leqslant i\leqslant n\;\;f[1][i]=1</script><script type="math/tex; mode=display">\text{nisc}(n,1)=\sum\limits_{i=1}^nf[1][i]=n</script><p>现在考虑$m=2$。假设我们在第一次选择前再选一次。如果我们在这一次选择了$j$，下一次可能的选项有$1,2,\cdots,j$，所以</p><script type="math/tex; mode=display">f[2][j]=\sum\limits_{k=1}^jf[1][k]</script><p>将这个公式进一步推广，我们得到</p><script type="math/tex; mode=display">f[i][j]=\sum\limits_{k=1}^jf[i-1][k]</script><script type="math/tex; mode=display">\text{nisc}(n,m)=\sum_{i=1}^nf[m][i]=f[m+1][n]</script><p>考虑对一个只有$1$的数组进行$m$次前缀和，然后询问第$n$个位置上的数是多少。虽然我不会证，不过我通过人力打表得出</p><script type="math/tex; mode=display">\text{nisc}(n,m)=\frac1{m!}\prod\limits_{i=1}^{m}(n+i-1)</script><p>考虑一种naive的$\text{DP}$。定义$g[i][j]$表示将$[1,i]$分成$j$段，第$j$段中选$cnt_j$个元素组成不上升序列，这样的总方案数。我们有</p><script type="math/tex; mode=display">g[n][m]=\sum\limits_{i=m-1}^{n-1}g[i][m-1]\text{nisc}(n-i,cnt_m)</script><p>然而很遗憾，这个方程是错的。</p><p>就比如说，考虑这样一组数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure><p>手动模拟一下，我们发现答案是$4$。但如果直接暴力地套上面的方程，我们会得到$5$。</p><p>从本质上来讲，上面的方程会把$[1,3]$划分成$\{[1,1],[2,3]\}$和$\{[1,2],[3,3]\}$。对于第一种，我们可以得到$\{\{1,2,1\},\{1,3,1\}\}$。对于第二种，我们可以得到$\{\{1,3,1\},\{1,3,2\},\{2,3,2\}\}$。注意到$\{1,3,1\}$出现了两次，这正是这种做法的错误所在。而且，更恐怖的是，我不认为我们有什么有效的去重方法。</p><blockquote><p>最近可能状态有些差，上面这些东西写完五分之四以后去吃午饭莫名感觉脑阔疼（</p><p>因此，就先到这里吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毒瘤题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「NOIp2018游记」夢の終わるところ</title>
      <link href="/2018/11/09/noip-2018-notes/"/>
      <url>/2018/11/09/noip-2018-notes/</url>
      
        <content type="html"><![CDATA[<p><del>€€£：禁赛警告。</del></p><a id="more"></a><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p><p><img src="https://i.loli.net/2018/11/09/5be4e6d8c122f.png" alt=""></p><p>明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废<del>，同时看着其他dalao随手切神仙题</del>。然后我看到yemdalao写了一篇<a href="https://www.cnblogs.com/taduro/p/9933329.html" target="_blank" rel="noopener">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p><blockquote><p>其他dalao都在机房补文化课而我在颓blog（</p><p>于是，此处以下，$\text{Updated on 2018-11-12}$。</p><blockquote><p>$\text{Updated on 2018-11-14}$：</p><p>看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。</p><p>但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p></blockquote></blockquote><p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。</p><p>然后一抽考场发现是外校，赛前先<code>rp--</code>。</p><p>然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（</p><p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（</p><p>除那之外就没啥了，算是颓了一个下午。</p><p>晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（</p><p>试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。</p><p>反正板子是不可能打炸的，这辈子都不可能的。</p><p>因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。</p><p>然后一打开E盘发现被清了，只有题目。</p><p>Day1的解压密码是不是就我一个人不懂啊（</p><p>那么于是，到了8：30，我点开今天的题目，定神一看……</p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5019" target="_blank" rel="noopener">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正<code>score+=100</code>。</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5020" target="_blank" rel="noopener">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5021" target="_blank" rel="noopener">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。</p><p>估分100+100+25=225。</p><p>出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（</p><p>前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（</p><p>那我可真是太菜了（</p><p>下午日常发呆，然后晚上是快乐的颓废时间。</p><p>中午买的零食一个下午就全吃完了（</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p><p>这次我东西是真的带全了（</p><p>Day2的解压密码依然不懂，然后是今天的题目：</p><h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5022" target="_blank" rel="noopener">T1</a></h2><p>NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。</p><p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点<code>std::sort</code>一遍。然后维护一个邻接矩阵处理断边（</p><p>为什么不直接用邻接矩阵呢（</p><h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5023" target="_blank" rel="noopener">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（</p><h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5024" target="_blank" rel="noopener">T3</a></h2><p>究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。</p><p>估分100+65+44=204（不存在的，肯定比这个低）。</p><p>这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……</p><p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p><p>好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……</p><p>下午请假回家开心地颓废。</p><h1 id="Extra-Notes"><a href="#Extra-Notes" class="headerlink" title="Extra Notes"></a>Extra Notes</h1><p>果然是等到NOIp结束后才更新的。</p><p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p><blockquote><p>$\text{Updated on 2018-11-26}$：</p><p>好像有些晚的更新。</p><p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p><p>具体成绩差不多是100+100+20+100+65+36=421。</p><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIp </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P5009」毒瘤分块题</title>
      <link href="/2018/11/08/luogu-p5009-solution/"/>
      <url>/2018/11/08/luogu-p5009-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5009" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>从来没做过这么毒瘤的题qaq</p><p>就算看了题解现在还是一脸懵逼qaq</p><p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq</p><p>对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\prime$使得$v_i^\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\prime$，然后查询的时候我们就可以直接返回$v_i^\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\prime=v_i-t_1xb_i$。</p><p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\Sigma v_i^\prime+t\Sigma (a_i+x+z)(b_i+y)=\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$，即$\Sigma v_i^\prime=\Sigma v_i-tz\Sigma (b_i+y)$。</p><p>不过，上式中$tz\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\Sigma b_i$，考虑到每层节点的$\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\Sigma v_i+=B\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。</p><p>然后是毒瘤的下推标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];</span><br><span class="line"><span class="comment">//就是上面这句qaq现在还是一脸懵逼qaq</span></span><br><span class="line">A[son]+=A[father];</span><br><span class="line">B[son]+=B[father];</span><br><span class="line">adda[son]+=adda[father];</span><br><span class="line">addb[son]+=addf[father];</span><br></pre></td></tr></table></figure><p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 100000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line"><span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ih==it)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *ih++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">oh=cltout;</span><br><span class="line">&#125;</span><br><span class="line">*oh++=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=gc();</span><br><span class="line"><span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">sn=<span class="number">-1</span>,c=gc();</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">x*=sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">pc(<span class="number">45</span>),x=-x;</span><br><span class="line"><span class="keyword">if</span>(!x)</span><br><span class="line">pc(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">pc(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> sumv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],suma[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sumb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sump[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],B[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> addv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],adda[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],addb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> ln,<span class="keyword">int</span> rn)</span></span>&#123;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addv[cur]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*ln%mod)%mod;</span><br><span class="line">suma[cur&lt;&lt;<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*adda[cur]%mod)%mod;</span><br><span class="line">sumb[cur&lt;&lt;<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addb[cur]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">A[cur&lt;&lt;<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">B[cur&lt;&lt;<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">adda[cur&lt;&lt;<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">addb[cur&lt;&lt;<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addv[cur]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*rn%mod)%mod;</span><br><span class="line">suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*adda[cur]%mod)%mod;</span><br><span class="line">sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addb[cur]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">sumv[cur]=(sumv[cur&lt;&lt;<span class="number">1</span>]+sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">suma[cur]=(suma[cur&lt;&lt;<span class="number">1</span>]+suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">sumb[cur]=(sumb[cur&lt;&lt;<span class="number">1</span>]+sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">sump[cur]=(sump[cur&lt;&lt;<span class="number">1</span>]+sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">cltstream::read(sumv[cur]);</span><br><span class="line">cltstream::read(suma[cur]);</span><br><span class="line">cltstream::read(sumb[cur]);</span><br><span class="line">sumv[cur]=(sumv[cur]%mod+mod)%mod;</span><br><span class="line">suma[cur]=(suma[cur]%mod+mod)%mod;</span><br><span class="line">sumb[cur]=(sumb[cur]%mod+mod)%mod;</span><br><span class="line">sump[cur]=<span class="number">1L</span>L*suma[cur]*sumb[cur]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">build(cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class="line"><span class="keyword">return</span> (sumv[cur]+<span class="number">1L</span>L*t*sump[cur]%mod)%mod;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>,l,mid))%mod;</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r))%mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyV</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">sumv[cur]=(sumv[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">addv[cur]=(addv[cur]+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyA</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">suma[cur]=(suma[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">sump[cur]=(sump[cur]+<span class="number">1L</span>L*sumb[cur]*x%mod)%mod;</span><br><span class="line">B[cur]=(B[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*addb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">adda[cur]=(adda[cur]+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyB</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*suma[cur]%mod+mod)%mod)%mod;</span><br><span class="line">sumb[cur]=(sumb[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">sump[cur]=(sump[cur]+<span class="number">1L</span>L*suma[cur]*x%mod)%mod;</span><br><span class="line">A[cur]=(A[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*adda[cur]%mod+mod)%mod)%mod;</span><br><span class="line">addb[cur]=(addb[cur]+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cltstream::read(n);</span><br><span class="line">cltstream::read(m);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> opt,t,l,r,x;</span><br><span class="line">cltstream::read(opt);</span><br><span class="line">cltstream::read(t);</span><br><span class="line">cltstream::read(l);</span><br><span class="line">cltstream::read(r);</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cltstream::write(query(l,r,t,<span class="number">1</span>,<span class="number">1</span>,n),<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cltstream::read(x);</span><br><span class="line">modifyA(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cltstream::read(x);</span><br><span class="line">modifyB(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">cltstream::read(x);</span><br><span class="line">modifyV(l,r,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是我太菜了不适合做这种毒瘤题吧qaq</p><p><img src="https://i.loli.net/2018/11/08/5be38edf529ca.jpg" alt=""></p><p>距 <strong>在NOIp2018爆零</strong> 还剩 <strong>1 天</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>状态压缩动态规划学习笔记</title>
      <link href="/2018/10/24/status-compression-learning-notes/"/>
      <url>/2018/10/24/status-compression-learning-notes/</url>
      
        <content type="html"><![CDATA[<p><del>把标签和分类连在一起读就是标题了（</del></p><p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p><p><del>马上就要复赛了，但反正我已经退役预定了来颓blog吧。</del></p><a id="more"></a><p>首先我们来看一道例题，<a href="https://www.luogu.org/problemnew/show/P1879" target="_blank" rel="noopener">「USACO06NOV」玉米田Corn Fields</a>。</p><p>首先，我们想到定义<code>f[i][...]</code>表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...(省略10个[0/1])...[0/1]</code>，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。</p><p>但是等等……$13$维的状态……</p><p><img src="https://i.loli.net/2018/10/24/5bd07656b885a.jpg" alt=""></p><p>注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。</p><p>于是，现在我们定义<code>f[i][S]</code>表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义<code>a[i]</code>表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。<code>valid[S]</code>表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。<code>a[i]</code>在读入时就可以处理出来，至于<code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    valid[i]=valid[i&gt;&gt;<span class="number">1</span>]&amp;(~(i&amp;(i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>用人话来讲就是<code>[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]</code>。</p><p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是<code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i])==a[i]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    (f[i][j]+=f[i<span class="number">-1</span>][k])%=mod;</span><br></pre></td></tr></table></figure><p>粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个<code>if</code>剪掉，因而实际运行跑得比谁都快（</p><p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href="https://www.luogu.org/problemnew/show/P2704" target="_blank" rel="noopener">「NOI2001」炮兵阵地</a>。</p><p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用<code>f[i][S1][S2]</code>表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录<code>a[i]</code>和<code>valid[S]</code>，不过，这次<code>valid[s]</code>的预处理过程差不多是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">    valid[i]=(i&amp;<span class="number">1</span>)?valid[i&gt;&gt;<span class="number">3</span>]&amp;((~i)&gt;&gt;<span class="number">2</span>)&amp;((~i)&gt;&gt;<span class="number">1</span>):valid[i&gt;&gt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg" alt=""></p><p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p><p>……不好像又没写错……</p><p>好吧没写错。</p><p>如果$S$的最后一位是$1$，则<code>[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]</code>，否则<code>[S是否合法]=[S&gt;&gt;1是否合法]</code>。</p><p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>转移过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">            <span class="keyword">if</span>((j|a[<span class="number">2</span>])==a[<span class="number">2</span>]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    f[<span class="number">2</span>][i][j]=cnt[i]+cnt[j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i<span class="number">-2</span>])==a[i<span class="number">-2</span>]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);++l)</span><br><span class="line">                        <span class="keyword">if</span>((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==<span class="number">0</span>&amp;&amp;(l&amp;k)==<span class="number">0</span>)</span><br><span class="line">                            f[i][k][l]=max(f[i][k][l],f[i<span class="number">-1</span>][j][k]+cnt[l]);</span><br></pre></td></tr></table></figure><p>时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\text{won’t TLE})$（</p><p>我们再来看一个状压的应用，<a href="https://www.spoj.com/problems/MMINPAID/" target="_blank" rel="noopener">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href="https://www.luogu.org/problemnew/show/SP3953" target="_blank" rel="noopener">洛谷</a>上提交。</p><p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义<code>dis[u][S]</code>为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。</p><p>这样一来，我们只需要写一个可重复入队的堆优化$Dijkstra$就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p><p><del>我是不会说我把$\text{impossible}$打成$\text{Impossible}$然后交上去$\text{WA}$了一发的（</del></p><p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p><p><img src="https://i.loli.net/2018/10/25/5bd13984b8601.jpg" alt=""></p><p>以上，我觉得我的状压讲的差不多了（</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>珂朵莉树学习笔记</title>
      <link href="/2018/10/13/chtholly-tree-learning-notes/"/>
      <url>/2018/10/13/chtholly-tree-learning-notes/</url>
      
        <content type="html"><![CDATA[<p><del>还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p><p><del>话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。</del></p><p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p><a id="more"></a><p>我们先来看一道<del>毒瘤</del>例题，<a href="http://codeforces.com/contest/896/problem/C" target="_blank" rel="noopener">「CF896C」Willem, Chtholly and Seniorious</a>。</p><p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？</p><p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫$\text{Old Driver Tree}$，简称$\text{ODT}$。当然您也可以叫它$\text{Chtholly Tree}$。从本质上来讲，珂朵莉树是一种基于<code>std::set</code>的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p><blockquote><p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p></blockquote><p>那么怎么推平呢？不急，我们慢慢讲。</p><p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="comment">//这里的mutable是为了让我们在之后的修改过程中可以修改val的值</span></span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//调用时_r或_val不填的话默认-1，为了后面split时方便</span></span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>初始化完了？</p><p>初始化完了。</p><p>然后就是珂朵莉树的核心操作<del>之一</del>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::&lt;<span class="built_in">set</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure><p>作用是分离出一个左端点为<code>pos</code>的区间并返回它的迭代器。它的具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="comment">//上面这句手打非常麻烦，建议宏定义</span></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="comment">//找第一个左端点大于等于pos的区间</span></span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="comment">//如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器</span></span><br><span class="line">    --it;</span><br><span class="line">    <span class="comment">//否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内</span></span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">    <span class="comment">//将区间[l,r]删除，并插入区间[l,pos)和[pos,r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p><p><code>insert</code>函数的返回值类型是<code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个<code>.first</code>。</p><p><code>std::set</code>内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\operatorname{log}n)$的。</p><p>然后是一个同样很核心的操作，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure><p>将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="comment">//注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内</span></span><br><span class="line">    <span class="comment">//后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器</span></span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    <span class="comment">//将[itl,itr)内所有区间删除</span></span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">    <span class="comment">//用一个大区间取代它们</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就完了？</p><p>这就完了。</p><p><code>assign</code>操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得<code>set</code>的大小迅速减小，并最终趋于$\operatorname{log}n$。本题的操作二就只需调用一次<code>assign(l,r,x)</code>即可。</p><p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p><p>操作一，一个一个区间地拿出来加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么几行？</p><p>就这么几行。</p><p>操作三，把所有区间取出来，然后直接调用<code>std::sort</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作四，暴力快速幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p><p>这是我在$\text{CodeForces}$上的提交记录：</p><p><img src="https://i.loli.net/2018/10/14/5bc28b1443ea5.png" alt=""></p><p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p><p><img src="https://i.loli.net/2018/10/14/5bc28c7ecfe96.png" alt=""></p><p><img src="https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg" alt=""></p><p>珂幻.jpg</p><p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href="http://codeforces.com/contest/915/problem/E" target="_blank" rel="noopener">「CF915E」Physical Education Lessons</a>，然而……</p><p><img src="https://i.loli.net/2018/10/14/5bc297890bbc6.png" alt=""></p><blockquote><p>$\text{Updated on 2018-11-01}$：</p><p>后来我卡了卡常数过了……</p><p>以及，删掉了某些内容（</p></blockquote><p>于是，接下来是珂朵莉树的完整板子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">        <span class="keyword">char</span> str[size+<span class="number">1</span>],*head=str,*tail=str;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">                tail=(head=str)+fread(str,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(head==tail)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];<span class="built_in">putchar</span>(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,seed,maxval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=seed;</span><br><span class="line">    seed=(<span class="number">7L</span>L*seed+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; l,<span class="keyword">int</span>&amp; r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=l;</span><br><span class="line">    l=r;</span><br><span class="line">    r=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> res=cltpow(x,y&gt;&gt;<span class="number">1</span>,mod);</span><br><span class="line">    res=<span class="number">1L</span>L*res*res%mod;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">        res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAssign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//就是之前提到的assign</span></span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(seed);</span><br><span class="line">    cltstream::read(maxval);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            swap(l,r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAdd(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAssign(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXth(l,r,x),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                y=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXpow(l,r,x,y),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「SDOI2009」虔诚的墓主人</title>
      <link href="/2018/10/12/luogu-p2154-solution/"/>
      <url>/2018/10/12/luogu-p2154-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p><p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是</p><script type="math/tex; mode=display">C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有$k\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p><script type="math/tex; mode=display">C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\sum\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个$\Sigma$所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p><p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NOIp</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> RP,score;</span><br><span class="line">&#125;;</span><br><span class="line">NOIp NOIp2018;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        NOIp2018.RP++;</span><br><span class="line">        NOIp2018.score++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDOI </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P4900」食堂</title>
      <link href="/2018/10/04/luogu-p4900-solution/"/>
      <url>/2018/10/04/luogu-p4900-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4900" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p><del>闲着没事写篇题解（</del></p><p>简单来说，就是要求</p><script type="math/tex; mode=display">\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\pmod{998244353}</script><p>其中$\lbrace x\rbrace$表示取$x$的小数部分。</p><p>稍加思索，我们不难发现</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\\\equiv&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\\\equiv&\sum\limits_{i=1}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}-\sum\limits_{i=1}^{A-1}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}\end{aligned}</script><p>因此，我们只需要关注下式的值</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}</script><p>我们可以参考一下<a href="https://www.luogu.org/problemnew/show/P3708" target="_blank" rel="noopener">这道题</a></p><p>在这道题中，我们定义了</p><script type="math/tex; mode=display">f(x)=\sum\limits_{i=1}^{n}x\%i</script><p>首先，如果不考虑$x\%i=0$的情况，我们有</p><script type="math/tex; mode=display">x\%i=(x-1)\%i+1</script><script type="math/tex; mode=display">f(x)=f(x-1)+n</script><p>如果$x\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此</p><script type="math/tex; mode=display">f(x)=f(x-1)+n-\sigma(x)</script><p>我们可以类似地定义</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{n}x\%i\times i^{-1}\pmod{998244353}</script><script type="math/tex; mode=display">h(x)=\sum\limits_{i\mid x}i\times i^{-1}\equiv\sum\limits_{i\mid x}1\equiv d(x)\pmod{998244353}</script><p>从而我们有</p><script type="math/tex; mode=display">g(x)\equiv g(x-1)+\sum\limits_{i=1}^{n}i^{-1}-d(x)\pmod{998244353}</script><p>然而我们需要的是</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>其中</p><script type="math/tex; mode=display">ans(x)=\sum\limits_{i=1}^{x}x\%i\times i^{-1}\pmod{998244353}</script><p>不难发现当$i&lt;j$时$i\%j=i$，从而</p><script type="math/tex; mode=display">\begin{aligned}&g(x)-ans(x)\\\equiv&\sum\limits_{i=x+1}^{n}x\%i\times i^{-1}\\\equiv&\sum\limits_{i=x+1}^{n}x\times i^{-1}\pmod{998244353}\end{aligned}</script><p>最终，我们得到</p><script type="math/tex; mode=display">ans(x)\equiv g(x)-x\sum\limits_{i=x+1}^{n}i^{-1}</script><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\equiv\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P3924」康娜的线段树</title>
      <link href="/2018/09/29/luogu-p3924-solution/"/>
      <url>/2018/09/29/luogu-p3924-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3924" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p><blockquote><p>对于$70\%$的数据，保证$1\leqslant n,m\leqslant 10^{5}$。</p><p>对于$100\%$的数据，保证$1\leqslant n,m\leqslant 10^{6}$。</p></blockquote><p><del>也就是说，上述做法<strong>最多</strong>只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。</del></p><blockquote><p>$\text{Updated on 2018-10-09}$：</p><p>不好意思时间复杂度算错了我太菜了。</p><p>但反正线段树需要卡常才能过（</p></blockquote><p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p><p>定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。</p><p>稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形$DP$的$DFS$来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在$DFS$时，我们实际上修改的是$c$数组的差分数组，$DFS$结束后再还原出$c$数组即可。</p><p>以及，最后一句话。</p><p>这道题卡精度。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-T47720」孤立元</title>
      <link href="/2018/09/27/luogu-t47720-solution/"/>
      <url>/2018/09/27/luogu-t47720-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/T47720" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>自己出的第一道<del>毒瘤</del>数论题。</p><p>对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\notin B$且$i+1\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为</p><script type="math/tex; mode=display">\frac{\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p><script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote><p>$\text{Updated on 2018-10-10}$：</p><p>之前公式写错了，分子上的$m$全都漏掉了（</p><p>以及，我们还可以将上式继续整理：</p><script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现<code>#ifdef</code>真没用也可能是我太菜了（</del></p><blockquote><p>$\text{Updated on 2018-10-16}$：</p><p>好吧我当时并不会用<code>#ifdef</code>（</p></blockquote><p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了$1861\text{ms}$，最慢的一个点只跑了$300\text{ms}$不到。截至本日，另外两个切掉这道题的$\text{dalao}$最慢的一个点也只跑了$400\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点$500\text{ms}$，是我们机房的电脑太菜了吗（</del></p></blockquote><p>于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。</p><p>但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/27/hello-world/"/>
      <url>/2018/09/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>总算是搞出来了一个自己觉得海星的blog……</p>]]></content>
      
      
      <categories>
          
          <category> 其它 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
