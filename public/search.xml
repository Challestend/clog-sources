<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>「NOI2016」循环之美</title>
      <link href="/luogu-p1587-solution/"/>
      <url>/luogu-p1587-solution/</url>
      
        <content type="html"><![CDATA[<p>突然被wzx安利的一道题。</p><p><a href="https://www.luogu.org/problemnew/show/P1587" target="_blank" rel="noopener">传送门</a></p><p><a href="https://www.cnblogs.com/asuldb/p/10706088.html" target="_blank" rel="noopener">wzx的题解</a></p><a id="more"></a><p><del>通过查阅fuge的题解，</del>我们发现我们要求的式子是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]</script><p>$[i\perp j]$保证了这是一个最简分数从而不会算重，$[j\perp k]$保证了这是一个纯循环小数。</p><p>首先关于$[1,n]$中与某个常数$k$互质的数的数量，我们有一个结论</p><script type="math/tex; mode=display">\sum_{i=1}^{n}[i\perp k]=\sum_{i=1}^{n}\sum_{x|i,x|k}\mu(x)=\sum_{x|k}\lfloor\cfrac{n}{x}\rfloor\mu(x)</script><p>然后大力整理</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]&=\sum_{j=1}^{m}[j\perp k]\sum_{i=1}^{n}[i\perp j]\\&=\sum_{j=1}^{m}[j\perp k]\sum_{x|j}\lfloor\cfrac{n}{x}\rfloor\mu(x)\\&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{x|j}[j\perp k]\\&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[jx\perp k]\\&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[j\perp k]\\&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{y|k}\lfloor\cfrac{m}{xy}\rfloor\mu(y)\end{aligned}</script><p>这道题有一个突破口在于，$k$的范围很小，只有$2000$，从而$d(k)$的范围会更小，这就使得我们能够暴力枚举$k$的约数来计算第二个$\sum$。</p><p>观察第一个$\sum$，我们发现，套上一层整除分块之后，我们需要计算的是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}f(i)</script><p>其中</p><script type="math/tex; mode=display">f(n)=[n\perp k]\mu(n)</script><p>考虑杜教筛，我们再找来一个函数</p><script type="math/tex; mode=display">g(n)=[n\perp k]</script><p>把它们卷积</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum_{d|n}f(d)g(\cfrac{n}{d})\\&=\sum_{d|n}[d\perp k][\cfrac{n}{d}\perp k]\mu(d)\\&=[n\perp k]\sum_{d|n}\mu(d)\\&=\epsilon(n)\end{aligned}</script><p>然后就差不多了。</p><p>不过有一个问题，像这种对$n$和$m$同时整除分块的情况，不能用类似min_25的trick（$N\leqslant\sqrt{n}$时存到<code>ans1[N]</code>，否则存到<code>ans2[n/N]</code>），只能通过unordered_map或者Hash来记忆化。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">50</span>],f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],mu[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">T</span><span class="params">(re <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d[<span class="number">0</span>];++i)</span><br><span class="line">        res+=<span class="number">1L</span>L*(x/d[i])*mu[d[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=maxn)</span><br><span class="line">        <span class="keyword">return</span> F[N];</span><br><span class="line">    <span class="keyword">if</span>(ans.count(N))</span><br><span class="line">        <span class="keyword">return</span> ans[N];</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,lst=T(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=N;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=N/(N/l);</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> tmp=T(r);</span><br><span class="line">        res-=S(N/l)*(tmp-lst);</span><br><span class="line">        lst=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[N]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(k);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        <span class="keyword">if</span>(k%i==<span class="number">0</span>)</span><br><span class="line">            d[++d[<span class="number">0</span>]]=i;</span><br><span class="line">    mu[<span class="number">1</span>]=F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">            F[i]=-(k%i!=<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%g[j])&#123;</span><br><span class="line">                mu[i*g[j]]=mu[i]*mu[g[j]];</span><br><span class="line">                F[i*g[j]]=F[i]*F[g[j]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        F[i]+=F[i<span class="number">-1</span>];</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>,lst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n&amp;&amp;l&lt;=m;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> tmp=S(r);</span><br><span class="line">        res+=(n/l)*T(m/l)*(tmp-lst);</span><br><span class="line">        lst=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::write(res);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>FWT抄袭笔记</title>
      <link href="/fwt-learning-notes/"/>
      <url>/fwt-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>看到坐在我左边的dalao在学FWT。</p><p>想着二轮前学一些很酷很炫<del>很失败</del>的算法，于是来<del>背一下</del>学一下吧。</p><p><a href="http://www.cnblogs.com/cjyyb/p/9065615.html" target="_blank" rel="noopener">抄袭来源</a>。</p><a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们利用FFT可以在$O(n\log n)$的时间复杂度内计算</p><script type="math/tex; mode=display">H[k]=(F\times G)[k]=\sum_{i+j=k}F[i]G[j]</script><p>假如说我们把这个式子变一变</p><script type="math/tex; mode=display">H[k]=(F\vee G)[k]=\sum_{i\vee j=k}F[i]G[j]</script><script type="math/tex; mode=display">H[k]=(F\wedge G)[k]=\sum_{i\wedge j=k}F[i]G[j]</script><script type="math/tex; mode=display">H[k]=(F\oplus G)[k]=\sum_{i\oplus j=k}F[i]G[j]</script><p>其中$\vee$指按位或，$\wedge$指按位与，$\oplus$指按位异或。</p><p>我们还是希望能够在$O(n\log n)$的时间复杂度内计算出答案。</p><p>这种时候我们就需要FWT（快速沃尔什变换，Fast Walsh–Hadamard Transformation）了。</p><p>在FFT中，我们先计算出了$F$和$G$的点值多项式，然后将对应位直接相乘得到了$F\times G$的点值多项式，最后还原回了$F\times G$。</p><p>类似地，我们可不可以试着计算出两个多项式$F^{\prime},G^{\prime}$，使得</p><script type="math/tex; mode=display">(F\times G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p><del>当然可以啊不然还怎么会有FWT（</del></p><h3 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h3><p>对于两个向量$A$和$B$，我们令</p><script type="math/tex; mode=display">(A,B)=(A[0],A[1],\cdots,B[0],B[1],\cdots)</script><p>设$F$的项数为$2^{t}$。为了方便，我们将其看做一个$2^{t}$维向量</p><script type="math/tex; mode=display">(F[0],F[1],\cdots,F[2^{t}-1])</script><p>然后我们定义</p><script type="math/tex; mode=display">F_{0}=(F[0],F[1],\cdots,F[2^{t-1}-1])</script><script type="math/tex; mode=display">F_{1}=(F[2^{t-1}],F[2^{t-1}+1],\cdots,F[2^{t}-1])</script><h3 id="正变换"><a href="#正变换" class="headerlink" title="正变换"></a>正变换</h3><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p>定义</p><script type="math/tex; mode=display">F^{\prime}=\begin{cases}&(F_{0}^{\prime},F_{1}^{\prime}+F_{0}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\&F&(t=0)\end{cases}</script><p>我们发现</p><script type="math/tex; mode=display">F^{\prime}[i]=\sum_{j\vee i=i}F[j]</script><p>$t=0$时这十分显然，我们来考虑$t\gt 0$时的情况。</p><p>首先很明显的一点是$j\vee i=i\Leftrightarrow j\subseteq i$，也就是说$j$是$i$的子集。</p><p>对于$F_{1}$中的一个下标$i$，我们在$F_{1}$左边接上$F_{0}$后，这个$i$就多了一个$2^{t-1}$。</p><p>之前$i$的每一个子集$j$，也同样多了一个$2^{t-1}$，它们产生的贡献已经被统计在了$F_{1}^{\prime}[i]$内。</p><p>那么去掉这个$2^{t-1}$，我们还有$j\subseteq i+2^{t-1}$，这部分其实就是$F_{0}^{\prime}[i]$的值。</p><p>据此，我们就有</p><script type="math/tex; mode=display">\begin{aligned}F^{\prime}\cdot G^{\prime}[i]&=\left(\sum_{j\subseteq i}F[j]\right)\left(\sum_{k\subseteq i}G[k]\right)\\&=\sum_{j\vee k\subseteq i}F[j]G[k]\\&=\sum_{l\subseteq i}\sum_{j\vee k=l}F[j]G[k]\\&=\sum_{l\subseteq i}(F\vee G)[l]\\&=(F\vee G)^{\prime}[i]\end{aligned}</script><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><p>定义</p><script type="math/tex; mode=display">F^{\prime}=\begin{cases}&(F_{0}^{\prime}+F_{1}^{\prime},F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\&F&(t=0)\end{cases}</script><p>它具有类似的性质</p><script type="math/tex; mode=display">F^{\prime}[i]=\sum_{j\wedge i=i}F[j]</script><script type="math/tex; mode=display">(F\wedge G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>证明略。</p><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>定义</p><script type="math/tex; mode=display">F^{\prime}=\begin{cases}&(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\&F&(t=0)\end{cases}</script><p>然后我们发现按位异或并没有像上面一样的和子集相关的性质。因此我们需要通过一些其他方式来证明它的正确性。</p><p>首先</p><script type="math/tex; mode=display">(F+G)^{\prime}=F^{\prime}+G^{\prime}</script><p>如果$F$和$G$都只有一项，这十分显然。</p><p>否则</p><script type="math/tex; mode=display">\begin{aligned}F^{\prime}+G^{\prime}&=(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})+(G_{0}^{\prime}+G_{1}^{\prime},G_{0}^{\prime}-G_{1}^{\prime})\\&=(F_{0}^{\prime}+G_{0}^{\prime}+F_{1}^{\prime}+G_{1}^{\prime},F_{0}^{\prime}+G_{0}^{\prime}-F_{1}^{\prime}-G_{1}^{\prime})\\&=((F+G)_{0}^{\prime}+(F+G)_{1}^{\prime},(F+G)_{0}^{\prime}-(F+G)_{1}^{\prime})\\&=(F+G)^{\prime}\end{aligned}</script><script type="math/tex; mode=display">(F\oplus G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>这个不会证，告辞。</p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>就是把刚刚算出来的$F^{\prime}$变回$F$。</p><script type="math/tex; mode=display">F=\begin{cases}&F^{\prime}&(t=0)\\&\begin{cases}&(F_{0},F_{1}-F_{0})&(\vee)\\&(F_{0}-F_{1},F_{1})&(\wedge)\\&(\cfrac{F_{0}+F_{1}}{2},\cfrac{F_{0}-F_{1}}{2})\;\;\;\;\;\;\;\;&(\oplus)\end{cases}\;\;\;\;\;\;\;\;&(t\gt 0)\end{cases}</script><p><del>啥意思啊看不懂啊（</del></p><p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P4717" target="_blank" rel="noopener">板子题</a>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>],G[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWT(F,tp) &#123;\</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;n;p&lt;&lt;=<span class="number">1</span>)\</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)\</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;\</span><br><span class="line">                F[j+p][<span class="number">0</span>]=!tp?(F[j+p][<span class="number">0</span>]+F[j][<span class="number">0</span>])%mod:(F[j+p][<span class="number">0</span>]-F[j][<span class="number">0</span>]+mod)%mod;\</span><br><span class="line">                F[j][<span class="number">1</span>]=!tp?(F[j][<span class="number">1</span>]+F[j+p][<span class="number">1</span>])%mod:(F[j][<span class="number">1</span>]-F[j+p][<span class="number">1</span>]+mod)%mod;\</span><br><span class="line">                re <span class="keyword">int</span> x=F[j][<span class="number">2</span>],y=F[j+p][<span class="number">2</span>];\</span><br><span class="line">                F[j][<span class="number">2</span>]=(x+y)%mod;\</span><br><span class="line">                F[j+p][<span class="number">2</span>]=(x-y+mod)%mod;\</span><br><span class="line">                <span class="keyword">if</span>(tp)&#123;\</span><br><span class="line">                    F[j][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j][<span class="number">2</span>]%mod;\</span><br><span class="line">                    F[j+p][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j+p][<span class="number">2</span>]%mod;\</span><br><span class="line">                &#125;\</span><br><span class="line">            &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    n=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(F[i][<span class="number">0</span>]);</span><br><span class="line">        F[i][<span class="number">1</span>]=F[i][<span class="number">2</span>]=F[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(G[i][<span class="number">0</span>]);</span><br><span class="line">        G[i][<span class="number">1</span>]=G[i][<span class="number">2</span>]=G[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FWT(F,<span class="number">0</span>);</span><br><span class="line">    FWT(G,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            F[i][j]=<span class="number">1L</span>L*F[i][j]*G[i][j]%mod;</span><br><span class="line">    FWT(F,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            cltstream::write(F[i][j],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>我们知道FFT中的单位元多项式是$F(x)=1$，类似地，FWT是否也拥有这样的一个单位元呢？</p><p>当然是有的。</p><p>对于按位或和按位异或来说，它们的单位元是</p><script type="math/tex; mode=display">(1,0,\cdots,0,0)</script><p>对于按位与来说，它的单位元是</p><script type="math/tex; mode=display">(0,0,\cdots,0,1)</script><h3 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h3><p>既然有了单位元，我们就不禁会想……这东西能求逆吗？</p><p>大概……能吧。</p><p>以下所有运算在模$998244353$意义下进行。</p><h4 id="按位或-1"><a href="#按位或-1" class="headerlink" title="按位或"></a>按位或</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p><script type="math/tex; mode=display">F\vee G=(1,0,\cdots,0,0)</script><p>首先我们需要知道</p><script type="math/tex; mode=display">F\vee G=(F_{0}\vee G_{0},F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1})</script><p>注意到左半部分和右半部分的下标有一个重要区别就是从右往左第$t$位是否为$1$。</p><p>如果某个下标和右半部分的某个下标进行了按位或，它的第$t$位一定是$1$，那么它就跑到右半部分去了。</p><p>否则，即两个左半部分的下标进行了按位或，这种情况结果还是在左半部分。</p><p>然后我们就可以往下推了</p><script type="math/tex; mode=display">\begin{aligned}F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1}&=0\\(F_{0}+F_{1})\vee G_{1}&=-F_{1}\vee G_{0}\\G_{1}&=-F_{1}\vee G_{0}\vee (F_{0}+F_{1})^{-1}\end{aligned}</script><p>边界条件$G[0]=F[0]^{-1}$。</p><p>大致代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1[<span class="number">1</span>&lt;&lt;maxn],tmp2[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line">        Inv(F,G,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            tmp1[i]=F[i]+F[(n&gt;&gt;<span class="number">1</span>)+i];</span><br><span class="line">        Inv(tmp1,tmp2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            tmp2[i]=<span class="number">1L</span>L*F[(n&gt;&gt;<span class="number">1</span>)+i]*G[i]%mod*tmp2[i]%mod;</span><br><span class="line">        FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            G[(n&gt;&gt;<span class="number">1</span>)+i]=(mod-tmp2[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度非常显然是$O(n^{2}2^{n})$。</p><h4 id="按位与-1"><a href="#按位与-1" class="headerlink" title="按位与"></a>按位与</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p><script type="math/tex; mode=display">F\wedge G=(0,0,\cdots,0,1)</script><p>我们可以用类似的过程得到如下结论</p><script type="math/tex; mode=display">F\wedge G=(F_{0}\wedge G_{0}+F_{0}\wedge G_{1}+F_{1}\wedge G_{0},F_{1}\wedge G_{1})</script><script type="math/tex; mode=display">G_{0}=-F_{0}\wedge G_{1}\wedge (F_{0}+F_{1})^{-1}</script><h4 id="按位异或-1"><a href="#按位异或-1" class="headerlink" title="按位异或"></a>按位异或</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p><script type="math/tex; mode=display">F\oplus G=(1,0,\cdots,0,0)</script><p>首先我们有</p><script type="math/tex; mode=display">F\oplus G=(F_{0}\oplus G_{0}+F_{1}\oplus G_{1},F_{0}\oplus G_{1}+F_{1}\oplus G_{0})</script><p>也就是说</p><script type="math/tex; mode=display">F_{0}\oplus G_{0}+F_{1}\oplus G_{1}=\epsilon</script><script type="math/tex; mode=display">F_{0}\oplus G_{1}+F_{1}\oplus G_{0}=0</script><p>将上面两个式子相加、相减，得到</p><script type="math/tex; mode=display">(F_{0}+F_{1})\oplus(G_{0}+G_{1})=\epsilon</script><script type="math/tex; mode=display">(F_{0}-F_{1})\oplus(G_{0}-G_{1})=\epsilon</script><p>于是</p><script type="math/tex; mode=display">G_{0}=\cfrac{(F_{0}+F_{1})^{-1}+(F_{0}-F_{1})^{-1}}{2}</script><script type="math/tex; mode=display">G_{1}=\cfrac{(F_{0}+F_{1})^{-1}-(F_{0}-F_{1})^{-1}}{2}</script><p>时间复杂度$O(n2^{n})$。</p><p>这就没了？并不是。</p><p>如果您按照上面的式子写好程序，然后往里面输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>这样一组数据，您会发现您的程序给出的结果并不正确。</p><p>那么原因是什么呢？是我们式子推错了吗？</p><p>输出一下中间的运算过程，我们发现，在中间有一步，我们计算$(2,2)^{-1}$时，需要用到$(0)^{-1}$。</p><p>显然它不存在，但是同样显然的是，如果$(2,2)^{-1}$存在，那么这个过程不应该出现这样的问题。</p><p>所以说原因就是，$(2,2)^{-1}$，或者更进一步地，$(1,2,3,4)^{-1}$<strong>不存在</strong>。</p><h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a><a href="https://loj.ac/problem/152" target="_blank" rel="noopener">子集卷积</a></h3><p><del>让我来看看有没有点进去看完题面一脸懵逼地关闭标签页的。</del></p><p>这道题是让我们求这个东西</p><script type="math/tex; mode=display">h_{R}=\sum_{S\vee T=R,S\wedge T=\varnothing}f_{S}g_{T}</script><p>这比我们之前看到的卷积拥有更加严格的要求，$S\wedge T=\varnothing$，很明显，这是在提示我们抄题解。</p><p>我们定义</p><script type="math/tex; mode=display">F_{i,S}=\begin{cases}&f_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\&0&(|S|\neq i)\end{cases}</script><script type="math/tex; mode=display">G_{i,S}=\begin{cases}&g_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\&0&(|S|\neq i)\end{cases}</script><script type="math/tex; mode=display">H_{i,S}=\begin{cases}&h_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\&0&(|S|\neq i)\end{cases}</script><p>然后我们从小到大枚举$i$，计算</p><script type="math/tex; mode=display">H_{i}=\sum_{j=0}^{i}F_{j}\vee G_{i-j}</script><p>为了理解这个式子，我们先将其展开</p><script type="math/tex; mode=display">H_{i,R}=\sum_{j=0}^{i}\sum_{S\vee T=R}F_{j,S}G_{i-j,T}</script><p>根据定义，$F_{i,S}$和$G_{i,S}$有值当且仅当$|S|=i$，因此这就相当于</p><script type="math/tex; mode=display">H_{i,R}=\sum_{S\vee T=R,|S|+|T|=i}F_{|S|,S}G_{|T|,T}</script><p>因为$S$和$T$可能会有交集，从而$i\gt |R|$时$H_{i,R}$也可能有值，这是不符合定义的，因此（如果有必要的话）我们需要手动清空。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,N;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1</span>&lt;&lt;maxn],F[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],G[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],H[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;N;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)</span><br><span class="line">                F[j+p]=!tp?(F[j+p]+F[j])%mod:(F[j+p]-F[j]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    N=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::read(F[cnt[i]][i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::read(G[cnt[i]][i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        FWT(F[i],<span class="number">0</span>);</span><br><span class="line">        FWT(G[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">                H[i][S]=(H[i][S]+<span class="number">1L</span>L*F[j][S]*G[i-j][S]%mod)%mod;</span><br><span class="line">        FWT(H[i],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">            cnt[S]==i||(H[i][S]=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::write(H[cnt[i]][i],<span class="number">32</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/images/TIM图片20181011211750.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「SDOI2019R1游记」僕らは泥を這いつくばるもの</title>
      <link href="/sdoi2019r1-notes/"/>
      <url>/sdoi2019r1-notes/</url>
      
        <content type="html"><![CDATA[<p>被强大无比且随手吊打我的shzr催更了，于是诚惶诚恐赶来写这篇游记。</p><a id="more"></a><h3 id="Day-X"><a href="#Day-X" class="headerlink" title="Day -X"></a>Day -X</h3><p>经过讨论，我们机房研究出了以下两个堪称完美的战术，若能施加实际行动，定能令SLYZ省选大获全胜：</p><ol><li>让潮子分身，在每一位dalao（如rqy、ckw等）身边分别派一个，然后潮他们，他们就炸了。</li><li>让潮子在厕所蹲着，每看到有选手上厕所，等他上到一半跑到他背后，潮之曰「你稳了」，他就炸了。</li></ol><p><del>这都什么鬼东西（</del></p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>「省选快到了，我想回家休息休息。」</p><p>像这样理直气壮地请假回家颓废了。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><h4 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h4><p>12：30从学校坐车走，等到了济南已经是大概16：00了。</p><p>到了宾馆loli让我们自由组合。然后mhr学长主动邀请我住一个房间。</p><p>我直接就答应了。</p><h4 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h4><p>晚上出去吃饭的时候，潮子一直在潮。</p><p>就比如说钦定wzx的SAM没有了A，只剩下了一些奇怪的东西一道题都A不动了。</p><p>可惜绝大部分名言已经失传了。</p><p>这可真是糟糕，OI文学界的一大损失啊。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>就算没有解压密码也是可以看压缩包内部的文件有哪些的。</p><p>然后就看到了T3有16个样例有点方。</p><p>解压密码直接一坨乱码。龙虾选手表示解压体验(?)极差。</p><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5283" target="_blank" rel="noopener">T1</a></h4><p>诶怎么感觉有点像超级钢琴啊。</p><p>但是因为我超级钢琴只会ST表+堆，想了想发现这题不能这么做。</p><p>好吧，暴力60分先安排上。</p><p>出了考场发现人均A掉T1。</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5284" target="_blank" rel="noopener">T2</a></h4><p>字符串（</p><p>不难想到这么一个做法：对于这$n_{a}+n_{b}$个串每一个建一个点，如果$A$类串$x$支配$B$类串$y$，或者$B$类串$x$是$A$类串$y$的前缀，从$x$向$y$连边。最后整张图有环就是$-1$，没有D个P就出来了。</p><p>然后暴力建图。莫名其妙能有60分。</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5285" target="_blank" rel="noopener">T3</a></h4><p>写作传统题读作提交答案题。</p><p>考场上只想出来了<code>1_998244353</code>的12分。</p><p>然后出考场被各路dalao吊打。</p><p>关于测试点8-16，一开始我的想法是给出两个数$x,y$，有一个长度为$x$的区间从左向右扫过$[1,y]$这个区间。</p><p>但实际上是$[x,y]$这个区间内每个数的性质。想到这一点后面的一些数据范围比较小的点就没啥问题了。</p><p>但是数据范围比较大的点怎么办？</p><p>打一些比较小的表（</p><p>标程70KB了一下。</p><h4 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h4><p>首先是讲评。</p><p>没有抢到座位于是只能站着。</p><p>因为非常吵什么也听不清。</p><p>印象比较深的是讲到T3突然一阵掌声。</p><p>然后回到宾馆快乐地颓废。</p><h4 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h4><p>集体不想出去吃于是点了肯德基，然后……诶诶诶你们什么时候吃完的太快了吧（</p><h3 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5289" target="_blank" rel="noopener">T1</a></h4><p>看到题目名我还以为是网络流。</p><p>然后我就在想有没有网络流计数这种操作。</p><p>大概是没有吧。</p><p>打了个爆搜结果还炸了。</p><h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5290" target="_blank" rel="noopener">T2</a></h4><p>看上去好神仙啊。</p><p>考场上写了45分的状压枚举子集。</p><p>结果一出考场听说人均75，就我不会链的贪心和$O(n^{2})$的做法，自毙了。</p><h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5291" target="_blank" rel="noopener">T3</a></h4><p>想写一写$L=n$或$k=1$的情况。</p><p>到最后发现什么也不会，只想到了$L=n$<strong>且</strong>$k=1$的情况。喜提8分。</p><p>但是最后测出来好像是12分来着？没仔细看。</p><h4 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h4><p>因为有人要回去所以讲评提前了半小时。</p><p>虽然说抢到了一个座位可是今天比昨天还吵真的什么也听不见了。</p><p>T3标程887行了解一下（</p><p><img src="/images/TIM图片20190409113807.jpg" alt></p><p>结果接我们回东营的车咕了大概有一个多小时吧，最后得有20：30才到家。</p><h4 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h4><p>当然是回家……啊什么明天就正常上课啦？咕了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后60+60+12+0+45+12=189。</p><p>随便抓只猴子就比我考的高/kk</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SDOI </tag>
            
            <tag> 2019 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>伯努利数失败笔记</title>
      <link href="/bernoulli-number-learning-notes/"/>
      <url>/bernoulli-number-learning-notes/</url>
      
        <content type="html"><![CDATA[<blockquote><p>「クールでまばゆいばかりのアルゴリズムを学ばないでください、それはうまく検索することが最も重要です。」</p><p>——loli</p></blockquote><p><del>以上，我失败了（</del></p><p><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/guan-yu-bo-nu-li-shuo-zhuai-hua-zi-ran-shuo-mi-hu-gong-shi-di-zheng-mi" target="_blank" rel="noopener">前半部分的抄袭来源</a>。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>伯努利数$B_{n}$具有如下性质：</p><script type="math/tex; mode=display">\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><h3 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h3><p>我们定义</p><script type="math/tex; mode=display">S(n,k)=\sum_{i=0}^{n-1}i^{k}</script><script type="math/tex; mode=display">T(n,k)=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><p>我们希望证明$S(n,k)=T(n,k)$。</p><p>在这里，我们采用一种名为「强归纳法」（或者「完全归纳法」）的方法。具体来说，假设我们已经对于任意的$0\leqslant j\lt k$，证明了$S(n,j)=T(n,j)$成立，利用这个结论推出$S(n,k)=T(n,k)$成立。</p><p>当$k=0$时</p><script type="math/tex; mode=display">S(n,k)=n</script><script type="math/tex; mode=display">T(n,k)=C_{1}^{0}B_{0}n</script><p>因为我们有</p><script type="math/tex; mode=display">C_{1}^{0}B_{0}=[0=0]=1</script><p>从而$S(n,k)=T(n,k)$成立。</p><p>当$k\gt 0$时</p><script type="math/tex; mode=display">S(n,k+1)=\sum_{i=0}^{n-1}i^{k+1}</script><script type="math/tex; mode=display">\begin{aligned}S(n,k+1)+n^{k+1}&=\sum_{i=0}^{n-1}(i+1)^{k+1}\\&=\sum_{i=0}^{n-1}\sum_{j=0}^{k+1}C_{k+1}^{j}i^{j}\\&=\sum_{j=0}^{k+1}C_{k+1}^{j}\sum_{i=0}^{n-1}i^{j}\\&=\sum_{j=0}^{k+1}C_{k+1}^{j}S(n,j)\\&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)+C_{k+1}^{k+1}S(n,k+1)\end{aligned}</script><p>注意到$C_{k+1}^{k+1}=1$，我们就能得到</p><script type="math/tex; mode=display">n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)</script><p>因为我们已经对于任意的$0\leqslant j\lt k$，证明了$S(n,j)=T(n,j)$成立，我们就可以将上式进一步变形</p><script type="math/tex; mode=display">\begin{aligned}n^{k+1}&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)\\&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)\\&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)+C_{k+1}^{k}T(n,k)-C_{k+1}^{k}T(n,k)\\&=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)-C_{k+1}^{k}T(n,k)\end{aligned}</script><p>接下来，如果我们能够证明</p><script type="math/tex; mode=display">n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)</script><p>自然就能得出$S(n,k)=T(n,k)$。</p><p>愉快地推式子</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i}B_{i}n^{j-i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{j-i}B_{j-i}n^{i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i+1}B_{j-i}n^{i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}\cfrac{j+1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\sum_{i=0}^{j}\cfrac{1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{j}C_{j}^{i}B_{j-i}n^{i+1}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{i}C_{k-i+1}^{j-i}B_{j-i}n^{i+1}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\end{aligned}</script><p>上面的第二个等号是将后面的那个$\sum$倒过来（$i\rightarrow j-i$）求和。</p><p><del>返回本页面最上端之后，</del>我们回想起伯努利数还有个这么个性质</p><script type="math/tex; mode=display">\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}[i=k]\\&=\cfrac{1}{k+1}C_{k+1}^{k}n^{k+1}\\&=n^{k+1}\end{aligned}</script><script type="math/tex; mode=display">\text{QED}</script><h3 id="诶刚才我干了些什么来着"><a href="#诶刚才我干了些什么来着" class="headerlink" title="诶刚才我干了些什么来着"></a>诶刚才我干了些什么来着</h3><p>哦我好像是证明了这么一个东西</p><script type="math/tex; mode=display">\sum_{i=0}^{n-1}i^{k}=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><h3 id="如何求伯努利数"><a href="#如何求伯努利数" class="headerlink" title="如何求伯努利数"></a>如何求伯努利数</h3><p><del>根据题解，</del>我们知道伯努利数的生成函数是</p><script type="math/tex; mode=display">\cfrac{x}{e^{x}-1}=\cfrac{x}{\sum\limits_{i=1}^{+\infty}\cfrac{x^{i}}{i!}}=\cfrac{1}{\sum\limits_{i=0}^{+\infty}\cfrac{x^{i}}{(i+1)!}}</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「Luogu-P3711」仓鼠的数学题"><a href="#「Luogu-P3711」仓鼠的数学题" class="headerlink" title="「Luogu-P3711」仓鼠的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3711" target="_blank" rel="noopener">「Luogu-P3711」仓鼠的数学题</a></h4><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x-1}j^{i}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{j}B_{j}x^{i-j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{i-j}B_{i-j}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}\cfrac{(i+1)!}{(i-j)!(j+1)!}B_{i-j}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}i!a_{i}\sum_{j=0}^{i}\cfrac{1}{(j+1)!}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\end{aligned}</script><p>定义</p><script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n}(n-i)!a_{n-i}x^{i}</script><script type="math/tex; mode=display">B(x)=\sum_{i=0}^{n}\cfrac{B_{i}}{i!}x^{i}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{FB[n-j]}{(j+1)!}x^{j+1}\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 伯努利数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「AT987」高橋君</title>
      <link href="/at987-solution/"/>
      <url>/at987-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tenka1-2014-final.contest.atcoder.jp/tasks/tenka1_2014_final_d" target="_blank" rel="noopener">传送门</a></p><p><a href="https://www.luogu.org/problemnew/show/AT987" target="_blank" rel="noopener">Luogu</a></p><p>第一道AtCoder的题解。</p><p>联动一波<a href="https://www.cnblogs.com/asuldb/p/10623281.html" target="_blank" rel="noopener">asuldb</a>。</p><a id="more"></a><p>「啊这题怎么做啊。看起来好难啊。不会啊。」</p><p>「我们来蒙一个做法吧。比如说就莫队了！」</p><script type="math/tex; mode=display">\sum_{i=0}^{m+1}C_{n}^{i}=\sum_{i=0}^{m}C_{n}^{i}+C_{n}^{m+1}</script><script type="math/tex; mode=display">\sum_{i=0}^{m}C_{n+1}^{i}=\sum_{i=0}^{m}(C_{n}^{i}+C_{n}^{i-1})=\sum_{i=0}^{m}C_{n}^{i}+\sum_{i=0}^{m-1}C_{n}^{i-1}=2\sum_{i=0}^{m}C_{n}^{i}-C_{n}^{m}</script><p>这是左右端点向右移动的情况。向左移动就反过来。</p><p>就这样。</p><p>但是不知道为什么奇偶性排序会WA。</p><p>好短啊QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(a) (a/sq+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(n,m) (1LL*fac[n]*inv[m]%mod*inv[n-m]%mod)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,sq;</span><br><span class="line"><span class="keyword">int</span> fac[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">Query q[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re Query p1,re Query p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> id(p1.l)==id(p2.l)?p1.r&lt;p2.r:p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        fac[i]=<span class="number">1L</span>L*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=<span class="number">1L</span>L*inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    sq=maxn/<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        q[i].t=i;</span><br><span class="line">        cltstream::read(q[i].r);</span><br><span class="line">        cltstream::read(q[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">    re <span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;R&lt;q[i].r;res=(<span class="number">2</span>*res-C(R,L)+mod)%mod,++R);</span><br><span class="line">        <span class="keyword">for</span>(;R&gt;q[i].r;--R,res=inv[<span class="number">2</span>]*(res+C(R,L))%mod);</span><br><span class="line">        <span class="keyword">for</span>(;L&lt;q[i].l;++L,res=(res+C(R,L))%mod);</span><br><span class="line">        <span class="keyword">for</span>(;L&gt;q[i].l;res=(res-C(R,L)+mod)%mod,--L);</span><br><span class="line">        ans[q[i].t]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::write(ans[i],<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> 莫队 </tag>
            
            <tag> 玄学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>后缀数组自闭笔记</title>
      <link href="/suffix-array-learning-notes/"/>
      <url>/suffix-array-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>省选前最后两周。同时也是退役前最后两周。</p><p><del>在wzx的鼓动下</del>开了字符串。</p><p>然后自闭了。</p><a id="more"></a><p>以下，我们约定，$S_{l,r}$表示字符串$S$下标为$[l,r]$的子串，下标从$1$开始。超过串长的部分用小于其他所有字符的空字符填充。</p><h3 id="后缀排序"><a href="#后缀排序" class="headerlink" title="后缀排序"></a><a href="https://www.luogu.org/problemnew/show/P3809" target="_blank" rel="noopener">后缀排序</a></h3><p><del><code>std::sort</code>（光速逃</del></p><p>不过<code>std::sort</code>也是可以做的（</p><p>我们发现，这种做法的瓶颈在于比较两个后缀的大小。我们可以二分+Hash求出它们的最长公共前缀的长度，然后比较这个前缀后一个字符的大小。这么做的时间复杂度是$O(n\log^{2}n)$的。</p><p><del>但是没什么用（</del></p><p>然后我们就需要用到后缀数组（Suffix Array）了。</p><p>SA一共有四种构建方式，分别是$O(n\log n)$的倍增，$O(n)$的DC3和SA-IS，以及$O(1)$的潮爷排序。<del>但是后三种太高端了我都不会（</del></p><p>假设对于每一个位置$i$，我们已经按照$S_{i,i+k-1}$的大小排好了序，并且有了一个排名。我们以$i$的排名为第一关键字，$i+k$的排名为第二关键字，排一遍序，整个字符串就被按照$S_{i,i+2k-1}$的大小排好了序。当所有位置的排名都不同时，说明整个过程可以结束了。</p><p><del>但是问题来了，排一遍序不是$O(n\log n)$的吗（</del></p><p><del>我们有基数排序啊（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[i]：原字符串</span></span><br><span class="line"><span class="comment">// fst[i]：后缀i的第一关键字</span></span><br><span class="line"><span class="comment">// snd[i]：第二关键字排名为i的后缀</span></span><br><span class="line"><span class="comment">// tak[i]：桶</span></span><br><span class="line"><span class="comment">// sa[i]：排名为i的后缀</span></span><br><span class="line"><span class="comment">// 一开始时以首字符为第一关键字，位置为第二关键字排序</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    ++tak[fst[i]=s[i]];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">122</span>;++i)</span><br><span class="line">    tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 处理桶内前缀和，用来求出第一关键字为i的后缀的最大可能排名</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    sa[tak[fst[i]]--]=i;</span><br><span class="line">    <span class="comment">// 第一关键字相同时，第二关键字排名越大总排名越大，因此倒序枚举</span></span><br><span class="line">    <span class="comment">// 因为第二关键字是位置，所以snd[i]=i</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> mx=<span class="number">122</span>,k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    re <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        snd[++cnt]=i;</span><br><span class="line">        <span class="comment">// (n-k,n]的这些后缀没有第二关键字，因此排名最靠前</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(sa[i]&gt;k)</span><br><span class="line">            snd[++cnt]=sa[i]-k;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">        tak[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ++tak[fst[i]];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">        tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        sa[tak[fst[snd[i]]]--]=snd[i];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        snd[i]=fst[i];</span><br><span class="line">        <span class="comment">// 因为要生成下一轮排序时的第一关键字，把fst里的信息先扔到snd里</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        fst[sa[i]]=fst[sa[i<span class="number">-1</span>]]+(snd[sa[i]]!=snd[sa[i<span class="number">-1</span>]]||snd[sa[i]+k]!=snd[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">        <span class="comment">// 如果当前后缀与前一个后缀相同则共用排名，否则+1</span></span><br><span class="line">    <span class="keyword">if</span>(fst[sa[n]]==n)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mx=fst[sa[n]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去非常的绕（</p><p>最后直接输出<code>sa</code>数组即可。</p><h3 id="rnk数组"><a href="#rnk数组" class="headerlink" title="rnk数组"></a><code>rnk</code>数组</h3><p><code>rnk[i]</code>表示排名为$i$的后缀。</p><p>不难发现<code>rnk[sa[i]]=sa[rnk[i]]=i</code>。</p><h3 id="het数组"><a href="#het数组" class="headerlink" title="het数组"></a><code>het</code>数组</h3><p>大概算是SA的重点。</p><p>令<code>lcp(x,y)</code>表示$x,y$两个后缀的最长公共前缀（Longest Common Prefix）的长度。</p><p><code>het[i]</code>就被定义为<code>lcp(sa[i],sa[i-1])</code>。<code>het[1]=0</code>。</p><p>不难发现<code>lcp(x,z)=min(lcp(x,y),lcp(y,z))(x&lt;y&lt;z)</code>，<code>lcp(x,y)=min{lcp(i,i-1)}=min{het[i]}(rnk[x]&lt;i&lt;=rnk[y])</code>。</p><p><del>那么问题来了，怎么求呢（</del></p><p>首先我们是肯定不能暴力枚举的。</p><p>二分+Hash？太麻烦而且复杂度不够优秀（</p><p>SA的<code>het</code>数组有一个性质，就是<code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p><p>我们只考虑<code>het[rnk[i-1]]&gt;0</code>时的情况。</p><p>令<code>k=sa[rnk[i-1]-1]</code>，<code>lcp(i-1,k)=het[rnk[i-1]]</code>，又因为后缀$i$是后缀$i-1$删去首字符得到的，后缀$k+1$是后缀$k$删去首字符得到的，从而<code>lcp(i,k+1)=het[rnk[i-1]]-1</code>。</p><p>后缀$i-1$比后缀$k$大，删去首字符后，后缀$i$肯定也比后缀$k+1$大。根据<code>lcp</code>的性质我们有<code>lcp(i,sa[rnk[i]-1])&gt;=lcp(i,k+1)</code>，也即<code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p><p>利用这个性质，我们就可以在$O(n)$的时间复杂度内求出<code>het</code>数组了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(rnk[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        j-=!!j;</span><br><span class="line">        re <span class="keyword">int</span> pos=sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(;i+j&lt;=n&amp;&amp;pos+j&lt;=n&amp;&amp;s[i+j]==s[pos+j];++j);</span><br><span class="line">        het[rnk[i]]=j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后SA就彻底建好了。没错就这么点东西（</p><h3 id="板子应用"><a href="#板子应用" class="headerlink" title="板子应用"></a><del>板子</del>应用</h3><h4 id="不同子串个数"><a href="#不同子串个数" class="headerlink" title="不同子串个数"></a>不同子串个数</h4><p>给定一个长度为$n$的字符串$S$，求其本质不同的子串的数量。</p><p>首先有一个很显然的结论是，如果一个字符串是$S$的子串，那么它一定是$S$的若干个排名连续的后缀的公共前缀。</p><p>对于排名为$1$和排名为$2$的两个后缀来说，它们一共有<code>het[2]</code>个公共前缀；排名为$2$和排名为$3$的两个后缀一共有<code>het[3]</code>个公共前缀……</p><p>因此，$S$的不同子串个数就是它的所有子串个数，$\cfrac{n(n+1)}{2}$，减去所有<code>het</code>的和。</p><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给定$n$个字符串$S_{1},S_{2},\cdots,S_{n}$，求它们的最长公共子串。</p><p>我们首先将这$n$个串拼在一起，中间插入特殊字符将相邻的两个串隔开。然后我们将每个串内部的字符染色，第$1$个串染成颜色$1$，第$2$个串染成颜色$2$，用尺取法找出<code>sa[l],sa[l+1],...,sa[r]</code>覆盖全部$n$种颜色的区间$[l,r]$，求出其中<code>min{het[i]}(l&lt;i&lt;=r)</code>的最大值即可。</p><h4 id="模式串出现次数"><a href="#模式串出现次数" class="headerlink" title="模式串出现次数"></a>模式串出现次数</h4><p>给定$n$个文本串和$m$个模式串，询问每个模式串在$n$个文本串中一共出现了多少次。</p><p>首先将所有文本串拼在一起。对于每一个模式串，如果我们能够找到这个长串的任意一个后缀$x$，使得其拥有这个模式串作为前缀，然后找到一个最小的$l$和一个最大的$r$，使得<code>min{het[i]}(l&lt;i&lt;=rnk[x])</code>和<code>min{het[i]}(rnk[x]&lt;i&lt;=r)</code>均大于等于该模式串长度，$r-l+1$就是答案。不难看出向两边取$\min$这个操作具有单调性，因此我们可以二分。</p><p>但是问题来了，我们该怎么找到这个后缀啊。</p><p>一想，把模式串也接到文本串后就可以了。</p><p>那如果说模式串出现了互相包含的情况呢？</p><p>我们可以再开一个数组<code>col</code>，<code>col[i]</code>表示<code>sa[i]</code>的首字符是否属于一个文本串。因为这个是静态的，直接一遍前缀和就行。</p><h4 id="母串数量"><a href="#母串数量" class="headerlink" title="母串数量"></a>母串数量</h4><p>给定$n$个文本串和$m$个模式串，询问每个模式串在多少个文本串中出现过。也就是说，在同一个文本串中出现多次只记一次。</p><p>和上面一样，只不过是最后一步<code>col[i]</code>表示<code>sa[i]</code>的首字符所属的文本串的编号，对于每一个模式串，二分出区间后数一下颜色种类数。</p><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p>自己找去吧（</p><p>然后您就会发现字符串的题一道比一道神仙（</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> SA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Ynoi2014D2T2」人人本着正义之名</title>
      <link href="/luogu-p5066-solution-not/"/>
      <url>/luogu-p5066-solution-not/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5066" target="_blank" rel="noopener">传送门</a></p><p><del>一人血书放大常数Splay一条生路。</del></p><a id="more"></a><p>之前Ynoi2014唯一一道没公开的题。</p><p>写个$O(nm)$的暴力就有30了。</p><p>我们来分析一下操作$3,4,5,6$都在干些啥。</p><p>以操作$3$为例，如果在操作前，有一个位置的数字是$1$，它左边是一个$0$，操作完之后那个$0$就会变成$1$。除此之外不会再有其它改变。</p><p>仔细想象一下这个过程，我们发现这实际上是将操作区间内所有极长连续$1$的左端点向左扩展了$1$位，所有极长连续$0$的右端点向左收缩了$1$位。</p><p>操作$4,5,6$也是类似的。</p><p>那么我们写一棵珂朵莉树就可以获得50分了。</p><p>但实际上emmmmm……我的珂朵莉树可能和别人不一样（</p><p>别人的珂朵莉树：</p><p><img src="/images/TIM截图20190319161404.png" alt></p><p>我的珂朵莉树：</p><p><img src="/images/TIM截图20190319161900.png" alt></p><p>那么满分做法？</p><p>手写平衡树。没了。</p><p><del>虽然这么说，但是lxl都写了将近10KB（</del></p><p>总体思路就是，手写平衡树维护所有极长连续段的长度，并不需要维护端点因为可以算出来，单独维护还麻烦。每个节点维护子树内极长连续$0$和$1$的数量、长度最小值，以及连续段的长度变化量（标记）。修改时判断一下如果最小值变成了$0$，那么就暴力重构。<del>反正lxl说因为有前两个操作的存在这么做时间复杂度是对的。</del></p><p>首先有一个问题就是，这样做每个节点维护的必须要是<strong>极长连续段</strong>。想象一下，如果有两个相邻的节点值都是$1$，我们进行一次操作$3$或$4$，会发生什么？</p><p>两个节点的长度都加了$1$。然后整个序列莫名其妙多出来$1$个数。再然后您就WA了。</p><p>然后就是各种各样乱七八糟的细节。虽然这么说但好像没什么可列举的了。</p><p>然后您按照上面的思路打完四五百行的代码之后交上去一看：</p><p><img src="/images/TIM截图20190319171721.png" alt></p><p>虽然说暴力重构的时间复杂度<del>应该</del>是对的，但是不难发现它常数大啊。</p><p>但是如果不重构，合并相邻的连续段就会变得非常麻烦。</p><p>结论就是这题不可写，散了吧散了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> 毒瘤 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>来扯点多项式？</title>
      <link href="/polynomial-triangle-function/"/>
      <url>/polynomial-triangle-function/</url>
      
        <content type="html"><![CDATA[<p>在luogu上看到了多项式三角函数/反三角函数的板子。</p><p>不过还没加进公共题库，没人交，于是不敢交（</p><p>于是来口胡一波吧。</p><a id="more"></a><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>总之就是求$\sin F(x)$，$\cos F(x)$，其他的三角函数都可以用这两个凑出来因此不需要单独讨论。</p><p>虽然说我们也有$\cos x=\sin(x+\cfrac{\pi}{2})$，但是问题来了，模意义下怎么表示$\pi$（</p><p>首先我们有欧拉公式</p><script type="math/tex; mode=display">e^{ix}=\cos x+i\sin x</script><p>于是</p><script type="math/tex; mode=display">e^{iF}=\cos F+i\sin F</script><p>根据定义，$i^{2}\equiv -1\equiv 998244352\pmod{998244353}$。而$998244352$是模$998244353$的二次剩余，说人话就是这样的$i$是存在的。</p><p>但是问题来了，我们该怎么分离$\sin$和$\cos$？</p><p>我们还需要有</p><script type="math/tex; mode=display">e^{i(-F)}=\cos F-i\sin F</script><p>很明显地</p><script type="math/tex; mode=display">\sin F=\cfrac{e^{iF}-e^{i(-F)}}{2i}</script><script type="math/tex; mode=display">\cos F=\cfrac{e^{iF}+e^{i(-F)}}{2}</script><h3 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h3><p>求$\arcsin F(x)$，$\arccos F(x)$。</p><p>我们令答案的多项式为$G(x)$。</p><p>我们都知道</p><script type="math/tex; mode=display">\sin^{2}x+\cos^{2}x=1</script><p>于是知道了$\sin G$或者是$\cos G$，我们就可以推出另一项，然后再根据</p><script type="math/tex; mode=display">e^{iG}=\cos G+i\sin G</script><script type="math/tex; mode=display">G=\cfrac{\ln(\cos G+i\sin G)}{i}</script><p>就可以算出$G$了。</p><p>那么$\arctan F(x)$？</p><script type="math/tex; mode=display">\sin^{2}G+\cos^{2}G=1</script><p>因为$\tan G$有意义，所以$\cos G\neq0$。</p><script type="math/tex; mode=display">\tan^{2}G+1=\sec^{2}G</script><script type="math/tex; mode=display">\cos G=\cfrac{1}{\sqrt{\tan^{2}G+1}}</script><p>但是看着就麻烦（</p><blockquote><p>Updated on 2019-03-18</p><p>上面这种做法大概不是正解，因为这样需要对一个常数项不是$1$，最低次非零系数也不是$1$的多项式求平方根，很明显这需要二次剩余<del>，而且我不会</del>。</p><p>考虑倍增。</p><script type="math/tex; mode=display">\sin G_{0}-F\equiv 0\pmod{x^{t}}</script><script type="math/tex; mode=display">\sin G-F\equiv 0\pmod{x^{2t}}</script><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\sin G_{0}-F}{(\sin G_{0}-F)^{\prime}}\equiv G_{0}-\cfrac{\sin G_{0}-F}{\cos G_{0}}\pmod{x^{2t}}</script><p>然后是$\arccos$。</p><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\cos G_{0}-F}{(\cos G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\cos G_{0}-F}{\sin G_{0}}\pmod{x^{2t}}</script><p>然后是$\arctan$。不过我不怎么会求导$\tan$（</p><script type="math/tex; mode=display">\begin{aligned}(\tan x)^{\prime}&=(\cfrac{\sin x}{\cos x})^{\prime}\\&=\cfrac{(\sin x)^{\prime}}{\cos x}+\sin x(\cfrac{1}{\cos x})^{\prime}\\&=1+\tan^{2}x\end{aligned}</script><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\tan G_{0}-F}{(\tan G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\tan G_{0}-F}{1+\tan^{2} G_{0}}\pmod{x^{2t}}</script><p>这大概不能写（</p></blockquote><h3 id="多项式GCD-LCM"><a href="#多项式GCD-LCM" class="headerlink" title="多项式GCD/LCM"></a>多项式GCD/LCM</h3><p>既然多项式能够整除和取模，那么GCD和LCM一定也是可以算的吧！</p><p>……应该可以吧（</p>]]></content>
      
      
      <categories>
          
          <category> 瞎扯 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多项式 </tag>
            
            <tag> 三角函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>生成函数学习笔记</title>
      <link href="/generating-function-learning-notes/"/>
      <url>/generating-function-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>又被wzx吊打了QAQ</p><p>来写一篇生成函数吧QAQ</p><p><del>本文全部内容抄袭自<a href="https://www.cnblogs.com/asuldb/p/10533453.html" target="_blank" rel="noopener">这篇blog</a>和<a href="https://www.cnblogs.com/asuldb/p/10534860.html" target="_blank" rel="noopener">这篇blog</a></del></p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数列$\{a_{0},a_{1},\cdots,a_{n}\}$的生成函数$f(x)$被定义为</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^{n}a_{i}x^{i}</script><p>就这样（</p><h3 id="封闭表达式"><a href="#封闭表达式" class="headerlink" title="封闭表达式"></a>封闭表达式</h3><p>但是这个形式比较玄乎，不便于我们推式子。特别是当我们需要求一个无穷数列的生成函数时。于是我们希望能够进一步化简。</p><p>比如说，当$a_{n}=c^{n}$，即这个数列是$\{1,c,c^{2},\cdots\}$时，它的生成函数是</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^{n}c^{i}x^{i}=\cfrac{1-(cx)^{n+1}}{1-cx}</script><p>就是一个简单地等比数列求和。很明显，当$x\in(-1,1)$时，如果$n$趋向于正无穷大，则上式等于$\cfrac{1}{1-cx}$。</p><p>我们现在来分析一下斐波那契数列的生成函数。</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\end{aligned}</script><p>为了方便，我们定义当$n\lt 0$时，$F_{n}=0$。</p><p>然后我们发现$F_{1}=F_{0}+F_{-1}=0+0=0$，于是我们再加上一项$[i=1]$。</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2}+[i=1])x^{i}\\&=x+\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\\&=x+x\sum_{i=0}^{n}F_{i-1}x^{i-1}+x^{2}\sum_{i=0}^{n}F_{i-2}x^{i-2}\\&=x+xF(x)+x^{2}F(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">F(x)=\cfrac{x}{1-x-x^{2}}</script><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><p>那么问题来了，我们闲着没事求这个生成函数有什么用啊。</p><p>求通项公式。</p><p>我们知道形如$a_{n}=c^{n}$的数列的生成函数等于$\cfrac{1}{1-cx}$，我们可以试着将$\cfrac{x}{1-x-x^{2}}$分解成两个类似形式的分式的和。</p><p>设</p><script type="math/tex; mode=display">1-x-x^{2}=(1-ax)(1-bx)</script><script type="math/tex; mode=display">\begin{cases}&a+b=1\\&ab=-1\end{cases}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\begin{cases}&a=\cfrac{1+\sqrt{5}}{2}\\&b=\cfrac{1-\sqrt{5}}{2}\end{cases}</script><p>再设</p><script type="math/tex; mode=display">\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{x}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><script type="math/tex; mode=display">\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><p>于是</p><script type="math/tex; mode=display">c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx=x</script><p>等式右边没有常数项，因此$c+d$应当是$0$。再继续接下去，我们得到</p><script type="math/tex; mode=display">\begin{cases}&c=\cfrac{1}{\sqrt{5}}\\&d=-\cfrac{1}{\sqrt{5}}\end{cases}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1+\sqrt{5}}{2}x}-\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1-\sqrt{5}}{2}x}\\&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}x^{i}-\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}x^{i}\\&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}\right)x^{i}\end{aligned}</script><p>结论就是</p><script type="math/tex; mode=display">F_{n}=\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{n}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{n}\right)</script><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}C_{i}x^{i}\\&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}+[i=0]\right)x^{i}\\&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i}\\&=1+x\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i-1}\\&=1+xF^{2}(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">xF^{2}(x)-F(x)+1=0</script><script type="math/tex; mode=display">F(x)=\cfrac{1\pm\sqrt{1-4x}}{2x}</script><script type="math/tex; mode=display">2xF(x)=1\pm\sqrt{1-4x}</script><p>当$x=0$时</p><script type="math/tex; mode=display">2\times 0\times 1=1\pm1</script><p>因此根号前应该取负。至此我们得到</p><script type="math/tex; mode=display">F(x)=\cfrac{1-\sqrt{1-4x}}{2x}</script><p>那么通项公式呢？</p><p>根据<del>一个我抄过来的</del>广义二项式定理，我们有</p><script type="math/tex; mode=display">\begin{aligned}\sqrt{1-4x}&=1+\sum_{i=1}^{n}\cfrac{(-1)^{i-1}}{i2^{2i-1}}C_{2i-2}^{i-1}(-4x)^{i}\\&=1+2\sum_{i=1}^{n}\cfrac{(-1)^{2i-1}}{i}C_{2i-2}^{i-1}x^{i}\\&=1-2\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}F(x)&=\cfrac{1-\sqrt{1-4x}}{2x}\\&=\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i-1}\\&=\sum_{i=0}^{n}\cfrac{1}{i+1}C_{2i}^{i}x^{i}\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">C_{n}=\cfrac{1}{n+1}C_{2n}^{n}</script><h4 id="默慈金数"><a href="#默慈金数" class="headerlink" title="默慈金数"></a>默慈金数</h4><p><del>等会默慈金数是个什么鬼？（</del></p><p>默慈金数一般记为$M_{n}$，被定义为在均匀分布在一个圆上的$n$个有编号的点之间连出彼此不相交的弦的方案数。一根弦也不连也是一种方案。</p><script type="math/tex; mode=display">M_{0}=1</script><script type="math/tex; mode=display">M_{n}=M_{n-1}+\sum_{i=0}^{n-2}M_{i}M_{n-i-2}</script><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}M_{i}x^{i}\\&=\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}+[i=0]\right)x^{i}\\&=1+\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}\right)x^{i}\\&=1+xF(x)+x^{2}F^{2}(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">x^{2}F^{2}(x)+(x-1)F(x)+1=0</script><script type="math/tex; mode=display">F(x)=\cfrac{1-x\pm\sqrt{1-2x-3x^{2}}}{2x^{2}}</script><p>总之根号前应该取负（</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\cfrac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}\\&=\cfrac{2-2x-2\sqrt{1-2x-3x^{2}}}{4x^{2}}\\&=\cfrac{(1+x)-2\sqrt{(1+x)(1-3x)}+(1-3x)}{4x^{2}}\\&=\cfrac{(\sqrt{1+x}-\sqrt{1-3x})^{2}}{4x^{2}}\end{aligned}</script><p>woc这什么鬼东西溜了溜了。</p><p><del>留作课后习题，哪位dalao推出来了让我%一%（</del></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「TJOI2015」概率论"><a href="#「TJOI2015」概率论" class="headerlink" title="「TJOI2015」概率论"></a><a href="https://www.luogu.org/problemnew/show/P3978" target="_blank" rel="noopener">「TJOI2015」概率论</a></h4><p>首先很明显，互不同构的二叉树一共$C_{n}$棵，其中$C_{n}$是卡特兰数。现在我们希望求出这些二叉树的叶子结点总数，我们记为$F_{n}$。不难发现</p><script type="math/tex; mode=display">F_{0}=0</script><script type="math/tex; mode=display">F_{1}=1</script><script type="math/tex; mode=display">F_{n}=2\sum_{i=0}^{n-1}C_{i}F_{n-i-1}+[i=1]</script><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\&=\sum_{i=0}^{n}\left(2\sum_{j=0}^{i-1}C_{j}F_{i-j-1}+[i=1]\right)x^{i}\\&=x+2\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}F_{i-j-1}\right)x^{i}\\&=x+2xCF(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">F(x)=\cfrac{x}{1-2xC(x)}</script><p>其中$C(x)$是卡特兰数的生成函数，我们知道它的值是$\cfrac{1-\sqrt{1-4x}}{2x}$，所以说</p><script type="math/tex; mode=display">F(x)=\cfrac{x}{\sqrt{1-4x}}</script><p><del>然后我又不会了（</del></p><script type="math/tex; mode=display">(xC(x))^{\prime}=\cfrac{1}{\sqrt{1-4x}}=\cfrac{F(x)}{x}</script><script type="math/tex; mode=display">(xC(x))^{\prime}=\sum_{i=0}^{n}(i+1)C_{i}x^{i}</script><script type="math/tex; mode=display">\cfrac{F(x)}{x}=\sum_{i=0}^{n}F_{i}x^{i-1}=\sum_{i=-1}^{n}F_{i+1}x^{i}</script><p>我们就得到</p><script type="math/tex; mode=display">iC_{i-1}=F_{i}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\text{Ans}&=\cfrac{F_{n}}{C_{n}}\\&=\cfrac{nC_{n-1}}{C_{n}}\\&=\cfrac{C_{2n-2}^{n-1}}{\cfrac{1}{n+1}C_{2n}^{n}}\\&=\cfrac{\cfrac{(2n-2)!}{(n-1)!(n-1)!}}{\cfrac{(2n)!}{n!(n+1)!}}\\&=\cfrac{(2n-2)!n!(n+1)!}{(n-1)!(n-1)!(2n)!}\\&=\cfrac{n(n+1)}{2(2n-1)}\end{aligned}</script><h4 id="「国家集训队」整数的lqp拆分"><a href="#「国家集训队」整数的lqp拆分" class="headerlink" title="「国家集训队」整数的lqp拆分"></a><a href="https://www.luogu.org/problemnew/show/P4451" target="_blank" rel="noopener">「国家集训队」整数的lqp拆分</a></h4><p>其实这道题我几个月前推出来了一个$O(n^{2})$的式子（</p><p>如果记答案为$G_{n}$，我们有</p><script type="math/tex; mode=display">G_{n}=\sum_{i=0}^{n}F_{i}G_{n-i}</script><p>其中$F_{n}$是斐波那契数。为了方便，我们强行定义$G_{0}=1$。</p><script type="math/tex; mode=display">\begin{aligned}G(x)&=\sum_{i=0}^{n}G_{i}x^{i}\\&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}+[i=0]\right)x^{i}\\&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}\right)x^{i}\\&=1+FG(x)\end{aligned}</script><p>其中$F(x)$是斐波那契数的生成函数。于是</p><script type="math/tex; mode=display">G(x)=\cfrac{1}{1-F(x)}=\cfrac{1-x-x^{2}}{1-2x-x^{2}}=1+\cfrac{x}{1-2x-x^{2}}</script><p>多出来的那个$1$是$G_{0}$，可以无视掉。</p><p>设</p><script type="math/tex; mode=display">(1-ax)(1-bx)=1-2x-x^{2}</script><p>（中间过程略）</p><script type="math/tex; mode=display">\begin{cases}&a=1+\sqrt{2}\\&b=1-\sqrt{2}\end{cases}</script><p>再设</p><script type="math/tex; mode=display">\cfrac{c}{1-(1+\sqrt{2})x}+\cfrac{d}{1-(1-\sqrt{2})x}=\cfrac{x}{1-2x-x^{2}}</script><p>（中间过程略$\times 2$）</p><script type="math/tex; mode=display">\begin{cases}&c=\cfrac{1}{2\sqrt{2}}\\&d=-\cfrac{1}{2\sqrt{2}}\end{cases}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}G(x)&=1+\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1+\sqrt{2})x}-\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1-\sqrt{2})x}\\&=1+\sum_{i=0}^{n}\cfrac{1}{2\sqrt{2}}\left((1+\sqrt{2})^{i}-(1-\sqrt{2})^{i}\right)x^{i}\end{aligned}</script><p>最终结论就是</p><script type="math/tex; mode=display">G_{n}=\cfrac{(1+\sqrt{2})^{n}-(1-\sqrt{2})^{n}}{2\sqrt{2}}</script><p>根据暴力枚举，我们得出$\sqrt{2}\equiv 59713600\pmod{10^{9}+7}$。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生成函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P4705」Van♂游戏</title>
      <link href="/luogu-p4705-solution/"/>
      <url>/luogu-p4705-solution/</url>
      
        <content type="html"><![CDATA[<p>下个月就要省选了我还在颓怕不是要凉</p><p>然后再一翻wzx的blog发现他更新频率快到爆炸</p><p>大概这就是神吧</p><p>啊啊我好菜啊，不过还是来抄篇题解吧</p><p><a href="https://www.luogu.org/problemnew/show/P4705" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>令$\text{Ans}[t]$表示$t$次价值：</p><script type="math/tex; mode=display">\begin{aligned}\text{Ans}[t]&=\sum_{i=1}^{n}\sum_{j=1}^{m}(a_{i}+b_{j})^{t}\\&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=0}^{t}C_{t}^{k}a_{i}^{k}b_{j}^{t-k}\\&=t!\sum_{k=0}^{t}\cfrac{\sum a_{i}^{k}}{k!}\cfrac{\sum b_{j}^{t-k}}{(t-k)!}\end{aligned}</script><p>然后我们看到了$\sum a_{i}^{k}$这种东西，要算的话时间复杂度至少要是$O(nt)$的（</p><p>从这里往下是抄的题解。</p><p>定义</p><script type="math/tex; mode=display">F(x)=\prod_{i=1}^{n}(a_{i}x+1)</script><script type="math/tex; mode=display">\begin{aligned}G(x)&=\ln F(x)\\&=\ln\prod_{i=1}^{n}(a_{i}x+1)\\&=\sum_{i=1}^{n}\ln(a_{i}x+1)\end{aligned}</script><p>我们先来考虑如何求出$F$。定义$Q_{i}$为从$\{a_{n}\}$中选出$i$个数相乘，这样的所有方案结果的总和，且$Q_{0}=1$。我们有</p><script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n}Q_{i}x^{i}</script><p>然后分治。假设我们现在已经求出了$[l,mid]$上的$Q_{L,0},Q_{L,1},\cdots,Q_{L,mid-l+1}$和$(mid,r]$上的$Q_{R,0},Q_{R,1},\cdots,Q_{R,r-mid}$，不难发现</p><script type="math/tex; mode=display">Q_{i}=\sum_{j=0}^{i}Q_{L,j}Q_{R,i-j}</script><p>这部分的时间复杂度为$O(n\log^{2}n)$。</p><p>然后我们将$G$在$1$这个位置泰勒展开。先回忆一下<a href="/polynomial-learning-notes-pt2/">泰勒展开</a>的式子</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{+\infty}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><script type="math/tex; mode=display">\ln^{(n)}(x)=(-1)^{n-1}(n-1)!x^{-n}</script><script type="math/tex; mode=display">\begin{aligned}G(x)&=\sum_{i=1}^{n}\ln(a_{i}x+1)\\&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{\ln^{(j)}(1)}{j!}a_{i}^{j}x^{j}\\&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}(j-1)!1^{-j}}{j!}a_{i}^{j}x^{j}\\&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}a_{i}^{j}x^{j}\\&=\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}\left(\sum_{i=1}^{n}a_{i}^{j}\right)x^{j}\end{aligned}</script><p><img src="/images/TIM图片20190123161752.jpg" alt></p><p>令人窒息（</p><p>然后这道题就做出来了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">            tmp1[k]=F[k];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            tmp1[k]=<span class="number">0</span>;</span><br><span class="line">        NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            G[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">    G[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    Inv(F,tmp2,n);</span><br><span class="line">    NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">    NTT(G,N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(re <span class="keyword">int</span>* P,re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        re <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,N=<span class="number">1</span>;</span><br><span class="line">        calc(P,l,mid);</span><br><span class="line">        calc(P,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">for</span>(;N&lt;r-l+<span class="number">2</span>;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mid-l+<span class="number">1</span>;++i)</span><br><span class="line">            F[i]=P[l+i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=mid-l+<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">            F[i]=<span class="number">0</span>;</span><br><span class="line">        NTT(F,N,<span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-mid;++i)</span><br><span class="line">            G[i]=P[mid+i];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=r-mid+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">            G[i]=<span class="number">0</span>;</span><br><span class="line">        NTT(G,N,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">            F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">        NTT(F,N,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;++i)</span><br><span class="line">            P[l+i<span class="number">-1</span>]=F[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::read(A[i]);</span><br><span class="line">    B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        cltstream::read(B[i]);</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    calc(A,<span class="number">1</span>,n);</span><br><span class="line">    calc(B,<span class="number">1</span>,m);</span><br><span class="line">    Ln(A,F,t+<span class="number">1</span>);</span><br><span class="line">    Ln(B,G,t+<span class="number">1</span>);</span><br><span class="line">    F[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*j%mod;</span><br><span class="line">    G[<span class="number">0</span>]=m;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*j%mod;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=t+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        F[i]=G[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(F,N,<span class="number">0</span>);</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">    NTT(F,N,<span class="number">1</span>);</span><br><span class="line">    N=cltpow(<span class="number">1L</span>L*n*m%mod,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=N;i&lt;=t;++i,j=<span class="number">1L</span>L*j*i%mod)</span><br><span class="line">        cltstream::write(<span class="number">1L</span>L*F[i]*j%mod,<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「网络流学习笔记Part II」总之XJB写点啥（</title>
      <link href="/network-flow-learning-notes-pt2/"/>
      <url>/network-flow-learning-notes-pt2/</url>
      
        <content type="html"><![CDATA[<p>Part I大概是<a href="/something-about-network-flow-learning-notes/">这篇</a>。</p><p>去郑州的时候讲的网络流部分。</p><p>什么你说游记？咕咕咕。</p><a id="more"></a><h3 id="一种似乎没有名字的二元组模型"><a href="#一种似乎没有名字的二元组模型" class="headerlink" title="一种似乎没有名字的二元组模型"></a>一种似乎没有名字的二元组模型</h3><h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><p>你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个三元组<del>（虽然说不是标题说的二元组不过不要在意这些细节）</del>，每一个三元组形如$(x,y,c)$，意思是如果$x$和$y$两个任务在不同的机器上完成需要额外付出$c$的代价。你需要完成这$n$个任务，并最小化代价和。</p><p>我们都知道最小割=最大流。因此在一些题目中，如果无法将问题抽象成最大流问题，我们可以试着抽象成最小割问题。</p><p>对于任务$i$，连边$(S,i,a_{i}),(i,T,b_{i})$。对于一个三元组$(x,y,c)$，连边$(x,y,c),(y,x,c)$。</p><p>割断$(S,i,a_{i})$意味着任务$i$在第一台机器上完成，割断$(i,T,b_{i})$意味着任务$i$在第二台机器上完成。</p><p>首先很明显的是，同时割断$(S,i,a_{i})$和$(i,T,b_{i})$一定不是最优的决策。因此一个任务只会在一台机器上被完成。</p><p>对于一个三元组$(x,y,c)$，如果我们同时割断$(S,x,a_{x})$和$(S,y,a_{y})$，$S$与$T$直接就断开了，这样我们的代价是$a_{x}+a_{y}$。同时割断$(x,T,b_{x})$和$(y,T,b_{y})$也是类似的。</p><p>如果说我们同时割断$(S,x,a_{x})$和$(y,T,b_{y})$，图上仍存在$\{(S,y,a_{y}),(y,x,c),(x,T,b_{x})\}$这样一条路径，我们还需要割断$(y,x,c)$，这样我们的代价是$a_{x}+b_{y}+c$。同时割断$(x,T,b_{x})$和$(S,y,a_{y})$也是类似的。</p><h4 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h4><p>你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个六元组，每一个六元组形如$(x,y,c_{1},c_{2},c_{3},c_{4})$，意思是你需要为$x$和$y$这两个任务付出一些额外代价：</p><ul><li>如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{1}$。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{2}$。</li><li>如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{3}$。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{4}$。</li></ul><p>你需要完成这$n$个任务，并最小化代价和。</p><p>首先仍然是连边$(S,i,a_{i}),(i,T,b_{i})$。对于每一个六元组，连边$(S,x,A),(S,y,B),(x,T,C),(y,T,D),(x,y,E),(y,x,F)$。我们发现</p><ul><li>如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,x,A),(S,y,B)$，付出$A+B$的代价。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(x,T,C),(y,T,D)$，付出$C+D$的代价。</li><li>如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(S,x,A),(y,T,D),(y,x,F)$，付出$A+D+F$的代价。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,y,B),(x,T,C),(x,y,E)$，付出$B+C+E$的代价。</li></ul><p>因此我们列出如下的方程组</p><script type="math/tex; mode=display">\begin{cases}&A+B=c_{1}&(1)\\&C+D=c_{2}&(2)\\&A+D+F=c_{3}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;&(3)\\&B+C+E=c_{4}&(4)\end{cases}</script><p>因为我们要将问题转化成最大流问题，首先想到，我们要有$A,B,C,D,E,F\geqslant 0$。注意到，$(S,x,A)$和$(x,T,C)$中有且仅有一条边会出现在最小割集中，因此我们可以将$A$和$C$同时加上一个数，求出最小割后在答案中减去。$B$和$D$也可以类似处理。</p><p>需要注意的是，$E$和$F$不能被这样处理，因为我们不能确定它们在答案中产生了几次贡献。</p><p>$(3)+(4)-(1)-(2)$，我们得到</p><script type="math/tex; mode=display">E+F=c_{3}+c_{4}-c_{1}-c_{2}</script><p>定义$K=c_{3}+c_{4}-c_{1}-c_{2}$，当$K\geqslant 0$时它有意义，我们直接令$E=F=\cfrac{K}{2}$即可。</p><p>剩下的四个量随便给几个值，好算就行。</p><p>其实就算$K\lt 0$有时也是可以做的，但是我太菜了不会（</p><p>因为太菜了所以没有图（</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="「国家集训队」happiness"><a href="#「国家集训队」happiness" class="headerlink" title="「国家集训队」happiness"></a><a href="https://www.luogu.org/problemnew/show/P1646" target="_blank" rel="noopener">「国家集训队」happiness</a></h5><p>题目要求最大化总收益，我们可以先将所有数取相反数，然后最小化总代价。</p><p>令位置$i$选文的单独收益是$a_{i}$，选理的单独收益是$b_{i}$，连边$(S,i,-a_{i}),(i,T,-b_{i})$。</p><p>考虑一对相邻的位置，他们都选文的额外收益是$v_{1}$，都选理的额外收益是$v_{2}$，列出方程组</p><script type="math/tex; mode=display">\begin{cases}&A+B=-v_{1}\\&C+D=-v_{2}\\&A+D+E=0\\&B+C+E=0\end{cases}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\begin{cases}&A=-\cfrac{v_{1}}{2}\\&B=-\cfrac{v_{1}}{2}\\&C=-\cfrac{v_{2}}{2}\\&D=-\cfrac{v_{2}}{2}\\&E=\cfrac{v_{1}+v_{2}}{2}\end{cases}</script><p>为了避免浮点数，我们把上面所有边的容量乘以$2$，包括$(S,i,-a_{i}),(i,T,-b_{i})$，最后再除回来。</p><p>然后，为了避免负数，我们将$A,B,C,D$加上$v_{1}+v_{2}$，把边$(S,i,-2a_{i}),(i,T,-2b_{i})$的容量加上$2a_{i}+2b_{i}$，最后再减回来。</p><p>总结一下就是，对于一个位置$i$，连边$(S,i,2b_{i}),(i,T,2a_{i})$。对于一对相邻位置$x,y$，连边$(S,x,v_{2}),(S,y,v_{2}),(x,T,v_{1}),(y,T,v_{1}),(x,y,v_{1}+v_{2}),(y,x,v_{1}+v_{2})$。</p><script type="math/tex; mode=display">\text{Ans}=\sum(a_{i}+b_{i})+\sum(v_{1}+v_{2})-\cfrac{\text{MinCut}(S,T)}{2}</script><p>但是我的<a href="https://www.luogu.org/recordnew/show/16563258" target="_blank" rel="noopener">代码</a>不知道为什么写炸了（</p><p>反正这个式子应该是没问题的（</p><p>那么告辞吧（</p><h3 id="闭合子图"><a href="#闭合子图" class="headerlink" title="闭合子图"></a>闭合子图</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个有向图$G$，它的一个闭合子图指的是一个顶点集合$V$，满足$V\subset G$，且</p><script type="math/tex; mode=display">\forall u\in V\wedge(u,v)\in G,v\in V</script><p>其中$|V|$最大的$V$被称为$G$的最大闭合子图。</p><p>如果$G$中的点有点权，$\sum_{u\in V}w(u)$最大的$V$被称为$G$的最大权闭合子图。</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先，我们还是需要将所有点权取相反数，转为求最小权闭合子图。</p><p>对于$G$中的一个点$x$，割断与$S$之间的边表示$x\notin V$，割断与$T$之间的边表示$x\in V$。对于$G$中的一条边$(x,y)$，如果$x\in V$，那么一定有$y\in V$。我们可以认为，如果令$x\in V$，$y\notin V$，需要付出$+\infty$的代价。由此列出方程组</p><script type="math/tex; mode=display">\begin{cases}&A+B=0\\&C+D=-w(x)-w(y)\\&A+D+F=-w(x)\\&B+C+E=-w(y)+\infty\end{cases}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\begin{cases}&A=0\\&B=0\\&C=-w(x)\\&D=-w(y)\\&E=+\infty\\&F=0\end{cases}</script><p>于是，去掉所有容量为$0$的边，我们得到$(x,T,-w(x)),(y,T,-w(y)),(x,y,+\infty)$这三条边。如果$w(x)\geqslant 0$，我们需要把边$(S,x,0),(x,T,-w(x))$的容量都加上$w(x)$，相当于是把$(x,T,-w(x))$换成了$(S,x,w(x))$。</p><p>总结一下就是，对于原图中的一个正权点$x$，连边$(S,x,w(x))$，对于原图中的一个负权点$x$，连边$(x,T,-w(x))$。对于原图中的一条边$(x,y)$，连边$(x,y,+\infty)$。</p><script type="math/tex; mode=display">\text{Ans}=\sum_{w(x)\geqslant 0}w(x)-\text{MinCut}(S,T)</script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P3613」睡觉困难综合征</title>
      <link href="/luogu-p3613-solution/"/>
      <url>/luogu-p3613-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3613" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><h3 id="xjb扯"><a href="#xjb扯" class="headerlink" title="xjb扯"></a>xjb扯</h3><p>以前刚学树剖时看到这题感觉好神仙啊没法做啊。</p><p>然后现在学了LCT过来一看<del>，这不就一水题（</del></p><p>xjb写了棵LCT一交。</p><p><img src="/images/TIM截图20190215193107.png" alt></p><p>emmmmmm……</p><p>然后改的时候才发现全是细节错误，LCT的部分动都没动一下（</p><p>就比如说，下面是我第一次交的程序的主程序部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> opt,x,y;</span><br><span class="line">    cltstream::read(opt);</span><br><span class="line">    cltstream::read(x);</span><br><span class="line">    cltstream::read(y);</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="comment">//我都不知道我当时是怎么想的（</span></span><br><span class="line">        cltstream::read(z);</span><br><span class="line">        split(mempool+x,mempool+y);</span><br><span class="line">        re <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans0=(mempool+y)-&gt;ans0,ans1=(mempool+y)-&gt;ans1,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(((ans0&gt;&gt;j)&amp;<span class="number">1</span>)&gt;=((ans1&gt;&gt;j)&amp;<span class="number">1</span>)||z&lt;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">            <span class="comment">//甚至忘了用1ULL（</span></span><br><span class="line">                ans^=ans0&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                z-=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                ans^=ans1&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        cltstream::write(ans,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">        cltstream::read(z);</span><br><span class="line">        access(mempool+x);</span><br><span class="line">        (mempool+x)-&gt;tp=y;</span><br><span class="line">        (mempool+x)-&gt;val=z;</span><br><span class="line">        (mempool+y)-&gt;pushUp();</span><br><span class="line">        <span class="comment">//？？？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我Splay节点的内部信息甚至开成了<code>unsigned</code>，excuse me？？？</p><p><del>不这个东西这不是我写的（</del></p><h3 id="真正的题解"><a href="#真正的题解" class="headerlink" title="真正的题解"></a>真正的题解</h3><p>首先LCT。</p><p>不过首先的首先您还是要先做了<a href="https://www.luogu.org/problemnew/show/P2114" target="_blank" rel="noopener">这道题</a>。</p><p>每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。</p><p>我们记这两个值为<code>ans0</code>和<code>ans1</code>。</p><p>左子树和节点本身的信息很好维护。</p><p>而关于右子树，看上去我们没办法迅速求出把到现在为止的<code>ans0</code>和<code>ans1</code>扔进去跑一遍的结果。</p><p>但是注意到这些都是按位运算，位与位之间不互相影响。</p><p>我们可以对于<code>ans0</code>中是$1$的那些位，提取出<code>rc-&gt;ans1</code>的对应位，对于<code>ans0</code>中是$0$的那些位，提取出<code>rc-&gt;ans0</code>的对应位。</p><p>然后<code>ans1</code>也类似处理就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    SplayNode *ftr,*lc,*rc;</span><br><span class="line">    <span class="keyword">int</span> tp,rev;</span><br><span class="line">    <span class="keyword">unsigned</span> val,ans0,ans1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">apply</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tp==<span class="number">1</span>?(x&amp;val):tp==<span class="number">2</span>?(x|val):(x^val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ans0=<span class="number">0</span>,ans1=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans0=lc-&gt;ans0;</span><br><span class="line">            ans1=lc-&gt;ans1;</span><br><span class="line">        &#125;</span><br><span class="line">        ans0=apply(ans0),ans1=apply(ans1);</span><br><span class="line">        <span class="keyword">if</span>(rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans0=(ans0&amp;rc-&gt;ans1)|((~ans0)&amp;rc-&gt;ans0);</span><br><span class="line">            ans1=(ans1&amp;rc-&gt;ans1)|((~ans1)&amp;rc-&gt;ans0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是还有一个问题是，LCT在连边和提取路径时需要<code>makeRoot</code>，也就是说需要区间翻转。</p><p>但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。</p><p>那么提前维护好就行了。提前维护好<code>sna0</code>和<code>sna1</code>，表示把$0$和$-1$反过来跑一遍的结果。</p><p>然后就没了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「年轻人，你渴望力量吗？」</title>
      <link href="/min-25-sieve-learning-notes/"/>
      <url>/min-25-sieve-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>标题来自某学长安利min_25筛的方式（</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，<a href="/number-theory-learning-notes/">杜教筛</a>可以在$O(n^{\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。</p><p>但是现在我们希望更快。于是我们有了min_25筛（</p><p>以下，我们约定$p$是一个质数。$\mathbb{P}_{i}$表示第$i$小的质数，$\mathbb{P}_{0}=0$。$\text{minp}(n)$表示$n$最小的质因数，$\text{minp}(1)=0$。</p><p>现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：</p><ol><li>$f(p)$是一个<strong>可以快速求前缀和的完全积性函数</strong>，或者能用多个这样的函数运算得到。</li><li>$f(p^{k})$可以快速求，大概$O(k)$以内就可以。</li></ol><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>我们要对每一个$x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，求出</p><script type="math/tex; mode=display">\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>定义</p><script type="math/tex; mode=display">F(x,y)=\sum_{i=1}^{x}[i\in\mathbb{P}\vee\text{minp}(i)\gt\mathbb{P}_{y}]f^{\prime}(i)</script><p>也就是把所有质数和最小质因数大于$\mathbb{P}_y$的合数全部当成质数代入$f^{\prime}$求值并求和。不难发现</p><script type="math/tex; mode=display">F(x,+\infty)=\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>我们回忆一下埃式筛法的运行过程。</p><p>筛完$k$次后，我们除去了最小质因数小于等于$\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\mathbb{P}_k$的合数。</p><p>可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\prime}$的值的和。</p><p>首先，第$y$次筛掉的最小的数很明显是$\mathbb{P}_{y}^{2}$，如果$\mathbb{P}_{y}^{2}\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。</p><p>也因此，筛质数筛到$\sqrt{n}$即可。</p><p>否则，即$\mathbb{P}_{y}^{2}\leqslant x$，我们将所有数除以$\mathbb{P}_{y}$，之前所有最小质因数等于$\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\mathbb{P}_{y}$的数。</p><p>又因为$f^{\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\prime}(\cfrac{z}{\mathbb{P}_{y}})f^{\prime}(\mathbb{P}_{y})$计算$f^{\prime}(z)$。</p><p>那么看起来</p><script type="math/tex; mode=display">F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)</script><p>$F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)$包含了三类数的$f^{\prime}$的值：</p><ol><li>大于等于$\mathbb{P}_{y}$的质数。</li><li>最小质因数大于等于$\mathbb{P}_{y}$（大于$\mathbb{P}_{y-1}$）的合数。</li><li>小于$\mathbb{P}_{y}$的质数。</li></ol><p>但是很明显第三类数不能被除去，因此实际上</p><script type="math/tex; mode=display">F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)</script><p>综上所述</p><script type="math/tex; mode=display">F(x,y)=\begin{cases}&F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum\limits_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)\;\;&(\mathbb{P}_{y}^{2}\leqslant x)\\&F(x,y-1)&(\mathbb{P}_{y}^{2}\gt x)\end{cases}</script><p>初值为</p><script type="math/tex; mode=display">F(x,0)=\sum_{i=2}^{x}f^{\prime}(i)</script><p>注意到第二维只与$y-1$有关，我们可以滚掉。</p><p>还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。</p><p>因为$x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，这样的$x$最多只有$2\sqrt{n}$个，我们可以离散化存储。</p><p>具体实现细节我说不清，看代码吧（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cltstream::read(n);</span><br><span class="line">sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sq;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">        g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">        fsum[g[<span class="number">0</span>]]=fsum[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="comment">/**/</span>;</span><br><span class="line">        <span class="comment">//注释处应填f`(i)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=sq;++j)&#123;</span><br><span class="line">        f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    w[++m]=n/l;</span><br><span class="line">    <span class="comment">//编号对应的离散化前的值</span></span><br><span class="line">    F[m]=<span class="comment">/**/</span>;</span><br><span class="line">    <span class="comment">//注释处应填\sum_&#123;t=2&#125;^&#123;w[m]&#125;f`(t)</span></span><br><span class="line">    <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">        id1[w[m]]=m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        id2[n/w[m]]=m;</span><br><span class="line">    <span class="comment">//分段存储值对应的编号，这样数组只需要开到sqrt&#123;n&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=g[j]*g[j];++i)&#123;</span><br><span class="line">    <span class="comment">//w[i]&gt;=g[j]*g[j]，所以w[i]/g[j]&gt;=g[j]</span></span><br><span class="line">        re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">        F[i]-=<span class="comment">/**/</span>*(F[id]-fsum[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//注释处应填f`(g[j])</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这一部分的时间复杂度已被证明是$O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>然而看上去很奇怪（</del></p><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。</p><p>定义</p><script type="math/tex; mode=display">S(x,y)=\sum_{i=1}^{x}[\text{minp}(i)\geqslant\mathbb{P}_{y}]f(i)</script><p>也就是所有最小质因数大于等于$\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。</p><p>首先我们需要统计所有质数的贡献，也就是$F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})$。</p><p>关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。</p><script type="math/tex; mode=display">\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)</script><p>但是还有一个问题是$S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)$中不包括$f(1)$，因此$f(\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来</p><script type="math/tex; mode=display">\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>于是</p><script type="math/tex; mode=display">S(x,y)=F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})+\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>然后暴力搜，记忆化都不需要，时间复杂度还是$O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>就很神奇（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">int</span> res=F[id]-fsum[y<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=<span class="comment">/*1*/</span>*S(x/p,i+<span class="number">1</span>)+<span class="comment">/*2*/</span>;</span><br><span class="line">                <span class="comment">//1处应填f(p)，2处应填f(p*g[i])</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="「Luogu-P4213」「模板」杜教筛（Sum）"><a href="#「Luogu-P4213」「模板」杜教筛（Sum）" class="headerlink" title="「Luogu-P4213」「模板」杜教筛（Sum）"></a><a href="https://www.luogu.org/problemnew/show/P4213" target="_blank" rel="noopener">「Luogu-P4213」「模板」杜教筛（Sum）</a></h3><p>首先我们有</p><script type="math/tex; mode=display">\varphi(p)=\text{id}(p)-1</script><script type="math/tex; mode=display">\mu(p)=-1</script><p>然后$\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。</p><p>说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,sq,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],w[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],id1[maxn+<span class="number">1</span>],id2[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> prmcnt[maxn+<span class="number">1</span>],prmCnt[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prmsum[maxn+<span class="number">1</span>],prmSum[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getPhi</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> res=(prmSum[id]-prmCnt[id])-(prmsum[y<span class="number">-1</span>]-prmcnt[y<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];<span class="number">1L</span>L*p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=<span class="number">1L</span>L*p/g[i]*(g[i]<span class="number">-1</span>)*getPhi(x/p,i+<span class="number">1</span>)+<span class="number">1L</span>L*p*(g[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">int</span> res=prmcnt[y<span class="number">-1</span>]-prmCnt[id];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            res-=getMu(x/g[i],i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">            prmcnt[g[<span class="number">0</span>]]=prmcnt[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            prmsum[g[<span class="number">0</span>]]=prmsum[g[<span class="number">0</span>]<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">        cltstream::read(n);</span><br><span class="line">        sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">            w[++m]=n/l;</span><br><span class="line">            prmCnt[m]=w[m]<span class="number">-1</span>;</span><br><span class="line">            prmSum[m]=<span class="number">1L</span>L*(w[m]<span class="number">-1</span>)*(w[m]+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">                id1[w[m]]=m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                id2[n/w[m]]=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=<span class="number">1L</span>L*g[j]*g[j];++i)&#123;</span><br><span class="line">                re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">                prmCnt[i]-=prmCnt[id]-prmcnt[j<span class="number">-1</span>];</span><br><span class="line">                prmSum[i]-=<span class="number">1L</span>L*g[j]*(prmSum[id]-prmsum[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        cltstream::write(getPhi(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(getMu(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/TIM截图20190214152934.png" alt></p><p>上为min_25筛，下为杜教筛。</p><p>min_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说</p><h3 id="「LOJ6053」简单的函数"><a href="#「LOJ6053」简单的函数" class="headerlink" title="「LOJ6053」简单的函数"></a><a href="https://loj.ac/problem/6053" target="_blank" rel="noopener">「LOJ6053」简单的函数</a></h3><p>总结一下这个函数：</p><script type="math/tex; mode=display">f(1)=1</script><script type="math/tex; mode=display">f\left(\prod_{i=1}^{N}p_{i}^{r_{i}}\right)=\prod_{i=1}^{N}(p_{i}\otimes r_{i})</script><p>其中$\otimes$表示按位异或。</p><p><img src="/images/TIM图片20190103092627.png" alt></p><p>按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（</p><p>注意到</p><script type="math/tex; mode=display">f(p)=p\otimes 1=\begin{cases}&p+1\;\;&(p=2)\\&p-1\;\;&(p\gt 2)\end{cases}</script><p>我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。</p><p>然后还是要用min_25筛的前半部分筛出$\text{id}$和$1$，其实和上面的$\varphi$没多大区别就是加了点细节（</p><p><a href="https://loj.ac/submission/336101" target="_blank" rel="noopener">好像这种能随便看代码的OJ可以直接扔个提交记录</a>。</p><h3 id="「UOJ188」Sanrd"><a href="#「UOJ188」Sanrd" class="headerlink" title="「UOJ188」Sanrd"></a><a href="http://uoj.ac/problem/188" target="_blank" rel="noopener">「UOJ188」Sanrd</a></h3><p>次大质因数和。</p><p>其实这个题面有点考阅读的。</p><p>但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。<del>说好的只能筛积性函数呢（</del></p><p>我们来分析一下min_25筛的运行过程。</p><p>调用到$S(x,y)$时，剩下的最小质因数大于等于$\mathbb{P}_{y}$的数中，只有质数与$\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\mathbb{P}_{y-1}$的数。这部分可以直接算。</p><p>关于次大质因数大于$\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\mathbb{P}_{i}^{j})$，手动加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">long</span> <span class="keyword">long</span> n,re <span class="keyword">long</span> <span class="keyword">long</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> k=id[x&lt;=sq?x:n/x+sq];</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> res=(y&gt;<span class="number">1</span>?g[y<span class="number">-1</span>]:<span class="number">0</span>)*(prmCnt[k]-y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">long</span> <span class="keyword">long</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=S(n,x/p,i+<span class="number">1</span>)+g[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://uoj.ac/submission/324057" target="_blank" rel="noopener">提交记录</a>。</p><p><del>一道比一道神仙，像我这种菜鸡只能抄题解了（</del></p><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><ul><li><a href="https://loj.ac/problem/572" target="_blank" rel="noopener">「LOJ572」「LibreOJ Round #11」Misaka Network与求和</a></li><li><a href="https://www.spoj.com/problems/DIVCNTK/" target="_blank" rel="noopener">「SP34096」DIVCNTK - Counting Divisors (general)</a></li><li><a href="https://www.spoj.com/problems/GCDEX2/" target="_blank" rel="noopener">「SP19985」GCDEX2 - GCD Extreme (hard)</a></li><li><a href="https://www.spoj.com/problems/APS2/" target="_blank" rel="noopener">「SP19975」APS2 - Amazing Prime Sequence (hard)</a></li></ul><h3 id="其它文献"><a href="#其它文献" class="headerlink" title="其它文献"></a>其它文献</h3><ul><li><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096" target="_blank" rel="noopener">https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096</a></li><li><a href="https://www.cnblogs.com/zhoushuyu/p/9187319.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoushuyu/p/9187319.html</a></li><li><a href="https://www.cnblogs.com/cjyyb/p/10169190.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/10169190.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> min_25筛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>动态树学习笔记</title>
      <link href="/link-cut-tree-learning-notes/"/>
      <url>/link-cut-tree-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>24号要出去学习，趁现在先自己xjb学点啥。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先我们有一道<a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">模板题</a>。</p><p>我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。</p><p>这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\log^{2}n)$。</p><p>但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。</p><p>很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。</p><p>实链剖分一般被称为LCT，全称<del>Link-Cat Tree</del> <del>Linear Challestend Transformation</del> Link-Cut Tree，也就是动态树。</p><p>与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。</p><p>为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：</p><ol><li>每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。</li><li>每个节点属于且仅属于一棵Splay。</li><li>如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。</li><li>不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。</li></ol><p>以下图片来自<a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。" target="_blank" rel="noopener">https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。</a></p><p>我们来看这样一棵树</p><p><img src="/images/1309909-20180123095924037-1618037447.png" alt></p><p>其中粗线表示实边，虚线表示虚边。</p><p>它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。</p><p><img src="/images/1309909-20180123095955350-1680422636.png" alt></p><p>当然这并不是唯一的。</p><p>为了方便，我先放出我Splay的代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    SplayNode *ftr,*ls,*rs;</span><br><span class="line">    <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//判断一个节点是否是原森林中的一棵树的树根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">        rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                ls-&gt;reverse();</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                rs-&gt;reverse();</span><br><span class="line">            rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sum=val;</span><br><span class="line">        <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">            sum^=ls-&gt;sum;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">            sum^=rs-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    re SplayNode* q=p-&gt;ftr;</span><br><span class="line">    q-&gt;pushDown();</span><br><span class="line">    p-&gt;pushDown();</span><br><span class="line">    p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">            p-&gt;ftr-&gt;ls=p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">            p-&gt;ftr-&gt;rs=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">        q-&gt;rs=p-&gt;ls;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;rs-&gt;ftr=q;</span><br><span class="line">        p-&gt;ls=q;</span><br><span class="line">        q-&gt;ftr=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;ls=p-&gt;rs;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;ls-&gt;ftr=q;</span><br><span class="line">        p-&gt;rs=q;</span><br><span class="line">        q-&gt;ftr=p;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;pushUp();</span><br><span class="line">    p-&gt;pushUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line"><span class="comment">//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可</span></span><br><span class="line">    <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">            rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><p>首先我们有一个基本操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>首先有一个问题是，这个单词怎么读？</p><p><code>/ək&#39;ses/</code>？不不不应该是<code>/&#39;ækses/</code>。</p><p>如果您有兴趣，可以在<a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">这里</a>看看自己以前都读错了多少单词（</p><p>这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。</p><p>我们来看看这个函数的具体过程。还是上面的例子，现在我们调用<code>access(N)</code>，整棵树会变成这样</p><p><img src="/images/1309909-20180123101901740-2118178734.png" alt></p><p><del>虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（</del></p><p>首先我们调用<code>splay(N)</code>，令$\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。</p><p><img src="/images/1309909-20180123110136115-1112016464.png" alt></p><p>向上找到$\text{N}$的父亲$\text{I}$，调用<code>splay(I)</code>，回收$\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\text{N}$，然后$\text{N}$就成了$\text{I}$的实儿子了。</p><p><img src="/images/1309909-20180123110156272-1242463729.png" alt></p><p>然后继续向上，找到$\text{I}$的父亲$\text{H}$，调用<code>splay(H)</code>，并令$\text{H}$的右儿子指针指向$\text{I}$。</p><p><img src="/images/1309909-20180123110209772-2057141058.png" alt></p><p>最后一步，找到$\text{H}$的父亲$\text{A}$，调用<code>splay(A)</code>，并令$\text{A}$的右儿子指针指向$\text{H}$。</p><p><img src="/images/1309909-20180123110213709-49169640.png" alt></p><p>然后我们看到，$\text{N}$和$\text{A}$到了同一颗Splay中，完成任务，返回。</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    splay(p);</span><br><span class="line">    p-&gt;pushDown();</span><br><span class="line">    p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;pushUp();</span><br><span class="line">    <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">        splay(q-&gt;ftr);</span><br><span class="line">        q-&gt;ftr-&gt;pushDown();</span><br><span class="line">        q-&gt;ftr-&gt;rs=q;</span><br><span class="line">        q-&gt;ftr-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p);</span><br><span class="line">    <span class="comment">//据说闲着没事瞎转转有利于摊开时间复杂度（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="findRoot"><a href="#findRoot" class="headerlink" title="findRoot"></a>findRoot</h3><p>有了<code>access</code>，我们就可以随心所欲的瞎搞了。比如说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SplayNode* <span class="title">findRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>返回给定节点所在的树的树根，也就是调用完<code>access</code>后它所在的实链上深度最小的节点。</p><p>因为<code>access</code>的最后自带了一个<code>splay</code>，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">    splay(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="makeRoot-amp-amp-split"><a href="#makeRoot-amp-amp-split" class="headerlink" title="makeRoot &amp;&amp; split"></a>makeRoot &amp;&amp; split</h3><p>现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。</p><p>不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用<code>access(x)</code>，然后考虑翻转$x$的子树之后会发生什么。</p><p><code>access</code>结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。</p><p>那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次<code>access(y)</code>就可以把它抽出来。</p><p>我们实现下面两个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>令给定节点成为树根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    p-&gt;reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    access(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p>我们需要实现函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。</p><p>思路很简单。假设我们指定$x$和$y$两个节点，首先调用<code>makeRoot(x)</code>，然后检查<code>findRoot(y)</code>的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即<code>findRoot(y)==x</code>，说明两个节点联通，直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">        p-&gt;ftr=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>我们需要实现函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>切断给定的两个节点之间的边。不存在就什么也不做。</p><p>需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用<code>makeRoot(x)</code>，此时$y$应该是$x$的右儿子，并且它不能有左儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。</p><p>完整板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">        _tp z=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">        SplayNode *ftr,*ls,*rs;</span><br><span class="line">        <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">            rev^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                    ls-&gt;reverse();</span><br><span class="line">                <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                    rs-&gt;reverse();</span><br><span class="line">                rev=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            sum=val;</span><br><span class="line">            <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                sum^=ls-&gt;sum;</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                sum^=rs-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        re SplayNode* q=p-&gt;ftr;</span><br><span class="line">        q-&gt;pushDown();</span><br><span class="line">        p-&gt;pushDown();</span><br><span class="line">        p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">                p-&gt;ftr-&gt;ls=p;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">                p-&gt;ftr-&gt;rs=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">            q-&gt;rs=p-&gt;ls;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">                q-&gt;rs-&gt;ftr=q;</span><br><span class="line">            p-&gt;ls=q;</span><br><span class="line">            q-&gt;ftr=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;ls=p-&gt;rs;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">                q-&gt;ls-&gt;ftr=q;</span><br><span class="line">            p-&gt;rs=q;</span><br><span class="line">            q-&gt;ftr=p;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;pushUp();</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">                rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            re SplayNode* p=mempool+i;</span><br><span class="line">            p-&gt;ftr=p-&gt;ls=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">            cltstream::read(p-&gt;val);</span><br><span class="line">            p-&gt;sum=p-&gt;val;</span><br><span class="line">            p-&gt;rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        splay(p);</span><br><span class="line">        p-&gt;pushDown();</span><br><span class="line">        p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">        <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">            splay(q-&gt;ftr);</span><br><span class="line">            q-&gt;ftr-&gt;pushDown();</span><br><span class="line">            q-&gt;ftr-&gt;rs=q;</span><br><span class="line">            q-&gt;ftr-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        access(p);</span><br><span class="line">        <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">        splay(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        access(p);</span><br><span class="line">        p-&gt;reverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        access(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">            p-&gt;ftr=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryPathXorSum</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        split(mempool+x,mempool+y);</span><br><span class="line">        <span class="keyword">return</span> (mempool+y)-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">createEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        link(mempool+x,mempool+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destoryEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        cut(mempool+x,mempool+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyVertice</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        splay(mempool+x);</span><br><span class="line">        (mempool+x)-&gt;val=y;</span><br><span class="line">        (mempool+x)-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;pushDown();</span><br><span class="line">            printTree(p-&gt;ls);</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"%d(%d,%d,%d)\n"</span>,</span><br><span class="line">                p-mempool,</span><br><span class="line">                p-&gt;ftr!=<span class="literal">NULL</span>?p-&gt;ftr-mempool:<span class="number">-1</span>,</span><br><span class="line">                p-&gt;ls!=<span class="literal">NULL</span>?p-&gt;ls-mempool:<span class="number">-1</span>,</span><br><span class="line">                p-&gt;rs!=<span class="literal">NULL</span>?p-&gt;rs-mempool:<span class="number">-1</span></span><br><span class="line">            );</span><br><span class="line">            printTree(p-&gt;rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LinkCutTree QAQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;\</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    QAQ.build(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x,y;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        cltstream::read(y);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cltstream::write(QAQ.queryPathXorSum(x,y),<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                QAQ.createEdge(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                QAQ.destoryEdge(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                QAQ.modifyVertice(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>是不是感觉很好写呢（</del></p><h3 id="用LCT维护子树信息"><a href="#用LCT维护子树信息" class="headerlink" title="用LCT维护子树信息"></a>用LCT维护子树信息</h3><p>咕咕咕。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
            <tag> Splay </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2019-01-20：loli的两场模拟赛的题解</title>
      <link href="/lolioi-2019-01-20-solutions/"/>
      <url>/lolioi-2019-01-20-solutions/</url>
      
        <content type="html"><![CDATA[<p>今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。</p><p>上午记为D1，下午记为D2。</p><a id="more"></a><h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><h4 id="T1-简-simple"><a href="#T1-简-simple" class="headerlink" title="T1 简 - simple"></a>T1 简 - simple</h4><p>给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。</p><p>$n\leqslant 100000$。</p><p>不予置评。</p><h4 id="T2-单-single"><a href="#T2-单-single" class="headerlink" title="T2 单 - single"></a>T2 单 - single</h4><p>给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义</p><script type="math/tex; mode=display">b_{u}=\sum_{i=1}^{n}dist(u,i)a_{i}</script><p>还会给你一个$\text{tp}$，$\text{tp}=0$时给你$\{a_{n}\}$让你求$\{b_{n}\}$，$\text{tp}=1$时给你$\{b_{n}\}$让你求$\{a_{n}\}$。多组数据。</p><p>$n\leqslant 100000,T\leqslant 5$。</p><p>$\text{tp}=0$时就是一个简单的树形DP。</p><p>$\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（</p><p>他给的题解我也没看懂（</p><p>我就打了$\text{tp}=0$的$30$分。</p><h4 id="T3-题-problem"><a href="#T3-题-problem" class="headerlink" title="T3 题 - problem"></a>T3 题 - problem</h4><p>有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。</p><p>关于$S$，首先会给你一个$\text{tp}$，然后$S$如下定义</p><script type="math/tex; mode=display">S=\begin{cases}&\{(x,y)\mid x,y\in\mathbb{Z}\}\;\;&(\text{tp}=0)\\&\{(x,y)\mid x\in\mathbb{N},y=0\}&(\text{tp}=1)\\&\{(x,y)\mid xy=0\}&(\text{tp}=2)\\&\{(x,y)\mid x,y\in\mathbb{N}\}&(\text{tp}=3)\end{cases}</script><p>$n\leqslant 100000$，$n\equiv 0\pmod{2}$，$\text{tp}\in\{0,1,2,3\}$。特殊地，当$\text{tp}=2$时$n\leqslant 1000$。</p><p>四合一数论提答（</p><p>很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。</p><p>$\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。<br>我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此</p><script type="math/tex; mode=display">\text{Ans}=(2n)!\sum_{i=0}^{n}\cfrac{1}{i!i!(n-i)!(n-i)!}</script><p>$\text{tp}=1$直接卡特兰数。</p><p>$\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。</p><p>如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP</p><script type="math/tex; mode=display">f[x]=\sum_{i=1}^{x}f[x-i]\cfrac{(2i)!}{i!i!}</script><p>其实如果改一下模数的话这个东西可以用NTT优化到$O(n\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（</p><p>$\text{tp}=3$大概是$\text{tp}=0$与$\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是</p><script type="math/tex; mode=display">\begin{aligned}\text{Ans}&=\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\&=\sum_{i=0}^{n}\cfrac{(2n)!}{(2i)!(2(n-i))!}\left(\cfrac{(2i)!}{i!i!}-\cfrac{(2i)!}{(i+1)!(i-1)!}\right)\left(\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\right)\\&=(2n)!\sum_{i=0}^{n}\left(\cfrac{1}{i!i!}-\cfrac{1}{(i+1)!(i-1)!}\right)\left(\cfrac{1}{(n-i)!(n-i)!}-\cfrac{1}{(n-i+1)!(n-i-1)!}\right)\end{aligned}</script><p>于是愉快地$230$直接rank1（</p><p>话说wzx打了$240$分的啊……然而炸成$210$（</p><h3 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h3><h4 id="T1-印章-seal"><a href="#T1-印章-seal" class="headerlink" title="T1 印章 - seal"></a>T1 印章 - seal</h4><p>给你一张$n\times m$的纸，上面有些格子要印墨水。你有一个$r\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。</p><p>$n,m,r,c\leqslant 1000,T\leqslant 10$。</p><p>首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个<code>bitset</code>瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（</p><p>拿了$60$就跑（</p><h4 id="T2-多边形-polygon"><a href="#T2-多边形-polygon" class="headerlink" title="T2 多边形 - polygon"></a>T2 多边形 - polygon</h4><p>一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。</p><p>这是一个$0-4$边形</p><p><img src="/images/图片1.png" alt></p><p>这是一个$1-4$边形</p><p><img src="/images/图片2.png" alt></p><p>这是一个$2-4$边形</p><p><img src="/images/图片3.png" alt></p><p>给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。</p><p>$0\leqslant k\leqslant 10^{6},3\leqslant n\leqslant 10^{9}$。</p><p><img src="/images/TIM图片20181023195537.jpg" alt></p><p>告辞（</p><p>彻底放弃治疗（</p><h4 id="T3-扔球-ball"><a href="#T3-扔球-ball" class="headerlink" title="T3 扔球 - ball"></a>T3 扔球 - ball</h4><p>给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。</p><p>所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\{a_{n}\}$的期望逆序对数量。四舍五入保留两位小数。</p><p>如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。</p><p>$n\leqslant 500000,0.4\leqslant p\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\Sigma|S_{i}|\leqslant 500000$。</p><p>从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。</p><p>套个树状数组就行。</p><p>但是等会，$a_{x}=y$的概率怎么算啊。</p><p>首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是</p><script type="math/tex; mode=display">\begin{aligned}\lim_{n\rightarrow+\infty}\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\&=\cfrac{p}{1-(1-p)^{|S_{x}|}}\end{aligned}</script><p>那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为</p><script type="math/tex; mode=display">\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}</script><p>最后总分只有$160$，被$190$分的wzx吊着打（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> loli </tag>
            
            <tag> 模拟赛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HEOI2016/TJOI2016」求和</title>
      <link href="/luogu-p4091-solution/"/>
      <url>/luogu-p4091-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4091" target="_blank" rel="noopener">传送门</a></p><p>感觉最近意志消沉啥也不想干，于是继续来颓blog（</p><a id="more"></a><p>仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（</p><p>首先我们知道如果$n\gt m$，$S(n,m)=0$。于是我们将原式写成</p><script type="math/tex; mode=display">\sum_{i=0}^{n}\sum_{j=0}^{n}2^{j}j!S(i,j)=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)</script><p>第二类斯特林数有一个通项公式，它长这样</p><script type="math/tex; mode=display">S(n,m)=\cfrac{1}{m!}\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现</p><script type="math/tex; mode=display">F(n,m,k)=C(m,k)(m-k)^{n}</script><p>然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现</p><script type="math/tex; mode=display">G(n,m)=\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。</p><p>然后我们继续推式子</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\&=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}\end{aligned}</script><p>我们看到右边就是一个等比数列求和，于是</p><script type="math/tex; mode=display">\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}</script><p>定义</p><script type="math/tex; mode=display">F[i]=\cfrac{(-1)^{i}}{i!}</script><p>右边的等比数列求和比较麻烦，我们需要一些特判。</p><script type="math/tex; mode=display">G[i]=\begin{cases}&1&(i=0)\\&n+1&(i=1)\\&\cfrac{i^{n+1}-1}{i!(i-1)}\;\;&(i>1)\end{cases}</script><p>然后我们就有</p><script type="math/tex; mode=display">\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\sum_{j=0}^{n}2^{j}j!(F\times G)[j]</script><p>这么一想前几天的我还只会暴力二项式定理展开（</p><p><img src="/images/TIM图片20181209192946.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEOI </tag>
            
            <tag> NTT </tag>
            
            <tag> TJOI </tag>
            
            <tag> 2016 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>有上下界的网络流问题与预留推进学习笔记</title>
      <link href="/something-about-network-flow-learning-notes/"/>
      <url>/something-about-network-flow-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>感觉最近好颓啊（</p><p>这是一篇正在咕咕咕的blog。<br><a id="more"></a></p><h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a><a href="https://loj.ac/problem/115" target="_blank" rel="noopener">无源汇有上下界可行流</a></h3><p>我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\text{upper}(e)-\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令</p><script type="math/tex; mode=display">w(u)=\sum_{v\in V,(v,u)\in E}\text{lower}((v,u))-\sum_{v\in V,(u,v)\in E}\text{lower}((u,v))</script><ul><li>如果$w(u)=0$，说明我们不需要对点$u$做出调整。</li><li>如果$w(u)\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。</li><li>如果$w(u)\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。</li></ul><p>然后直接跑一边从源点到汇点的最大流即可。</p><p>需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。</p><p>否则，我们就已经构造出了一组可行解。</p><h3 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a><a href="https://loj.ac/problem/116" target="_blank" rel="noopener">有源汇有上下界最大流</a></h3><p>这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。</p><p>我们可以从汇点到源点连一条流量上界为$+\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。</p><p>需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。</p><p>当然，求解可行流时无解的话，整个问题无解。</p><h3 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a><a href="https://loj.ac/problem/117" target="_blank" rel="noopener">有源汇有上下界最小流</a></h3><p>还没看懂，先咕着。</p><h3 id="最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）"><a href="#最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）" class="headerlink" title="最高标号预流推进（HLPP-Highest Label Preflow Pushing？）"></a><a href="https://loj.ac/problem/127" target="_blank" rel="noopener">最高标号预流推进（HLPP-Highest Label Preflow Pushing？）</a></h3><p>还没看懂，先咕着。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 最大流 </tag>
            
            <tag> 预留推进 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类欧几里得算法学习笔记</title>
      <link href="/similar-euclid-algorithm-learning-notes/"/>
      <url>/similar-euclid-algorithm-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>其实我也不知道这个算法的英文名是啥（</p><p>我就yy出来一个「Similar Euclid Algorithm」（</p><a id="more"></a><p>给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出</p><script type="math/tex; mode=display">\sum_{i=0}^{n}i^{k_{1}}\lfloor\cfrac{ai+b}{c}\rfloor^{k_{2}}\pmod{1000000007}</script><p>$n,a,b,c\leqslant 10^{9}$，$k_{1}+k_{2}\leqslant 10$。</p><p><img src="https://i.loli.net/2019/01/10/5c36dbda14c92.jpg" alt></p><p>太难了，告辞（</p><p>所以我们现在来研究简单一点的。</p><p>给你四个非负整数$n,a,b,c$，你需要求出</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\g(n,a,b,c)&\equiv\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\h(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\pmod{998244353}\end{aligned}</script><p>$n,a,b,c\leqslant 10^{9}$，$10^{5}$组询问。</p><p><a href="https://www.luogu.org/problemnew/show/P5170" target="_blank" rel="noopener">传送门</a></p><p>于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。</p><p>首先考虑$f(n,a,b,c)$，假设$a\geqslant c\vee b\geqslant c$</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)\\&=\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\\&=f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\end{aligned}</script><p>也就是说，我们只需要重点关注$a\lt c\wedge b\lt c$时的情况即可。我们令$m=\lfloor\cfrac{an+b}{c}\rfloor$，然后继续往下推</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\sum_{j=1}^{m}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\leqslant ai+b\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\geqslant cj+c-b\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\geqslant\cfrac{cj+c-b}{a}\right]\\\end{aligned}</script><p>然后我们发现，我们可能需要在$\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。</p><p>考虑转换一下思路。既然$cj+c\leqslant ai+b$，我们就有$cj+c\lt ai+b+1$，然后再往下</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\lt ai+b+1\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\gt cj+c-b-1\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]\\&=\sum_{j=0}^{m-1}\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\&=mn-\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\&=mn-f(m-1,c,c-b-1,a)\end{aligned}</script><p>然后我们看到，这个函数它递归了！</p><p>注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\log a$次，时间复杂度就是$O(\log a)$了。</p><p>然后考虑$g(n,a,b,c)$。</p><p>$a\geqslant c\vee b\geqslant c$：</p><script type="math/tex; mode=display">\begin{aligned}g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\left(i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i^{2}\lfloor\cfrac{a}{c}\rfloor+i\lfloor\cfrac{b}{c}\rfloor\right)\\&=\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\\&=g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\end{aligned}</script><p>$a\lt c\wedge b\lt c$，当然$m$还是$\lfloor\cfrac{an+b}{c}\rfloor$：</p><script type="math/tex; mode=display">\begin{aligned}g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\sum_{j=1}^{m}i\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}i\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]\end{aligned}</script><p>我们可以把上面这个式子理解成$\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor$且$\leqslant n$的所有自然数之和，于是差分一下我们得到</p><script type="math/tex; mode=display">\begin{aligned}g(n,a,b,c)&=\sum_{j=0}^{m-1}\left(\cfrac{n(n+1)}{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)\end{aligned}</script><p>我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。</p><p>$a\geqslant c\vee b\geqslant c$：</p><script type="math/tex; mode=display">\begin{aligned}h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)^{2}\\&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}+i^{2}\lfloor\cfrac{a}{c}\rfloor^{2}+\lfloor\cfrac{b}{c}\rfloor^{2}+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+2\lfloor\cfrac{b}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\right)\\&=\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}\\&+2\lfloor\cfrac{a}{c}\rfloor\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+2\lfloor\cfrac{b}{c}\rfloor\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\\&=h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\end{aligned}</script><p>您绝对想象不到上面这一坨子东西的$\TeX$源码长什么样（</p><p>$a\lt c\wedge b\lt c$：</p><script type="math/tex; mode=display">\begin{aligned}h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\&=\sum_{i=0}^{n}\sum_{j=1}^{m^{2}}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor^{2}\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[c^{2}j+c^{2}\lt a^{2}i^{2}+2abi+b^{2}+1\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[i\gt\sqrt{\lfloor\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\rfloor}\right]\end{aligned}</script><p><img src="https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg" alt></p><p>然后我们发现推不下去了。</p><p>不过办法总是有的。首先我们有一个看起来没啥用的式子</p><script type="math/tex; mode=display">x^{2}=2\sum_{i=1}^{n}i-x</script><p>套进去</p><script type="math/tex; mode=display">\begin{aligned}h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\&=\sum_{i=0}^{n}\left(2\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\lfloor\cfrac{ai+b}{c}\rfloor\right)\\&=2\sum_{i=0}^{n}\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\&=2\sum_{j=1}^{m}j\sum_{i=0}^{n}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]-f(n,a,b,c)\\&=2\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^{n}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]-f(n,a,b,c)\\&=2\sum_{j=0}^{m-1}(j+1)\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)-f(n,a,b,c)\\&=m(m+1)n-2\sum_{j=0}^{m-1}j\lfloor\cfrac{cj+c-b-1}{a}\rfloor-2\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor-f(n,a,b,c)\\&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\end{aligned}</script><p>然后我们看到它奇迹般地递归了！</p><p>我们来总结一下。</p><script type="math/tex; mode=display">f(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}&f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\&mn-f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)\end{cases}</script><script type="math/tex; mode=display">g(n,a,b,c)=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}&g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\&\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)\end{cases}</script><script type="math/tex; mode=display">h(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}=\begin{cases}&h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\lt c\wedge b\lt c)\end{cases}</script><p>但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：</p><script type="math/tex; mode=display">f(n,a,b,c)=\begin{cases}&\lfloor\cfrac{b}{c}\rfloor\;\;&(n=0)\\&(n+1)\lfloor\cfrac{b}{c}\rfloor&(a=0)\end{cases}</script><script type="math/tex; mode=display">g(n,a,b,c)=\begin{cases}&0\;\;&(n=0)\\&\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor&(a=0)\end{cases}</script><script type="math/tex; mode=display">h(n,a,b,c)=\begin{cases}&\lfloor\cfrac{b}{c}\rfloor^{2}&(n=0)\\&(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}&(a=0)\end{cases}</script><p>另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,a,b,c,n,I2=<span class="number">499122177</span>,I6=<span class="number">166374059</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,h;</span><br><span class="line"></span><br><span class="line">    Query(re <span class="keyword">int</span> _f,re <span class="keyword">int</span> _g,re <span class="keyword">int</span> _h)&#123;</span><br><span class="line">        f=_f;</span><br><span class="line">        g=_g;</span><br><span class="line">        h=_h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Query <span class="title">query</span><span class="params">(re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(b,<span class="number">0</span>,<span class="number">1L</span>L*b*b%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod,<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod,<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">        re Query res=query(a%c,b%c,c,n);</span><br><span class="line">        a/=c,</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(</span><br><span class="line">            (res.f+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*a%mod+<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod)%mod,</span><br><span class="line">            (res.g+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod)%mod,</span><br><span class="line">            (res.h+<span class="number">2L</span>L*a*res.g%mod+<span class="number">2L</span>L*b*res.f%mod</span><br><span class="line">                  +<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod*a%mod</span><br><span class="line">                  +<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*a%mod*b%mod)%mod</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> m=(<span class="number">1L</span>L*a*n+b)/c;</span><br><span class="line">        re Query res=query(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">        re <span class="keyword">int</span> tmp=((<span class="number">1L</span>L*m*n%mod-res.f)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> Query(</span><br><span class="line">            tmp,</span><br><span class="line">            ((<span class="number">1L</span>L*m*n%mod*(n+<span class="number">1</span>)%mod-res.h-res.f)%mod+mod)*I2%mod,</span><br><span class="line">            ((<span class="number">1L</span>L*m*(m+<span class="number">1</span>)%mod*n%mod<span class="number">-2L</span>L*res.g%mod<span class="number">-2L</span>L*res.f%mod-tmp)%mod+mod)%mod</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">        cltstream::read(n);</span><br><span class="line">        cltstream::read(a);</span><br><span class="line">        cltstream::read(b);</span><br><span class="line">        cltstream::read(c);</span><br><span class="line">        Query ans=query(a,b,c,n);</span><br><span class="line">        cltstream::write(ans.f,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(ans.h,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(ans.g,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，这个东西有什么用啊。</p><p><del>没啥用（</del></p><p>其他的模板题我就不举了，我们来看一下<a href="https://www.luogu.org/problemnew/show/P4433" target="_blank" rel="noopener">这样一道题</a>。</p><p>看到推平操作我们可以直接往珂朵莉树上想了。</p><p>那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息<code>l,r,L,R,a,b</code>，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\sum_{i=L}^{R}ai\operatorname{mod}b$颗石头。注意这里的<code>l,r,L,R</code>一定不要搞混<del>，我就是因为这样WA了整整四遍（</del>。</p><p><del>这三个样例一定是故意的。</del></p><p>然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：</p><script type="math/tex; mode=display">\sum_{i=L}^{R}ai\operatorname{mod}b=\sum_{i=L}^{R}\left(ai-\lfloor\cfrac{ai}{b}\rfloor b\right)=\cfrac{(R+L)(R-L+1)}{2}-\sum_{i=0}^{R}\lfloor\cfrac{ai}{b}\rfloor b+\sum_{i=0}^{L-1}\lfloor\cfrac{ai}{b}\rfloor b</script><p>直接一波板子套上去。</p><p>还有就是，这么算的话中间量会爆<code>long long</code>，我们可以考虑用<code>__int128_t</code>来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后把一些没必要用或者是不能用<code>__int128_t</code>的改成<code>signed</code>即可。</p><p>代码还是有必要贴一下的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">signed</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">signed</span> digit[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">simEuc</span><span class="params">(re <span class="keyword">int</span> n,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)</span><br><span class="line">        <span class="keyword">return</span> b/c;</span><br><span class="line">    <span class="keyword">if</span>(!a)</span><br><span class="line">        <span class="keyword">return</span> (n+<span class="number">1</span>)*(b/c);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">        re <span class="keyword">int</span> res=simEuc(n,a%c,b%c,c);</span><br><span class="line">        <span class="keyword">return</span> res+n*(n+<span class="number">1</span>)*(a/c)/<span class="number">2</span>+(n+<span class="number">1</span>)*(b/c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> m=(a*n+b)/c;</span><br><span class="line">        <span class="keyword">return</span> m*n-simEuc(m<span class="number">-1</span>,c,c-b<span class="number">-1</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,L,R,a,b,sum;</span><br><span class="line"></span><br><span class="line">    node(re <span class="keyword">int</span> _l,re <span class="keyword">int</span> _r,re <span class="keyword">int</span> _L,re <span class="keyword">int</span> _R,re <span class="keyword">int</span> _a,re <span class="keyword">int</span> _b)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        L=_L;</span><br><span class="line">        R=_R;</span><br><span class="line">        a=_a;</span><br><span class="line">        b=_b;</span><br><span class="line">        sum=(R+L)*(R-L+<span class="number">1</span>)*a/<span class="number">2</span>-simEuc(R,a,<span class="number">0</span>,b)*b+simEuc(L<span class="number">-1</span>,a,<span class="number">0</span>,b)*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re node p1,re node p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(re <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    re _it it=s.lower_bound(node(pos,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        --it;</span><br><span class="line">        re <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b;</span><br><span class="line">        s.erase(it);</span><br><span class="line">        s.insert(node(l,pos<span class="number">-1</span>,L,L+pos-l<span class="number">-1</span>,a,b));</span><br><span class="line">        <span class="keyword">return</span> s.insert(node(pos,r,L+pos-l,R,a,b)).first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,<span class="number">1</span>,r-l+<span class="number">1</span>,a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;res+=itl-&gt;sum,++itl);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    s.insert(node(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        re <span class="keyword">int</span> opt,l,r,a,b;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(l);</span><br><span class="line">        cltstream::read(r);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cltstream::read(a);</span><br><span class="line">            cltstream::read(b);</span><br><span class="line">            modifyStone(l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cltstream::write(queryStone(l,r),<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 类欧几里得 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「HEOI2012」采花</title>
      <link href="/luogu-p4113-solution/"/>
      <url>/luogu-p4113-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4113" target="_blank" rel="noopener">传送门</a></p><p><a href="https://dftyem.github.io/2019/01/07/HEOI2012-采花/" target="_blank" rel="noopener">Taduro的题解</a></p><p>sto <strong>Taduro</strong> orz</p><a id="more"></a><p>首先，读完题一定有人要跳出来喊「莫队！」。</p><p><del>莫队！</del></p><p>然后再一看数据范围</p><blockquote><p>对于$100\%$的数据，$1\leqslant c\leqslant n,m\leqslant 2\times 10^{6}$。</p></blockquote><p><del>笑容逐渐消失。</del></p><p>然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了<del>，树状数组什么时候有这种操作了</del>。</p><p>首先这个样例比较菜，我们手造一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 6 2 4 2 3 6 2</span><br></pre></td></tr></table></figure><p>首先我们维护一个<code>nxt</code>数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的<code>nxt</code>差不多长这样：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>nxt[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$7$</td><td style="text-align:center">$5$</td><td style="text-align:center">$0$</td><td style="text-align:center">$8$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><p>然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。</p><p>然后我们还需要一个数组<code>ans</code>，对于每一种颜色，我们令<strong>其在指针所在位置及其之后的部分中第二次出现的位置</strong>的<code>ans</code>为$1$。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><p>因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。</p><p>不难发现，此时$\sum_{i=1}^{x}ans[i]$就是询问<code>1 x</code>的答案。</p><p>需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的<code>ans</code>置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。</p><p>这个时候<code>nxt</code>数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。</p><p>让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$\underline{1}$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$\underline{2}$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$\underline{3}$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">${\color{red}6}$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">${\color{red}6}$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">${\color{red}0}$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$\underline{4}$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">${\color{red}2}$</td><td style="text-align:center">$4$</td><td style="text-align:center">${\color{red}2}$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">${\color{red}2}$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">${\color{red}0}$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">${\color{red}1}$</td></tr></tbody></table></div><p>对于一次询问<code>l r</code>，我们将指针移动到<code>l</code>这个位置之后查询$\sum_{i=l}^{r}ans[i]$即可。</p><p>代码就不贴了<del>，其实我还没写（</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 分块 </tag>
            
            <tag> HEOI </tag>
            
            <tag> 2012 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「AHOI2017/HNOI2017」礼物</title>
      <link href="/luogu-p3723-solution/"/>
      <url>/luogu-p3723-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3723" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>首先我们要有一个简单粗暴的暴力。</p><script type="math/tex; mode=display">\min\limits_{x=0}^{n-1}\min\limits_{c_{1}=0,c_{2}=0}^{m}\sum\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\%n}-c_{2})^{2}</script><p>因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。</p><script type="math/tex; mode=display">\min\limits_{x=0}^{n-1}\min\limits_{c=-m}^{m}\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}</script><p>我们仔细观察一下那个$\Sigma$。</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}\\=&\sum\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\%n}+2cA_{i}-2cB_{(i+x)\%n})\\=&\sum\limits_{i=0}^{n-1}A_{i}^{2}+\sum\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\sum\limits_{i=0}^{n-1}A_{i}-\sum\limits_{i=0}^{n-1}B_{i})-2\sum\limits_{i=0}^{n-1}A_{i}B_{(i+x)\%n}\end{aligned}</script><p>首先$\Sigma A_{i}^{2}$和$\Sigma B_{i}^{2}$可以看成是常数项。</p><p>$nc^{2}+2c(\Sigma A_{i}-\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\Sigma A_{i}-\Sigma B_{i})$，我们知道它在$c=-\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\lfloor -\cfrac{k}{n}\rfloor$和$c=\lceil -\cfrac{k}{n}\rceil$两者都代入原式，然后取较小值。</p><p>然后我们想要求出$\Sigma A_{i}B_{(i+x)\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。</p><script type="math/tex; mode=display">\sum\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\sum\limits_{i=0}^{x-1}A_{i-x+n}B_{i}</script><p>然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。</p><p>然后一想，我们可以倒过来搞啊。</p><p>定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\sum\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\end{aligned}</script><p>然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。</p><p>以下是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 131072</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans,k,mx;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],C[maxn+<span class="number">1</span>],D[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(A[i]);</span><br><span class="line">        ans+=A[i]*A[i];</span><br><span class="line">        k+=A[i];</span><br><span class="line">        C[n<span class="number">-1</span>-i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(B[i]);</span><br><span class="line">        ans+=B[i]*B[i];</span><br><span class="line">        k-=B[i];</span><br><span class="line">        D[n<span class="number">-1</span>-i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=min(n*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n),n*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n));</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">1</span>;m&lt;n;m&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    m&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(m&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    NTT(A,m,<span class="number">0</span>);</span><br><span class="line">    NTT(B,m,<span class="number">0</span>);</span><br><span class="line">    NTT(C,m,<span class="number">0</span>);</span><br><span class="line">    NTT(D,m,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        A[i]=<span class="number">1L</span>L*A[i]*D[i]%mod;</span><br><span class="line">        B[i]=<span class="number">1L</span>L*B[i]*C[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(A,m,<span class="number">1</span>);</span><br><span class="line">    NTT(B,m,<span class="number">1</span>);</span><br><span class="line">    mx=A[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        mx=max(mx,A[n<span class="number">-1</span>-i]+B[i<span class="number">-1</span>]);</span><br><span class="line">    cltstream::write(ans-=<span class="number">2</span>*mx);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTT </tag>
            
            <tag> AHOI </tag>
            
            <tag> HNOI </tag>
            
            <tag> 2017 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P5162」WD与积木</title>
      <link href="/luogu-p5162-solution/"/>
      <url>/luogu-p5162-solution/</url>
      
        <content type="html"><![CDATA[<p>9102年的第一篇blog。</p><p><a href="https://www.luogu.org/problemnew/show/P5162" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>大概算是我用NTT切的第一道非模板题。</p><p>其实本来应该是<a href="http://codeforces.com/contest/438/problem/E" target="_blank" rel="noopener">这道</a>。不过调不出来了弃了。</p><p>首先我们会有一种想法是将方案数和每种方案的层数和分别求出来，然后一除就可以了。我们令$F[i]$表示$i$块积木所有堆放方案的层数和，$G[i]$表示$i$块积木的堆放方案数。</p><p>首先考虑如何求方案数。我们可以枚举第一层放了哪些积木。于是我们大胆地写出这样一个$n^{2}$的方程：</p><script type="math/tex; mode=display">G[n]=\sum\limits_{i=0}^{n}C_{n}^{i}G[n-i]</script><p>但是这样对吗？</p><p>代入$n=0$我们发现</p><script type="math/tex; mode=display">G[0]=C_{0}^{0}G[0]=G[0]</script><p><img src="https://i.loli.net/2019/01/02/5c2c7c9a52fe9.jpg" alt></p><p>注意到，这主要是因为$C_{n}^{0}=1$导致的，因此我们强行将它定义成$0$就好了。</p><p>那然后$G[0]$应该等于几？</p><script type="math/tex; mode=display">G[1]=C_{1}^{0}G[1]+C_{1}^{1}G[0]=G[0]=1</script><p>所以说$G[0]=1$。</p><p>如果说您再往下算几项，您就会发现令$G[0]=1$是一个正确的选择。</p><p>再然后，我们看到这个式子像极了卷积。我们先来把组合数拆开</p><script type="math/tex; mode=display">G[n]=n!\sum\limits_{i=0}^{n}\cfrac{1}{i!}\times\cfrac{G[n-i]}{(n-i)!}</script><p>定义</p><script type="math/tex; mode=display">H[n]=\begin{cases}&0&(n=0)\\&\cfrac{1}{n!}\;\;&(n>1)\end{cases}</script><script type="math/tex; mode=display">G[n]=n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{G[n-i]}{(n-i)!}</script><p>注意到我们在运算时先除以了$n-i$的阶乘，累加完之后又乘了一个$n$的逆元。这就启示我们，如果我们定义</p><script type="math/tex; mode=display">G^{\prime}[n]=\cfrac{G[n]}{n!}</script><p>就可以得到</p><script type="math/tex; mode=display">\begin{aligned}G^{\prime}[n]&=\sum\limits_{i=0}^{n}H[i]\times G^{\prime}[n-i]\\G^{\prime}&=G^{\prime}H+1\end{aligned}</script><p>注意不要忘了$+1$。因为很明显地$G^{\prime}H[0]=0$，而$G^{\prime}[0]=1$。</p><p>然后我们就有</p><script type="math/tex; mode=display">G^{\prime}=\cfrac{1}{1-H}</script><p>然后接下来我们并不需要还原出$G$。直接考虑$F$，也就是层数和。</p><p>首先还是枚举第一层放了哪些积木。不过需要注意的是，因为我们把第一层单独考虑了，因此每有一种堆放方案，我们就要再多算上一层。因此</p><script type="math/tex; mode=display">F[n]=G[n]+\sum\limits_{i=0}^{n}C_{n}^{i}F[n-i]</script><p>然后我们拆开组合数，引入上面的$H$数组，并令$F[0]=0$。至于为什么，留作习题自证（</p><script type="math/tex; mode=display">\begin{aligned}F[n]&=G[n]+n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{F[n-i]}{(n-i)!}\\&=n!\sum\limits_{i=0}^{n}H[i]\times\cfrac{F[n-i]+G[n-i]}{(n-i)!}\\F^{\prime}[n]&=\cfrac{F[n]}{n!}\\&=\sum\limits_{i=0}^{n}H[i]\times(F^{\prime}[n-i]+G^{\prime}[n-i])\\F^{\prime}&=H(F^{\prime}+G^{\prime})\end{aligned}</script><p>不过这次我们就不需要$+1$了。</p><p>解上面的方程，我们得到</p><script type="math/tex; mode=display">F^{\prime}=\cfrac{HG^{\prime}}{1-H}=\cfrac{G^{\prime}}{(1-H)^{2}}</script><p>然后我们总结一下</p><script type="math/tex; mode=display">H[n]=\begin{cases}&0&(n=0)\\&\cfrac{1}{n!}\;\;&(n>1)\end{cases}</script><script type="math/tex; mode=display">G^{\prime}=\cfrac{1}{1-H}</script><script type="math/tex; mode=display">F^{\prime}=\cfrac{G^{\prime}}{(1-H)^{2}}</script><p>最后的答案，也就是$n$块积木的期望层数，就是$\cfrac{F[n]}{G[n]}$。然后不难发现$\cfrac{F^{\prime}[n]}{G^{\prime}[n]}=\cfrac{F[n]}{G[n]}$。</p><p>我就是不贴代码（</p><p><del>反正会的应该都能写出来了吧（</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题目组试题选讲</title>
      <link href="/timuzu-solutions/"/>
      <url>/timuzu-solutions/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="输入密码继续阅读" />    <label for="pass">输入密码继续阅读</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 毒瘤 </tag>
            
            <tag> 题目组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于块状分块的研究报告</title>
      <link href="/block-decomposition/"/>
      <url>/block-decomposition/</url>
      
        <content type="html"><![CDATA[<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="输入密码继续阅读" />    <label for="pass">输入密码继续阅读</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 研究报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 块状分块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「多项式学习笔记Part II」多项式的进阶操作</title>
      <link href="/polynomial-learning-notes-pt2/"/>
      <url>/polynomial-learning-notes-pt2/</url>
      
        <content type="html"><![CDATA[<p>以下，如果不特别声明，则所有运算在模$998244353$意义下进行。</p><a id="more"></a><h3 id="接下来的前置知识"><a href="#接下来的前置知识" class="headerlink" title="接下来的前置知识"></a>接下来的前置知识</h3><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><p>说实话，其实我也不是很能理解这个东西（</p><p>我就凭感觉xjb扯了（</p><p>现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。</p><p>我们令</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=0}^{n}g[i](x-x_{0})^{i}</script><p>我们想要让$x\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。</p><p>我们先考虑$0$阶，也就是原函数。因为$x\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有</p><script type="math/tex; mode=display">g[0]=f(x_{0})</script><p>然后是$1$阶</p><script type="math/tex; mode=display">g^{\prime}(x)=\sum\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\prime}(x_{0})</script><p>再然后是$2$阶</p><script type="math/tex; mode=display">g^{\prime\prime}(x)=\sum\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\prime\prime}(x_{0})</script><p>最后是$3$阶</p><script type="math/tex; mode=display">g^{\prime\prime\prime}(x)=\sum\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\prime\prime\prime}(x_{0})</script><p>我们发现$g[n]$有如下的规律</p><script type="math/tex; mode=display">g[n]=\cfrac{f^{(n)}(x_{0})}{n!}</script><p>综上所述</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=0}^{n}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><p><del>应该吧（</del></p><h4 id="多项式牛顿迭代"><a href="#多项式牛顿迭代" class="headerlink" title="多项式牛顿迭代"></a>多项式牛顿迭代</h4><p>考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">F(G(x))\equiv 0\pmod{x^{n}}</script><p>我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得</p><script type="math/tex; mode=display">F(G_{0})\equiv 0\pmod{x^{t}}</script><p>我们希望求出一个$G$使得</p><script type="math/tex; mode=display">F(G)\equiv 0\pmod{x^{2t}}</script><p>我们将$F$在$G_{0}$这里进行泰勒展开：</p><script type="math/tex; mode=display">\begin{aligned}F(G)&=F(G_{0})\\&+F^{\prime}(G_{0})(G-G_{0})\\&+\cfrac{F^{\prime\prime}(G_{0})}{2}(G-G_{0})^{2}\\&+\cdots\end{aligned}</script><p>注意到</p><script type="math/tex; mode=display">\begin{aligned}F(G)-F(G_{0})&\equiv 0\pmod{x^{t}}\\G-G_{0}&\equiv 0\pmod{x^{t}}\end{aligned}</script><p>也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有</p><script type="math/tex; mode=display">\begin{aligned}F(G)&\equiv F(G_{0})+F^{\prime}(G_{0})(G-G_{0})\pmod{x^{2t}}\\F^{\prime}(G_{0})G&\equiv F^{\prime}(G_{0})G_{0}-F(G_{0})\pmod{x^{2t}}\\G&\equiv G_{0}-\cfrac{F(G_{0})}{F^{\prime}(G_{0})}\pmod{x^{2t}}\end{aligned}</script><p>然后我们就一直倍增，倍增到$t\geqslant n$为止，此时$G_{0}$即为所求多项式。</p><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a><a href="https://www.luogu.org/problemnew/show/P4238" target="_blank" rel="noopener">多项式求逆</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">F(x)\times G(x)\equiv 1\pmod{x^{n}}</script><p>假设我们已经求出了$G_{0}$使得</p><script type="math/tex; mode=display">F\times G_{0}\equiv 1\pmod{x^{t}}</script><p>我们希望找到一个$G$使得</p><script type="math/tex; mode=display">F\times G\equiv 1\pmod{x^{2t}}</script><p>据说能用牛顿迭代推，然而我不会（</p><p>考虑正常一点的方式<del>，虽然说还是倍增</del>。</p><script type="math/tex; mode=display">\begin{aligned}F\times G-F\times G_{0}&\equiv 0\pmod{x^{t}}\\G-G_{0}&\equiv 0\pmod{x^{t}}\\(G-G_{0})^{2}&\equiv 0\pmod{x^{2t}}\\G^{2}-2GG_{0}+G_{0}^{2}&\equiv 0\pmod{x^{2t}}\end{aligned}</script><p>两边同时乘$F$</p><script type="math/tex; mode=display">\begin{aligned}G-2G_{0}+FG_{0}^{2}&\equiv 0\pmod{x^{2t}}\\G&\equiv 2G_{0}-FG_{0}^{2}\pmod{x^{2t}}\end{aligned}</script><p>边界条件也很明显，就是当$t=1$时，$G[0]\equiv F[0]^{-1}$。</p><p>说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（</p><p>关于代码……现在还不是时候（</p><p>后面有一道超级综合题在等着我们（</p><h3 id="多项式对数函数"><a href="#多项式对数函数" class="headerlink" title="多项式对数函数"></a><a href="https://www.luogu.org/problemnew/show/P4725" target="_blank" rel="noopener">多项式对数函数</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">G(x)\equiv\ln F(x)\pmod{x^{n}}</script><p>对上式两边求导</p><script type="math/tex; mode=display">G^{\prime}\equiv F^{\prime}\ln^{\prime}F\pmod{x^{n}}</script><p>又因为</p><script type="math/tex; mode=display">\ln^{\prime}x=\frac{1}{x}</script><p>我们就得到</p><script type="math/tex; mode=display">G^{\prime}\equiv\cfrac{F^{\prime}}{F}\pmod{x^{n}}</script><p>求导+求逆+不定积分即可。</p><h3 id="多项式指数函数"><a href="#多项式指数函数" class="headerlink" title="多项式指数函数"></a><a href="https://www.luogu.org/problemnew/show/P4726" target="_blank" rel="noopener">多项式指数函数</a></h3><p>超级综合题来了。</p><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">G(x)\equiv e^{F(x)}\pmod{x^{n}}</script><p>首先</p><script type="math/tex; mode=display">\ln G-F\equiv 0\pmod{x^{n}}</script><p>我们把$F$看成是常数项，定义函数</p><script type="math/tex; mode=display">A(G)=\ln G-F</script><script type="math/tex; mode=display">A^{\prime}(G)=\ln^{\prime}G=\cfrac{1}{G}</script><p>套牛顿迭代</p><script type="math/tex; mode=display">\begin{aligned}G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\&\equiv G_{0}(1-\ln G_{0}+F)\pmod{x^{2t}}\end{aligned}</script><p>然后把以上提到的所有板子全都复制过来就行了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>],tmp3[maxn+<span class="number">1</span>],tmp4[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">            tmp1[k]=F[k];</span><br><span class="line">        NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            G[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            tmp1[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">    Inv(F,tmp2,n);</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">    NTT(G,N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        tmp2[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        Ln(G,tmp3,i);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">            tmp4[k]=F[k];</span><br><span class="line">        NTT(tmp3,j,<span class="number">0</span>);</span><br><span class="line">        NTT(tmp4,j,<span class="number">0</span>);</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=((<span class="number">1L</span>L-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            tmp3[k]=tmp4[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cltstream::read(F[i]);</span><br><span class="line">    Exp(F,G,n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cltstream::write(G[i],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项式开平方根"><a href="#多项式开平方根" class="headerlink" title="多项式开平方根"></a>多项式开平方根</h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">G^{2}(x)\equiv F(x)\pmod{x^{n}}</script><p>牛顿迭代吼啊！</p><script type="math/tex; mode=display">A(G)=G^{2}-F</script><script type="math/tex; mode=display">A^{\prime}(G)=2G</script><script type="math/tex; mode=display">\begin{aligned}G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\&\equiv G_{0}-\cfrac{G_{0}^{2}-F}{2G_{0}}\\&\equiv\cfrac{G_{0}^{2}+F}{2G_{0}}\\&=\cfrac{1}{2}(G_{0}+\cfrac{F}{G_{0}})\pmod{x^{2t}}\end{aligned}</script><p><del>复制粘贴吼啊！</del></p><h3 id="我刚才都学了些啥破玩意"><a href="#我刚才都学了些啥破玩意" class="headerlink" title="我刚才都学了些啥破玩意"></a>我刚才都学了些啥破玩意</h3><p><a href="http://codeforces.com/contest/438/problem/E" target="_blank" rel="noopener">一道例题</a>。</p><p><a href="https://www.luogu.org/problemnew/show/CF438E" target="_blank" rel="noopener">Remote Judge</a>。</p><p>这是读题前的我：</p><p><img src="https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif" alt></p><p>这是读题后的我：</p><p><img src="https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg" alt></p><p>这是知道了这题正解是多项式开平方根后的我：</p><p><img src="https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg" alt></p><p>我……我怕不是学了个假的多项式哦（</p><p>厚颜无耻地抄题解（</p><p>首先我们搞出生成函数（然而并不是很懂）</p><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{m}G[i]x^{i}</script><p>其中</p><script type="math/tex; mode=display">G[i]=[i\in\{c_{1},c_{2},\cdots,c_{n}\}]</script><p>定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有</p><script type="math/tex; mode=display">F[0]=1</script><script type="math/tex; mode=display">F[x]=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]</script><p>就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。</p><p>然后是一些神仙操作</p><script type="math/tex; mode=display">\begin{aligned}F[x]&=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]\\&=\sum\limits_{i=0}^{x}G[i]F^{2}[x-i]\\&=(GF^{2})[x]\end{aligned}</script><p>令人窒息（</p><p>然后我们就有</p><script type="math/tex; mode=display">GF^{2}+1=F</script><p>但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。</p><p>于是解上面这个一元二次方程，我们得到</p><script type="math/tex; mode=display">F=\cfrac{1\pm\sqrt{1-4G}}{2G}</script><p>但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\mp\sqrt{1-4G})$，然后化简一波</p><script type="math/tex; mode=display">F=\cfrac{2}{1\mp\sqrt{1-4G}}</script><p>如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\cfrac{2}{2}=1$。综上所述</p><script type="math/tex; mode=display">F=\cfrac{2}{1+\sqrt{1-4G}}</script><p>本来接下来应该有代码实现的，但是<del>我拒绝</del>咕咕咕。</p><p><del>其实是调不出来了（</del></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTT </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「多项式学习笔记Part I」最基本的多项式乘法</title>
      <link href="/polynomial-learning-notes-pt1/"/>
      <url>/polynomial-learning-notes-pt1/</url>
      
        <content type="html"><![CDATA[<p>最近正好月考，然而并不想去月考，于是来颓blog吧。</p><a id="more"></a><p>给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\times G)(x)$的各项系数。$n,m\leqslant 10^{6}$。</p><p>我们不妨将$F(x)$的$i$次项系数记为$F[i]$</p><script type="math/tex; mode=display">F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{m-1}G[i]x^{i}</script><script type="math/tex; mode=display">(F\times G)(x)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}</script><script type="math/tex; mode=display">(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。</p><p>不过为了优化，我们得先扯远点。</p><h1 id="点值表达"><a href="#点值表达" class="headerlink" title="点值表达"></a>点值表达</h1><p>如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。</p><p>就比如说</p><script type="math/tex; mode=display">(0,2),(1,7),(2,4)</script><p><del>瞎写的（</del></p><p>我们可以列出如下的三元一次方程组：</p><script type="math/tex; mode=display">\begin{cases}&\text{C}=2\\&\text{A}+\text{B}+\text{C}=7\\&4\text{A}+2\text{B}+\text{C}=4\end{cases}</script><p>解得</p><script type="math/tex; mode=display">\begin{cases}&\text{A}=-4\\&\text{B}=9\\&\text{C}=2\end{cases}</script><p>注意到$(F\times G)(x)=F(x)G(x)$<del>（废话）</del>，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\times G)(x)$的点值表达了。因为$(F\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。</p><p>但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（</p><p>于是我们还需要优化，于是我们还需要再扯远一点。</p><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>对，你没看错，扯到复数了。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说</p><script type="math/tex; mode=display">x^{2}+1=0</script><p>我们知道，它的判别式是$\Delta=b^{2}-4ac=-4\lt 0$，因此它没有实数根。</p><p>于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\operatorname{tan}^{-1}\cfrac{y}{x}$。</p><p>因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。</p><p><img src="https://i.loli.net/2018/12/19/5c1a46b4d785b.png" alt></p><p>上图展示了$4+i$和$3+4i$。</p><p>复数的运算其实没什么出乎意料的：</p><script type="math/tex; mode=display">(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i</script><script type="math/tex; mode=display">(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i</script><script type="math/tex; mode=display">(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i</script><script type="math/tex; mode=display">\begin{aligned}\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\&=\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\&=\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i\end{aligned}</script><p>我们来单独考虑一下复数相乘的几何意义。</p><p>假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\alpha_{1}$，$\alpha_{2}$。不难发现我们有</p><script type="math/tex; mode=display">c_{1}=r_{1}(\operatorname{cos}\alpha_{1}+i\operatorname{sin}\alpha_{1})</script><script type="math/tex; mode=display">c_{2}=r_{2}(\operatorname{cos}\alpha_{2}+i\operatorname{sin}\alpha_{2})</script><script type="math/tex; mode=display">\begin{aligned}c_{1}c_{2}&=r_{1}r_{2}(\cos\alpha_{1}+i\sin\alpha_{1})(\cos\alpha_{2}+i\sin\alpha_{2})\\&=r_{1}r_{2}(\cos\alpha_{1}\cos\alpha_{2}+i\cos\alpha_{1}\sin\alpha_{2}+i\sin\alpha_{1}\cos\alpha_{2}-\sin\alpha_{1}\sin\alpha_{2})\\&=r_{1}r_{2}[\cos(\alpha_{1}+\alpha_{2})+i\sin(\alpha_{1}+\alpha_{2})]\end{aligned}</script><p>总结成一句话，就是「模长相乘，幅角相加」。</p><h2 id="单位圆与单位根"><a href="#单位圆与单位根" class="headerlink" title="单位圆与单位根"></a>单位圆与单位根</h2><p>单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。</p><p><img src="https://i.loli.net/2018/12/20/5c1b06e5602fa.png" alt></p><p>考虑这么一个方程</p><script type="math/tex; mode=display">x^{n}=1</script><p>它的所有复数根。</p><p>因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有</p><script type="math/tex; mode=display">2\pi\mid na</script><script type="math/tex; mode=display">\cfrac{2\pi}{n}\mid a</script><p>不难想象出我们有$n$个这样的复数，它们的幅角通式是$\cfrac{2k\pi}{n}(k\in[0,n)\cap\mathbb{Z})$。我们称其中幅角等于$\cfrac{2\pi}{n}$的复数，即$\cos\cfrac{2\pi}{n}+i\sin\cfrac{2\pi}{n}$为$n$次单位根$\omega_{n}$，我们就可以把这$n$个复数表示为$\omega_{n}^{k}(k\in[0,n)\cap\mathbb{Z})$。</p><p>它有如下的一些性质</p><script type="math/tex; mode=display">\omega_{2n}^{2k}=\omega_{n}^{k}</script><p>因为它们的模长都是$1$，幅角相等就相等了。</p><p>然后就没了，读者自证不难（</p><script type="math/tex; mode=display">\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}</script><p>因为$\omega_{n}^{\frac{n}{2}}$的幅角是$\cfrac{2\times\frac{n}{2}\pi}{n}=\pi$，不难发现它就是$-1$了。</p><h1 id="快速傅里叶变换（Fast-Fourier-Transformation）"><a href="#快速傅里叶变换（Fast-Fourier-Transformation）" class="headerlink" title="快速傅里叶变换（Fast Fourier Transformation）"></a>快速傅里叶变换（Fast Fourier Transformation）</h1><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>那么问题来了，我们刚才扯了这么些，有什么用呢？</p><p>就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。</p><p>首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。</p><p>然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：</p><script type="math/tex; mode=display">\begin{aligned}F_{1}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i]x^{i}\\&=F[0]x^{0}+F[2]x^{1}+\cdots+F[n-2]x^{\frac{n}{2}-1}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}F_{2}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i+1]x^{i}\\&=F[1]x^{0}+F[3]x^{1}+\cdots+F[n-1]x^{\frac{n}{2}-1}\end{aligned}</script><p>于是我们有</p><script type="math/tex; mode=display">F(x)=F_{1}(x^{2})+xF_{2}(x^{2})</script><p>现在我们假设$0\leqslant k&lt;\cfrac{n}{2}$，将$x=\omega_{n}^{k}$和$x=\omega_{n}^{k+\frac{n}{2}}$代入</p><script type="math/tex; mode=display">\begin{aligned}F(\omega_{n}^{k})&=F_{1}(\omega_{n}^{2k})+\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\&=F_{1}(\omega_{\frac{n}{2}}^{k})+\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}F(\omega_{n}^{k+\frac{n}{2}})&=F_{1}(\omega_{n}^{2k+n})+\omega_{n}^{k+\frac{n}{2}}F_{2}(\omega_{n}^{2k+n})\\&=F_{1}(\omega_{n}^{2k})-\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\&=F_{1}(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})\end{aligned}</script><p>我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。</p><p>简单地贴一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">complex</span> F1[n&gt;&gt;<span class="number">1</span>],F2[n&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    F1[i]=F[<span class="number">2</span>*i];</span><br><span class="line">        F2[i]=F[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    work(F1,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    work(F2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i,tmp=tmp*unit)&#123;</span><br><span class="line">    <span class="keyword">complex</span> w=F2[i+(n&gt;&gt;<span class="number">1</span>)]*tmp;</span><br><span class="line">        F[i]=F1[i]+w;</span><br><span class="line">        F[i+(n&gt;&gt;<span class="number">1</span>)]=F1[i]-w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，以上代码是我现写出来的，<del>保证其不正确性</del>不保证其正确性。</p><p>不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，<code>F</code>数组的每一个位置上实际存的是几次项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">0 2 4 6|1 3 5 7</span><br><span class="line">0 4|2 6|1 5|3 7</span><br><span class="line">0|4|2|6|1|5|3|7</span><br></pre></td></tr></table></figure><p>写成二进制看看：</p><div class="table-container"><table><thead><tr><th style="text-align:center">位置（十进制）</th><th style="text-align:center">位置（二进制）</th><th style="text-align:center">次数（十进制）</th><th style="text-align:center">次数（二进制）</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$000$</td><td style="text-align:center">$0$</td><td style="text-align:center">$000$</td></tr><tr><td style="text-align:center">$1$</td><td style="text-align:center">$001$</td><td style="text-align:center">$4$</td><td style="text-align:center">$100$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$010$</td><td style="text-align:center">$2$</td><td style="text-align:center">$010$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$011$</td><td style="text-align:center">$6$</td><td style="text-align:center">$110$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$100$</td><td style="text-align:center">$1$</td><td style="text-align:center">$001$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$101$</td><td style="text-align:center">$5$</td><td style="text-align:center">$101$</td></tr><tr><td style="text-align:center">$6$</td><td style="text-align:center">$110$</td><td style="text-align:center">$3$</td><td style="text-align:center">$011$</td></tr><tr><td style="text-align:center">$7$</td><td style="text-align:center">$111$</td><td style="text-align:center">$7$</td><td style="text-align:center">$111$</td></tr></tbody></table></div><p>注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。</p><p>我们可以$O(n)$地处理处每个数的镜像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。</p><p>接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        complex unit(cos(Pi/p),sin(Pi/p));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                <span class="keyword">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                F[j+p]=F[j]-tmp;</span><br><span class="line">                F[j]=F[j]+tmp;</span><br><span class="line">                cur=cur*unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\omega_{n}^{0}),F(\omega_{n}^{1}),\cdots,F(\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：</p><script type="math/tex; mode=display">\begin{bmatrix}&(\omega_{n}^{0})^{0}&(\omega_{n}^{0})^{1}&\cdots&(\omega_{n}^{0})^{n-1}&\\&(\omega_{n}^{1})^{0}&(\omega_{n}^{1})^{1}&\cdots&(\omega_{n}^{1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&(\omega_{n}^{n-1})^{0}&(\omega_{n}^{n-1})^{1}&\cdots&(\omega_{n}^{n-1})^{n-1}\\\end{bmatrix}\begin{bmatrix}&F[0]&\\&F[1]\\&\vdots\\&F[n-1]\end{bmatrix}=\begin{bmatrix}&y_{0}&\\&y_{1}\\&\vdots\\&y_{n-1}\end{bmatrix}</script><p>我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：</p><script type="math/tex; mode=display">\begin{bmatrix}&\frac{1}{n}(\omega_{n}^{0})^{0}&\frac{1}{n}(\omega_{n}^{0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{0})^{n-1}&\\&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\\end{bmatrix}</script><p>现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\times B=C$。不难发现$A[i][j]=\omega_{n}^{ij}$，$B[i][j]=\cfrac{1}{n}\omega_{n}^{-ij}$，我们有</p><script type="math/tex; mode=display">\begin{aligned}C[i][j]&=\sum\limits_{k=0}^{n-1}A[i][k]B[k][j]\\&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{ik-kj}\end{aligned}</script><p>若$i=j$，不难发现此时$C[i][j]=1$。</p><p>否则，即$i\neq j$，设$i-j=l$，我们有</p><script type="math/tex; mode=display">\begin{aligned}C[i][j]&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{lk}\\&=\cfrac{\omega_{n}^{ln}-1}{n(\omega_{n}^{l}-1)}\\&=\cfrac{1-1}{n(\omega_{n}^{l}-1)}\\&=0\end{aligned}</script><p>综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。</p><p>因此我们有</p><script type="math/tex; mode=display">\begin{bmatrix}&\frac{1}{n}(\omega_{n}^{-0})^{0}&\frac{1}{n}(\omega_{n}^{-0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-0})^{n-1}&\\&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\\end{bmatrix}\begin{bmatrix}&y_{0}&\\&y_{1}\\&\vdots\\&y_{n-1}\end{bmatrix}=\begin{bmatrix}&F[0]&\\&F[1]\\&\vdots\\&F[n-1]\end{bmatrix}</script><p>注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$换成$\omega_{n}^{0},\omega_{n}^{-1},\cdots,\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。</p><p>注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex unit(cos(Pi/p),sin(Pi/p));</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br></pre></td></tr></table></figure><p>然后调用时再传一个参数<code>tp</code>进去。<code>tp=1</code>表示是系数转点值，<code>tp=-1</code>表示是点值转系数。</p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">        r=_r;</span><br><span class="line">        c=_c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">complex</span> F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">    _tp tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="keyword">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        register complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">register</span> <span class="keyword">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="keyword">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                F[j+p]=F[j]-tmp;</span><br><span class="line">                F[j]=F[j]+tmp;</span><br><span class="line">                cur=cur*unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;F[i].r);</span><br><span class="line">    ++m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i].r);</span><br><span class="line">    <span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    FAQ(F,<span class="number">1</span>);</span><br><span class="line">    FAQ(G,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=F[i]*G[i];</span><br><span class="line">    FAQ(F,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%0.0lf "</span>,F[i].r/n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不要问我<code>cltstream</code>哪去了（</del></p><p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P3803" target="_blank" rel="noopener">板子题</a>了。</p><p>其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（</p><p>最好还是自己写吧（</p><p>什么？想知道是哪道题？往下看（</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="「ZJOI2014」力"><a href="#「ZJOI2014」力" class="headerlink" title="「ZJOI2014」力"></a><a href="https://www.luogu.org/problemnew/show/P3338" target="_blank" rel="noopener">「ZJOI2014」力</a></h3><p>这是一道裸的卷积题。</p><p>考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足</p><script type="math/tex; mode=display">H[i]=\sum\limits_{j=0}^{i}F[j]G[i-j]=\sum\limits_{0\leqslant j<n,0\leqslant k<n,j+k=i}F[j]G[k]</script><p>在本页面往上翻，翻到这个式子：</p><script type="math/tex; mode=display">(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>发现了吗？这两个过程其实是一样的。</p><p>于是，我们如下构造两个多项式</p><script type="math/tex; mode=display">F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{n-1}G[i]x^{i}</script><p>然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。</p><p>那么这题呢？首先我们把$j\lt i$和$j\gt i$分开计算。</p><p>先考虑$j\lt i$，令$F[i]=q_{i}$，$G[i]=\begin{cases}&amp;\cfrac{1}{i^{2}}\;\;&amp;(i\gt 0)\\&amp;0&amp;(i=0)\end{cases}$，那么</p><script type="math/tex; mode=display">\begin{aligned}E_{i}&=\sum_{j=0}^{i-1}F[j]G[i-j]\\&=\sum_{j=0}^{i}F[j]G[i-j]\end{aligned}</script><p>直接套板子就行。</p><p>对于$j&gt;i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（</p><p>具体还是看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>\lt cstdio&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">        r=_r;</span><br><span class="line">        c=_c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">complex</span> F1[maxn+<span class="number">1</span>],F2[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">    _tp tmp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="keyword">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        register complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">register</span> <span class="keyword">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line">                <span class="keyword">register</span> <span class="keyword">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">                F[j+p]=F[j]-tmp;</span><br><span class="line">                F[j]=F[j]+tmp;</span><br><span class="line">                cur=cur*unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;F1[i].r);</span><br><span class="line">        F2[n-i<span class="number">-1</span>].r=F1[i].r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i]=<span class="number">1.0</span>/i/i;</span><br><span class="line">    <span class="keyword">for</span>(m=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    FAQ(G,<span class="number">1</span>);</span><br><span class="line">    FAQ(F1,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F1[i]=F1[i]*G[i];</span><br><span class="line">    FAQ(F1,<span class="number">-1</span>);</span><br><span class="line">    FAQ(F2,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F2[i]=F2[i]*G[i];</span><br><span class="line">    FAQ(F2,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,(F1[i].r-F2[m-i<span class="number">-1</span>].r)/n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论变换（Number-Theoretic-Transformation）"><a href="#数论变换（Number-Theoretic-Transformation）" class="headerlink" title="数论变换（Number-Theoretic Transformation）"></a>数论变换（Number-Theoretic Transformation）</h1><p>注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用<code>double</code>存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。</p><p>这就启示我们，能不能用其他的什么东西替换掉单位复根。</p><p>设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\equiv 1\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\delta_{p}(a)$。</p><p>如果说$\delta_{p}(a)=\varphi(p)$，我们就称$a$是模$p$的一个原根。</p><p>现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：</p><p>$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。</p><p>虽然我不会证，不过我们的确有$g^{0},g^{1},\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。</p><blockquote><p>Updated on 2019-03-17</p><p>似乎这么证明有些问题？</p><p>原根的这个性质实际上是$g^{0},g^{1},\cdots,g^{p-2}$在模$p$意义下互不相同。因此如果$(n-1)a&lt;p-1$，那么上面的结论就是正确的。</p><script type="math/tex; mode=display">\begin{aligned}(n-1)a&=na-a\\&=p-1-\cfrac{p-1}{n}\\&\lt p-1\end{aligned}</script><p>以上。</p></blockquote><p>$\omega_{2n}^{2k}=\omega_{n}^{k}$。这是为了让我们可以分治。</p><p>根据定义，$\omega_{2n}=g^{\frac{a}{2}}$，就是将现在的$p$进一步拆成$\cfrac{a}{2}\cdot2n+1$。不难发现</p><script type="math/tex; mode=display">\omega_{2n}^{2k}=g^{\frac{a}{2}\cdot{2}k}=g^{ak}=\omega_{n}^{k}</script><p>因而原根有上述性质。</p><p>$\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}$，或者说$\omega_{n}^{\frac{n}{2}}=-1$。这同样是为了让我们可以分治。</p><p>因为$p=an+1$，根据费马小定理，我们有</p><script type="math/tex; mode=display">\omega_{n}^{n}\equiv g^{an}\equiv g^{p-1}\equiv 1\pmod{p}</script><p>因而$\omega_{n}^{\frac{n}{2}}\equiv\pm 1\pmod{p}$。又因为$\omega_{n}^{0}=1$，而$\omega_{n}^{\frac{n}{2}}\not\equiv\omega_{n}^{0}\pmod{p}$，我们就得到$\omega_{n}^{\frac{n}{2}}\equiv -1\pmod{p}$。</p><p>若$k\neq 0$，$\sum_{i=0}^{n-1}(\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。</p><p>以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\times 17\times 2^{23}+1$，它的原根是$3$。</p><p>需要注意的是，我们还有一个可以优化的小细节。注意到$\omega_{n}=g^{a}=g^{\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\omega_{2},\omega_{4},\cdots,\omega_{2^{23}}$。注意到</p><script type="math/tex; mode=display">\omega_{2^{23}}=3^{7\times 17}=3^{119}</script><script type="math/tex; mode=display">\omega_{2^{k}}=\omega_{2^{k+1}}^{2}</script><p>我们一遍快速幂算出$\omega_{2^{23}}$然后倒着推出剩下的即可。</p><p>关于$\omega_{n}^{-k}$，注意到它就是$\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。</p><p>然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    ++n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        cltstream::read(F[i]);</span><br><span class="line">    ++m;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        cltstream::read(G[i]);</span><br><span class="line">    <span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    NTT(F,<span class="number">0</span>);</span><br><span class="line">    NTT(G,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">    NTT(F,<span class="number">1</span>);</span><br><span class="line">    n=cltpow(n,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        cltstream::write(<span class="number">1L</span>L*F[i]*n%mod,i&lt;m<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTT </tag>
            
            <tag> FFT </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于最优化分块时间复杂度的研究报告</title>
      <link href="/sqrt-decomposition-complexity-optimization/"/>
      <url>/sqrt-decomposition-complexity-optimization/</url>
      
        <content type="html"><![CDATA[<p>最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。</p><a id="more"></a><p>假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\text{A}x+\text{B}y$。根据均值不等式</p><script type="math/tex; mode=display">\cfrac{1}{2}(x+y)\geqslant\sqrt{xy}</script><p>我们有</p><script type="math/tex; mode=display">\text{A}x+\text{B}y\geqslant2\sqrt{\text{AB}n}</script><p>当且仅当$x=\sqrt{\cfrac{\text{B}}{\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\sqrt{\text{AB}n})$。</p><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 研究报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「未来算法Episode I」严格根号分块实现树套树</title>
      <link href="/future-algorithm-ep1/"/>
      <url>/future-algorithm-ep1/</url>
      
        <content type="html"><![CDATA[<p>分块天下第一！！！！！！！！！</p><a id="more"></a><p>我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。</p><p><a href="https://www.luogu.org/record/show?rid=14518116" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/12/08/5c0bb272768cf.png" alt></a></p><p><img src="https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg" alt></p><p>我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。</p><p>先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。</p><p>然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\operatorname{log}n)$的。</p><p>那我们就在外层套个树状数组，把修改$O(n\operatorname{log}n)$查询$O(\operatorname{log}n)$均摊成全部$O(\operatorname{log}^{2}n)$。</p><p>然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。</p><p>考虑<del>无敌的</del>分块。</p><p>一般我们想到的分块就是在块内维护<code>std::set</code>。这样操作$3$可以做到$O(\operatorname{log}\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\sqrt{n}\operatorname{log}\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\operatorname{log}10^{9}\sqrt{n}\operatorname{log}\sqrt{n})$。</p><p>然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。</p><p>我们来看一下<a href="https://www.luogu.org/space/show?uid=56384" target="_blank" rel="noopener"><strong>Shadowice1984</strong></a>dalao在他的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119" target="_blank" rel="noopener">另一篇题解</a>中做出的评价：</p><blockquote><p>这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\text{log}$之内。</p><p>但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\sqrt{n})$而不是$O(\operatorname{log}n)$，这意味着分块其实和$\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\text{log}$来，这在强调常数的根号算法中绝对是致命的。</p></blockquote><p>我也是从这位dalao的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380" target="_blank" rel="noopener">blog</a>里看到了严格根号分块实现树套树这种未来算法。</p><p>主要思想其实不难理解，既然分块和$\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。</p><p>定义<code>cnt1[i][j]</code>表示前$i$个块内有多少个元素的值在第$j$个块内，<code>cnt2[i][j]</code>表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\sqrt{n})$的。</p><p>然后我们来分析每个操作该怎么实现：</p><ol><li>首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。</li><li>还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组<code>tmp1</code>和<code>tmp2</code>来保存边角块的信息。</li><li>直接$O(\sqrt{n})$暴力重构两个<code>cnt</code>就好。</li><li>需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内<strong>从后往前扫</strong>，找到答案直接退出。否则还是<strong>从后往前扫所有值域块</strong>，找到第一个非空的块然后进去找。</li><li>操作$4$换个方向即可。</li></ol><p>综上所述，该算法的时间复杂度为$O((n+m)\sqrt{n}+m\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\operatorname{log}^{2}n)\approx 12183043$。看起来好像比不过树套树，实际上开个$\text{O}2$跑得比谁都快，正如一开始那张图所示。</p><p>不过代码写出来有点长的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxs 230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(a) ((a)&amp;(-(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,sq1,sq2;</span><br><span class="line"><span class="keyword">int</span> id1[maxn+<span class="number">1</span>],id2[maxn+maxm+<span class="number">1</span>],p[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],opt[maxm+<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt1[maxs+<span class="number">1</span>][(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],cnt2[maxs+<span class="number">1</span>][maxn+maxm+<span class="number">1</span>],tmp1[(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],tmp2[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(;(sq1+<span class="number">1</span>)*(sq1+<span class="number">1</span>)&lt;=n;++sq1);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        id1[i]=(i<span class="number">-1</span>)/sq1+<span class="number">1</span>;</span><br><span class="line">        cltstream::read(a[i]);</span><br><span class="line">        p[++p[<span class="number">0</span>]]=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        cltstream::read(opt[i][<span class="number">0</span>]);</span><br><span class="line">        cltstream::read(opt[i][<span class="number">1</span>]);</span><br><span class="line">        cltstream::read(opt[i][<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">if</span>(opt[i][<span class="number">0</span>]!=<span class="number">3</span>)</span><br><span class="line">            cltstream::read(opt[i][<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p[++p[<span class="number">0</span>]]=opt[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">    p[<span class="number">0</span>]=<span class="built_in">std</span>::unique(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>)-p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;(sq2+<span class="number">1</span>)*(sq2+<span class="number">1</span>)&lt;=p[<span class="number">0</span>];++sq2);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p[<span class="number">0</span>];++i)</span><br><span class="line">        id2[i]=(i<span class="number">-1</span>)/sq2+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,a[i])-p;</span><br><span class="line">        ++cnt1[id1[i]][id2[a[i]]];</span><br><span class="line">        ++cnt2[id1[i]][a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=id1[n];++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]];++j)</span><br><span class="line">            cnt1[i][j]+=cnt1[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[<span class="number">0</span>];++j)</span><br><span class="line">            cnt2[i][j]+=cnt2[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        re <span class="keyword">int</span> l,r,x,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span>(opt[i][<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)</span><br><span class="line">                        ans+=(a[j]&lt;x);</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)</span><br><span class="line">                        ans+=(a[j]&lt;x);</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;id2[x];++j)</span><br><span class="line">                        ans+=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j];</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>;j&lt;x;++j)</span><br><span class="line">                        ans+=cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)</span><br><span class="line">                        ans+=(a[j]&lt;x);</span><br><span class="line">                cltstream::write(ans+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=opt[i][<span class="number">3</span>];</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                            x-=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j];</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line">                                <span class="keyword">if</span>(x&gt;cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                    x-=cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k];</span><br><span class="line">                                <span class="keyword">else</span>&#123;</span><br><span class="line">                                    cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line">                        <span class="keyword">if</span>(x&gt;tmp1[j])</span><br><span class="line">                            x-=tmp1[j];</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line">                                <span class="keyword">if</span>(x&gt;tmp2[k])</span><br><span class="line">                                    x-=tmp2[k];</span><br><span class="line">                                <span class="keyword">else</span>&#123;</span><br><span class="line">                                    cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">2</span>])-p;</span><br><span class="line">                <span class="keyword">for</span>(re <span class="keyword">int</span> j=id1[l];j&lt;=id1[n];++j)&#123;</span><br><span class="line">                    --cnt1[j][id2[a[l]]];</span><br><span class="line">                    ++cnt1[j][id2[x]];</span><br><span class="line">                    --cnt2[j][a[l]];</span><br><span class="line">                    ++cnt2[j][x];</span><br><span class="line">                &#125;</span><br><span class="line">                a[l]=x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line">                                <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line">                                <span class="keyword">if</span>(tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cltstream::write(ans?p[ans]:<span class="number">-2147483647</span>,<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::upper_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line">                                <span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        ++tmp1[id2[a[j]]];</span><br><span class="line">                        ++tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp2[j])</span><br><span class="line">                            ans=j;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line">                        <span class="keyword">if</span>(tmp1[j])</span><br><span class="line">                            <span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line">                                <span class="keyword">if</span>(tmp2[k])</span><br><span class="line">                                    ans=k;</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">                        --tmp1[id2[a[j]]];</span><br><span class="line">                        --tmp2[a[j]];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cltstream::write(ans?p[ans]:<span class="number">2147483647</span>,<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还没写啥呢咋就$12\text{KB}$了（</p><p>这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（</p>]]></content>
      
      
      <categories>
          
          <category> 未来算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 树套树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些乱七八糟的数论</title>
      <link href="/number-theory-learning-notes/"/>
      <url>/number-theory-learning-notes/</url>
      
        <content type="html"><![CDATA[<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p><p><del>抄袭来源</del>参考文献：</p><ul><li><a href="https://lx-2003.blog.luogu.org/mobius-inversion" target="_blank" rel="noopener">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li><li><a href="https://www.luogu.org/blog/54745/dls-tql" target="_blank" rel="noopener">浅谈杜教筛</a></li><li><a href="https://lx-2003.blog.luogu.org/dujiao-sieve" target="_blank" rel="noopener">铃悬的数学小讲堂——杜教筛</a></li></ul><a id="more"></a><h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><h2 id="定义与相关性质"><a href="#定义与相关性质" class="headerlink" title="定义与相关性质"></a>定义与相关性质</h2><p>数论函数就是定义域为$\mathbb{N}^{+}$的函数。</p><p>两个数论函数相加，就是简单地把函数值相加。</p><script type="math/tex; mode=display">(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p><script type="math/tex; mode=display">(\alpha f)(n)=\alpha f(n)</script><p>点积也是类似的。</p><script type="math/tex; mode=display">(f\cdot g)(n)=f(n)g(n)</script><p><del>好像没啥用。</del></p><p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p><script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})</script><p>或者说：</p><script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p><p>交换律，即$f\times g=g\times f$。</p><p>这很明显。</p><p>结合律，即$(f\times g)\times h=f\times(g\times h)$。</p><script type="math/tex; mode=display">\begin{aligned}((f\times g)\times h)(n)&=\sum\limits_{ij=n}(\sum\limits_{kl=i}f(k)g(l))h(j)\\&=\sum\limits_{ijk=n}f(i)g(j)h(k)\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}(f\times(g\times h))(n)&=\sum\limits_{ij=n}f(i)(\sum\limits_{kl=j}g(k)h(l))\\&=\sum\limits_{ijk=n}f(i)g(j)h(k)\end{aligned}</script><p>分配率，即$(f+g)\times h=f\times h+g\times h$。</p><script type="math/tex; mode=display">\begin{aligned}((f+g)\times h)(n)&=\sum\limits_{ij=n}(f+g)(i)h(j)\\&=\sum\limits_{ij=n}f(i)h(j)+g(i)h(j)\\&=(f\times h)(n)+(g\times h)(n)\end{aligned}</script><p>单位元为$\epsilon(n)=[n=1]$，$f\times\epsilon =f$。</p><p>这也很明显。</p><p>对于任意一个满足$f(1)\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\times g=\epsilon$。这时我们称$g$是$f$的逆。</p><p>我们可以这样定义一个函数的逆：</p><script type="math/tex; mode=display">g(n)=\cfrac{\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum_{i\mid n}f(i)g(\cfrac{n}{i})\\&=f(1)g(n)+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\&=\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\&=\epsilon(n)\end{aligned}</script><h2 id="积性函数与完全积性函数"><a href="#积性函数与完全积性函数" class="headerlink" title="积性函数与完全积性函数"></a>积性函数与完全积性函数</h2><p>如果一个数论函数$f$满足</p><script type="math/tex; mode=display">\forall x,y\in\mathbb{N}^{+}\wedge x\perp y\;\;f(xy)=f(x)f(y)</script><p>我们就说$f$是一个积性函数。</p><p>特别的，如果上式去掉$x\perp y$仍成立，则称$f$是一个完全积性函数。</p><p>很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\times n)=f(1)\times f(n)=f(n)$。</p><p>常见的完全积性函数有$\epsilon,id^{k}$。$\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p><p>常见的积性函数有$\varphi,d,\sigma$。$\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\sigma(n)$的值分别等于$n$的约数个数和约数和。</p><p>关于$\varphi$的积性，我并不会证（</p><p>我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有</p><script type="math/tex; mode=display">d(n)=\prod\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个$m$，且</p><script type="math/tex; mode=display">m=\prod\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说$n\perp m$，肯定有</p><script type="math/tex; mode=display">\forall i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z}\;\;p_{i}\neq q_{j}</script><p>于是我们就有</p><script type="math/tex; mode=display">nm=(\prod\limits_{i=1}^{N}p_{i}^{r_{i}})(\prod\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type="math/tex; mode=display">\begin{aligned}d(nm)&=(\prod\limits_{i=1}^{N}(r_{i}+1))(\prod\limits_{j=1}^{M}(s_{j}+1))\\&=d(n)d(m)\end{aligned}</script><p>不妨再反过来考虑。如果说$n\not\perp m$，那么一定存在一对$(i,j)(i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\neq d(n)d(m)$。</p><p>我们再来分析$\sigma$的积性。还是设</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\in [0,r_{i}]\cap\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p><script type="math/tex; mode=display">\prod\limits_{i=1}^{N}\sum\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是$\sigma(n)$的值。</p><p>接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。</p><p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)(f\times g)(m)&=(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(i)g(\cfrac{n}{i})f(j)g(\cfrac{m}{j})\\&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(ij)g(\cfrac{nm}{ij})\\&=\sum\limits_{k\mid nm}f(k)g(\cfrac{nm}{k})\\&=(f\times g)(nm)\end{aligned}</script><p>关于上面的第四个等号。时刻注意$n\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。</p><p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p><p>设有一个积性函数$f$，它的逆是$g$。</p><p>当$nm=1$时，$g(1)=1$。</p><p>当$nm&gt;1$时，我们假设对于任意$n^{\prime}m^{\prime}&lt;nm$，都有$g(n^{\prime}m^{\prime})=g(n^{\prime})g(m^{\prime})$。此时</p><script type="math/tex; mode=display">\begin{aligned}g(nm)&=-\sum\limits_{k\mid nm,k\neq 1}f(k)g(\cfrac{nm}{k})\\&=-\sum\limits_{i\mid n,j\mid m,ij\neq 1}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\&=g(n)g(m)-\sum\limits_{i\mid n,j\mid m}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\&=g(n)g(m)-(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\&=g(n)g(m)-\epsilon(n)\epsilon(m)\\&=g(n)g(m)\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="正向反演"><a href="#正向反演" class="headerlink" title="正向反演"></a>正向反演</h2><p>定义$\mu$为$1$的逆。也就是说，$\mu\times 1=\epsilon$。</p><p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p><blockquote><p>首先地，$\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\mu(n)=(-1)^{k}$。否则，$\mu(n)=0$。</p></blockquote><p>那么，这两种定义等价吗？</p><p>考虑到$\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p><script type="math/tex; mode=display">\mu(n)=\prod\limits_{i=1}^{N}\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p><p>设有一个质数$p$。不难发现</p><script type="math/tex; mode=display">\mu(p)=-\mu(1)=-1</script><script type="math/tex; mode=display">\mu(p^{2})=-\mu(1)-\mu(p)=-1+1=0</script><script type="math/tex; mode=display">\mu(p^{3})=-\mu(1)-\mu(p)-\mu(p^{2})=-1+1+0=0</script><script type="math/tex; mode=display">\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p><p>那么这个东西有什么用呢？</p><p>我们设</p><script type="math/tex; mode=display">F(n)=\sum\limits_{i\mid n}f(i)</script><p>或者等价地说，$F=f\times 1$。我们可以得到</p><script type="math/tex; mode=display">\begin{aligned}F&=f\times 1\\F\times\mu&=f\times 1\times\mu\\F\times\mu&=f\end{aligned}</script><p>像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说</p><script type="math/tex; mode=display">f(n)=\sum\limits_{i\mid n}F(i)\mu(\cfrac{n}{i})</script><h2 id="反向反演"><a href="#反向反演" class="headerlink" title="反向反演"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p><script type="math/tex; mode=display">F(n)=\sum\limits_{n\mid d}f(d)⇔f(n)=\sum\limits_{n\mid d}F(d)\mu(\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p><script type="math/tex; mode=display">(f\otimes g)(n)=\sum\limits_{n\mid d}f(d)g(\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p><script type="math/tex; mode=display">F=f\otimes 1⇔F\otimes\mu=f</script><p>于是就有了上面的反向反演。</p><blockquote><p>Updated on 2018-12-03</p><p>例题……还是算了吧（</p><p>发现反演常用的套路都忘的差不多了，还是别丢人了（</p></blockquote><h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><h2 id="实现与模板题"><a href="#实现与模板题" class="headerlink" title="实现与模板题"></a>实现与模板题</h2><p>接下来才是主要内容。</p><p>现在，我们要求一个积性函数的前$n$项和。$n\leqslant 10^{10}$。</p><p>我们定义</p><script type="math/tex; mode=display">S(n)=\sum\limits_{i=1}^{n}f(i)</script><p>再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^{n}(f\times g)(i)&=\sum_{i=1}^{n}\sum_{j\mid i}f(j)g(\cfrac{i}{j})\\&=\sum_{i=1}^{n}g(i)\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}f(j)\\&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\end{aligned}</script><p>然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（</p><p>因为$g$也是积性函数，有$g(1)=1$，所以</p><script type="math/tex; mode=display">\begin{aligned}S(n)&=g(1)S(n)\\&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\\&=\sum_{i=1}^{n}(f\times g)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\end{aligned}</script><p>就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。</p><p>如果说我们选择的$g$可以让我们迅速地求出$f\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。</p><p>关于后面的$g(i)S(\lfloor\cfrac{n}{i}\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。</p><p>我们来分析一下$\lfloor\cfrac{n}{i}\rfloor$。如果$1\leqslant i\leqslant\sqrt{n}$，因为$i$只有$\sqrt{n}$种不同的取值，$\lfloor\cfrac{n}{i}\rfloor$同样也只有$\sqrt{n}$种不同的取值。如果$\sqrt{n}&lt;i\leqslant n$，$1\leqslant\lfloor\cfrac{n}{i}\rfloor&lt;\sqrt{n}$，又因为要向下取整，自然也只有$\sqrt{n}$种不同的取值。如果我们能够把$\lfloor\cfrac{n}{i}\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\sqrt{n})$。</p><p>大体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    r=n/(n/l);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于$r$的这个上界是怎么来的，我并不会证（</p><p>这样一来，要计算$S(n)$，我们需要调用所有的$\lfloor\cfrac{n}{x}\rfloor$，分别是$\lfloor\cfrac{n}{1}\rfloor,\lfloor\cfrac{n}{2}\rfloor,\cdots,\lfloor\cfrac{n}{\sqrt{n}}\rfloor,\sqrt{n},\sqrt{n}-1,\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\sqrt{n})$的。那么这样一来，总体的时间复杂度就是</p><script type="math/tex; mode=display">\begin{aligned}O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{i}+\sqrt{\lfloor\cfrac{n}{i}\rfloor})&=O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{i}\rfloor})\\&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{x}\rfloor}dx)\\&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\cfrac{n}{x}}dx)\\&=O(2n^{\frac{1}{2}}(n^{\frac{1}{4}}-1))\\&=O(n^{\frac{3}{4}})\end{aligned}</script><p>因为相比之下$\sqrt{\lfloor\cfrac{n}{i}\rfloor}$很明显要大一些，我们就可以将$\sqrt{i}$舍去。然后去掉取整符号并用积分近似。</p><p>这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\cfrac{n}{\sqrt{m}})$，当$m=n^{\frac{2}{3}}$时取得最小值$O(n^{\frac{2}{3}})$。</p><p>举个例子，就比如说我们要求</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\varphi(i)</script><p>我们取$f=\varphi,g=1$，这样根据$\varphi$的性质，$f\times g=id$。不难看出$g$与$f\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=maxn)</span><br><span class="line">        <span class="keyword">return</span> phi[n];</span><br><span class="line">    <span class="comment">//phi是提前线性筛好的前缀和</span></span><br><span class="line">    <span class="keyword">if</span>(ans.count(n))</span><br><span class="line">        <span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="comment">//ans用来实现记忆化的哈希表，比如说unordered_map</span></span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1L</span>L*n*(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//f*g的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//注意要从2开始</span></span><br><span class="line">        r=n/(n/l);</span><br><span class="line">        res-=(r-l+<span class="number">1</span>)*getSum(n/l);</span><br><span class="line">        <span class="comment">//r-l+1是g的前缀和</span></span><br><span class="line">        <span class="comment">//像这样递归+记忆化求解f的前缀和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[n]=res;</span><br><span class="line">    <span class="comment">//返回的时候不要忘记存一下</span></span><br><span class="line">    <span class="comment">//就比如说我就忘过一次（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及，不用哈希表也是可以的。因为我们查询的数都是形如$\lfloor\cfrac{n}{x}\rfloor$的，当这个值大于$n^{\frac{2}{3}}$，即$x&lt;n^{\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令<code>ans[x]</code>表示$S(\lfloor\cfrac{n}{x}\rfloor)$。具体代码我就不写了（</p><p>再举个例子，求</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\mu(i)</script><p>取$f=\mu,g=1,f\times g=\epsilon$。代码和上面差不多。</p><p>如果您理解了上面两个函数，这道<a href="https://www.luogu.org/problemnew/show/P4213" target="_blank" rel="noopener">模板题</a>您就可以切了。</p><h2 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h2><h3 id="「Luogu-P3768」简单的数学题"><a href="#「Luogu-P3768」简单的数学题" class="headerlink" title="「Luogu-P3768」简单的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3768" target="_blank" rel="noopener">「Luogu-P3768」简单的数学题</a></h3><p>快乐地推式子：</p><script type="math/tex; mode=display">\begin{aligned}\sum\limits_{i=1}^{n}i\sum\limits_{j=1}^{n}j\text{gcd}(i,j)&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j[i\perp j]\\&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j\sum\limits_{x\mid i,x\mid j}\mu(x)\\&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^{2}\mu(x)\text{Sum}^{2}(\lfloor\cfrac{n}{dx}\rfloor)\\&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\sum\limits_{j\mid i}j\mu(\cfrac{i}{j})\\&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\varphi(i)\end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\text{Sum}(n)=\sum\limits_{i=1}^{n}i</script><p>最后一步是因为</p><script type="math/tex; mode=display">\begin{aligned}id\times\mu&=\varphi\times 1\times\mu\\&=\varphi\times\epsilon\\&=\varphi\end{aligned}</script><p>理解不了上面的式子的话就多看看吧（</p><p>不难发现我们是要求$f(n)=n^{2}\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？</p><p><del>枚举瞎蒙（</del></p><p>考虑$g(n)=n^{2}$。</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})\\&=\sum\limits_{i\mid n}i^{2}\varphi(i)\cfrac{n^{2}}{i^{2}}\\&=n^{2}\sum\limits_{i\mid n}\varphi(i)\\&=n^{3}\end{aligned}</script><p><del>其实我都不知道我当时是怎么想到这种操作的（</del></p><p>然后就和上面一样了。</p><h3 id="「Luogu-U18201」分析矿洞"><a href="#「Luogu-U18201」分析矿洞" class="headerlink" title="「Luogu-U18201」分析矿洞"></a><a href="https://www.luogu.org/problemnew/show/U18201" target="_blank" rel="noopener">「Luogu-U18201」分析矿洞</a></h3><p>不知道从哪翻出来的题（</p><p>是某场个人邀请赛的$\text{T}1$<del>，从某种意义上也能看出那场比赛有多么神仙</del>。</p><script type="math/tex; mode=display">\begin{aligned}\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\varphi(\text{gcd}^{2}(i,j))&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}[i\perp j]\\&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{x\mid i,x\mid j}\mu(x)\\&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\cfrac{n}{dx}\rfloor^{2}\\&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}\varphi(j^{2})\mu(\cfrac{i}{j})\\&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}j\varphi(j)\mu(\cfrac{i}{j})\end{aligned}</script><p>设$f_1(n)=n\varphi(n),f_2(n)=\mu(n)$，考虑筛$f=f_1\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\times g$的前缀和。一种较优的方案是，令$g=1$，$f\times g=(id\cdot\varphi)\times\mu\times 1=id\cdot\varphi$，这样，我们还需要筛出$f_1(n)=n\varphi(n)$的前缀和。</p><p>怎么办？</p><p>再套一层杜教筛！</p><p>然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（</p><p>以及，像这种$n$爆了<code>int</code>的，一定要注意经常取模。<del>因为这个WA了好几次（</del></p><p>最后，源文件$17\text{KB}​$祭，blog翻页祭。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 杜教筛 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「NOIp2018游记」夢の終わるところ</title>
      <link href="/noip-2018-notes/"/>
      <url>/noip-2018-notes/</url>
      
        <content type="html"><![CDATA[<p><del>€€£：禁赛警告。</del></p><a id="more"></a><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p><p><img src="https://i.loli.net/2018/11/09/5be4e6d8c122f.png" alt></p><p>明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废<del>，同时看着其他dalao随手切神仙题</del>。然后我看到yemdalao写了一篇<a href="https://www.cnblogs.com/taduro/p/9933329.html" target="_blank" rel="noopener">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p><blockquote><p>其他dalao都在机房补文化课而我在颓blog（</p><p>于是，此处以下，Updated on 2018-11-12。</p><blockquote><p>Updated on 2018-11-14</p><p>看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。</p><p>但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p></blockquote></blockquote><p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。</p><p>然后一抽考场发现是外校，赛前先<code>rp--</code>。</p><p>然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（</p><p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（</p><p>除那之外就没啥了，算是颓了一个下午。</p><p>晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（</p><p>试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。</p><p>反正板子是不可能打炸的，这辈子都不可能的。</p><p>因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。</p><p>然后一打开E盘发现被清了，只有题目。</p><p>Day1的解压密码是不是就我一个人不懂啊（</p><p>那么于是，到了8：30，我点开今天的题目，定神一看……</p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5019" target="_blank" rel="noopener">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正<code>score+=100</code>。</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5020" target="_blank" rel="noopener">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5021" target="_blank" rel="noopener">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。</p><p>估分100+100+25=225。</p><p>出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（</p><p>前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（</p><p>那我可真是太菜了（</p><p>下午日常发呆，然后晚上是快乐的颓废时间。</p><p>中午买的零食一个下午就全吃完了（</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p><p>这次我东西是真的带全了（</p><p>Day2的解压密码依然不懂，然后是今天的题目：</p><h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5022" target="_blank" rel="noopener">T1</a></h2><p>NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。</p><p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点<code>std::sort</code>一遍。然后维护一个邻接矩阵处理断边（</p><p>为什么不直接用邻接矩阵呢（</p><h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5023" target="_blank" rel="noopener">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（</p><h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5024" target="_blank" rel="noopener">T3</a></h2><p>究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。</p><p>估分100+65+44=204（不存在的，肯定比这个低）。</p><p>这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……</p><p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p><p>好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……</p><p>下午请假回家开心地颓废。</p><h1 id="Extra-Notes"><a href="#Extra-Notes" class="headerlink" title="Extra Notes"></a>Extra Notes</h1><p>果然是等到NOIp结束后才更新的。</p><p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p><blockquote><p>Updated on 2018-11-26</p><p>好像有些晚的更新。</p><p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p><p>具体成绩差不多是100+100+20+100+65+36=421。</p><p>以上。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIp </tag>
            
            <tag> 2018 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P5009」毒瘤分块题</title>
      <link href="/luogu-p5009-solution/"/>
      <url>/luogu-p5009-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5009" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>从来没做过这么毒瘤的题qaq</p><p>就算看了题解现在还是一脸懵逼qaq</p><p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq</p><p>对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\prime$使得$v_i^\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\prime$，然后查询的时候我们就可以直接返回$v_i^\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\prime=v_i-t_1xb_i$。</p><p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\Sigma v_i^\prime+t\Sigma (a_i+x+z)(b_i+y)=\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$，即$\Sigma v_i^\prime=\Sigma v_i-tz\Sigma (b_i+y)$。</p><p>不过，上式中$tz\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\Sigma b_i$，考虑到每层节点的$\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\Sigma v_i+=B\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。</p><p>然后是毒瘤的下推标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];</span><br><span class="line"><span class="comment">//就是上面这句qaq现在还是一脸懵逼qaq</span></span><br><span class="line">A[son]+=A[father];</span><br><span class="line">B[son]+=B[father];</span><br><span class="line">adda[son]+=adda[father];</span><br><span class="line">addb[son]+=addf[father];</span><br></pre></td></tr></table></figure><p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 100000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> sumv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],suma[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sumb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sump[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],B[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> addv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],adda[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],addb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> ln,<span class="keyword">int</span> rn)</span></span>&#123;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addv[cur]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*ln%mod)%mod;</span><br><span class="line">    suma[cur&lt;&lt;<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*adda[cur]%mod)%mod;</span><br><span class="line">    sumb[cur&lt;&lt;<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addb[cur]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">    A[cur&lt;&lt;<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">    B[cur&lt;&lt;<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">    adda[cur&lt;&lt;<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">    addb[cur&lt;&lt;<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addv[cur]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*rn%mod)%mod;</span><br><span class="line">    suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*adda[cur]%mod)%mod;</span><br><span class="line">    sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addb[cur]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">    addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">    A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">    B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">    adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">    addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">    A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">    sumv[cur]=(sumv[cur&lt;&lt;<span class="number">1</span>]+sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    suma[cur]=(suma[cur&lt;&lt;<span class="number">1</span>]+suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    sumb[cur]=(sumb[cur&lt;&lt;<span class="number">1</span>]+sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">    sump[cur]=(sump[cur&lt;&lt;<span class="number">1</span>]+sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        cltstream::read(sumv[cur]);</span><br><span class="line">        cltstream::read(suma[cur]);</span><br><span class="line">        cltstream::read(sumb[cur]);</span><br><span class="line">        sumv[cur]=(sumv[cur]%mod+mod)%mod;</span><br><span class="line">        suma[cur]=(suma[cur]%mod+mod)%mod;</span><br><span class="line">        sumb[cur]=(sumb[cur]%mod+mod)%mod;</span><br><span class="line">        sump[cur]=<span class="number">1L</span>L*suma[cur]*sumb[cur]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        build(cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        build(cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class="line">        <span class="keyword">return</span> (sumv[cur]+<span class="number">1L</span>L*t*sump[cur]%mod)%mod;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>,l,mid))%mod;</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r))%mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyV</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sumv[cur]=(sumv[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">        addv[cur]=(addv[cur]+x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyA</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        suma[cur]=(suma[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">        sump[cur]=(sump[cur]+<span class="number">1L</span>L*sumb[cur]*x%mod)%mod;</span><br><span class="line">        B[cur]=(B[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">        addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*addb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        adda[cur]=(adda[cur]+x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyB</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*suma[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        sumb[cur]=(sumb[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">        sump[cur]=(sump[cur]+<span class="number">1L</span>L*suma[cur]*x%mod)%mod;</span><br><span class="line">        A[cur]=(A[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">        addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*adda[cur]%mod+mod)%mod)%mod;</span><br><span class="line">        addb[cur]=(addb[cur]+x)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line">        <span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">            modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        <span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">            modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        pushUp(cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,t,l,r,x;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(t);</span><br><span class="line">        cltstream::read(l);</span><br><span class="line">        cltstream::read(r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cltstream::write(query(l,r,t,<span class="number">1</span>,<span class="number">1</span>,n),<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                modifyA(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                modifyB(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                modifyV(l,r,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是我太菜了不适合做这种毒瘤题吧qaq</p><p><img src="https://i.loli.net/2018/11/08/5be38edf529ca.jpg" alt></p><p>距 <strong>在NOIp2018爆零</strong> 还剩 <strong>1 天</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>状态压缩动态规划学习笔记</title>
      <link href="/status-compression-learning-notes/"/>
      <url>/status-compression-learning-notes/</url>
      
        <content type="html"><![CDATA[<p><del>把标签和分类连在一起读就是标题了（</del></p><p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p><p><del>马上就要复赛了，但反正我已经退役预定了来颓blog吧。</del></p><a id="more"></a><p>首先我们来看一道例题，<a href="https://www.luogu.org/problemnew/show/P1879" target="_blank" rel="noopener">「USACO06NOV」玉米田Corn Fields</a>。</p><p>首先，我们想到定义<code>f[i][...]</code>表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...(省略10个[0/1])...[0/1]</code>，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。</p><p>但是等等……$13$维的状态……</p><p><img src="https://i.loli.net/2018/10/24/5bd07656b885a.jpg" alt></p><p>注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。</p><p>于是，现在我们定义<code>f[i][S]</code>表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义<code>a[i]</code>表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。<code>valid[S]</code>表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。<code>a[i]</code>在读入时就可以处理出来，至于<code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    valid[i]=valid[i&gt;&gt;<span class="number">1</span>]&amp;(~(i&amp;(i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>用人话来讲就是<code>[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]</code>。</p><p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是<code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i])==a[i]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    (f[i][j]+=f[i<span class="number">-1</span>][k])%=mod;</span><br></pre></td></tr></table></figure><p>粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个<code>if</code>剪掉，因而实际运行跑得比谁都快（</p><p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href="https://www.luogu.org/problemnew/show/P2704" target="_blank" rel="noopener">「NOI2001」炮兵阵地</a>。</p><p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用<code>f[i][S1][S2]</code>表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录<code>a[i]</code>和<code>valid[S]</code>，不过，这次<code>valid[s]</code>的预处理过程差不多是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">    valid[i]=(i&amp;<span class="number">1</span>)?valid[i&gt;&gt;<span class="number">3</span>]&amp;((~i)&gt;&gt;<span class="number">2</span>)&amp;((~i)&gt;&gt;<span class="number">1</span>):valid[i&gt;&gt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg" alt></p><p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p><p>……不好像又没写错……</p><p>好吧没写错。</p><p>如果$S$的最后一位是$1$，则<code>[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]</code>，否则<code>[S是否合法]=[S&gt;&gt;1是否合法]</code>。</p><p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>转移过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">            <span class="keyword">if</span>((j|a[<span class="number">2</span>])==a[<span class="number">2</span>]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    f[<span class="number">2</span>][i][j]=cnt[i]+cnt[j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i<span class="number">-2</span>])==a[i<span class="number">-2</span>]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);++l)</span><br><span class="line">                        <span class="keyword">if</span>((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==<span class="number">0</span>&amp;&amp;(l&amp;k)==<span class="number">0</span>)</span><br><span class="line">                            f[i][k][l]=max(f[i][k][l],f[i<span class="number">-1</span>][j][k]+cnt[l]);</span><br></pre></td></tr></table></figure><p>时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\text{won’t TLE})$（</p><p>我们再来看一个状压的应用，<a href="https://www.spoj.com/problems/MMINPAID/" target="_blank" rel="noopener">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href="https://www.luogu.org/problemnew/show/SP3953" target="_blank" rel="noopener">洛谷</a>上提交。</p><p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义<code>dis[u][S]</code>为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。</p><p>这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p><p><del>我是不会说我把impossible打成Impossible然后交上去WA了一发的（</del></p><p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p><p><img src="https://i.loli.net/2018/10/25/5bd13984b8601.jpg" alt></p><p>以上，我觉得我的状压讲的差不多了（</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>珂朵莉树学习笔记</title>
      <link href="/chtholly-tree-learning-notes/"/>
      <url>/chtholly-tree-learning-notes/</url>
      
        <content type="html"><![CDATA[<p><del>还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p><p><del>话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。</del></p><p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p><a id="more"></a><p>我们先来看一道<del>毒瘤</del>例题，<a href="http://codeforces.com/contest/896/problem/C" target="_blank" rel="noopener">「CF896C」Willem, Chtholly and Seniorious</a>。</p><p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？</p><p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于<code>std::set</code>的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p><blockquote><p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p></blockquote><p>那么怎么推平呢？不急，我们慢慢讲。</p><p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="comment">//这里的mutable是为了让我们在之后的修改过程中可以修改val的值</span></span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//调用时_r或_val不填的话默认-1，为了后面split时方便</span></span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>初始化完了？</p><p>初始化完了。</p><p>然后就是珂朵莉树的核心操作<del>之一</del>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::&lt;<span class="built_in">set</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure><p>作用是分离出一个左端点为<code>pos</code>的区间并返回它的迭代器。它的具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="comment">//上面这句手打非常麻烦，建议宏定义</span></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="comment">//找第一个左端点大于等于pos的区间</span></span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="comment">//如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器</span></span><br><span class="line">    --it;</span><br><span class="line">    <span class="comment">//否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内</span></span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">    <span class="comment">//将区间[l,r]删除，并插入区间[l,pos)和[pos,r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p><p><code>insert</code>函数的返回值类型是<code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个<code>.first</code>。</p><p><code>std::set</code>内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\operatorname{log}n)$的。</p><p>然后是一个同样很核心的操作，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure><p>将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="comment">//注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内</span></span><br><span class="line">    <span class="comment">//后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器</span></span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    <span class="comment">//将[itl,itr)内所有区间删除</span></span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">    <span class="comment">//用一个大区间取代它们</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就完了？</p><p>这就完了。</p><p><code>assign</code>操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得<code>set</code>的大小迅速减小，并最终趋于$\operatorname{log}n$。本题的操作二就只需调用一次<code>assign(l,r,x)</code>即可。</p><p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p><p>操作一，一个一个区间地拿出来加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么几行？</p><p>就这么几行。</p><p>操作三，把所有区间取出来，然后直接调用<code>std::sort</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作四，暴力快速幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p><p>这是我在CodeForces上的提交记录：</p><p><img src="https://i.loli.net/2018/10/14/5bc28b1443ea5.png" alt></p><p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p><p><img src="https://i.loli.net/2018/10/14/5bc28c7ecfe96.png" alt></p><p><img src="https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg" alt></p><p>珂幻.jpg</p><p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href="http://codeforces.com/contest/915/problem/E" target="_blank" rel="noopener">「CF915E」Physical Education Lessons</a>，然而……</p><p><img src="https://i.loli.net/2018/10/14/5bc297890bbc6.png" alt></p><blockquote><p>Updated on 2018-11-01</p><p>后来我卡了卡常数过了……</p><p>以及，删掉了某些内容（</p></blockquote><p>于是，接下来是珂朵莉树的完整板子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">        <span class="keyword">char</span> str[size+<span class="number">1</span>],*head=str,*tail=str;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">                tail=(head=str)+fread(str,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(head==tail)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];<span class="built_in">putchar</span>(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,seed,maxval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=seed;</span><br><span class="line">    seed=(<span class="number">7L</span>L*seed+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; l,<span class="keyword">int</span>&amp; r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=l;</span><br><span class="line">    l=r;</span><br><span class="line">    r=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> res=cltpow(x,y&gt;&gt;<span class="number">1</span>,mod);</span><br><span class="line">    res=<span class="number">1L</span>L*res*res%mod;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">        res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAssign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//就是之前提到的assign</span></span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(seed);</span><br><span class="line">    cltstream::read(maxval);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            swap(l,r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAdd(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAssign(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXth(l,r,x),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                y=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXpow(l,r,x,y),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 珂朵莉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「SDOI2009」虔诚的墓主人</title>
      <link href="/luogu-p2154-solution/"/>
      <url>/luogu-p2154-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p><p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是</p><script type="math/tex; mode=display">C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有$k\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p><script type="math/tex; mode=display">C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\sum\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个$\Sigma$所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p><p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NOIp</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> RP,score;</span><br><span class="line">&#125;;</span><br><span class="line">NOIp NOIp2018;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        NOIp2018.RP++;</span><br><span class="line">        NOIp2018.score++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
            <tag> SDOI </tag>
            
            <tag> 2009 </tag>
            
            <tag> 离散化 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P4900」食堂</title>
      <link href="/luogu-p4900-solution/"/>
      <url>/luogu-p4900-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4900" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p><del>闲着没事写篇题解（</del></p><p>简单来说，就是要求</p><script type="math/tex; mode=display">\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\pmod{998244353}</script><p>其中$\lbrace x\rbrace$表示取$x$的小数部分。</p><p>稍加思索，我们不难发现</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\\\equiv&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\\\equiv&\sum\limits_{i=1}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}-\sum\limits_{i=1}^{A-1}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}\end{aligned}</script><p>因此，我们只需要关注下式的值</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}</script><p>我们可以参考一下<a href="https://www.luogu.org/problemnew/show/P3708" target="_blank" rel="noopener">这道题</a></p><p>在这道题中，我们定义了</p><script type="math/tex; mode=display">f(x)=\sum\limits_{i=1}^{n}x\%i</script><p>首先，如果不考虑$x\%i=0$的情况，我们有</p><script type="math/tex; mode=display">x\%i=(x-1)\%i+1</script><script type="math/tex; mode=display">f(x)=f(x-1)+n</script><p>如果$x\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此</p><script type="math/tex; mode=display">f(x)=f(x-1)+n-\sigma(x)</script><p>我们可以类似地定义</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{n}x\%i\times i^{-1}\pmod{998244353}</script><script type="math/tex; mode=display">h(x)=\sum\limits_{i\mid x}i\times i^{-1}\equiv\sum\limits_{i\mid x}1\equiv d(x)\pmod{998244353}</script><p>从而我们有</p><script type="math/tex; mode=display">g(x)\equiv g(x-1)+\sum\limits_{i=1}^{n}i^{-1}-d(x)\pmod{998244353}</script><p>然而我们需要的是</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>其中</p><script type="math/tex; mode=display">ans(x)=\sum\limits_{i=1}^{x}x\%i\times i^{-1}\pmod{998244353}</script><p>不难发现当$i&lt;j$时$i\%j=i$，从而</p><script type="math/tex; mode=display">\begin{aligned}&g(x)-ans(x)\\\equiv&\sum\limits_{i=x+1}^{n}x\%i\times i^{-1}\\\equiv&\sum\limits_{i=x+1}^{n}x\times i^{-1}\pmod{998244353}\end{aligned}</script><p>最终，我们得到</p><script type="math/tex; mode=display">ans(x)\equiv g(x)-x\sum\limits_{i=x+1}^{n}i^{-1}</script><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\equiv\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-P3924」康娜的线段树</title>
      <link href="/luogu-p3924-solution/"/>
      <url>/luogu-p3924-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3924" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p><blockquote><p>对于$70\%$的数据，保证$1\leqslant n,m\leqslant 10^{5}$。</p><p>对于$100\%$的数据，保证$1\leqslant n,m\leqslant 10^{6}$。</p></blockquote><p><del>也就是说，上述做法<strong>最多</strong>只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。</del></p><blockquote><p>Updated on 2018-10-09</p><p>不好意思时间复杂度算错了我太菜了。</p><p>但反正线段树需要卡常才能过（</p></blockquote><p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p><p>定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。</p><p>稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。</p><p>以及，最后一句话。</p><p>这道题卡精度。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「Luogu-T47720」孤立元</title>
      <link href="/luogu-t47720-solution/"/>
      <url>/luogu-t47720-solution/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/T47720" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>自己出的第一道<del>毒瘤</del>数论题。</p><p>对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\notin B$且$i+1\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为</p><script type="math/tex; mode=display">\frac{\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p><script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote><p>Updated on 2018-10-10</p><p>之前公式写错了，分子上的$m$全都漏掉了（</p><p>以及，我们还可以将上式继续整理：</p><script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现<code>#ifdef</code>真没用也可能是我太菜了（</del></p><blockquote><p>Updated on 2018-10-16</p><p>好吧我当时并不会用<code>#ifdef</code>（</p></blockquote><p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了$1861\text{ms}$，最慢的一个点只跑了$300\text{ms}$不到。截至本日，另外两个切掉这道题的$\text{dalao}$最慢的一个点也只跑了$400\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点$500\text{ms}$，是我们机房的电脑太菜了吗（</del></p></blockquote><p>于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。</p><p>但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 期望 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>总算是搞出来了一个自己觉得海星的blog……</p>]]></content>
      
      
      <categories>
          
          <category> 未分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其它 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
