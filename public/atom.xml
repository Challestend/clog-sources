<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>空を喰らう幽霊塔</title>
  
  <subtitle>どうか醜いくらいに美しい愛で、この心を抉ってくれよ。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Challestend/"/>
  <updated>2018-12-29T04:37:58.357Z</updated>
  <id>https://github.com/Challestend/</id>
  
  <author>
    <name>Challestend Rehtorbegnaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>题目组试题选讲</title>
    <link href="https://github.com/Challestend/timuzu-solutions/"/>
    <id>https://github.com/Challestend/timuzu-solutions/</id>
    <published>2018-12-26T12:17:22.000Z</published>
    <updated>2018-12-29T04:37:58.357Z</updated>
    
    <content type="html"><![CDATA[<p>先宣传一波<a href="https://www.luogu.org/team/show?teamid=11367" target="_blank" rel="noopener">团队</a>。</p><a id="more"></a><h1 id="「T47720」孤立元"><a href="#「T47720」孤立元" class="headerlink" title="「T47720」孤立元"></a><a href="https://www.luogu.org/problemnew/show/T47720" target="_blank" rel="noopener">「T47720」孤立元</a></h1><p><a href="/luogu-t47720-solution/">已有题解</a>。</p><h1 id="「T53537」营救元首"><a href="#「T53537」营救元首" class="headerlink" title="「T53537」营救元首"></a><a href="https://www.luogu.org/problemnew/show/T53537" target="_blank" rel="noopener">「T53537」营救元首</a></h1><p>能看出<a href="https://www.luogu.org/problemnew/show/P4117" target="_blank" rel="noopener">五彩斑斓的世界</a>来吗？</p><p>没错就是JF切了这道题以后<del>根号上脑</del>搞了这么一个东西。</p><p>不过这道题相对之下有点麻烦的，因为你需要维护两个tag，一个处理减，一个处理推平。而且求前驱的时候不能值域分块，然后就只能套<code>set</code>。</p><p>详细点说的话，就是每个块维护最大值和最小值。操作$1$可以选择枚举所有大于$k$的数，然后减去$k$；也可以枚举所有小于等于$k$的数，加上$k$之后整个块打上一个减$k$的标记，标记这个块内的所有数都被减去了$k$。哪个运算量少就选哪个。</p><p>操作$2$就先查询最小值<del>（这个都会吧）</del>，然后散块直接改，整块打个标记就好，标记这个块内的所有数都被改成了另一个数。</p><p>操作$3$就不必多说了，散块暴力找，整块<code>lower_bound</code>。</p><p>不过说实话，写起来挺麻烦的。也懒得看以前我写的代码了，直接贴出来吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxblock 320</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxval 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout;</span><br><span class="line">    <span class="keyword">int</span> outcnt=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">-1</span>)</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,outcnt,<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(outcnt==size)&#123;</span><br><span class="line">                fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">                oh=cltout;</span><br><span class="line">                outcnt=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            *oh++=c;</span><br><span class="line">            ++outcnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,size;</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],id[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> val[maxn+<span class="number">1</span>],f[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> pos[maxblock+<span class="number">1</span>][maxval+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> maxv[maxblock+<span class="number">1</span>],minv[maxblock+<span class="number">1</span>],tag[maxblock+<span class="number">1</span>],sam[maxblock+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s[maxblock+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f[x]==x?x:f[x]=find(f[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    maxv[x]=<span class="number">-2e9</span>;</span><br><span class="line">    minv[x]=<span class="number">2e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=(x<span class="number">-1</span>)*size+<span class="number">1</span>;i&lt;=x*size&amp;&amp;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!pos[x][a[i]])&#123;</span><br><span class="line">            val[i]=a[i];</span><br><span class="line">            f[i]=i;</span><br><span class="line">            pos[x][a[i]]=i;</span><br><span class="line">            maxv[x]=max(maxv[x],a[i]);</span><br><span class="line">            minv[x]=min(minv[x],a[i]);</span><br><span class="line">            s[x].insert(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            f[i]=pos[x][a[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=(x<span class="number">-1</span>)*size+<span class="number">1</span>;i&lt;=x*size&amp;&amp;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]=sam[x]?sam[x]:val[find(i)]+tag[x];</span><br><span class="line">        pos[x][val[i]]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tag[x]=sam[x]=<span class="number">0</span>;</span><br><span class="line">    s[x].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sam[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(sam[x]&gt;y)</span><br><span class="line">            sam[x]-=y;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(maxv[x]-(y-tag[x])&lt;=(y-tag[x])-minv[x]+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=(y-tag[x])+<span class="number">1</span>;i&lt;=maxv[x];++i)</span><br><span class="line">            <span class="keyword">if</span>(pos[x][i])&#123;</span><br><span class="line">                s[x].erase(i);</span><br><span class="line">                <span class="keyword">if</span>(!pos[x][i-y])&#123;</span><br><span class="line">                    val[pos[x][i]]-=y;</span><br><span class="line">                    pos[x][i-y]=pos[x][i];</span><br><span class="line">                    s[x].insert(i-y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(pos[x][i]&gt;pos[x][i-y])</span><br><span class="line">                        f[pos[x][i]]=pos[x][i-y];</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        f[pos[x][i-y]]=pos[x][i];</span><br><span class="line">                        pos[x][i-y]=pos[x][i];</span><br><span class="line">                        val[pos[x][i-y]]-=y;</span><br><span class="line">                    &#125;</span><br><span class="line">                pos[x][i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=(y-tag[x]);i&gt;=minv[x];--i)</span><br><span class="line">            <span class="keyword">if</span>(pos[x][i])&#123;</span><br><span class="line">                s[x].erase(i);</span><br><span class="line">                <span class="keyword">if</span>(!pos[x][i+y])&#123;</span><br><span class="line">                    val[pos[x][i]]+=y;</span><br><span class="line">                    pos[x][i+y]=pos[x][i];</span><br><span class="line">                    s[x].insert(i+y);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">if</span>(pos[x][i]&gt;pos[x][i+y])</span><br><span class="line">                        f[pos[x][i]]=pos[x][i+y];</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        f[pos[x][i+y]]=pos[x][i];</span><br><span class="line">                        pos[x][i+y]=pos[x][i];</span><br><span class="line">                        val[pos[x][i+y]]+=y;</span><br><span class="line">                    &#125;</span><br><span class="line">                pos[x][i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        tag[x]-=y;</span><br><span class="line">    &#125;</span><br><span class="line">    minv[x]=*s[x].begin();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s[x].end();</span><br><span class="line">    --it;</span><br><span class="line">    maxv[x]=*it;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalCut</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=id[l],R=id[r];</span><br><span class="line">    destory(L);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;x)</span><br><span class="line">            a[i]-=x;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;=R<span class="number">-1</span>;++i)</span><br><span class="line">        solve(i,x);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">        destory(R);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=(R<span class="number">-1</span>)*size+<span class="number">1</span>;i&lt;=r;++i)</span><br><span class="line">            <span class="keyword">if</span>(a[i]&gt;x)</span><br><span class="line">                a[i]-=x;</span><br><span class="line">        init(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAssignToMin</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=id[l],R=id[r],res=<span class="number">2e9</span>;</span><br><span class="line">    destory(L);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i)</span><br><span class="line">        res=min(res,a[i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;=R<span class="number">-1</span>;++i)</span><br><span class="line">        res=min(res,sam[i]?sam[i]:minv[i]+tag[i]);</span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">        destory(R);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=(R<span class="number">-1</span>)*size+<span class="number">1</span>;i&lt;=r;++i)</span><br><span class="line">            res=min(res,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i)</span><br><span class="line">        a[i]=res;</span><br><span class="line">    init(L);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;=R<span class="number">-1</span>;++i)</span><br><span class="line">        sam[i]=res;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=(R<span class="number">-1</span>)*size+<span class="number">1</span>;i&lt;=r;++i)</span><br><span class="line">            a[i]=res;</span><br><span class="line">        init(R);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalPre</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=id[l],R=id[r],p=<span class="number">0</span>,res=<span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">if</span>(sam[L])&#123;</span><br><span class="line">        <span class="keyword">if</span>(sam[L]&lt;x&amp;&amp;sam[L]&gt;res)&#123;</span><br><span class="line">            p=l;</span><br><span class="line">            res=sam[L];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=l;i&lt;=L*size&amp;&amp;i&lt;=r;++i)</span><br><span class="line">            <span class="keyword">if</span>(val[find(i)]+tag[L]&lt;x&amp;&amp;val[find(i)]+tag[L]&gt;res)&#123;</span><br><span class="line">                p=i;</span><br><span class="line">                res=val[f[i]]+tag[L];</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=L+<span class="number">1</span>;i&lt;=R<span class="number">-1</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(sam[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(sam[i]&lt;x&amp;&amp;sam[i]&gt;res)&#123;</span><br><span class="line">                p=(i<span class="number">-1</span>)*size+<span class="number">1</span>;</span><br><span class="line">                res=sam[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s[i].lower_bound(x-tag[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=s[i].begin())&#123;</span><br><span class="line">                --it;</span><br><span class="line">                <span class="keyword">if</span>(*it+tag[i]&lt;x&amp;&amp;*it+tag[i]&gt;res)&#123;</span><br><span class="line">                    p=pos[i][*it];</span><br><span class="line">                    res=*it+tag[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;R)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sam[R])&#123;</span><br><span class="line">            <span class="keyword">if</span>(sam[R]&lt;x&amp;&amp;sam[R]&gt;res)&#123;</span><br><span class="line">                p=(R<span class="number">-1</span>)*size+<span class="number">1</span>;</span><br><span class="line">                res=sam[R];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> i=(R<span class="number">-1</span>)*size+<span class="number">1</span>;i&lt;=r;++i)</span><br><span class="line">                <span class="keyword">if</span>(val[find(i)]+tag[R]&lt;x&amp;&amp;val[find(i)]+tag[R]&gt;res)&#123;</span><br><span class="line">                    p=i;</span><br><span class="line">                    res=val[f[i]]+tag[R];</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        cltstream::write(p,<span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cltstream::pc(<span class="string">'G'</span>);</span><br><span class="line">        cltstream::pc(<span class="string">'R'</span>);</span><br><span class="line">        cltstream::pc(<span class="string">'E'</span>);</span><br><span class="line">        cltstream::pc(<span class="string">'A'</span>);</span><br><span class="line">        cltstream::pc(<span class="string">'T'</span>);</span><br><span class="line">        cltstream::pc(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::read(a[i]);</span><br><span class="line">    <span class="keyword">for</span>(;(size+<span class="number">1</span>)*(size+<span class="number">1</span>)&lt;=n;++size);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;(i<span class="number">-1</span>)*size+<span class="number">1</span>&lt;=n;++i)&#123;</span><br><span class="line">        init(i);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=(i<span class="number">-1</span>)*size+<span class="number">1</span>;j&lt;=i*size&amp;&amp;j&lt;=n;++j)</span><br><span class="line">            id[j]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,l,r,x;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(l);</span><br><span class="line">        cltstream::read(r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                IntervalCut(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                IntervalAssignToMin(l,r);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                cltstream::read(x);</span><br><span class="line">                IntervalPre(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        (a[<span class="number">0</span>]+=sam[id[i]]?sam[id[i]]:val[find(i)]+tag[id[i]])%=mod;</span><br><span class="line">    cltstream::write(a[<span class="number">0</span>],<span class="string">'\n'</span>);</span><br><span class="line">    cltstream::pc(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="「T53987」ZJF日记"><a href="#「T53987」ZJF日记" class="headerlink" title="「T53987」ZJF日记"></a><a href="https://www.luogu.org/problemnew/show/T53987" target="_blank" rel="noopener">「T53987」ZJF日记</a></h1><p>最短路计数+次短路求解。</p><p>其实这才应该是签到题啊，然而当初却被排到了T3。不是很懂（</p><p>不过话说回来其实题面写的很好啊。</p><p>sto <strong>多弗桃</strong> orz</p><h2 id="关于SPFA"><a href="#关于SPFA" class="headerlink" title="关于SPFA"></a>关于SPFA</h2><p>他死了。</p><h1 id="「T56269」选择性失忆"><a href="#「T56269」选择性失忆" class="headerlink" title="「T56269」选择性失忆"></a><a href="https://www.luogu.org/problemnew/show/T56269" target="_blank" rel="noopener">「T56269」选择性失忆</a></h1><p>sto <strong>SnoWY</strong> orz</p><p>才刚学了几个月就出这种神仙题，把我这种从初中就开始学OI的菜鸡吊起来打（</p><p>首先我们看到要最小化第$k+1$大的边权。二分？那么问题就转化成了找一条路径，使得其中恰有$k$条边的边权小于某个给定数值。</p><p>emmmmmm……这是什么鬼（</p><p>总之二分大概不大可行。然后我觉得我扯不下去了，直接讲正解吧（</p><p>构造一张$k+1$层的分层图。如果说我们在某一层有一条边从$u$到$v$，边权是$w$，我们就从这一层的$u$，向下一层的$v$连一条$0$权边。然后从最上层的$1$开始跑最短路，路径长度定义为边权最大值，跑到最下层的$n$。然后<code>dis[最下层的n]</code>就是答案。</p><p>那么为什么这样做可行？假设说我们现在跑出了最上层的$n$的<code>dis</code>。现在我们将$n$下压一层，我们肯定会在之前边权最大的那一条边处跨越至下层。这样这条边的边权减为$0$，相当于是说被过滤掉了。不难想象出，如果我们下压$k$层到最底层，边权前$k$大的边就都被过滤掉了，这时路径上的边权最大值就是一开始的$k+1$大。</p><p>相信各位应该都会了，我就不贴代码了。</p><p>然后还是要%SnoWY。</p><p><a href="https://i.loli.net/2018/12/26/5c237e1c077b4.jpg" target="_blank" rel="noopener"></a></p><h1 id="「T62117」复习"><a href="#「T62117」复习" class="headerlink" title="「T62117」复习"></a><a href="https://www.luogu.org/problemnew/show/T62117" target="_blank" rel="noopener">「T62117」复习</a></h1><p>这是一道被线段树踩爆了的分块题。</p><p>每个块内维护总和、正数数量和绝对值最小的负数的绝对值。</p><p>每次加的时候，散块还是暴力重构，整块就判断一下绝对值最小的负数加完会不会变号，会就重构。</p><p>因为保证$k$非负，每个数最多变号一次，也就是说最多重构$n$次，时间复杂度$O(n\sqrt{n})$。</p><p>代码太丢人了不贴了。</p><h1 id="「T64137」「魔板」线段树-2"><a href="#「T64137」「魔板」线段树-2" class="headerlink" title="「T64137」「魔板」线段树 2"></a><a href="https://www.luogu.org/problemnew/show/T64137" target="_blank" rel="noopener">「T64137」「魔板」线段树 2</a></h1><p>这是一道<del>丧心病狂的</del>卡时空块状分块题。</p><p>关于块状分块请看<a href="/block-decomposition/">这里</a>。</p><p>反正也没啥可说的，就是写起来麻烦，我就简单讲一下这题背后的故事吧。</p><p>首先一开始我们定的时空限制是$1\text{s}/4\text{MB}$。然而还是放跑了空间复杂度足够优秀的线段树。然后一气之下删了<code>fread</code>，把空间限制改到$2\text{MB}$，并把时间限制改到$850\text{ms}$。然后有神仙通过将线段树的多个叶子结点合并起来的方法又水过去了。最后空间直接卡到了现在的$1.5\text{MB}$。然后最后两个点询问加到$2\times 10^{6}$，并塞入大量单点操作，才算把该卡的都卡掉了。</p><p>顺便第一次写计分脚本祭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先宣传一波&lt;a href=&quot;https://www.luogu.org/team/show?teamid=11367&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;团队&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="洛谷" scheme="https://github.com/Challestend/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="毒瘤题" scheme="https://github.com/Challestend/tags/%E6%AF%92%E7%98%A4%E9%A2%98/"/>
    
      <category term="题目组" scheme="https://github.com/Challestend/tags/%E9%A2%98%E7%9B%AE%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>关于块状分块的研究报告</title>
    <link href="https://github.com/Challestend/block-decomposition/"/>
    <id>https://github.com/Challestend/block-decomposition/</id>
    <published>2018-12-24T02:27:06.000Z</published>
    <updated>2018-12-29T05:58:09.513Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="输入密码继续阅读" />    <label for="pass">输入密码继续阅读</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">U2FsdGVkX19FMZcLUHUkTovLTVCkZzUp5bHudXca+1ACZbSzYAwvLUR87pr0IMY/G02JqVth9y6uPCKFeunY3URX1RxKaEBtOwBthBkjwFYD69crbV1foQ/2psiGkzRb211O2wyE6XfGUMmh2XAioz6EhhBpBEM5jZlHBPcTpFU76tIWDjERxQQMRGpb57Ym5g9FCkQwyquci2mZXvotk5Ew4Ohk1qjMqYDKM6/mpFyGSb/nlhrGgFcMlc+dYsFn7qVDfjFOkB6SZKW99ERbd4G4bBNqwIUixDJiq+i6N5TKSMjQK5vmkUeF0UH7yPJlgw9EyVuYVOw2wj1HXxhHhbl2rB4PGbe1VD+Pcxhq5lwLg0L3Hxjl8mPtHYJrmP8l8J7aa63d4eRHnsF3NMzDCu8YzoSKASpMHrUkcOdpGtHubaiuGFoPHl5wYLLizUaosb3FCBsrLKJRxnmmxrQfCkkTcG9nS4ZiN+pPAEefdiIklICQXmJfGTrH4uzRF2GvdOPtTWHS6aMXjltP9MOONvYF2VbQsoP1uTi4AEexHgpr92YpVqkcpMLzgXPIkoqFdJdWuqXXHER7raVOOl5I3rd+eEUdJQFrwkt/byYV22ixIO9y21mdgHv+JP+lbZjnFRO4L24XROKyDEPXMqRJr55DAf6tSsieZ38noaR9HOxmG04qnaGvijAg4q+EZQdzkPYl5bOQeLegtgdZIaMOO9HsXoWYFysQfC7D6bFQHRjcm9OwXOastwSc1rBc7+IFLDRyxeaPxBcDOSZCNBhdSLjGRQaaw8MmpZUMOE2Ug5lZV/FS1Ej6bBRVZRKnd7ItGjlzUwLArHDR22ZdsQs0VPRoJUCikoDpFVwPGn0naMT+0Y8dv6OmEgRE/EwoNqmEY/nt4j1Vss4pYjfT4d0gRDUvczXG+bp39vVA12jWQpcHE1sQFWNRvQG5oEhTQb9tIYQSZ0O/QyVN8rkfyY9q/gaKg0gVSFUskglPZ9xA8AyzXsccLGIb0zhP2wHGNn+FRZ8M6MquaWSCibt+kx69K0zMc6A0wvLovFswFAH5N1fAYmRuTgCrr+wnFXRJ0l6RKO9zt+1ATsruqmOyfgE6VVHm2pRfkZiak60S7UldUcLo+4zLPqiZodrHWPwHwZbVCE5LQh7VCWwVGtytDc8BmYBCT17PT6dEzofiiR0ZCy9SxpmugabErd7F4/aX3tLCn3oGE7nLTi3I03d//RYjLg/FvQDxCptDaTYJy/+ZWBR+iOhJ5bUoiKeBbAThizPiO8hW1RZCl5FPe0I9PaDVjRFfYNue8FbtxLeMhh0YxB5BpQE+fqsKn0BbkGg7rhQUnypkICL9+Sc8CQIfA/EbnSkOQ1v7tHXkX3f3Dg0cQ9Un5HQ0t+MEaIRRImBO+5zJOOJpKDOdzaI63nmUR04FhHj2DKj+SdWZynppW5lI9vP5CkfEPD/WpDKg6JASWaiM7SX6cumUj4PwrKLMaqICmeb30K4ElhIk/awmnxYWQIKW3LfhCJlx8pwWa7yXB0tmzx2oD/aEYgEezo8RAbC5ieqYXaouvT43ui2dKDIFAMl4RFzJDrk3w1TOydbDrPBy26GrsjcKrTtVYcg3m+0HGRcLgyiudCo/afc0txFjr0zhB376M1GDSedHMpyHaqzFhT6lwq+YwXH6MbS/7zgp6DfCGscH66XiB13BJY02E+MsumnqUm+Jq35rg0/ReCiQ/jC3IZlqdHXU3aTrqPsom5dumCaJWNhalKPURkZu9RPAWEJHhtECJJRjsUOvK/p/5UlQLREwMzjkzJpthLcDMKDBXVkNYa+G62gwRJQpCcNWeKTAzqyhQDZH5ReisYWz052osLRrMCFymGZ/ZtowtdBjGTFAfbSuQ8WSe3sdVYJYMHKNe1PPXm7B+LuFi5oalBTPDVtpN1bScoefWLr7TDEPDdZ3bY2q8kuphALRh3MWkyz98OuVFCa2SCUn0WRRgpIxQzPeCLLMWR85LFshe/s8Tq7XwJWKbUZZ3WlEZVObrAAPrN+LdEVfF0NjOmqVC/oyN8ILKcG+qU8iGFVSP6SWuJ8qryiJBTtKdRyAzbCC4UBgWyeE+JHDd4OoM5SkJHFETJYWkVDoGTyCNiXCjnPvCjB8uKsnWqp12uY5i4sAY11sA/ChAMBacCt5/6bQhs8elsX7em1Yuc2+nRDLimFWidLcZeN1Ub15L6o9dp+D9QwkOJSDTk/+7NFAt6/I6k9COR+NWGnesyyIxXyF/TnzpWAh8yl9PnxNGhaz2S1wJDNFbq2bygurObKNJC6PYUzYTgsshiOslh/xDiKnvgFFedoTvKg9ay3ThOcJfIFUty0S/Jm9413jo1gMbNOyIvND/zp+3F63+yKEFkQPtGaWDHZt9AglC7N1yMoBc8loJB82C6gVJdzmYcZQ+iJlh2360JfDTHDB6dhilrWSk8Ve96jngPrdcWl4DeaTaJJS3yNkKmc9T/01l+v3H8OlS+NtaijCeY5xDIHT7m5OcUUzBAlOSGtlO6W60WRHOrXfV2+x+H126BS3BL2bg5ibGj5v4OHNGKRFSLLYGgMm4fPvlEiZvbNnxcJnPw557L60SdVcwftb2F1GF4tCovLfGuZs6ipt6s3iRQVBMKRje80/CQIslEU1VVArr5rX2/D7rZGv81roB1AfOIGeFNh5rgbkjAVdpcMKS8j7KhvpMlO2zSMgD++AoAQyPkG2Pq/nm0jBVx6KW+CX29akGZJ/kyeq0YE4XE7KY6UvOrbwZpISrOUo5kQJITBWYt/rd14D9AE1x4bHB/z6beS5wWnEy4oPIrcvBQp8oo1aJPcjs/xYeWaBh7jgIQw5wD2Cgv7DL0sGT4cRrnc1k0EPVI/xumtdglWjOvWJPpeJwhoAuSMDfSzd/I7tDPrXb4VwQfRB2CIODa2hW8hDukhKGmKO2fow+GpC13bs++rpb5wpRzDcDNrEWw51raCwOb3dkt7B22GwqhtmYSooCLK26QCqbuxMUOnNEdeoQiPWKJBNBM7VBjZkUEzLqAS1nD2OwkjrwGlCSLYv1FsbUkVlKxXzdmDGzZGkT28Yqa0OUm7ruXMxipg7ujL8QWxmV8yHO5nnz4Ut18okHkIaIoUXWOpr+3G+A1128ft+XQjn+u98k9Pm4s/r2G2RSEr940XoFOiCI1WPYgLb5jjd4yKfgcbdM8o0r8rY6cYtB9bMaUJI39B3Bm18oc/nmgCVD0GyPFRpWtoNS1GunfRY7gTYNigPMRu6Yd8f1LKHteJtYcuIx+pN5uC7nD+fMsTQrncyBurHYIM8XLZSwjIeY6HlFgOEq9t0Juo0r3HB9PzsZSnAoyArLj5ZixpR+q/xCf3wr6pfMctynQ/8VKHB/FYZo/AJQkTRbw5l0fhQOUUmWf606tf8Rk4VkZGkXah9HD720Oadr1JfCSCIBQArFp+Uyqd+Ck/uFDsM9JSPAtIx1aj/uJk/zNP/mEp+yTvIjIoQ4J0wYVUqS7i6L+YsnkKYeC79Cln/j4/qAvtNiT4Ei2e2HLldQImeJglCZcvcgM1khrxMDxVmPd/lKn3WFrMncpnpsJrmxMBf0IM7m9ZjbGAnx7T/jMeFiYSLH26neSjSVowDG1f8R00w2T8EvTd/6pUp2bV1zYAGf7LSeDYprMke/18r11fZ74hXRjYkpKw1vSI9LNmiGbxjxH+CQyIuDOAlzUvHe0g27AMnUpZVDHXZGP06BK4qdCAq4HkuU0nDC96ppTIXTwyEqkk4KzqZC82g81k4EpI2MJnSFJXSIGnv4uKpeXHM4aOtvcnr6JvbedRWOmfrl4/mGP1CRFrIGrXRrLhySgqoeIzwlS9PETtXsv9IcuM9exnUWxRQwLCQBbMyU1e6R1qfwVkYVgya9xyI184W6/QuRb02ZRqrSHENqKqVHz/rmNAjvs7rEZvL/qMULYMK6nUZfsJ4ylOi+dj9IrzpGPReQt8sxNGs0XnS2BzBGDYBAW3a4eiiFAIyND2VzAogxCwH5PYTVAA34DVe7fLcyf6zmL1ewprz0/LDd2mn6i9nqf9N5oi/U+9a4uV6aE5z/FWClsuki0CXAt46awA05AXL65MU0oR82reMKw5Cna592YkKkjhcskkxypuMqvl7QtxTm+4rfWwTW0fEUzgQ8qTt5vC1DpJjSmu22bNTe3uKyWtOVwYfB6ZQGOWijQj6Rbwr7AhU3Izg9jsQRvRjTJs2Vdiq5oR1WyP6PQGGJf1v4RDGHWQR4jdBR4RfjMXid236ES0lnEXqC81XdC0tj52vQD7L+4WgkzBOr4bLfIkFB+cVXmLzKUfR1MlFz1jq1TzZxgr0GkBalLovmIWKCIs4wA98fyZHfs9OeNP1dylbigOLO5YXOaSyg2iWRxzAXeEbJ4PwnX3GDnodSeznB/U0lc9QKj/kFuveAgsDcasZZFahpYhsnSCSMiG+k16Zn468ie/hp7AqhU0CK6kJhQaEhtJjUVwttYPxR6hZpFGarGoPTD8Lnk4sGCZQXRKBgGC7TeaenF1dX0j5JP0R2fYzqln1XUmfHSrMSxs2F3D543QAkE2mrKkXnGLfOti/uDr9qvaMLrGxIVt09gOCDldQS3IA3QlX/71AF+TGLzFSVv5iV6A6w4AJF0weP9DrOGvuhcBAag1o/D4mzFI0hRcSBVlrVYPra6cGhX8F99DVRJe3SIVZzgMUn9jHOGqscl+rsijnLQlSnWWJRm8oABTBKZ/pQgkRftetiSgG9OS/KSDThe3sqr/se1CwP8tpC4ft/43aGfMJUuSAeglaJAcqwgTaM1r2zrDXUNvSPcIFIxSf1DrmhlbNXfWpOZUzVIKX9muyjbbQ1rzDMjDjjeMwqHeSAU0EqD6aSBHIyu7kTk59ZfmSK/tutmwp3rmwgQp3LsZrOhtJ/VvGKbTZBgBTToQspmyidixpDZYG/bSzy1F8DxkIuDDiKjCFj8lchUxMtbcUZ8laPM8gSg/DnPK43+oOhbq7oHRyrOUYA7jCfjHT53Ae6cjAS6zJSyVm+UPFAkdbpMJCR70RggIegf1EN1fskWeVQMmkEqSGY3JkPRtq5cH0oWHd33YkFgI+TQOw8W5IQKwbhWJQvxQzFqX7VcM1SVEPpukMzb8tuGKb8bCexyN1dmds8RJquY99XfP7sr7sq72b+ZMcOqv6VzwgwkybDbMXqfwKp8iTcJzrB2fjJYMHFquOBfQsyXs54m5C3zMtn4KnMKEMIb9hKgDANCWnAtFL0wvls/cUhozhc3ZsP/IeHkdOC1epPRP4jlddakbpBUKpDxCWo3Kbw1JqG3vfmUcC6O6lKWWJbiydn5APpNMLHcCrkO8LRVBKhsE6+oh7tLR3aFIbbuiqzUcHMZTgxHPpvKMo2Mp2QA8kkE/CL3U8pUjFzTrEniv60oIh+3XCNRcgYNW85r/9nPdm+Yzx8lsCJSuw50hv2YYoOuuHxm2liI4ibknykJ+9jGuEBD9KcPYT+qzXC7DiuEC1G1RFZSR057VHRQ5TeCHHiFqtgm7aOqnM6PhITyHrku9ctbMoGVqdrxBkkPE8qERipE6rprtYlHrGoD85ZysNsPaz0Rcr4dF0vXGvjgfs0fTBmfMz5kng+QmI6yuM5Zkf2FVbcbYEe2hIR7SLV74QFisaRcIY2CL+H809oK79WC+Y5tcfWVEp3gj4auELkFuHAKUihZVUvNk8uJP7cDpz7TXbn8jmELncxuQIambBmWAFosr+7clr+pl+TgdC/kMadAXss71CpqHZRU9dcP8phWBr8Ud6nP0fbBzmcTFvkN1lVtEl+QyZ6FdSmPAMP0Oxc34KSY40j6hOtL4UQSOoSKrOiylmSLkdMSMCiqrsfKNtnyhdmsAPiQmBNIu5zcnRtAtB5jw/lurOL8B6WGiAAPfNIijKb30ty0kIxj+jn5LjnedG3zZ5H9auUwC3xx9nG3ihiTzqKNYl1WJcsLZesX8dWoT0Z7vXzYNZ+nw8NVAOrzZHQfjmCPVv5Hkl/rGCKQ0CAwrQFl9fd7ReG7O0KkeYzODNRh86wtCsyQb+erMsafcowiYq0Vm6ZizF3mZMrXueDhr1lm7a0AgE6fs5fdzHuhuPsQGpFKUnYl7CrId79nEzheq1B4lgtPn0mbkJkF1AsMWjWJPSV2gr3ZaYaoSydkyFS/aiiSNc9r0WMtxPR1cCnzJ0v1yvhmcpLV3FxdQjx0oD+6SOHegzCT/DtKiBoRSc217eGJhJ6xUqzgfTKdzDxFG9ombFkyJhNIgqZ9lz1ucLtG1ZzU42AuAPcTU1Ec83RGiRTWUMrXhVNzsA+qGbXMo3htxzPhtkGT0Ev2emQ+zEiv0YYqO6T+F101w8Iify0ahBubaknv+aW9A+hz8SsZpqr0vgGWYHe51hHoOt1uq1lmsNc13rViZn5BFjK8FTyyiJ3LHAQWmtTkXDSmeyVwDp8L9JAdbEADL0fNxSxcGb0fh2xNI1IQmSB0f90IVS1aN3jHTWWHGS73R8OtaPNaRPSgNhcQEx4fOLUgbqTJiPJd9LcKxboX0sMYFLXuEAiX/HVpo6unsSBj7g+LOHQ4JvnpW2ROabn9bPRtNc5vRMWwR9WBYAng7YbkL1+c98JPBcxz/+VPkGKg+St+V3DrjhYfieH/NqNcHl6VER212vpTdudlFoWmZ3Hzx+X2WfNJOzsQY30Jhz1F2RsuT/gQaaJJY5VQK5jD0fycLeg3mnWWBojW31bd6XjR6cAflfYRQBn+Tm0YP0STI/N0d0kU3PWaH569Te7JI6ud8q0MaetfMq/MLPAfJ4cs4OXrXdwNUR46gYth1Ml/FhuILdy2NRanQ6Xby1BLhSii2t6jkguRgoAjztLVwJyGQ3EsTIz4ouo1EV4CdwRVzNX6oaX4VMSz4os/Ck7VtnmtCxrVlNzuEcynR3A9ZbpojRXADEXKyBMlxIRRnD0wVWJUf7vmWBltG3+wGuqHR1are4W6BrnxnxFKGq+sGvWcuoDWc4IwNErLu64SH94doKeElp+w6oBtn/py40dobf/us8kAvz5KuzmN8KdM4kWMHG+F3g1Rl4nN7lMQ5dAT74R4/f0mqKEJCgADKskswpMxP4L51NcCJ6v5xCYZ25lX5Z5RG9cIbQ3i0va+WX6h4sXTyiYUyKIymdpHwWuckU9Z4Z+fsgby9pDpTYkzcM8+Q+E0T+2yCApWxaI9GCBAXjft4nzK+sQc/eITWTpv+F5Dfotu8JHHxddD0SdN3NFVKCFnephopgsZeuByQiTiH29qQf6OmOGhr2SGiewEb20pBpi9LfmuiU1qSHLM/c2PEGLyJaBwiRxUb9X1TKIOnw6KuzF9dJZ83WhlYZpiitcGu3YdU1CT+AULgx7dmXi685kmJ4qlZHuLw=</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      该文章已被加密
    
    </summary>
    
      <category term="研究报告" scheme="https://github.com/Challestend/categories/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="分块" scheme="https://github.com/Challestend/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="块状分块" scheme="https://github.com/Challestend/tags/%E5%9D%97%E7%8A%B6%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>「多项式学习笔记Part II」多项式的进阶操作</title>
    <link href="https://github.com/Challestend/polynomial-learning-notes-pt2/"/>
    <id>https://github.com/Challestend/polynomial-learning-notes-pt2/</id>
    <published>2018-12-20T08:58:39.000Z</published>
    <updated>2018-12-23T03:26:13.483Z</updated>
    
    <content type="html"><![CDATA[<p>以下，如果不特别声明，则所有运算在模$998244353$意义下进行。</p><a id="more"></a><h3 id="接下来的前置知识"><a href="#接下来的前置知识" class="headerlink" title="接下来的前置知识"></a>接下来的前置知识</h3><h4 id="泰勒展开"><a href="#泰勒展开" class="headerlink" title="泰勒展开"></a>泰勒展开</h4><p>说实话，其实我也不是很能理解这个东西（</p><p>我就凭感觉xjb扯了（</p><p>现在我们有一个函数$f(x)$，我们想要用一个多项式$g(x)$来近似$x$在$x_{0}$附近时$f(x)$的取值。</p><p>我们令</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=0}^{n}g[i](x-x_{0})^{i}</script><p>我们想要让$x\rightarrow x_{0}$时，$g$在$x$处的各阶导数与$f$在$x_{0}$处的各阶导数分别相等。</p><p>我们先考虑$0$阶，也就是原函数。因为$x\rightarrow x_{0}$，所有包含$x-x_{0}$的项都可以忽略，因此我们有</p><script type="math/tex; mode=display">g[0]=f(x_{0})</script><p>然后是$1$阶</p><script type="math/tex; mode=display">g^{\prime}(x)=\sum\limits_{i=1}^{n}ig[i](x-x_{0})^{i-1}=g[1]=f^{\prime}(x_{0})</script><p>再然后是$2$阶</p><script type="math/tex; mode=display">g^{\prime\prime}(x)=\sum\limits_{i=2}^{n}i(i-1)g[i](x-x_{0})^{i-2}=2g[2]=f^{\prime\prime}(x_{0})</script><p>最后是$3$阶</p><script type="math/tex; mode=display">g^{\prime\prime\prime}(x)=\sum\limits_{i=3}^{n}i(i-1)(i-2)g[i](x-x_{0})^{i-3}=6g[3]=f^{\prime\prime\prime}(x_{0})</script><p>我们发现$g[n]$有如下的规律</p><script type="math/tex; mode=display">g[n]=\cfrac{f^{(n)}(x_{0})}{n!}</script><p>综上所述</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=0}^{n}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><p><del>应该吧（</del></p><h4 id="多项式牛顿迭代"><a href="#多项式牛顿迭代" class="headerlink" title="多项式牛顿迭代"></a>多项式牛顿迭代</h4><p>考虑一个$n-1$次多项式$F(x)$，我们希望求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">F(G(x))\equiv 0\pmod{x^{n}}</script><p>我们采用倍增的思想，假设我们已经求出了一个$G_{0}$使得</p><script type="math/tex; mode=display">F(G_{0})\equiv 0\pmod{x^{t}}</script><p>我们希望求出一个$G$使得</p><script type="math/tex; mode=display">F(G)\equiv 0\pmod{x^{2t}}</script><p>我们将$F$在$G_{0}$这里进行泰勒展开：</p><script type="math/tex; mode=display">\begin{aligned}F(G)&=F(G_{0})\\&+F^{\prime}(G_{0})(G-G_{0})\\&+\cfrac{F^{\prime\prime}(G_{0})}{2}(G-G_{0})^{2}\\&+\cdots\end{aligned}</script><p>注意到</p><script type="math/tex; mode=display">\begin{aligned}F(G)-F(G_{0})&\equiv 0\pmod{x^{t}}\\G-G_{0}&\equiv 0\pmod{x^{t}}\end{aligned}</script><p>也就是说$G-G_{0}$的最低非零系数的项数大于等于$t$，$(G-G_{0})^{k}$的最低非零系数的项数大于等于$kt$，从而我们有</p><script type="math/tex; mode=display">\begin{aligned}F(G)&\equiv F(G_{0})+F^{\prime}(G_{0})(G-G_{0})\pmod{x^{2t}}\\F^{\prime}(G_{0})G&\equiv F^{\prime}(G_{0})G_{0}-F(G_{0})\pmod{x^{2t}}\\G&\equiv G_{0}-\cfrac{F(G_{0})}{F^{\prime}(G_{0})}\pmod{x^{2t}}\end{aligned}</script><p>然后我们就一直倍增，倍增到$t\geqslant n$为止，此时$G_{0}$即为所求多项式。</p><h3 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a><a href="https://www.luogu.org/problemnew/show/P4238" target="_blank" rel="noopener">多项式求逆</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">F(x)\times G(x)\equiv 1\pmod{x^{n}}</script><p>假设我们已经求出了$G_{0}$使得</p><script type="math/tex; mode=display">F\times G_{0}\equiv 1\pmod{x^{t}}</script><p>我们希望找到一个$G$使得</p><script type="math/tex; mode=display">F\times G\equiv 1\pmod{x^{2t}}</script><p>据说能用牛顿迭代推，然而我不会（</p><p>考虑正常一点的方式<del>，虽然说还是倍增</del>。</p><script type="math/tex; mode=display">\begin{aligned}F\times G-F\times G_{0}&\equiv 0\pmod{x^{t}}\\G-G_{0}&\equiv 0\pmod{x^{t}}\\(G-G_{0})^{2}&\equiv 0\pmod{x^{2t}}\\G^{2}-2GG_{0}+G_{0}^{2}&\equiv 0\pmod{x^{2t}}\end{aligned}</script><p>两边同时乘$F$</p><script type="math/tex; mode=display">\begin{aligned}G-2G_{0}+FG_{0}^{2}&\equiv 0\pmod{x^{2t}}\\G&\equiv 2G_{0}-FG_{0}^{2}\pmod{x^{2t}}\end{aligned}</script><p>边界条件也很明显，就是当$t=1$时，$G[0]\equiv F[0]^{-1}$。</p><p>说起来是很简单对吧……然而我真正开始写了才发现自己就是个傻子啥也不会（</p><p>关于代码……现在还不是时候（</p><p>后面有一道超级综合题在等着我们（</p><h3 id="多项式对数函数"><a href="#多项式对数函数" class="headerlink" title="多项式对数函数"></a><a href="https://www.luogu.org/problemnew/show/P4725" target="_blank" rel="noopener">多项式对数函数</a></h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">G(x)\equiv\ln F(x)\pmod{x^{n}}</script><p>对上式两边求导</p><script type="math/tex; mode=display">G^{\prime}\equiv F^{\prime}\ln^{\prime}F\pmod{x^{n}}</script><p>又因为</p><script type="math/tex; mode=display">\ln^{\prime}x=\frac{1}{x}</script><p>我们就得到</p><script type="math/tex; mode=display">G^{\prime}\equiv\cfrac{F^{\prime}}{F}\pmod{x^{n}}</script><p>求导+求逆+不定积分即可。</p><h3 id="多项式指数函数"><a href="#多项式指数函数" class="headerlink" title="多项式指数函数"></a><a href="https://www.luogu.org/problemnew/show/P4726" target="_blank" rel="noopener">多项式指数函数</a></h3><p>超级综合题来了。</p><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">G(x)\equiv e^{F(x)}\pmod{x^{n}}</script><p>首先</p><script type="math/tex; mode=display">\ln G-F\equiv 0\pmod{x^{n}}</script><p>我们把$F$看成是常数项，定义函数</p><script type="math/tex; mode=display">A(G)=\ln G-F</script><script type="math/tex; mode=display">A^{\prime}(G)=\ln^{\prime}G=\cfrac{1}{G}</script><p>套牛顿迭代</p><script type="math/tex; mode=display">\begin{aligned}G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\&\equiv G_{0}(1-\ln G_{0}+F)\pmod{x^{2t}}\end{aligned}</script><p>然后把以上提到的所有板子全都复制过来就行了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line"><span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ih==it)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *ih++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">oh=cltout;</span><br><span class="line">&#125;</span><br><span class="line">*oh++=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=gc();</span><br><span class="line"><span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">sn=<span class="number">-1</span>,c=gc();</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">x*=sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">pc(<span class="number">45</span>),x=-x;</span><br><span class="line"><span class="keyword">if</span>(!x)</span><br><span class="line">pc(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">pc(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>],tmp3[maxn+<span class="number">1</span>],tmp4[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">swap(F[i],F[rev[i]]);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">F[j]=(x+y)%mod;</span><br><span class="line">F[j+p]=(x-y+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">tmp1[k]=F[k];</span><br><span class="line">NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">NTT(G,j,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">NTT(G,j,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">G[k]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">tmp1[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">Inv(F,tmp2,n);</span><br><span class="line">re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">NTT(G,N,<span class="number">0</span>);</span><br><span class="line">NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">NTT(G,N,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">G[i]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">tmp2[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Exp</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">2</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">Ln(G,tmp3,i);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;++k)</span><br><span class="line">tmp4[k]=F[k];</span><br><span class="line">NTT(tmp3,j,<span class="number">0</span>);</span><br><span class="line">NTT(tmp4,j,<span class="number">0</span>);</span><br><span class="line">NTT(G,j,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">G[k]=((<span class="number">1L</span>L-tmp3[k]+tmp4[k])%mod+mod)*G[k]%mod;</span><br><span class="line">NTT(G,j,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">tmp3[k]=tmp4[k]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">cltstream::read(n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">cltstream::read(F[i]);</span><br><span class="line">Exp(F,G,n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">cltstream::write(G[i],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">clop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项式开平方根"><a href="#多项式开平方根" class="headerlink" title="多项式开平方根"></a>多项式开平方根</h3><p>给你一个$n-1$次多项式$F(x)$，让你求出一个多项式$G(x)$，使得</p><script type="math/tex; mode=display">G^{2}(x)\equiv F(x)\pmod{x^{n}}</script><p>牛顿迭代吼啊！</p><script type="math/tex; mode=display">A(G)=G^{2}-F</script><script type="math/tex; mode=display">A^{\prime}(G)=2G</script><script type="math/tex; mode=display">\begin{aligned}G&\equiv G_{0}-\cfrac{A(G_{0})}{A{^\prime}(G_{0})}\\&\equiv G_{0}-\cfrac{G_{0}^{2}-F}{2G_{0}}\\&\equiv\cfrac{G_{0}^{2}+F}{2G_{0}}\\&=\cfrac{1}{2}(G_{0}+\cfrac{F}{G_{0}})\pmod{x^{2t}}\end{aligned}</script><p><del>复制粘贴吼啊！</del></p><h3 id="我刚才都学了些啥破玩意"><a href="#我刚才都学了些啥破玩意" class="headerlink" title="我刚才都学了些啥破玩意"></a>我刚才都学了些啥破玩意</h3><p><a href="http://codeforces.com/contest/438/problem/E" target="_blank" rel="noopener">一道例题</a>。</p><p><a href="https://www.luogu.org/problemnew/show/CF438E" target="_blank" rel="noopener">Remote Judge</a>。</p><p>这是读题前的我：</p><p><img src="https://i.loli.net/2018/12/21/5c1c3e4d32b6f.gif" alt=""></p><p>这是读题后的我：</p><p><img src="https://i.loli.net/2018/12/21/5c1c3e4d34c6e.jpg" alt=""></p><p>这是知道了这题正解是多项式开平方根后的我：</p><p><img src="https://i.loli.net/2018/12/21/5c1c3f327ea74.jpg" alt=""></p><p>我……我怕不是学了个假的多项式哦（</p><p>厚颜无耻地抄题解（</p><p>首先我们搞出生成函数（然而并不是很懂）</p><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{m}G[i]x^{i}</script><p>其中</p><script type="math/tex; mode=display">G[i]=[i\in\{c_{1},c_{2},\cdots,c_{n}\}]</script><p>定义$F[i]$表示权值为$i$的神犇二叉树的数量，我们有</p><script type="math/tex; mode=display">F[0]=1</script><script type="math/tex; mode=display">F[x]=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]</script><p>就是先枚举根节点权值（$i$），再枚举左子树权值（$j$），然后算出右子树权值（$x-i-j$）。</p><p>然后是一些神仙操作</p><script type="math/tex; mode=display">\begin{aligned}F[x]&=\sum\limits_{i=0}^{x}G[i]\sum\limits_{j=0}^{x-i}F[j]F[x-i-j]\\&=\sum\limits_{i=0}^{x}G[i]F^{2}[x-i]\\&=(GF^{2})[x]\end{aligned}</script><p>令人窒息（</p><p>然后我们就有</p><script type="math/tex; mode=display">GF^{2}+1=F</script><p>但是为什么要$+1$？因为$F(0)=F[0]=1$而$G(0)=G[0]=0$。</p><p>于是解上面这个一元二次方程，我们得到</p><script type="math/tex; mode=display">F=\cfrac{1\pm\sqrt{1-4G}}{2G}</script><p>但是这个形式还是不是很好搞，我们将分子分母同时乘$(1\mp\sqrt{1-4G})$，然后化简一波</p><script type="math/tex; mode=display">F=\cfrac{2}{1\mp\sqrt{1-4G}}</script><p>如果根号前取负，代入$x=0$，分母就减成$0$了；而如果取正，我们就得到很健康的$\cfrac{2}{2}=1$。综上所述</p><script type="math/tex; mode=display">F=\cfrac{2}{1+\sqrt{1-4G}}</script><p>本来接下来应该有代码实现的，但是<del>我拒绝</del>咕咕咕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下，如果不特别声明，则所有运算在模$998244353$意义下进行。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="FFT" scheme="https://github.com/Challestend/tags/FFT/"/>
    
      <category term="NTT" scheme="https://github.com/Challestend/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>「多项式学习笔记Part I」最基本的多项式乘法</title>
    <link href="https://github.com/Challestend/polynomial-learning-notes-pt1/"/>
    <id>https://github.com/Challestend/polynomial-learning-notes-pt1/</id>
    <published>2018-12-19T12:23:01.000Z</published>
    <updated>2018-12-25T00:58:11.054Z</updated>
    
    <content type="html"><![CDATA[<p>最近正好月考，然而并不想去月考，于是来颓blog吧。</p><a id="more"></a><p>给你一个$n-1$次多项式$F(x)$和一个$m-1$次多项式$G(x)$，让你求$(F\times G)(x)$的各项系数。$n,m\leqslant 10^{6}$。</p><p>我们不妨将$F(x)$的$i$次项系数记为$F[i]$</p><script type="math/tex; mode=display">F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{m-1}G[i]x^{i}</script><script type="math/tex; mode=display">(F\times G)(x)=\sum\limits_{i=0}^{n-1}\sum\limits_{j=0}^{m-1}F[i]G[j]x^{i+j}</script><script type="math/tex; mode=display">(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>不难发现直接暴力算是$O(n^{2})$的，因此我们需要优化。</p><p>不过为了优化，我们得先扯远点。</p><h1 id="点值表达"><a href="#点值表达" class="headerlink" title="点值表达"></a>点值表达</h1><p>如果我们选取$n$个点$(x_{0},y_{0}),(x_{1},y_{1}),\cdots,(x_{n-1},y_{n-1})$，并且其中$x_{i}$两两不同，我们就可以唯一地确定出一个$n-1$次多项式。</p><p>就比如说</p><script type="math/tex; mode=display">(0,2),(1,7),(2,4)</script><p><del>瞎写的（</del></p><p>我们可以列出如下的三元一次方程组：</p><script type="math/tex; mode=display">\begin{cases}&\text{C}=2\\&\text{A}+\text{B}+\text{C}=7\\&4\text{A}+2\text{B}+\text{C}=4\end{cases}</script><p>解得</p><script type="math/tex; mode=display">\begin{cases}&\text{A}=-4\\&\text{B}=9\\&\text{C}=2\end{cases}</script><p>注意到$(F\times G)(x)=F(x)G(x)$<del>（废话）</del>，我们只要知道了$F(x)$和$G(x)$的点值表达，就可以$O(n)$的计算出$(F\times G)(x)$的点值表达了。因为$(F\times G)(x)$的次数是$n+m-2$，我们选出前$n+m-1$个自然数即可。</p><p>但是这还不够。注意到，如果我们选取的点的横坐标如果很普通，我们首先需要$O(n^{2})$转成点值表达，乘完之后又要转回系数表达，效率甚至不如暴力（</p><p>于是我们还需要优化，于是我们还需要再扯远一点。</p><h1 id="复数"><a href="#复数" class="headerlink" title="复数"></a>复数</h1><p>对，你没看错，扯到复数了。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>根据初中学习的数学知识，我们知道有些一元二次方程是没有实数根的。就比如说</p><script type="math/tex; mode=display">x^{2}+1=0</script><p>我们知道，它的判别式是$\Delta=b^{2}-4ac=-4\lt 0$，因此它没有实数根。</p><p>于是我们就定义了虚数单位$i$，并规定$i^{2}=-1$。形如$x+yi$这样的数被称为复数。它的模长被定义为它到原点的距离，即$\sqrt{x^{2}+y^{2}}$；幅角被定义为与$x$轴正半轴的夹角，即$\operatorname{tan}^{-1}\cfrac{y}{x}$。</p><p>因为$i$不是实数，它不能被画在我们现有的数轴上。那我们就再拿来一条数轴，将两条数轴垂直放置，垂足为原点。或者说，我们可以将这理解成平面直角坐标系，$x$就是实轴，$y$轴就是虚轴，$x+yi$就对应了点$(x,y)$。</p><p><img src="https://i.loli.net/2018/12/19/5c1a46b4d785b.png" alt=""></p><p>上图展示了$4+i$和$3+4i$。</p><p>复数的运算其实没什么出乎意料的：</p><script type="math/tex; mode=display">(x_{1}+y_{1}i)+(x_{2}+y_{2}i)=(x_{1}+x_{2})+(y_{1}+y_{2})i</script><script type="math/tex; mode=display">(x_{1}+y_{1}i)-(x_{2}+y_{2}i)=(x_{1}-x_{2})+(y_{1}-y_{2})i</script><script type="math/tex; mode=display">(x_{1}+y_{1}i)(x_{2}+y_{2}i)=(x_{1}x_{2}-y_{1}y_{2})+(x_{1}y_{2}+x_{2}y_{1})i</script><script type="math/tex; mode=display">\begin{aligned}\cfrac{x_{1}+y_{1}i}{x_{2}+y_{2}i}&=\cfrac{(x_{1}+y_{1}i)(x_{2}-y_{2}i)}{(x_{2}+y_{2}i)(x_{2}-y_{2}i)}\\&=\cfrac{(x_{1}x_{2}+y_{1}y_{2})+(x_{2}y_{1}-x_{1}y_{2})i}{x_{2}^{2}+y_{2}^{2}}\\&=\cfrac{x_{1}x_{2}+y_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}+\cfrac{x_{2}y_{1}-x_{1}y_{2}}{x_{2}^{2}+y_{2}^{2}}i\end{aligned}</script><p>我们来单独考虑一下复数相乘的几何意义。</p><p>假设我们有两个复数$c_{1}$，$c_{2}$，它们的模长分别是$r_{1}$，$r_{2}$，幅角分别是$\alpha_{1}$，$\alpha_{2}$。不难发现我们有</p><script type="math/tex; mode=display">c_{1}=r_{1}(\operatorname{cos}\alpha_{1}+i\operatorname{sin}\alpha_{1})</script><script type="math/tex; mode=display">c_{2}=r_{2}(\operatorname{cos}\alpha_{2}+i\operatorname{sin}\alpha_{2})</script><script type="math/tex; mode=display">\begin{aligned}c_{1}c_{2}&=r_{1}r_{2}(\cos\alpha_{1}+i\sin\alpha_{1})(\cos\alpha_{2}+i\sin\alpha_{2})\\&=r_{1}r_{2}(\cos\alpha_{1}\cos\alpha_{2}+i\cos\alpha_{1}\sin\alpha_{2}+i\sin\alpha_{1}\cos\alpha_{2}-\sin\alpha_{1}\sin\alpha_{2})\\&=r_{1}r_{2}[\cos(\alpha_{1}+\alpha_{2})+i\sin(\alpha_{1}+\alpha_{2})]\end{aligned}</script><p>总结成一句话，就是「模长相乘，幅角相加」。</p><h2 id="单位圆与单位根"><a href="#单位圆与单位根" class="headerlink" title="单位圆与单位根"></a>单位圆与单位根</h2><p>单位圆就是指半径为$1$的圆。不过一般我们都是把它画在原点的。</p><p><img src="https://i.loli.net/2018/12/20/5c1b06e5602fa.png" alt=""></p><p>考虑这么一个方程</p><script type="math/tex; mode=display">x^{n}=1</script><p>它的所有复数根。</p><p>因为复数相乘意味着模长相乘，如果一个复数的$n$次方等于$1$，它自身的模长也应该是$1$。如果它的幅角是$a$，我们应该有</p><script type="math/tex; mode=display">2\pi\mid na</script><script type="math/tex; mode=display">\cfrac{2\pi}{n}\mid a</script><p>不难想象出我们有$n$个这样的复数，它们的幅角通式是$\cfrac{2k\pi}{n}(k\in[0,n)\cap\mathbb{Z})$。我们称其中幅角等于$\cfrac{2\pi}{n}$的复数，即$\cos\cfrac{2\pi}{n}+i\sin\cfrac{2\pi}{n}$为$n$次单位根$\omega_{n}$，我们就可以把这$n$个复数表示为$\omega_{n}^{k}(k\in[0,n)\cap\mathbb{Z})$。</p><p>它有如下的一些性质</p><script type="math/tex; mode=display">\omega_{2n}^{2k}=\omega_{n}^{k}</script><p>因为它们的模长都是$1$，幅角相等就相等了。</p><p>然后就没了，读者自证不难（</p><script type="math/tex; mode=display">\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}</script><p>因为$\omega_{n}^{\frac{n}{2}}$的幅角是$\cfrac{2\times\frac{n}{2}\pi}{n}=\pi$，不难发现它就是$-1$了。</p><h1 id="快速傅里叶变换（Fast-Fourier-Transformation）"><a href="#快速傅里叶变换（Fast-Fourier-Transformation）" class="headerlink" title="快速傅里叶变换（Fast Fourier Transformation）"></a>快速傅里叶变换（Fast Fourier Transformation）</h1><h2 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h2><p>那么问题来了，我们刚才扯了这么些，有什么用呢？</p><p>就是说，有个叫「让·巴普蒂斯·约瑟夫·傅里叶」（Jean Baptiste Joseph Fourier）的神仙有一天大开脑洞，掏出$n$次单位根想要求点值表达。</p><p>首先，我们通过在高次补$0$的方式，将这个多项式的项数（也就是次数$+1$）补到$2$的非负整数次幂。</p><p>然后一巴掌把这个多项式拍成两半，按奇偶性拼成两个多项式：</p><script type="math/tex; mode=display">\begin{aligned}F_{1}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i]x^{i}\\&=F[0]x^{0}+F[2]x^{1}+\cdots+F[n-2]x^{\frac{n}{2}-1}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}F_{2}(x)&=\sum\limits_{i=0}^{\frac{n}{2}-1}F[2i+1]x^{i}\\&=F[1]x^{0}+F[3]x^{1}+\cdots+F[n-1]x^{\frac{n}{2}-1}\end{aligned}</script><p>于是我们有</p><script type="math/tex; mode=display">F(x)=F_{1}(x^{2})+xF_{2}(x^{2})</script><p>现在我们假设$0\leqslant k&lt;\cfrac{n}{2}$，将$x=\omega_{n}^{k}$和$x=\omega_{n}^{k+\frac{n}{2}}$代入</p><script type="math/tex; mode=display">\begin{aligned}F(\omega_{n}^{k})&=F_{1}(\omega_{n}^{2k})+\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\&=F_{1}(\omega_{\frac{n}{2}}^{k})+\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}F(\omega_{n}^{k+\frac{n}{2}})&=F_{1}(\omega_{n}^{2k+n})+\omega_{n}^{k+\frac{n}{2}}F_{2}(\omega_{n}^{2k+n})\\&=F_{1}(\omega_{n}^{2k})-\omega_{n}^{k}F_{2}(\omega_{n}^{2k})\\&=F_{1}(\omega_{\frac{n}{2}}^{k})-\omega_{n}^{k}F_{2}(\omega_{\frac{n}{2}}^{k})\end{aligned}</script><p>我们注意到，如果说我们求出了$F_{1}(x)$和$F_{2}(x)$的点值表达，我们就能够$O(n)$地求出$F(x)$的点值表达了。至此，我们不难想到分治，边界条件就是$n=1$，这时什么也不用做直接返回即可。</p><p>简单地贴一下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">complex</span> F1[n&gt;&gt;<span class="number">1</span>],F2[n&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">2</span>)&#123;</span><br><span class="line">    F1[i]=F[<span class="number">2</span>*i];</span><br><span class="line">        F2[i]=F[<span class="number">2</span>*i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    work(F1,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    work(F2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    complex unit(cos(2*Pi/n),sin(2*Pi/n)),tmp=1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i,tmp=tmp*unit)&#123;</span><br><span class="line">    <span class="keyword">complex</span> w=F2[i+(n&gt;&gt;<span class="number">1</span>)]*tmp;</span><br><span class="line">        F[i]=F1[i]+w;</span><br><span class="line">        F[i+(n&gt;&gt;<span class="number">1</span>)]=F1[i]-w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，以上代码是我现写出来的，<del>保证其不正确性</del>不保证其正确性。</p><p>不过，这样递归运算效率还是太低了。我们来考虑一下，递归到底层后，<code>F</code>数组的每一个位置上实际存的是几次项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7</span><br><span class="line">0 2 4 6|1 3 5 7</span><br><span class="line">0 4|2 6|1 5|3 7</span><br><span class="line">0|4|2|6|1|5|3|7</span><br></pre></td></tr></table></figure><p>写成二进制看看：</p><div class="table-container"><table><thead><tr><th style="text-align:center">位置（十进制）</th><th style="text-align:center">位置（二进制）</th><th style="text-align:center">次数（十进制）</th><th style="text-align:center">次数（二进制）</th></tr></thead><tbody><tr><td style="text-align:center">$0$</td><td style="text-align:center">$000$</td><td style="text-align:center">$0$</td><td style="text-align:center">$000$</td></tr><tr><td style="text-align:center">$1$</td><td style="text-align:center">$001$</td><td style="text-align:center">$4$</td><td style="text-align:center">$100$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$010$</td><td style="text-align:center">$2$</td><td style="text-align:center">$010$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$011$</td><td style="text-align:center">$6$</td><td style="text-align:center">$110$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$100$</td><td style="text-align:center">$1$</td><td style="text-align:center">$001$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$101$</td><td style="text-align:center">$5$</td><td style="text-align:center">$101$</td></tr><tr><td style="text-align:center">$6$</td><td style="text-align:center">$110$</td><td style="text-align:center">$3$</td><td style="text-align:center">$011$</td></tr><tr><td style="text-align:center">$7$</td><td style="text-align:center">$111$</td><td style="text-align:center">$7$</td><td style="text-align:center">$111$</td></tr></tbody></table></div><p>注意到两边的数字的二进制是镜像的。也就是说，我们只要把位置编号的二进制位的最后$\operatorname{log}n$位左右镜像过来，就可以得到递归到最底层后，这个位置上的系数所对应的项的次数了。</p><p>我们可以$O(n)$地处理处每个数的镜像：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>中间有一个位或运算符，我们以它为分界线，将上面这行代码分成左右两部分。左边就是$i$这个数除了最后一位以外的所有位的镜像；右边特判了一下$i$的最后一位是否为$1$，如果是的话，就在最高位补一个$1$。</p><p>接下来的步骤我不是很能解释得清楚，因为我也是背的板子。总之这个东西写出来差不多长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">complex</span>* F,<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">swap(F[i],F[rev[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">complex unit(cos(Pi/p),sin(Pi/p));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line"><span class="function"><span class="keyword">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line"><span class="keyword">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">F[j+p]=F[j]-tmp;</span><br><span class="line">F[j]=F[j]+tmp;</span><br><span class="line">cur=cur*unit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在还差最后一步，将点值表达转回系数表达。我们将$F(\omega_{n}^{0}),F(\omega_{n}^{1}),\cdots,F(\omega_{n}^{n-1})$分别记为$y_{0},y_{1},\cdots,y_{n-1}$，我们求点值的过程可以用矩阵表达成这样：</p><script type="math/tex; mode=display">\begin{bmatrix}&(\omega_{n}^{0})^{0}&(\omega_{n}^{0})^{1}&\cdots&(\omega_{n}^{0})^{n-1}&\\&(\omega_{n}^{1})^{0}&(\omega_{n}^{1})^{1}&\cdots&(\omega_{n}^{1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&(\omega_{n}^{n-1})^{0}&(\omega_{n}^{n-1})^{1}&\cdots&(\omega_{n}^{n-1})^{n-1}\\\end{bmatrix}\begin{bmatrix}&F[0]&\\&F[1]\\&\vdots\\&F[n-1]\end{bmatrix}=\begin{bmatrix}&y_{0}&\\&y_{1}\\&\vdots\\&y_{n-1}\end{bmatrix}</script><p>我们可以试图寻找左边那个矩阵的逆矩阵。直接摆结论的话，它差不多长这样：</p><script type="math/tex; mode=display">\begin{bmatrix}&\frac{1}{n}(\omega_{n}^{0})^{0}&\frac{1}{n}(\omega_{n}^{0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{0})^{n-1}&\\&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\\end{bmatrix}</script><p>现在我们要证明这两个矩阵乘起来是单位矩阵。令第一个矩阵为$A$，第二个矩阵为$B$，$A\times B=C$。不难发现$A[i][j]=\omega_{n}^{ij}$，$B[i][j]=\cfrac{1}{n}\omega_{n}^{-ij}$，我们有</p><script type="math/tex; mode=display">\begin{aligned}C[i][j]&=\sum\limits_{k=0}^{n-1}A[i][k]B[k][j]\\&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{ik-kj}\end{aligned}</script><p>若$i=j$，不难发现此时$C[i][j]=1$。</p><p>否则，即$i\neq j$，设$i-j=l$，我们有</p><script type="math/tex; mode=display">\begin{aligned}C[i][j]&=\sum\limits_{k=0}^{n-1}\cfrac{1}{n}\omega_{n}^{lk}\\&=\cfrac{\omega_{n}^{ln}-1}{n(\omega_{n}^{l}-1)}\\&=\cfrac{1-1}{n(\omega_{n}^{l}-1)}\\&=0\end{aligned}</script><p>综上所述，矩阵$C$是单位矩阵，因此矩阵$B$是矩阵$A$的逆矩阵。</p><p>因此我们有</p><script type="math/tex; mode=display">\begin{bmatrix}&\frac{1}{n}(\omega_{n}^{-0})^{0}&\frac{1}{n}(\omega_{n}^{-0})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-0})^{n-1}&\\&\frac{1}{n}(\omega_{n}^{-1})^{0}&\frac{1}{n}(\omega_{n}^{-1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-1})^{n-1}\\&\vdots&\vdots&\ddots&\vdots\\&\frac{1}{n}(\omega_{n}^{-n+1})^{0}&\frac{1}{n}(\omega_{n}^{-n+1})^{1}&\cdots&\frac{1}{n}(\omega_{n}^{-n+1})^{n-1}\\\end{bmatrix}\begin{bmatrix}&y_{0}&\\&y_{1}\\&\vdots\\&y_{n-1}\end{bmatrix}=\begin{bmatrix}&F[0]&\\&F[1]\\&\vdots\\&F[n-1]\end{bmatrix}</script><p>注意到这个过程和我们之前将系数转化为点值表达的过程极为相似。这就是在启示我们，如果说我们把之前用的$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$换成$\omega_{n}^{0},\omega_{n}^{-1},\cdots,\omega_{n}^{-n+1}$，然后对着点值表达来一遍FFT，然后再除以$n$，就得到了原多项式的系数了。</p><p>注意到这两个过程只有用到的单位根不一样，我们可以将上面那段代码的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex unit(cos(Pi/p),sin(Pi/p));</span><br></pre></td></tr></table></figure><p>改成</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br></pre></td></tr></table></figure><p>然后调用时再传一个参数<code>tp</code>进去。<code>tp=1</code>表示是系数转点值，<code>tp=-1</code>表示是点值转系数。</p><p>完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">r=_r;</span><br><span class="line">c=_c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">complex</span> F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">_tp tmp=x;</span><br><span class="line">x=y;</span><br><span class="line">y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="keyword">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">swap(F[i],F[rev[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">register complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">F[j+p]=F[j]-tmp;</span><br><span class="line">F[j]=F[j]+tmp;</span><br><span class="line">cur=cur*unit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">++n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;F[i].r);</span><br><span class="line">++m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;G[i].r);</span><br><span class="line"><span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">FAQ(F,<span class="number">1</span>);</span><br><span class="line">FAQ(G,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">F[i]=F[i]*G[i];</span><br><span class="line">FAQ(F,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0.0lf "</span>,F[i].r/n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不要问我<code>cltstream</code>哪去了（</del></p><p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P3803" target="_blank" rel="noopener">板子题</a>了。</p><p>其实上面的代码是我从另一道题里复制过来然后现改的，说不定会改出错（</p><p>最好还是自己写吧（</p><p>什么？想知道是哪道题？往下看（</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="「ZJOI2014」力"><a href="#「ZJOI2014」力" class="headerlink" title="「ZJOI2014」力"></a><a href="https://www.luogu.org/problemnew/show/P3338" target="_blank" rel="noopener">「ZJOI2014」力</a></h3><p>这是一道裸的卷积题。</p><p>考虑两个长度为$n$的数组$F$和$G$，现在我们想求一个数组$H$，它满足</p><script type="math/tex; mode=display">H[i]=\sum\limits_{j=0}^{i}F[j]G[i-j]=\sum\limits_{0\leqslant j<n,0\leqslant k<n,j+k=i}F[j]G[k]</script><p>在本页面往上翻，翻到这个式子：</p><script type="math/tex; mode=display">(F\times G)[k]=\sum\limits_{0\leqslant i<n,0\leqslant j<m,i+j=k}F[i]G[j]</script><p>发现了吗？这两个过程其实是一样的。</p><p>于是，我们如下构造两个多项式</p><script type="math/tex; mode=display">F(x)=\sum\limits_{i=0}^{n-1}F[i]x^{i}</script><script type="math/tex; mode=display">G(x)=\sum\limits_{i=0}^{n-1}G[i]x^{i}</script><p>然后直接一波FFT套上去，输出次数最低的$n$项的系数就好。</p><p>那么这题呢？首先我们把$j\lt i$和$j\gt i$分开计算。</p><p>先考虑$j\lt i$，令$F[i]=q_{i}$，$G[i]=\begin{cases}&amp;\cfrac{1}{i^{2}}\;\;&amp;(i\gt 0)\\&amp;0&amp;(i=0)\end{cases}$，那么</p><script type="math/tex; mode=display">\begin{aligned}E_{i}&=\sum_{j=0}^{i-1}F[j]G[i-j]\\&=\sum_{j=0}^{i}F[j]G[i-j]\end{aligned}</script><p>直接套板子就行。</p><p>对于$j&gt;i$的情况，我们将数组$F$左右翻转，然后继续套板子就行（</p><p>具体还是看代码吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>\lt cstdio&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi=<span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> rev[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line"><span class="keyword">double</span> r,c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">complex</span>(<span class="keyword">double</span> _r=<span class="number">0</span>,<span class="keyword">double</span> _c=<span class="number">0</span>)&#123;</span><br><span class="line">r=_r;</span><br><span class="line">c=_c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">complex</span> F1[maxn+<span class="number">1</span>],F2[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.r+b.r,a.c+b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.r-b.r,a.c-b.c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span>&amp; a,<span class="keyword">complex</span>&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">complex</span>(a.r*b.r-a.c*b.c,a.r*b.c+a.c*b.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">_tp tmp=x;</span><br><span class="line">x=y;</span><br><span class="line">y=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FAQ</span><span class="params">(<span class="keyword">complex</span> F[],<span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">swap(F[i],F[rev[i]]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> len=<span class="number">2</span>,p=<span class="number">1</span>;len&lt;=n;len&lt;&lt;=<span class="number">1</span>,p&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">register complex unit(cos(Pi/p),tp*sin(Pi/p));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=len)&#123;</span><br><span class="line"><span class="function"><span class="keyword">register</span> <span class="keyword">complex</span> <span class="title">cur</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">complex</span> tmp=F[j+p]*cur;</span><br><span class="line">F[j+p]=F[j]-tmp;</span><br><span class="line">F[j]=F[j]+tmp;</span><br><span class="line">cur=cur*unit;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;F1[i].r);</span><br><span class="line">F2[n-i<span class="number">-1</span>].r=F1[i].r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">G[i]=<span class="number">1.0</span>/i/i;</span><br><span class="line"><span class="keyword">for</span>(m=n,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">n&lt;&lt;=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">FAQ(G,<span class="number">1</span>);</span><br><span class="line">FAQ(F1,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">F1[i]=F1[i]*G[i];</span><br><span class="line">FAQ(F1,<span class="number">-1</span>);</span><br><span class="line">FAQ(F2,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">F2[i]=F2[i]*G[i];</span><br><span class="line">FAQ(F2,<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lf\n"</span>,(F1[i].r-F2[m-i<span class="number">-1</span>].r)/n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数论变换（Number-Theoretic-Transformation）"><a href="#数论变换（Number-Theoretic-Transformation）" class="headerlink" title="数论变换（Number-Theoretic Transformation）"></a>数论变换（Number-Theoretic Transformation）</h1><p>注意到朴素的FFT使用的是单位复根。然而它们有一个十分大的缺陷，就是必须要用<code>double</code>存。这会带来精度上的误差，一个直接的结果就是，对于只有整数参与的多项式乘法，跑完FFT却会出现小数。</p><p>这就启示我们，能不能用其他的什么东西替换掉单位复根。</p><p>设有两个互质的正整数$a$和$p$，最小的使得$a^{k}\equiv 1\pmod{p}$的$k$被称为$a$模$p$的阶，记作$\delta_{p}(a)$。</p><p>如果说$\delta_{p}(a)=\varphi(p)$，我们就称$a$是模$p$的一个原根。</p><p>现在我们找一个质数$p=an+1$，其中$a$是一个正整数，$n$是$2$的非负整数次幂。然后我们找到它的原根$g$，并定义$\omega_{n}=g^{a}$。让我们来看看单位复根有的性质现在的原根有没有：</p><p>$\omega_{n}^{0},\omega_{n}^{1},\cdots,\omega_{n}^{n-1}$互不相同。这是为了保证点值表达的合法。</p><p>虽然我不会证，不过我们的确有$g^{0},g^{1},\cdots,g^{n-1}$在模$p$意义下互不相同，$a$次幂自然也一样。</p><p>$\omega_{2n}^{2k}=\omega_{n}^{k}$。这是为了让我们可以分治。</p><p>根据定义，$\omega_{2n}=g^{\frac{a}{2}}$，就是将现在的$p$进一步拆成$\cfrac{a}{2}\cdot2n+1$。不难发现</p><script type="math/tex; mode=display">\omega_{2n}^{2k}=g^{\frac{a}{2}\cdot{2}k}=g^{ak}=\omega_{n}^{k}</script><p>因而原根有上述性质。</p><p>$\omega_{n}^{k+\frac{n}{2}}=-\omega_{n}^{k}$，或者说$\omega_{n}^{\frac{n}{2}}=-1$。这同样是为了让我们可以分治。</p><p>因为$p=an+1$，根据费马小定理，我们有</p><script type="math/tex; mode=display">\omega_{n}^{n}\equiv g^{an}\equiv g^{p-1}\equiv 1\pmod{p}</script><p>因而$\omega_{n}^{\frac{n}{2}}\equiv\pm 1\pmod{p}$。又因为$\omega_{n}^{0}=1$，而$\omega_{n}^{\frac{n}{2}}\not\equiv\omega_{n}^{0}\pmod{p}$，我们就得到$\omega_{n}^{\frac{n}{2}}\equiv -1\pmod{p}$。</p><p>若$k\neq 0$，$\sum_{i=0}^{n-1}(\omega_{n}^{k})^{i}=0$。这是为了实现逆变换。不过这个很明显，就留作习题吧。</p><p>以上，我们成功地用原根取代了单位复根。一般情况下，我们会取$p=998244353=7\times 17\times 2^{23}+1$，它的原根是$3$。</p><p>需要注意的是，我们还有一个可以优化的小细节。注意到$\omega_{n}=g^{a}=g^{\frac{p-1}{n}}$，我们可以将这些值预处理出来，就不用每次都跑快速幂了。对于$998244353$来说，我们需要预处理$\omega_{2},\omega_{4},\cdots,\omega_{2^{23}}$。注意到</p><script type="math/tex; mode=display">\omega_{2^{23}}=3^{7\times 17}=3^{119}</script><script type="math/tex; mode=display">\omega_{2^{k}}=\omega_{2^{k+1}}^{2}</script><p>我们一遍快速幂算出$\omega_{2^{23}}$然后倒着推出剩下的即可。</p><p>关于$\omega_{n}^{-k}$，注意到它就是$\omega_{n}^{k}$在模$998244353$意义下的逆元。那么我们把上面两个式子中的$3$换成它在模$998244353$意义下的逆元即可，这个数是$332748118$。</p><p>然后我们把FFT板子里的单位复根全部换成原根，运算换成模意义下的就行了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 2097152</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line"><span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ih==it)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *ih++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">oh=cltout;</span><br><span class="line">&#125;</span><br><span class="line">*oh++=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=gc();</span><br><span class="line"><span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">sn=<span class="number">-1</span>,c=gc();</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">x*=sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">pc(<span class="number">45</span>),x=-x;</span><br><span class="line"><span class="keyword">if</span>(!x)</span><br><span class="line">pc(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">pc(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(;y;)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line"><span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">swap(F[i],F[rev[i]]);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">F[j]=(x+y)%mod;</span><br><span class="line">F[j+p]=(x-y+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">cltstream::read(n);</span><br><span class="line">cltstream::read(m);</span><br><span class="line">++n;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">cltstream::read(F[i]);</span><br><span class="line">++m;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">cltstream::read(G[i]);</span><br><span class="line"><span class="keyword">for</span>(m+=n<span class="number">-1</span>,n=<span class="number">1</span>;n&lt;m;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">NTT(F,<span class="number">0</span>);</span><br><span class="line">NTT(G,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">NTT(F,<span class="number">1</span>);</span><br><span class="line">n=cltpow(n,mod<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">cltstream::write(<span class="number">1L</span>L*F[i]*n%mod,i&lt;m<span class="number">-1</span>?<span class="number">32</span>:<span class="number">-1</span>);</span><br><span class="line">clop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近正好月考，然而并不想去月考，于是来颓blog吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="FFT" scheme="https://github.com/Challestend/tags/FFT/"/>
    
      <category term="NTT" scheme="https://github.com/Challestend/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>关于最优化分块时间复杂度的研究报告</title>
    <link href="https://github.com/Challestend/sqrt-decomposition-complexity-optimization/"/>
    <id>https://github.com/Challestend/sqrt-decomposition-complexity-optimization/</id>
    <published>2018-12-19T12:19:18.000Z</published>
    <updated>2018-12-21T02:20:30.115Z</updated>
    
    <content type="html"><![CDATA[<p>最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。</p><a id="more"></a><p>假设我们有一个长度为$n$的序列，块的大小是$x$，令$y=\cfrac{n}{x}$。对于每一次修改操作，我们的运算量是$\text{A}x+\text{B}y$。根据均值不等式</p><script type="math/tex; mode=display">\cfrac{1}{2}(x+y)\geqslant\sqrt{xy}</script><p>我们有</p><script type="math/tex; mode=display">\text{A}x+\text{B}y\geqslant2\sqrt{\text{AB}n}</script><p>当且仅当$x=\sqrt{\cfrac{\text{B}}{\text{A}}n}$时取等号。此时时间复杂度最小，为$O(\sqrt{\text{AB}n})$。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在刷Ynoi，然后卡常卡到自闭，于是来系统地研究一下分块的复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="研究报告" scheme="https://github.com/Challestend/categories/%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A/"/>
    
    
      <category term="分块" scheme="https://github.com/Challestend/tags/%E5%88%86%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>「未来算法Episode I」严格根号分块实现树套树</title>
    <link href="https://github.com/Challestend/future-algorithm-ep1/"/>
    <id>https://github.com/Challestend/future-algorithm-ep1/</id>
    <published>2018-12-08T11:55:00.000Z</published>
    <updated>2018-12-19T12:08:11.478Z</updated>
    
    <content type="html"><![CDATA[<p>分块天下第一！！！！！！！！！</p><a id="more"></a><p>我也不知道我为什么要写这个玩意，大概是我真的被这个外挂一般的东西吓到了吧。</p><p><a href="https://www.luogu.org/record/show?rid=14518116" target="_blank" rel="noopener"><img src="https://i.loli.net/2018/12/08/5c0bb272768cf.png" alt=""></a></p><p><img src="https://i.loli.net/2018/12/08/5c0bb2c767fda.jpg" alt=""></p><p>我们从头说起。点开上面的那个评测记录，我们可以看到一道树套树的模板题。</p><p>先退一步来说，假如说我们去掉操作$3$，剩下的操作都可以用主席树来完成。</p><p>然而麻烦的是，我们在树上存的是前缀和。想要修改的话，暴力的复杂度是单次$O(n\operatorname{log}n)$的。</p><p>那我们就在外层套个树状数组，把修改$O(n\operatorname{log}n)$查询$O(\operatorname{log}n)$均摊成全部$O(\operatorname{log}^{2}n)$。</p><p>然而，很遗憾，我不会树套树，一点都不会，就连上面的这段文字也是我瞎扯出来的。</p><p>考虑<del>无敌的</del>分块。</p><p>一般我们想到的分块就是在块内维护<code>std::set</code>。这样操作$3$可以做到$O(\operatorname{log}\sqrt{n})$，操作$1$、$4$、$5$可以做到$O(\sqrt{n}\operatorname{log}\sqrt{n})$。至于操作$2$，我们在外层套一个二分，然后检查二分到的数的排名是不是$k$，时间复杂度$O(\operatorname{log}10^{9}\sqrt{n}\operatorname{log}\sqrt{n})$。</p><p>然而很明显的，这样做的效率十分低下，除了实现复杂度相对树套树小了一点以外没有任何优势。</p><p>我们来看一下<a href="https://www.luogu.org/space/show?uid=56384" target="_blank" rel="noopener"><strong>Shadowice1984</strong></a>dalao在他的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p4119" target="_blank" rel="noopener">另一篇题解</a>中做出的评价：</p><blockquote><p>这其实是一个误区。主席树之所以采取了二分的思路来解决问题是因为我们要求回答单次询问做到$O(\operatorname{log}n)$的复杂度，这时候唯一的可行思路就是二分否则我们无法将复杂度控制在一个$\text{log}$之内。</p><p>但是我们现在是使用分块解决问题。分块是有自己复杂度的，就是$O(\sqrt{n})$而不是$O(\operatorname{log}n)$，这意味着分块其实和$\text{log}$的数据结构以及二分法并不是很搭（因为分块的结构本质上就不支持二分）。如果我们需要强行嵌入$\text{log}$的数据结构的话在绝大部分情况下都会使复杂度凭空多出个$\text{log}$来，这在强调常数的根号算法中绝对是致命的。</p></blockquote><p>我也是从这位dalao的<a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-p3380" target="_blank" rel="noopener">blog</a>里看到了严格根号分块实现树套树这种未来算法。</p><p>主要思想其实不难理解，既然分块和$\text{log}$不适合放在一起，我们就再套个分块，或者说，把值域也分成块。</p><p>定义<code>cnt1[i][j]</code>表示前$i$个块内有多少个元素的值在第$j$个块内，<code>cnt2[i][j]</code>表示前$i$个块内有多少个$j$（当然是离散化后的）。不难发现预处理出这两个数组的时间复杂度是$O((n+m)\sqrt{n})$的。</p><p>然后我们来分析每个操作该怎么实现：</p><ol><li>首先考虑序列中的整块。从头开始扫一遍值域块，一直扫到给定数所在块的前一个块，然后再在给定数所在块内从头扫到给定数的前一个，查询扫过的值有多少落在这些整块内。剩下的边角块自然地暴力判断。</li><li>还是从头扫一遍值域块，看看每个值域块内有多少数落在给定区间内，大概判断出答案在哪个值域块内。然后在这个值域块内再扫一遍即可。需要注意的是我们需要再开两个数组<code>tmp1</code>和<code>tmp2</code>来保存边角块的信息。</li><li>直接$O(\sqrt{n})$暴力重构两个<code>cnt</code>就好。</li><li>需要两个类似于操作$2$的临时数组，存储的信息也是类似的。首先在给定数所在值域块内<strong>从后往前扫</strong>，找到答案直接退出。否则还是<strong>从后往前扫所有值域块</strong>，找到第一个非空的块然后进去找。</li><li>操作$4$换个方向即可。</li></ol><p>综上所述，该算法的时间复杂度为$O((n+m)\sqrt{n}+m\sqrt{n+m})$。当$n$，$m$取到极限值时，差不多是$38172068$，相比之下$O(m\operatorname{log}^{2}n)\approx 12183043$。看起来好像比不过树套树，实际上开个$\text{O}2$跑得比谁都快，正如一开始那张图所示。</p><p>不过代码写出来有点长的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxs 230</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(a) ((a)&amp;(-(a)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line"><span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ih==it)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *ih++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">oh=cltout;</span><br><span class="line">&#125;</span><br><span class="line">*oh++=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=gc();</span><br><span class="line"><span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">sn=<span class="number">-1</span>,c=gc();</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">x*=sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">pc(<span class="number">45</span>),x=-x;</span><br><span class="line"><span class="keyword">if</span>(!x)</span><br><span class="line">pc(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">pc(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,sq1,sq2;</span><br><span class="line"><span class="keyword">int</span> id1[maxn+<span class="number">1</span>],id2[maxn+maxm+<span class="number">1</span>],p[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn+<span class="number">1</span>],opt[maxm+<span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> cnt1[maxs+<span class="number">1</span>][(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],cnt2[maxs+<span class="number">1</span>][maxn+maxm+<span class="number">1</span>],tmp1[(maxs&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],tmp2[maxn+maxm+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cltstream::read(n);</span><br><span class="line">cltstream::read(m);</span><br><span class="line"><span class="keyword">for</span>(;(sq1+<span class="number">1</span>)*(sq1+<span class="number">1</span>)&lt;=n;++sq1);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">id1[i]=(i<span class="number">-1</span>)/sq1+<span class="number">1</span>;</span><br><span class="line">cltstream::read(a[i]);</span><br><span class="line">p[++p[<span class="number">0</span>]]=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">cltstream::read(opt[i][<span class="number">0</span>]);</span><br><span class="line">cltstream::read(opt[i][<span class="number">1</span>]);</span><br><span class="line">cltstream::read(opt[i][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span>(opt[i][<span class="number">0</span>]!=<span class="number">3</span>)</span><br><span class="line">cltstream::read(opt[i][<span class="number">3</span>]);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">p[++p[<span class="number">0</span>]]=opt[i][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::sort(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>]=<span class="built_in">std</span>::unique(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>)-p<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(;(sq2+<span class="number">1</span>)*(sq2+<span class="number">1</span>)&lt;=p[<span class="number">0</span>];++sq2);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p[<span class="number">0</span>];++i)</span><br><span class="line">id2[i]=(i<span class="number">-1</span>)/sq2+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">a[i]=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,a[i])-p;</span><br><span class="line">++cnt1[id1[i]][id2[a[i]]];</span><br><span class="line">++cnt2[id1[i]][a[i]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=id1[n];++i)&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]];++j)</span><br><span class="line">cnt1[i][j]+=cnt1[i<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=p[<span class="number">0</span>];++j)</span><br><span class="line">cnt2[i][j]+=cnt2[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">re <span class="keyword">int</span> l,r,x,ans=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span>(opt[i][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line"><span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)</span><br><span class="line">ans+=(a[j]&lt;x);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)</span><br><span class="line">ans+=(a[j]&lt;x);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;id2[x];++j)</span><br><span class="line">ans+=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>;j&lt;x;++j)</span><br><span class="line">ans+=cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)</span><br><span class="line">ans+=(a[j]&lt;x);</span><br><span class="line">cltstream::write(ans+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=opt[i][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line"><span class="keyword">if</span>(x&gt;cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line">x-=cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line"><span class="keyword">if</span>(x&gt;cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">x-=cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;;++j)</span><br><span class="line"><span class="keyword">if</span>(x&gt;tmp1[j])</span><br><span class="line">x-=tmp1[j];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2;++k)</span><br><span class="line"><span class="keyword">if</span>(x&gt;tmp2[k])</span><br><span class="line">x-=tmp2[k];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cltstream::write(p[k],<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">l=opt[i][<span class="number">1</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">2</span>])-p;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=id1[l];j&lt;=id1[n];++j)&#123;</span><br><span class="line">--cnt1[j][id2[a[l]]];</span><br><span class="line">++cnt1[j][id2[x]];</span><br><span class="line">--cnt2[j][a[l]];</span><br><span class="line">++cnt2[j][x];</span><br><span class="line">&#125;</span><br><span class="line">a[l]=x;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::lower_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p;</span><br><span class="line"><span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line"><span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">ans=j;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line"><span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line"><span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">ans=k;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=x<span class="number">-1</span>;j&gt;=(id2[x]<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line"><span class="keyword">if</span>(tmp2[j])</span><br><span class="line">ans=j;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]<span class="number">-1</span>;j&gt;=<span class="number">1</span>&amp;&amp;!ans;--j)</span><br><span class="line"><span class="keyword">if</span>(tmp1[j])</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=j*sq2;k&gt;=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>&amp;&amp;!ans;--k)</span><br><span class="line"><span class="keyword">if</span>(tmp2[k])</span><br><span class="line">ans=k;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cltstream::write(ans?p[ans]:<span class="number">-2147483647</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">l=opt[i][<span class="number">1</span>],r=opt[i][<span class="number">2</span>],x=<span class="built_in">std</span>::upper_bound(p+<span class="number">1</span>,p+p[<span class="number">0</span>]+<span class="number">1</span>,opt[i][<span class="number">3</span>])-p<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(id1[l]&lt;id1[r])&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line"><span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][j]-cnt2[id1[l]][j]+tmp2[j])</span><br><span class="line">ans=j;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line"><span class="keyword">if</span>(cnt1[id1[r]<span class="number">-1</span>][j]-cnt1[id1[l]][j]+tmp1[j])</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line"><span class="keyword">if</span>(cnt2[id1[r]<span class="number">-1</span>][k]-cnt2[id1[l]][k]+tmp2[k])</span><br><span class="line">ans=k;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=id1[l]*sq1;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=(id1[r]<span class="number">-1</span>)*sq1+<span class="number">1</span>;j&lt;=r;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">++tmp1[id2[a[j]]];</span><br><span class="line">++tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=x+<span class="number">1</span>;j&lt;=id2[x]*sq2&amp;&amp;!ans;++j)</span><br><span class="line"><span class="keyword">if</span>(tmp2[j])</span><br><span class="line">ans=j;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=id2[x]+<span class="number">1</span>;j&lt;=id2[p[<span class="number">0</span>]]&amp;&amp;!ans;++j)</span><br><span class="line"><span class="keyword">if</span>(tmp1[j])</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> k=(j<span class="number">-1</span>)*sq2+<span class="number">1</span>;k&lt;=j*sq2&amp;&amp;!ans;++k)</span><br><span class="line"><span class="keyword">if</span>(tmp2[k])</span><br><span class="line">ans=k;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=l;j&lt;=r;++j)&#123;</span><br><span class="line">--tmp1[id2[a[j]]];</span><br><span class="line">--tmp2[a[j]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cltstream::write(ans?p[ans]:<span class="number">2147483647</span>,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我还没写啥呢咋就$12\text{KB}$了（</p><p>这大概会成为一个系列，名字就叫做「未来算法」（Future Algorithm），不过也说不定，会不会以后哪天突然蹦出来个「未来算法Episode II」也说不定（</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;分块天下第一！！！！！！！！！&lt;/p&gt;
    
    </summary>
    
      <category term="未来算法" scheme="https://github.com/Challestend/categories/%E6%9C%AA%E6%9D%A5%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分块" scheme="https://github.com/Challestend/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="树套树" scheme="https://github.com/Challestend/tags/%E6%A0%91%E5%A5%97%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>一些乱七八糟的数论</title>
    <link href="https://github.com/Challestend/number-theory-learning-notes/"/>
    <id>https://github.com/Challestend/number-theory-learning-notes/</id>
    <published>2018-11-29T06:41:17.000Z</published>
    <updated>2018-12-19T12:13:00.250Z</updated>
    
    <content type="html"><![CDATA[<p>最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。</p><p><del>抄袭来源</del>参考文献：</p><ul><li><a href="https://lx-2003.blog.luogu.org/mobius-inversion" target="_blank" rel="noopener">铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演</a></li><li><a href="https://www.luogu.org/blog/54745/dls-tql" target="_blank" rel="noopener">浅谈杜教筛</a></li><li><a href="https://lx-2003.blog.luogu.org/dujiao-sieve" target="_blank" rel="noopener">铃悬的数学小讲堂——杜教筛</a></li></ul><a id="more"></a><h1 id="数论函数"><a href="#数论函数" class="headerlink" title="数论函数"></a>数论函数</h1><h2 id="定义与相关性质"><a href="#定义与相关性质" class="headerlink" title="定义与相关性质"></a>定义与相关性质</h2><p>数论函数就是定义域为$\mathbb{N}^{+}$的函数。</p><p>两个数论函数相加，就是简单地把函数值相加。</p><script type="math/tex; mode=display">(f+g)(n)=f(n)+g(n)</script><p>数乘也是类似的。</p><script type="math/tex; mode=display">(\alpha f)(n)=\alpha f(n)</script><p>点积也是类似的。</p><script type="math/tex; mode=display">(f\cdot g)(n)=f(n)g(n)</script><p><del>好像没啥用。</del></p><p>在数论函数相关的运算中，一个非常重要的运算是狄利克雷卷积。两个数论函数的狄利克雷卷积是这样定义的：</p><script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})</script><p>或者说：</p><script type="math/tex; mode=display">(f\times g)(n)=\sum\limits_{ij=n}f(i)g(j)</script><p>它具有以下的一些性质：</p><p>交换律，即$f\times g=g\times f$。</p><p>这很明显。</p><p>结合律，即$(f\times g)\times h=f\times(g\times h)$。</p><script type="math/tex; mode=display">\begin{aligned}((f\times g)\times h)(n)&=\sum\limits_{ij=n}(\sum\limits_{kl=i}f(k)g(l))h(j)\\&=\sum\limits_{ijk=n}f(i)g(j)h(k)\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}(f\times(g\times h))(n)&=\sum\limits_{ij=n}f(i)(\sum\limits_{kl=j}g(k)h(l))\\&=\sum\limits_{ijk=n}f(i)g(j)h(k)\end{aligned}</script><p>分配率，即$(f+g)\times h=f\times h+g\times h$。</p><script type="math/tex; mode=display">\begin{aligned}((f+g)\times h)(n)&=\sum\limits_{ij=n}(f+g)(i)h(j)\\&=\sum\limits_{ij=n}f(i)h(j)+g(i)h(j)\\&=(f\times h)(n)+(g\times h)(n)\end{aligned}</script><p>单位元为$\epsilon(n)=[n=1]$，$f\times\epsilon =f$。</p><p>这也很明显。</p><p>对于任意一个满足$f(1)\neq 0$的函数$f$，都存在唯一的一个函数$g$使得$f\times g=\epsilon$。这时我们称$g$是$f$的逆。</p><p>我们可以这样定义一个函数的逆：</p><script type="math/tex; mode=display">g(n)=\cfrac{\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})}{f(1)}</script><p>这样我们就有</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum_{i\mid n}f(i)g(\cfrac{n}{i})\\&=f(1)g(n)+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\&=\epsilon(n)-\sum\limits_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})+\sum_{i\mid n,i\neq 1}f(i)g(\cfrac{n}{i})\\&=\epsilon(n)\end{aligned}</script><h2 id="积性函数与完全积性函数"><a href="#积性函数与完全积性函数" class="headerlink" title="积性函数与完全积性函数"></a>积性函数与完全积性函数</h2><p>如果一个数论函数$f$满足</p><script type="math/tex; mode=display">\forall x,y\in\mathbb{N}^{+}\wedge x\perp y\;\;f(xy)=f(x)f(y)</script><p>我们就说$f$是一个积性函数。</p><p>特别的，如果上式去掉$x\perp y$仍成立，则称$f$是一个完全积性函数。</p><p>很明显地，任意一个积性函数$f$一定有$f(1)=1$，这样才能有$f(1\times n)=f(1)\times f(n)=f(n)$。</p><p>常见的完全积性函数有$\epsilon,id^{k}$。$\epsilon$在上文已经提到过。$id^{k}(n)=n^k$。这两个函数的完全积性十分明显。</p><p>常见的积性函数有$\varphi,d,\sigma$。$\varphi(n)$的值等于小于等于$n$且与$n$互质的正整数的数量。$d(n)$和$\sigma(n)$的值分别等于$n$的约数个数和约数和。</p><p>关于$\varphi$的积性，我并不会证（</p><p>我们来分析$d$的积性。首先，根据唯一分解定理，$n$的每个因数都可以唯一地分解成$n$所有质因子的非负整数次幂乘积。不妨设</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。对于每一个$p_{i}$，它的指数有$(r_{i}+1)$种取值，因而我们有</p><script type="math/tex; mode=display">d(n)=\prod\limits_{i=1}^{N}(r_{i}+1)</script><p>我们再假设有一个$m$，且</p><script type="math/tex; mode=display">m=\prod\limits_{i=1}^{M}q_{i}^{s_{i}}</script><p>如果说$n\perp m$，肯定有</p><script type="math/tex; mode=display">\forall i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z}\;\;p_{i}\neq q_{j}</script><p>于是我们就有</p><script type="math/tex; mode=display">nm=(\prod\limits_{i=1}^{N}p_{i}^{r_{i}})(\prod\limits_{j=1}^{M}q_{j}^{s_{j}})</script><script type="math/tex; mode=display">\begin{aligned}d(nm)&=(\prod\limits_{i=1}^{N}(r_{i}+1))(\prod\limits_{j=1}^{M}(s_{j}+1))\\&=d(n)d(m)\end{aligned}</script><p>不妨再反过来考虑。如果说$n\not\perp m$，那么一定存在一对$(i,j)(i\in [1,N]\cap\mathbb{Z},j\in [1,M]\cap\mathbb{Z})$，使得$p_{i}=q_{j}$。那么$d(n)d(m)$就会有一个因子是$(r_{i}+1)(s_{j}+1)=r_{i}s_{j}+r_{i}+s_{j}+1$。但是仔细思考我们会发现，$d(nm)$中对应的项应该是$r_{i}+s_{j}+1$。因而此时$d(nm)\neq d(n)d(m)$。</p><p>我们再来分析$\sigma$的积性。还是设</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>其中$p_{i}$都是质数，所有$r_{i}$都是正整数。与$d$不同的是，现在我们是要用$p_{i}$乘出$n$的因数，$p_{i}$在此过程中可以产生的贡献为$p_{i}^x(x\in [0,r_{i}]\cap\mathbb{Z})$。我们可以把这想象成一个$N$个数组，第$i$个数组的长度为$r_{i}+1$，第$j$个元素为$p_{i}^{j-1}$。现在我们每次从每个数组里选出恰好一个元素相乘，要求所有方案的乘积之和。我们知道，这个问题的答案就是</p><script type="math/tex; mode=display">\prod\limits_{i=1}^{N}\sum\limits_{j=0}^{r_{i}}p_{i}^{j}</script><p>这正是$\sigma(n)$的值。</p><p>接下来的过程就与上文证明$d$的积性如出一辙了，在此不再重复。</p><p>现在我们来分析，两个积性函数的卷积是否也是积性函数。<del>虽然说都这么问了肯定就是了。</del></p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)(f\times g)(m)&=(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(i)g(\cfrac{n}{i})f(j)g(\cfrac{m}{j})\\&=\sum\limits_{i\mid n}\sum\limits_{j\mid m}f(ij)g(\cfrac{nm}{ij})\\&=\sum\limits_{k\mid nm}f(k)g(\cfrac{nm}{k})\\&=(f\times g)(nm)\end{aligned}</script><p>关于上面的第四个等号。时刻注意$n\perp m$，在这种前提下，我们枚举到的$i$和$j$一定也是互质的，那么$ij$的所有值一定是互不相同的。这从$d(nm)=d(n)d(m)$这一等式中也能看出。</p><p>再接下来，我们来分析一下一个积性函数的逆是否也是积性函数。</p><p>设有一个积性函数$f$，它的逆是$g$。</p><p>当$nm=1$时，$g(1)=1$。</p><p>当$nm&gt;1$时，我们假设对于任意$n^{\prime}m^{\prime}&lt;nm$，都有$g(n^{\prime}m^{\prime})=g(n^{\prime})g(m^{\prime})$。此时</p><script type="math/tex; mode=display">\begin{aligned}g(nm)&=-\sum\limits_{k\mid nm,k\neq 1}f(k)g(\cfrac{nm}{k})\\&=-\sum\limits_{i\mid n,j\mid m,ij\neq 1}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\&=g(n)g(m)-\sum\limits_{i\mid n,j\mid m}f(i)f(j)g(\cfrac{n}{i})g(\cfrac{m}{j})\\&=g(n)g(m)-(\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i}))(\sum\limits_{j\mid m}f(j)g(\cfrac{m}{j}))\\&=g(n)g(m)-\epsilon(n)\epsilon(m)\\&=g(n)g(m)\end{aligned}</script><p><del>其实上面这些全都是抄来的（</del></p><h1 id="莫比乌斯反演"><a href="#莫比乌斯反演" class="headerlink" title="莫比乌斯反演"></a>莫比乌斯反演</h1><h2 id="正向反演"><a href="#正向反演" class="headerlink" title="正向反演"></a>正向反演</h2><p>定义$\mu$为$1$的逆。也就是说，$\mu\times 1=\epsilon$。</p><p>如果您看过其他的一些关于莫比乌斯反演的学习笔记的话，您可能会看到如下的定义：</p><blockquote><p>首先地，$\mu(1)=1$。当$n&gt;1$时，如果$n$的所有质因子互不相同，设其有$k$个质因子，那么$\mu(n)=(-1)^{k}$。否则，$\mu(n)=0$。</p></blockquote><p>那么，这两种定义等价吗？</p><p>考虑到$\mu$是一个积性函数，对于任意一个$n&gt;1$，如果我们把它分解成</p><script type="math/tex; mode=display">n=\prod\limits_{i=1}^{N}p_{i}^{r_{i}}</script><p>我们就有</p><script type="math/tex; mode=display">\mu(n)=\prod\limits_{i=1}^{N}\mu(p_{i}^{r_{i}})</script><p>因此，确定一个积性函数的函数值的关键在于确定其在质数的非负整数次幂上的取值。</p><p>设有一个质数$p$。不难发现</p><script type="math/tex; mode=display">\mu(p)=-\mu(1)=-1</script><script type="math/tex; mode=display">\mu(p^{2})=-\mu(1)-\mu(p)=-1+1=0</script><script type="math/tex; mode=display">\mu(p^{3})=-\mu(1)-\mu(p)-\mu(p^{2})=-1+1+0=0</script><script type="math/tex; mode=display">\vdots</script><p>至此，不难看出上文给出的两种定义是等价的。</p><p>那么这个东西有什么用呢？</p><p>我们设</p><script type="math/tex; mode=display">F(n)=\sum\limits_{i\mid n}f(i)</script><p>或者等价地说，$F=f\times 1$。我们可以得到</p><script type="math/tex; mode=display">\begin{aligned}F&=f\times 1\\F\times\mu&=f\times 1\times\mu\\F\times\mu&=f\end{aligned}</script><p>像这样，如果说$F$相对好求，而$f$相对难求，我们就可以通过上式来减小我们求解$f$的难度。具体地说</p><script type="math/tex; mode=display">f(n)=\sum\limits_{i\mid n}F(i)\mu(\cfrac{n}{i})</script><h2 id="反向反演"><a href="#反向反演" class="headerlink" title="反向反演"></a>反向反演</h2><p>有些时候我们还需要用到像下面这样反过来的莫比乌斯反演</p><script type="math/tex; mode=display">F(n)=\sum\limits_{n\mid d}f(d)⇔f(n)=\sum\limits_{n\mid d}F(d)\mu(\cfrac{d}{n})</script><p>我们可以定义一种新的运算</p><script type="math/tex; mode=display">(f\otimes g)(n)=\sum\limits_{n\mid d}f(d)g(\cfrac{d}{n})</script><p>我们不难证明出它具有结合律。具体过程与上文证明狄利克雷卷积的结合律的过程基本重复。那么我们就有</p><script type="math/tex; mode=display">F=f\otimes 1⇔F\otimes\mu=f</script><p>于是就有了上面的反向反演。</p><blockquote><p>Updated on 2018-12-03</p><p>例题……还是算了吧（</p><p>发现反演常用的套路都忘的差不多了，还是别丢人了（</p></blockquote><h1 id="杜教筛"><a href="#杜教筛" class="headerlink" title="杜教筛"></a>杜教筛</h1><h2 id="实现与模板题"><a href="#实现与模板题" class="headerlink" title="实现与模板题"></a>实现与模板题</h2><p>接下来才是主要内容。</p><p>现在，我们要求一个积性函数的前$n$项和。$n\leqslant 10^{10}$。</p><p>我们定义</p><script type="math/tex; mode=display">S(n)=\sum\limits_{i=1}^{n}f(i)</script><p>再拿来一个积性函数$g$，然后把它与$f$卷积并求前缀和。</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^{n}(f\times g)(i)&=\sum_{i=1}^{n}\sum_{j\mid i}f(j)g(\cfrac{i}{j})\\&=\sum_{i=1}^{n}g(i)\sum_{j=1}^{\lfloor\frac{n}{i}\rfloor}f(j)\\&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\end{aligned}</script><p>然而我的语文实在是太菜了，大概说也说不明白，自行理解吧（</p><p>因为$g$也是积性函数，有$g(1)=1$，所以</p><script type="math/tex; mode=display">\begin{aligned}S(n)&=g(1)S(n)\\&=\sum_{i=1}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\\&=\sum_{i=1}^{n}(f\times g)(i)-\sum_{i=2}^{n}g(i)S(\lfloor\cfrac{n}{i}\rfloor)\end{aligned}</script><p>就是说从第一项开始的前缀和减去从第二项开始的前缀和等于第一项本身。</p><p>如果说我们选择的$g$可以让我们迅速地求出$f\times g$和$g$的前缀和，我们就可以做到快速求$f$的前缀和了。</p><p>关于后面的$g(i)S(\lfloor\cfrac{n}{i}\rfloor)$，如果直接暴力算复杂度会是$O(n)$的，在大部分情况下，这是无法接受的。</p><p>我们来分析一下$\lfloor\cfrac{n}{i}\rfloor$。如果$1\leqslant i\leqslant\sqrt{n}$，因为$i$只有$\sqrt{n}$种不同的取值，$\lfloor\cfrac{n}{i}\rfloor$同样也只有$\sqrt{n}$种不同的取值。如果$\sqrt{n}&lt;i\leqslant n$，$1\leqslant\lfloor\cfrac{n}{i}\rfloor&lt;\sqrt{n}$，又因为要向下取整，自然也只有$\sqrt{n}$种不同的取值。如果我们能够把$\lfloor\cfrac{n}{i}\rfloor$相同的$i$一起计算，就能够将时间杂度优化到$O(\sqrt{n})$。</p><p>大体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">r=n/(n/l);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于$r$的这个上界是怎么来的，我并不会证（</p><p>这样一来，要计算$S(n)$，我们需要调用所有的$\lfloor\cfrac{n}{x}\rfloor$，分别是$\lfloor\cfrac{n}{1}\rfloor,\lfloor\cfrac{n}{2}\rfloor,\cdots,\lfloor\cfrac{n}{\sqrt{n}}\rfloor,\sqrt{n},\sqrt{n}-1,\cdots,1$。单独计算一个$S(n)$的时间复杂度很明显是$O(\sqrt{n})$的。那么这样一来，总体的时间复杂度就是</p><script type="math/tex; mode=display">\begin{aligned}O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{i}+\sqrt{\lfloor\cfrac{n}{i}\rfloor})&=O(\sum\limits_{i=1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{i}\rfloor})\\&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\lfloor\cfrac{n}{x}\rfloor}dx)\\&=O(\int\limits_{1}^{\sqrt{n}}\sqrt{\cfrac{n}{x}}dx)\\&=O(2n^{\frac{1}{2}}(n^{\frac{1}{4}}-1))\\&=O(n^{\frac{3}{4}})\end{aligned}</script><p>因为相比之下$\sqrt{\lfloor\cfrac{n}{i}\rfloor}$很明显要大一些，我们就可以将$\sqrt{i}$舍去。然后去掉取整符号并用积分近似。</p><p>这个实现方法还可以优化。具体来讲，我们先线性筛出前$m$项，然后再用杜教筛。这么做的时间复杂度是$O(m+\cfrac{n}{\sqrt{m}})$，当$m=n^{\frac{2}{3}}$时取得最小值$O(n^{\frac{2}{3}})$。</p><p>举个例子，就比如说我们要求</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\varphi(i)</script><p>我们取$f=\varphi,g=1$，这样根据$\varphi$的性质，$f\times g=id$。不难看出$g$与$f\times g$的前缀和都可以$O(1)$求。具体的代码实现差不多长这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n&lt;=maxn)</span><br><span class="line"><span class="keyword">return</span> phi[n];</span><br><span class="line"><span class="comment">//phi是提前线性筛好的前缀和</span></span><br><span class="line"><span class="keyword">if</span>(ans.count(n))</span><br><span class="line"><span class="keyword">return</span> ans[n];</span><br><span class="line"><span class="comment">//ans用来实现记忆化的哈希表，比如说unordered_map</span></span><br><span class="line">re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1L</span>L*n*(n+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="comment">//f*g的前缀和</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=n;l=r+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">//注意要从2开始</span></span><br><span class="line">r=n/(n/l);</span><br><span class="line">res-=(r-l+<span class="number">1</span>)*getSum(n/l);</span><br><span class="line"><span class="comment">//r-l+1是g的前缀和</span></span><br><span class="line"><span class="comment">//像这样递归+记忆化求解f的前缀和</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans[n]=res;</span><br><span class="line"><span class="comment">//返回的时候不要忘记存一下</span></span><br><span class="line"><span class="comment">//就比如说我就忘过一次（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及，不用哈希表也是可以的。因为我们查询的数都是形如$\lfloor\cfrac{n}{x}\rfloor$的，当这个值大于$n^{\frac{2}{3}}$，即$x&lt;n^{\frac{1}{3}}$时，我们才会到哈希表里查询。因此我们可以令<code>ans[x]</code>表示$S(\lfloor\cfrac{n}{x}\rfloor)$。具体代码我就不写了（</p><p>再举个例子，求</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\mu(i)</script><p>取$f=\mu,g=1,f\times g=\epsilon$。代码和上面差不多。</p><p>如果您理解了上面两个函数，这道<a href="https://www.luogu.org/problemnew/show/P4213" target="_blank" rel="noopener">模板题</a>您就可以切了。</p><h2 id="其他题"><a href="#其他题" class="headerlink" title="其他题"></a>其他题</h2><h3 id="「Luogu-P3768」简单的数学题"><a href="#「Luogu-P3768」简单的数学题" class="headerlink" title="「Luogu-P3768」简单的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3768" target="_blank" rel="noopener">「Luogu-P3768」简单的数学题</a></h3><p>快乐地推式子：</p><script type="math/tex; mode=display">\begin{aligned}\sum\limits_{i=1}^{n}i\sum\limits_{j=1}^{n}j\text{gcd}(i,j)&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j[i\perp j]\\&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}i\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}j\sum\limits_{x\mid i,x\mid j}\mu(x)\\&=\sum\limits_{d=1}^{n}d^{3}\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}x^{2}\mu(x)\text{Sum}^{2}(\lfloor\cfrac{n}{dx}\rfloor)\\&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\sum\limits_{j\mid i}j\mu(\cfrac{i}{j})\\&=\sum\limits_{i=1}^{n}\text{Sum}^{2}(\lfloor\cfrac{n}{i}\rfloor)i^{2}\varphi(i)\end{aligned}</script><p>其中</p><script type="math/tex; mode=display">\text{Sum}(n)=\sum\limits_{i=1}^{n}i</script><p>最后一步是因为</p><script type="math/tex; mode=display">\begin{aligned}id\times\mu&=\varphi\times 1\times\mu\\&=\varphi\times\epsilon\\&=\varphi\end{aligned}</script><p>理解不了上面的式子的话就多看看吧（</p><p>不难发现我们是要求$f(n)=n^{2}\varphi(n)$的前缀和，那么，我们该怎么选取$g$呢？</p><p><del>枚举瞎蒙（</del></p><p>考虑$g(n)=n^{2}$。</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum\limits_{i\mid n}f(i)g(\cfrac{n}{i})\\&=\sum\limits_{i\mid n}i^{2}\varphi(i)\cfrac{n^{2}}{i^{2}}\\&=n^{2}\sum\limits_{i\mid n}\varphi(i)\\&=n^{3}\end{aligned}</script><p><del>其实我都不知道我当时是怎么想到这种操作的（</del></p><p>然后就和上面一样了。</p><h3 id="「Luogu-U18201」分析矿洞"><a href="#「Luogu-U18201」分析矿洞" class="headerlink" title="「Luogu-U18201」分析矿洞"></a><a href="https://www.luogu.org/problemnew/show/U18201" target="_blank" rel="noopener">「Luogu-U18201」分析矿洞</a></h3><p>不知道从哪翻出来的题（</p><p>是某场个人邀请赛的$\text{T}1$<del>，从某种意义上也能看出那场比赛有多么神仙</del>。</p><script type="math/tex; mode=display">\begin{aligned}\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{n}\varphi(\text{gcd}^{2}(i,j))&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}[i\perp j]\\&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{j=1}^{\lfloor\frac{n}{d}\rfloor}\sum\limits_{x\mid i,x\mid j}\mu(x)\\&=\sum\limits_{d=1}^{n}\varphi(d^{2})\sum\limits_{x=1}^{\lfloor\frac{n}{d}\rfloor}\mu(x)\lfloor\cfrac{n}{dx}\rfloor^{2}\\&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}\varphi(j^{2})\mu(\cfrac{i}{j})\\&=\sum\limits_{i=1}^{n}\lfloor\cfrac{n}{i}\rfloor^{2}\sum\limits_{j\mid i}j\varphi(j)\mu(\cfrac{i}{j})\end{aligned}</script><p>设$f_1(n)=n\varphi(n),f_2(n)=\mu(n)$，考虑筛$f=f_1\times f_2$的前缀和。然而，与上面的其它题不同，并不存在一个$g$使我们能够$O(1)$地求出$g$和$f\times g$的前缀和。一种较优的方案是，令$g=1$，$f\times g=(id\cdot\varphi)\times\mu\times 1=id\cdot\varphi$，这样，我们还需要筛出$f_1(n)=n\varphi(n)$的前缀和。</p><p>怎么办？</p><p>再套一层杜教筛！</p><p>然而可能是常数会有些大也可能是我太菜了自带大常数，好像会跑的很慢（</p><p>以及，像这种$n$爆了<code>int</code>的，一定要注意经常取模。<del>因为这个WA了好几次（</del></p><p>最后，源文件$17\text{KB}​$祭，blog翻页祭。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在洛谷日报的待审核列表里翻到了杜教筛的相关内容，打算连着之前的卷积反演啥的一起复习一下。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;抄袭来源&lt;/del&gt;参考文献：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lx-2003.blog.luogu.org/mobius-inversion&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;铃悬的数学小讲堂——狄利克雷卷积与莫比乌斯反演&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.luogu.org/blog/54745/dls-tql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;浅谈杜教筛&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lx-2003.blog.luogu.org/dujiao-sieve&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;铃悬的数学小讲堂——杜教筛&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="https://github.com/Challestend/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="杜教筛" scheme="https://github.com/Challestend/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>自己的一些大胆的想法（持续更新）</title>
    <link href="https://github.com/Challestend/poisonous-problems/"/>
    <id>https://github.com/Challestend/poisonous-problems/</id>
    <published>2018-11-14T03:02:21.000Z</published>
    <updated>2018-12-12T07:49:27.217Z</updated>
    
    <content type="html"><![CDATA[<p>自己闲得没事搞出来的一些毒瘤题。</p><p><del>不保证有解（</del></p><a id="more"></a><h1 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>定义一个从序列到序列的映射$\text{LIS()}$。我们认为$\text{LIS}(\{ a_n\})=\{ f_n\}$，当且仅当</p><script type="math/tex; mode=display">\forall 1\leqslant i\leqslant n\;\; f_i=\begin{cases}&1&(i=1\vee \forall 1\leqslant j<i\;\; a_j\geqslant a_i)\\&\max\limits_{1\leqslant j<i\wedge a_j<a_i}f_j+1&(\text{Otherwise})\\\end{cases}</script><p>给你一个长度为$n$的序列$\{ f_n\}$，你需要求出满足</p><script type="math/tex; mode=display">\text{LIS}(\{ a_n\})=\{ f_n\}\wedge\forall 1\leqslant i\leqslant n\;\; a_i\in [1,m]\cap\mathbb{Z}</script><p>的$\{ a_n\}$的数量，对$998244353$取模。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>很明显地，我们有</p><script type="math/tex; mode=display">\forall 1\leqslant i<j\leqslant n\wedge f_i=f_j\;\;a_i\geqslant a_j</script><script type="math/tex; mode=display">\forall 1\leqslant i,j\leqslant n\wedge f_i<f_j\;\;a_i<a_j</script><p>我们可以考虑将$\{ f_n\}$中最大的数记为$k$，数$x$的出现次数记为$cnt_x$。然后将$[1,m]$划分成$k$个独立区间$[1,x_1],[x_1+1,x_2],\cdots,[x_{k-1}+1,m]$，在第$i$个区间内独立地选出$cnt_i$个数并统计组成的所有不上升序列的数量。</p><p>我们定义$\text{nisc}(\text{Non-Increasing Sequence Count})(n,m)$表示在$n$个互不相等且具有大小关系的元素中选出$m$个元素（没有必要互不相同）组成的本质不同的不上升序列的数量。</p><p>考虑$m=1$时的情况。此时每个元素被选中都可以组成不上升序列。我们令$f[i][j]$表示$m=i$且第一次选中的元素是$j$时的总方案数。很明显地，我们有</p><script type="math/tex; mode=display">\forall 1\leqslant i\leqslant n\;\;f[1][i]=1</script><script type="math/tex; mode=display">\text{nisc}(n,1)=\sum\limits_{i=1}^nf[1][i]=n</script><p>现在考虑$m=2$。假设我们在第一次选择前再选一次。如果我们在这一次选择了$j$，下一次可能的选项有$1,2,\cdots,j$，所以</p><script type="math/tex; mode=display">f[2][j]=\sum\limits_{k=1}^jf[1][k]</script><p>将这个公式进一步推广，我们得到</p><script type="math/tex; mode=display">f[i][j]=\sum\limits_{k=1}^jf[i-1][k]</script><script type="math/tex; mode=display">\text{nisc}(n,m)=\sum_{i=1}^nf[m][i]=f[m+1][n]</script><p>考虑对一个只有$1$的数组进行$m$次前缀和，然后询问第$n$个位置上的数是多少。虽然我不会证，不过我通过人力打表得出</p><script type="math/tex; mode=display">\text{nisc}(n,m)=\frac1{m!}\prod\limits_{i=1}^{m}(n+i-1)</script><p>考虑一种naive的$\text{DP}$。定义$g[i][j]$表示将$[1,i]$分成$j$段，第$j$段中选$cnt_j$个元素组成不上升序列，这样的总方案数。我们有</p><script type="math/tex; mode=display">g[n][m]=\sum\limits_{i=m-1}^{n-1}g[i][m-1]\text{nisc}(n-i,cnt_m)</script><p>然而很遗憾，这个方程是错的。</p><p>就比如说，考虑这样一组数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2 1</span><br></pre></td></tr></table></figure><p>手动模拟一下，我们发现答案是$4$。但如果直接暴力地套上面的方程，我们会得到$5$。</p><p>从本质上来讲，上面的方程会把$[1,3]$划分成$\{[1,1],[2,3]\}$和$\{[1,2],[3,3]\}$。对于第一种，我们可以得到$\{\{1,2,1\},\{1,3,1\}\}$。对于第二种，我们可以得到$\{\{1,3,1\},\{1,3,2\},\{2,3,2\}\}$。注意到$\{1,3,1\}$出现了两次，这正是这种做法的错误所在。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己闲得没事搞出来的一些毒瘤题。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;不保证有解（&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="https://github.com/Challestend/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="毒瘤题" scheme="https://github.com/Challestend/tags/%E6%AF%92%E7%98%A4%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>「NOIp2018游记」夢の終わるところ</title>
    <link href="https://github.com/Challestend/noip-2018-notes/"/>
    <id>https://github.com/Challestend/noip-2018-notes/</id>
    <published>2018-11-09T01:40:45.000Z</published>
    <updated>2018-12-19T12:05:09.580Z</updated>
    
    <content type="html"><![CDATA[<p><del>€€£：禁赛警告。</del></p><a id="more"></a><h1 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h1><p>自从一周前放假回来以后，我就开始一颓不振：</p><p><img src="https://i.loli.net/2018/11/09/5be4e6d8c122f.png" alt=""></p><p>明天就是NOIp2018复赛了，大概算是我人生中的第四场NOIp了。上午我和平时一样在颓废<del>，同时看着其他dalao随手切神仙题</del>。然后我看到yemdalao写了一篇<a href="https://www.cnblogs.com/taduro/p/9933329.html" target="_blank" rel="noopener">NOIp2018<del>禁赛记</del>游记</a><del>，想着禁赛真有趣</del>，我就写下了这篇游记。</p><blockquote><p>其他dalao都在机房补文化课而我在颓blog（</p><p>于是，此处以下，Updated on 2018-11-12。</p><blockquote><p>Updated on 2018-11-14</p><p>看了其他dalao的blog发现自己写得实在是太菜了，于是大改一波。</p><p>但就算这样好像也没什么可写的。看到其他dalao用了大段文字来描写自己做题时的心理活动，但是……今年的题都是简单的想一想就会了，难的看一眼就能明白谁打正解谁退役，能有什么心理活动啊（逃</p></blockquote></blockquote><p>中午去超市随便买了点吃的就走了，然后上了车直接就睡过去了，到了CYYZ大概15点了。</p><p>然后一抽考场发现是外校，赛前先<code>rp--</code>。</p><p>然后和wzxdalao分到了一个宿舍。听说他被mhr学长奶了一路，我大概是被传染了吧（</p><p>下午一直在换宿舍，理由都差不多，就是其他学校的同一个学校的想住在同一个宿舍，莫名感觉rp被补回来了（</p><p>除那之外就没啥了，算是颓了一个下午。</p><p>晚上试机，庆幸自己用的是Win7，然后对面机房就是XP，下午的rp看来补得有效（</p><p>试机就xjb打了个st表，还有我平时用的快读板子，当时是都存到E盘了，说不定明天会用得上。</p><p>反正板子是不可能打炸的，这辈子都不可能的。</p><p>因为某些原因，试机时间被推迟了，回来已经过了10点，就直接睡了。</p><h1 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h1><p>早上懒得吃早饭了，就一个人在宿舍里发呆，想着自己肯定什么东西都带全了，结果一到考场发现准考证没带，尴尬.jpg。不过还好，我被允许先进考场了。</p><p>然后一打开E盘发现被清了，只有题目。</p><p>Day1的解压密码是不是就我一个人不懂啊（</p><p>那么于是，到了8：30，我点开今天的题目，定神一看……</p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5019" target="_blank" rel="noopener">T1</a></h2><p>智障单调栈，有不开数组的做法，不过我懒得细想了，反正<code>score+=100</code>。</p><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5020" target="_blank" rel="noopener">T2</a></h2><p>稍微想一想不难想到完全背包，<code>score+=100</code>。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5021" target="_blank" rel="noopener">T3</a></h2><p>神仙树上操作……切不动切不动。我就打了$m=1$的20分和树是一条链中的5分。</p><p>估分100+100+25=225。</p><p>出考场后……啥啥啥，今天考了三道原题？爆破！把NOIp爆破掉，并从此以后不再接受CCF的公开赛！（</p><p>前两题没什么意外的。不过，是不是是个人T3就能骗到55分啊（</p><p>那我可真是太菜了（</p><p>下午日常发呆，然后晚上是快乐的颓废时间。</p><p>中午买的零食一个下午就全吃完了（</p><h1 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h1><p>早上莫名起不来，然后就没吃早饭。</p><p>这次我东西是真的带全了（</p><p>Day2的解压密码依然不懂，然后是今天的题目：</p><h2 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5022" target="_blank" rel="noopener">T1</a></h2><p>NOIp开始考基环树了么……不过还算简单，找到环以后暴力断边然后dfs即可。听crydalao说有$O(n)$的做法，不过他调了两个小时还是放弃了。</p><p>现在回想起来，我当时用了个什么智障存图方法啊……先开个邻接表，对每个点<code>std::sort</code>一遍。然后维护一个邻接矩阵处理断边（</p><p>为什么不直接用邻接矩阵呢（</p><h2 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5023" target="_blank" rel="noopener">T2</a></h2><p>神仙结论题……切不动切不动。随便打了个爆搜找到了$n=2$和$n=3$时的规律。虽然说$n=1$时规律很明显，然而我当时智障忘判断了（</p><h2 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5024" target="_blank" rel="noopener">T3</a></h2><p>究极神仙题，读完题yy出ddp，然而不会，只拿了$O(nm)$的44分。</p><p>估分100+65+44=204（不存在的，肯定比这个低）。</p><p>这么两天算下来，乐观估计的话，差不多有100+100+25+100+65+44=434分，保守估计应该不会掉到400分以下，应该算是稳了吧……</p><p>不不不不存在的，我一定会六道题全部写炸然后华丽爆零并退役（</p><p>好像其他dalao们都有这样那样乱七八糟的地方出锅了啊……</p><p>下午请假回家开心地颓废。</p><h1 id="Extra-Notes"><a href="#Extra-Notes" class="headerlink" title="Extra Notes"></a>Extra Notes</h1><p>果然是等到NOIp结束后才更新的。</p><p>以及，我比较菜，第一次写游记，写的<del>可能</del>一定很菜，所以……算了，告辞。</p><blockquote><p>Updated on 2018-11-26</p><p>好像有些晚的更新。</p><p>出正式成绩之后被教练赶回教室补了一段时间文化课，感觉刚刚度过了人生中最长的一星期（</p><p>具体成绩差不多是100+100+20+100+65+36=421。</p><p>以上。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;€€£：禁赛警告。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="https://github.com/Challestend/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="NOIp" scheme="https://github.com/Challestend/tags/NOIp/"/>
    
      <category term="2018" scheme="https://github.com/Challestend/tags/2018/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu-P5009」毒瘤分块题</title>
    <link href="https://github.com/Challestend/luogu-p5009-solution/"/>
    <id>https://github.com/Challestend/luogu-p5009-solution/</id>
    <published>2018-11-08T00:04:22.000Z</published>
    <updated>2018-12-12T02:05:04.885Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5009" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>从来没做过这么毒瘤的题qaq</p><p>就算看了题解现在还是一脸懵逼qaq</p><p>首先，题目带了分块，我们可以先考虑分块。但是我太菜了不知道分块怎么写，所以我写的线段树qaq</p><p>对$v$的修改相对来说比较简单，我们来重点看对$a$和$b$的修改。假设在某个时刻$t_1$，我们将某个$a_i$加上了$x$，然后又在某个时刻$t_2(t_2&gt;t_1)$，我们要查询之前那个位置上的值，很明显地，答案应该是$v_i+t_1a_ib_i+(t_2-t_1)(a_i+x)b_i$。但是如果真的像这样计算，每次修改就要在这个表达式后面加上一项，很难有效地维护大量的修改。考虑到对$v$的修改比较简单，我们可以通过修改$v$将表达式维持在一个较为简单的形式。形式化地，我们可以找到一个$v_i^\prime$使得$v_i^\prime+t_1(a_i+x)b_i=v+t_1a_ib_i$，并将$v_i$修改至$v_i^\prime$，然后查询的时候我们就可以直接返回$v_i^\prime+t_2(a_i+x)b_i$了。不难发现$v_i^\prime=v_i-t_1xb_i$。</p><p>需要注意的是，因为我们要使用线段树维护，必然会遇到同一个区间被连续修改多次的情况。假设有这样一个区间，区间内$a$的总修改值是$x$，$b$的总修改值是$y$，那么在某一时刻$t$，该区间内所有值的和应该是$\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$。现在我们考虑将$a$加上$z$，此时$\Sigma v_i^\prime+t\Sigma (a_i+x+z)(b_i+y)=\Sigma v_i+t\Sigma (a_i+x)(b_i+y)$，即$\Sigma v_i^\prime=\Sigma v_i-tz\Sigma (b_i+y)$。</p><p>不过，上式中$tz\Sigma (b_i+y)$的$(b_i+y)$指的是修改后的$b_i$的值，我们是肯定不能在下推标记时存储每一个历史版本的$b_i$的。我们考虑拆括号，将上式拆成$tz\Sigma b_i+tzy$，其中$tzy$是一个常数，我们可以直接累加入标记。而至于$tz\Sigma b_i$，考虑到每层节点的$\Sigma b_i$都不同，我们可以维护一个$B$，意思是$\Sigma v_i+=B\Sigma b_i$，每次修改时$B+=tz$。当然，我们还需要一个标记来记录对$a$自身的修改。对$b$的修改也是类似的。</p><p>然后是毒瘤的下推标记。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addv[son]+=A[father]*suma[son]+B[father]*sumb[son]+addv[father];</span><br><span class="line"><span class="comment">//就是上面这句qaq现在还是一脸懵逼qaq</span></span><br><span class="line">A[son]+=A[father];</span><br><span class="line">B[son]+=B[father];</span><br><span class="line">adda[son]+=adda[father];</span><br><span class="line">addb[son]+=addf[father];</span><br></pre></td></tr></table></figure><p>其实我也不知道我上面在扯些啥，所以以下是代码<del>，反正应该没人能看懂我的清奇写法（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 200005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 100000007</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line"><span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line"><span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line"><span class="keyword">if</span>(ih==it)</span><br><span class="line"><span class="keyword">return</span> EOF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *ih++;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">return</span> getchar();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">oh=cltout;</span><br><span class="line">&#125;</span><br><span class="line">*oh++=c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> c=gc();</span><br><span class="line"><span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line"><span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">sn=<span class="number">-1</span>,c=gc();</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">x*=sn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">pc(<span class="number">45</span>),x=-x;</span><br><span class="line"><span class="keyword">if</span>(!x)</span><br><span class="line">pc(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line"><span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">pc(text);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> sumv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],suma[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sumb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],sump[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> A[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],B[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> addv[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],adda[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>],addb[(maxn&lt;&lt;<span class="number">2</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> ln,<span class="keyword">int</span> rn)</span></span>&#123;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addv[cur]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*ln%mod)%mod;</span><br><span class="line">suma[cur&lt;&lt;<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*adda[cur]%mod)%mod;</span><br><span class="line">sumb[cur&lt;&lt;<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*ln*addb[cur]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">A[cur&lt;&lt;<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">B[cur&lt;&lt;<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">adda[cur&lt;&lt;<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">addb[cur&lt;&lt;<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addv[cur]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*addb[cur]*suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*adda[cur]*addb[cur]%mod*rn%mod)%mod;</span><br><span class="line">suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*adda[cur]%mod)%mod;</span><br><span class="line">sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*rn*addb[cur]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*A[cur]*adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+<span class="number">1L</span>L*B[cur]*addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]%mod)%mod;</span><br><span class="line">addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addv[cur])%mod;</span><br><span class="line">A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(A[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+A[cur])%mod;</span><br><span class="line">B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(B[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+B[cur])%mod;</span><br><span class="line">adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(adda[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+adda[cur])%mod;</span><br><span class="line">addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=(addb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]+addb[cur])%mod;</span><br><span class="line">A[cur]=B[cur]=addv[cur]=adda[cur]=addb[cur]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">(<span class="keyword">int</span> cur)</span></span>&#123;</span><br><span class="line">sumv[cur]=(sumv[cur&lt;&lt;<span class="number">1</span>]+sumv[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">suma[cur]=(suma[cur&lt;&lt;<span class="number">1</span>]+suma[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">sumb[cur]=(sumb[cur&lt;&lt;<span class="number">1</span>]+sumb[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">sump[cur]=(sump[cur&lt;&lt;<span class="number">1</span>]+sump[cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">cltstream::read(sumv[cur]);</span><br><span class="line">cltstream::read(suma[cur]);</span><br><span class="line">cltstream::read(sumb[cur]);</span><br><span class="line">sumv[cur]=(sumv[cur]%mod+mod)%mod;</span><br><span class="line">suma[cur]=(suma[cur]%mod+mod)%mod;</span><br><span class="line">sumb[cur]=(sumb[cur]%mod+mod)%mod;</span><br><span class="line">sump[cur]=<span class="number">1L</span>L*suma[cur]*sumb[cur]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">build(cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">build(cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)</span><br><span class="line"><span class="keyword">return</span> (sumv[cur]+<span class="number">1L</span>L*t*sump[cur]%mod)%mod;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,res=<span class="number">0</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>,l,mid))%mod;</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">res=(res+query(L,R,t,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r))%mod;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyV</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">sumv[cur]=(sumv[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">addv[cur]=(addv[cur]+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">modifyV(L,R,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyA</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*sumb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">suma[cur]=(suma[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">sump[cur]=(sump[cur]+<span class="number">1L</span>L*sumb[cur]*x%mod)%mod;</span><br><span class="line">B[cur]=(B[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*addb[cur]%mod+mod)%mod)%mod;</span><br><span class="line">adda[cur]=(adda[cur]+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">modifyA(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modifyB</span><span class="params">(<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> t,<span class="keyword">int</span> x,<span class="keyword">int</span> cur,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=L&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">sumv[cur]=(sumv[cur]+(<span class="number">-1L</span>L*x*t%mod*suma[cur]%mod+mod)%mod)%mod;</span><br><span class="line">sumb[cur]=(sumb[cur]+<span class="number">1L</span>L*(r-l+<span class="number">1</span>)*x%mod)%mod;</span><br><span class="line">sump[cur]=(sump[cur]+<span class="number">1L</span>L*suma[cur]*x%mod)%mod;</span><br><span class="line">A[cur]=(A[cur]+(<span class="number">-1L</span>L*x*t%mod+mod)%mod)%mod;</span><br><span class="line">addv[cur]=(addv[cur]+(<span class="number">-1L</span>L*x*t%mod*adda[cur]%mod+mod)%mod)%mod;</span><br><span class="line">addb[cur]=(addb[cur]+x)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">pushDown(cur,mid-l+<span class="number">1</span>,r-mid);</span><br><span class="line"><span class="keyword">if</span>(L&lt;=mid)</span><br><span class="line">modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line"><span class="keyword">if</span>(R&gt;mid)</span><br><span class="line">modifyB(L,R,t,x,cur&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">pushUp(cur);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cltstream::read(n);</span><br><span class="line">cltstream::read(m);</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line"><span class="keyword">int</span> opt,t,l,r,x;</span><br><span class="line">cltstream::read(opt);</span><br><span class="line">cltstream::read(t);</span><br><span class="line">cltstream::read(l);</span><br><span class="line">cltstream::read(r);</span><br><span class="line"><span class="keyword">switch</span>(opt)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cltstream::write(query(l,r,t,<span class="number">1</span>,<span class="number">1</span>,n),<span class="number">10</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cltstream::read(x);</span><br><span class="line">modifyA(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cltstream::read(x);</span><br><span class="line">modifyB(l,r,t,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">cltstream::read(x);</span><br><span class="line">modifyV(l,r,(x%mod+mod)%mod,<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">clop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大概是我太菜了不适合做这种毒瘤题吧qaq</p><p><img src="https://i.loli.net/2018/11/08/5be38edf529ca.jpg" alt=""></p><p>距 <strong>在NOIp2018爆零</strong> 还剩 <strong>1 天</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5009&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="洛谷" scheme="https://github.com/Challestend/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="线段树" scheme="https://github.com/Challestend/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>状态压缩动态规划学习笔记</title>
    <link href="https://github.com/Challestend/status-compression-learning-notes/"/>
    <id>https://github.com/Challestend/status-compression-learning-notes/</id>
    <published>2018-10-24T13:24:05.000Z</published>
    <updated>2018-12-19T12:03:55.791Z</updated>
    
    <content type="html"><![CDATA[<p><del>把标签和分类连在一起读就是标题了（</del></p><p><del>好像上一篇珂朵莉树学习笔记也是这样（</del></p><p><del>马上就要复赛了，但反正我已经退役预定了来颓blog吧。</del></p><a id="more"></a><p>首先我们来看一道例题，<a href="https://www.luogu.org/problemnew/show/P1879" target="_blank" rel="noopener">「USACO06NOV」玉米田Corn Fields</a>。</p><p>首先，我们想到定义<code>f[i][...]</code>表示当前处理到第$i$行，然后blablabla一堆状态的总方案数。既然任意两块草地之间不能有公共边，我们肯定需要记录第$i$行哪些地方种了草，哪些地方没种草。那么我们记录的状态就是……<code>f[i][0/1]...(省略10个[0/1])...[0/1]</code>，后面$12$维状态中第$j+1$维表示的是第$i$行第$j$列是否种草。</p><p>但是等等……$13$维的状态……</p><p><img src="https://i.loli.net/2018/10/24/5bd07656b885a.jpg" alt=""></p><p>注意到，后面$12$维状态只有$0$和$1$，于是我们就有了这么一个想法：把后$12$维状态看成一个$2$进制数，其中从右往左第$i$位表示当前行第$i$列是否种草，$1$表示种，$0$表示不种。在这一过程中，我们将后$12$维状态「压缩」成了一个$2$进制数，这也正是「状态压缩」这个名字的含义。</p><p>于是，现在我们定义<code>f[i][S]</code>表示当前处理到第$i$行，其中第$i$行的状态是$S$的总方案数。在转移时，我们还需要判断状态是否合法，我们可以定义<code>a[i]</code>表示第$i$行哪些格子能种草，$1$表示能，$0$表示不能。<code>valid[S]</code>表示如果不考虑某些格子不能种草，状态$S$是否合法，也就是是否不存在两个相邻的$1$。<code>a[i]</code>在读入时就可以处理出来，至于<code>valid[S]</code>，我们可以通过这样的一个循环处理出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    valid[i]=valid[i&gt;&gt;<span class="number">1</span>]&amp;(~(i&amp;(i&gt;&gt;<span class="number">1</span>)&amp;<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>用人话来讲就是<code>[S是否合法]=[S&gt;&gt;1是否合法]&amp;[S与S&gt;&gt;1的最后一位是否不同为1]</code>。</p><p>在转移时，我们认为当前枚举到的状态是合法的当且仅当它只在能种草的格子上种草，并且不与上一行的状态冲突，也就是<code>(S|a[i])==a[i]&amp;&amp;valid[S]&amp;&amp;(S&amp;S&#39;)==0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        f[<span class="number">1</span>][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i])==a[i]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(k&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    (f[i][j]+=f[i<span class="number">-1</span>][k])%=mod;</span><br></pre></td></tr></table></figure><p>粗略计算的话，时间复杂度差不多是$O(n4^m)$，最坏情况下差不多是$12\times 4^{12}=201326592$，看着很吓人，然而实际上，其中大部分状态都是不合法的，会被我们的两个<code>if</code>剪掉，因而实际运行跑得比谁都快（</p><p>为了更好地体会状压的复杂度的神奇之处，我们再来看一下这道题，<a href="https://www.luogu.org/problemnew/show/P2704" target="_blank" rel="noopener">「NOI2001」炮兵阵地</a>。</p><p>因为一个炮兵部队的攻击范围能够上下扩展两行，我们在记录状态时，需要记录之前两行的状态，也就是用<code>f[i][S1][S2]</code>表示当前处理到第$i$行，第$i-1$行状态为$S1$，第$i$状态为$S2$时最多能放多少个炮兵部队。我们自然也需要记录<code>a[i]</code>和<code>valid[S]</code>，不过，这次<code>valid[s]</code>的预处理过程差不多是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)&#123;</span><br><span class="line">    valid[i]=(i&amp;<span class="number">1</span>)?valid[i&gt;&gt;<span class="number">3</span>]&amp;((~i)&gt;&gt;<span class="number">2</span>)&amp;((~i)&gt;&gt;<span class="number">1</span>):valid[i&gt;&gt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/10/25/5bd124f4cdbb9.jpg" alt=""></p><p><del>看起来</del>有些<del>非常</del>复杂，用人话来讲就是……诶我当时是不是写错了（</p><p>……不好像又没写错……</p><p>好吧没写错。</p><p>如果$S$的最后一位是$1$，则<code>[S是否合法]=[S&gt;&gt;3是否合法]&amp;[S的倒数第2位和倒数第3位是否都为0]</code>，否则<code>[S是否合法]=[S&gt;&gt;1是否合法]</code>。</p><p>因为我们要求的是最多能放多少个炮兵部队，我们还需要知道某个状态放了多少个炮兵部队，也就是某个状态$S$在二进制下$1$的个数，我们可以这样处理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>转移过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="number">1</span>&lt;&lt;m);++i)</span><br><span class="line">    <span class="keyword">if</span>((i|a[<span class="number">1</span>])==a[<span class="number">1</span>]&amp;&amp;valid[i])</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">            <span class="keyword">if</span>((j|a[<span class="number">2</span>])==a[<span class="number">2</span>]&amp;&amp;valid[j]&amp;&amp;(i&amp;j)==<span class="number">0</span>)</span><br><span class="line">                    f[<span class="number">2</span>][i][j]=cnt[i]+cnt[j];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">3</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;(<span class="number">1</span>&lt;&lt;m);++j)</span><br><span class="line">        <span class="keyword">if</span>((j|a[i<span class="number">-2</span>])==a[i<span class="number">-2</span>]&amp;&amp;valid[j])</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(<span class="number">1</span>&lt;&lt;m);++k)</span><br><span class="line">                <span class="keyword">if</span>((k|a[i<span class="number">-1</span>])==a[i<span class="number">-1</span>]&amp;&amp;valid[k]&amp;&amp;(j&amp;k)==<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">0</span>;l&lt;(<span class="number">1</span>&lt;&lt;m);++l)</span><br><span class="line">                        <span class="keyword">if</span>((l|a[i])==a[i]&amp;&amp;valid[l]&amp;&amp;(l&amp;j)==<span class="number">0</span>&amp;&amp;(l&amp;k)==<span class="number">0</span>)</span><br><span class="line">                            f[i][k][l]=max(f[i][k][l],f[i<span class="number">-1</span>][j][k]+cnt[l]);</span><br></pre></td></tr></table></figure><p>时间复杂度差不多是$O(n8^m)$，最坏情况下差不多是$100\times 8^{10}=107374182400$，然而由于转移过程中的大量剪枝，实际时间复杂度差不多是$O(\text{won’t TLE})$（</p><p>我们再来看一个状压的应用，<a href="https://www.spoj.com/problems/MMINPAID/" target="_blank" rel="noopener">「SP3953」MMINPAID - Paid Roads</a>，或者您也可以<del>反正我就是</del>在<a href="https://www.luogu.org/problemnew/show/SP3953" target="_blank" rel="noopener">洛谷</a>上提交。</p><p>大概是一道最短路，然而与一般的最短路不同的是，在这道题中，经过某条边之前所经过的节点集合如果不同，可能会导致花费的不同。这样一来，我们一般的最短路算法就会有后效性。解决方法也很简单，就是把经过节点集合压缩到一个$2$进制数内。定义<code>dis[u][S]</code>为只经过$S$内的节点的前提下，从$1$到$u$的最小花费。对于$u$发出的所有边的终点$v$，<code>dis[v][S|(1&lt;&lt;(v-1))]=min(dis[v][S|(1&lt;&lt;(v-1))],dis[u][S]+cost)</code>，其中$cost$表示经过从$u$到$v$这条边的花费，当然这需要分情况讨论。</p><p>这样一来，我们只需要写一个可重复入队的堆优化Dijkstra就可以了。需要注意的是，我们需要把节点与经过节点集合看成是一个整体，或者说，将它们联系在一起然后抽象成一个「点」。</p><p><del>我是不会说我把impossible打成Impossible然后交上去WA了一发的（</del></p><p>一般情况下，如果一道题数据范围很小，但是爆搜过不去，比如说$n\leqslant 20$，就很有可能是状压题<del>或者也有可能是神仙剪枝题</del>。大部分状压的时间复杂度都不会直接是一个$O(2^n)$，$O(n2^n)$或者说$O(n^22^n)$大概比较常见，当然我比较菜，做过的题比较少，所以这一段基本是瞎扯。</p><p><img src="https://i.loli.net/2018/10/25/5bd13984b8601.jpg" alt=""></p><p>以上，我觉得我的状压讲的差不多了（</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;把标签和分类连在一起读就是标题了（&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;好像上一篇珂朵莉树学习笔记也是这样（&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;马上就要复赛了，但反正我已经退役预定了来颓blog吧。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="状态压缩" scheme="https://github.com/Challestend/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="动态规划" scheme="https://github.com/Challestend/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>珂朵莉树学习笔记</title>
    <link href="https://github.com/Challestend/chtholly-tree-learning-notes/"/>
    <id>https://github.com/Challestend/chtholly-tree-learning-notes/</id>
    <published>2018-10-13T13:13:09.000Z</published>
    <updated>2018-12-19T12:03:00.539Z</updated>
    
    <content type="html"><![CDATA[<p><del>还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。</del></p><p><del>话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。</del></p><p>总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。</p><a id="more"></a><p>我们先来看一道<del>毒瘤</del>例题，<a href="http://codeforces.com/contest/896/problem/C" target="_blank" rel="noopener">「CF896C」Willem, Chtholly and Seniorious</a>。</p><p>如果只看前三个操作的话<del>，虽然我不会写也没写过</del>，我觉得分块大概是可以做的。然而操作四是个什么鬼？区间$10^{9}$次方和？认真的？</p><p>这种时候我们就需要用到珂朵莉树了。珂朵莉树的英文名叫Old Driver Tree，简称ODT。当然您也可以叫它Chtholly Tree。从本质上来讲，珂朵莉树是一种基于<code>std::set</code>的暴力数据结构<del>，虽然您也可以手写一颗平衡树</del>，它的高效几乎全部建立在数据的完全随机上。如果您看过一些其他的珂朵莉树的学习笔记或者是题解的话，您应该总是会看到这样一句话：</p><blockquote><p>珂朵莉树的核心操作在于推平一段区间，使一整段区间内的东西变得一样。</p></blockquote><p>那么怎么推平呢？不急，我们慢慢讲。</p><p>珂朵莉树存储的是区间，而且每个区间内的所有值都相同，也就是说，我们需要存储的是一个区间的左右端点和值。我们可以写一个结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line">    <span class="comment">//这里的mutable是为了让我们在之后的修改过程中可以修改val的值</span></span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">//调用时_r或_val不填的话默认-1，为了后面split时方便</span></span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们就可以初始化了。对于这道题，我们可以像这样初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>初始化完了？</p><p>初始化完了。</p><p>然后就是珂朵莉树的核心操作<del>之一</del>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::&lt;<span class="built_in">set</span>&gt;::<span class="function">iterator <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span></span><br></pre></td></tr></table></figure><p>作用是分离出一个左端点为<code>pos</code>的区间并返回它的迭代器。它的具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="comment">//上面这句手打非常麻烦，建议宏定义</span></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="comment">//找第一个左端点大于等于pos的区间</span></span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="comment">//如果找到了一个左端点恰好为pos的区间，我们就不用split了，直接返回它的迭代器</span></span><br><span class="line">    --it;</span><br><span class="line">    <span class="comment">//否则当前区间的左端点一定大于pos，pos这个位置一定在前一个区间内</span></span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">    <span class="comment">//将区间[l,r]删除，并插入区间[l,pos)和[pos,r]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然只是把一个区间砍成两半又放回去了，但我们并不是在做无用功，因为我们把原区间与操作无关的部分分离开了。</p><p><code>insert</code>函数的返回值类型是<code>std::pair&lt;std::_Rb_tree_const_iterator&lt;node&gt;,bool&gt;</code><del>，别问我啥意思我也不懂，我只是从它的错误报告里抄过来了</del>，因此我们需要加个<code>.first</code>。</p><p><code>std::set</code>内部是用红黑树实现的，虽然我没写过，不过据说，它每次操作的时间复杂度都是近似$O(\operatorname{log}n)$的。</p><p>然后是一个同样很核心的操作，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span></span><br></pre></td></tr></table></figure><p>将区间$[l,r]$推平，全部赋成$x$。它的具体实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="comment">//注意一定要先split(r+1)再split(l)，因为如果l与r+1一开始恰好在同一区间内</span></span><br><span class="line">    <span class="comment">//后split(r+1)~~大概~~会修改树中左端点为l的区间的迭代器</span></span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    <span class="comment">//将[itl,itr)内所有区间删除</span></span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">    <span class="comment">//用一个大区间取代它们</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就完了？</p><p>这就完了。</p><p><code>assign</code>操作保证了珂朵莉树的时间复杂度，在数据随机的情况下，会使得<code>set</code>的大小迅速减小，并最终趋于$\operatorname{log}n$。本题的操作二就只需调用一次<code>assign(l,r,x)</code>即可。</p><p>然后是剩下的三个操作<del>，一个比一个暴力</del>。</p><p>操作一，一个一个区间地拿出来加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么几行？</p><p>就这么几行。</p><p>操作三，把所有区间取出来，然后直接调用<code>std::sort</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作四，暴力快速幂。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可能会想，这么暴力的东西，时间复杂度确定不会动不动原地起爆？</p><p>这是我在CodeForces上的提交记录：</p><p><img src="https://i.loli.net/2018/10/14/5bc28b1443ea5.png" alt=""></p><p>这是我之前提到的那位<del>不愿意透露姓名的</del>珂学家的跑得最快的一次提交记录：</p><p><img src="https://i.loli.net/2018/10/14/5bc28c7ecfe96.png" alt=""></p><p><img src="https://i.loli.net/2018/10/14/5bc28bc4eed79.jpg" alt=""></p><p>珂幻.jpg</p><p>因为珂朵莉树的高效几乎全部建立在数据的完全随机上，能用珂朵莉树做的题并没有多少，大部分是在做正解是线段树之类的题想不出正解时骗分用。就比如说，我在学习珂朵莉树时参考的一篇题解提到了<a href="http://codeforces.com/contest/915/problem/E" target="_blank" rel="noopener">「CF915E」Physical Education Lessons</a>，然而……</p><p><img src="https://i.loli.net/2018/10/14/5bc297890bbc6.png" alt=""></p><blockquote><p>Updated on 2018-11-01</p><p>后来我卡了卡常数过了……</p><p>以及，删掉了某些内容（</p></blockquote><p>于是，接下来是珂朵莉树的完整板子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">        <span class="keyword">char</span> str[size+<span class="number">1</span>],*head=str,*tail=str;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(head==tail)&#123;</span><br><span class="line">                tail=(head=str)+fread(str,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(head==tail)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *head++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">define</span> gc getchar</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="string">' '</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">20</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];<span class="built_in">putchar</span>(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">putchar</span>(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,seed,maxval;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">long</span> <span class="keyword">long</span> val;</span><br><span class="line"></span><br><span class="line">    node(<span class="keyword">int</span> _l,<span class="keyword">int</span> _r=<span class="number">-1</span>,<span class="keyword">long</span> <span class="keyword">long</span> _val=<span class="number">-1</span>)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        val=_val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=seed;</span><br><span class="line">    seed=(<span class="number">7L</span>L*seed+<span class="number">13</span>)%<span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; l,<span class="keyword">int</span>&amp; r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp=l;</span><br><span class="line">    l=r;</span><br><span class="line">    r=tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> mod)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(y==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">int</span> res=cltpow(x,y&gt;&gt;<span class="number">1</span>,mod);</span><br><span class="line">    res=<span class="number">1L</span>L*res*res%mod;</span><br><span class="line">    <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">        res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(node p,node q)&#123;</span><br><span class="line">    <span class="keyword">return</span> p.l&lt;q.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    _it it=<span class="built_in">std</span>::lower_bound(s.begin(),s.end(),node(pos));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    --it;</span><br><span class="line">    <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> val=it-&gt;val;</span><br><span class="line">    s.erase(it);</span><br><span class="line">    s.insert(node(l,pos<span class="number">-1</span>,val));</span><br><span class="line">    <span class="keyword">return</span> s.insert(node(pos,r,val)).first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAdd</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        p-&gt;val+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">IntervalAssign</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="comment">//就是之前提到的assign</span></span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,x));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">IntervalXth</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    vec.clear();</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        vec.push_back(<span class="built_in">std</span>::make_pair(p-&gt;val,p-&gt;r-p-&gt;l+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::sort(vec.begin(),vec.end());</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;vec.size();++i)&#123;</span><br><span class="line">        x-=vec[i].second;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> vec[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">IntervalXpow</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re _it p=itl;p!=itr;++p)</span><br><span class="line">        res=(<span class="number">1L</span>L*res+<span class="number">1L</span>L*(p-&gt;r-p-&gt;l+<span class="number">1</span>)*cltpow(p-&gt;val%y,x,y)%y)%y;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(seed);</span><br><span class="line">    cltstream::read(maxval);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        s.insert(node(i,i,rnd()%maxval+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt=rnd()%<span class="number">4</span>+<span class="number">1</span>,l=rnd()%n+<span class="number">1</span>,r=rnd()%n+<span class="number">1</span>,x,y;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;r)</span><br><span class="line">            swap(l,r);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAdd(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                IntervalAssign(l,r,x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                x=rnd()%(r-l+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXth(l,r,x),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                x=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                y=rnd()%maxval+<span class="number">1</span>;</span><br><span class="line">                cltstream::write(IntervalXpow(l,r,x,y),<span class="string">'\n'</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;del&gt;还有三周就是NOIp复赛了，我还在这学些乱七八糟的东西怕不是要凉。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;话说上面那个数字是3你们看的出来吗，反正我在我的编辑器内看不出来。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;总之就是，我们机房的一位珂学家突然沉迷数据结构并不知道从哪翻出来的毒瘤数据结构。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="珂朵莉树" scheme="https://github.com/Challestend/tags/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>「SDOI2009」虔诚的墓主人</title>
    <link href="https://github.com/Challestend/luogu-p2154-solution/"/>
    <id>https://github.com/Challestend/luogu-p2154-solution/</id>
    <published>2018-10-12T03:28:50.000Z</published>
    <updated>2018-12-12T02:06:49.568Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2154" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>几个月前某学姐给我推荐的<del>毒瘤</del>题之一。然而我直到现在也只切掉两道<del>，我真是太菜了</del>。</p><p>首先，为了方便，我们将题目中所给的坐标系顺时针旋转一下，令正下为$x$轴正方向。我们先考虑单独一块墓地的虔诚度的计算。设其往左数有$L$棵常青树，往右数有$R$棵常青树，往上数有$U$棵常青树，往下数有$D$棵常青树，其虔诚度就是</p><script type="math/tex; mode=display">C_{L}^{k}C_{R}^{k}C_{U}^{k}C_{D}^{k}</script><p>考虑到墓地不能和常青树重合，又有$k\geqslant 1$，虔诚度为正的，也就是会对答案产生有效贡献的墓地，一定是在某几棵常青树之间。我们在读入时就可以统计出第$x$行，第$y$列上有多少棵常青树，分别记为$sumx[x]$，$sumy[y]$。然后我们令$x$坐标为第一关键字，$y$坐标为第二关键字，将所有常青树按坐标从小到大排序，然后按顺序遍历一遍。假设我们遍历到了第$i$棵常青树，记$cntx[x]$为前$i-1$棵常青树中第$x$行上有多少棵常青树，$cnty[y]$为前$i-1$棵常青树中第$y$列上有多少棵常青树，当前常青树坐标为$(x[i],y[i])$。如果$x[i]=x[i-1]$，则第$i$棵常青树与第$i-1$棵常青树之间就有可能有虔诚度为正的墓地。具体地，它们的虔诚度之和为</p><script type="math/tex; mode=display">C_{cntx[x[i]]}^{k}C_{sumx[x[i]]-cntx[x[i]]}^{k}(\sum\limits_{i=y[i-1]+1}^{y[i]-1}C_{cnty[i]}^{k}C_{sumy[i]-cnty[i]}^{k})</script><p>怎么快速地查询与修改后面那个$\Sigma$所涉及到的值？树状数组啊<del>当然如果您非要写些乱七八糟的数据结构也没人拦着您</del>。</p><p>坐标范围很大，因此我们需要离散化。而且很明显地，没有常青树的行与列是不需要考虑的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NOIp</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> RP,score;</span><br><span class="line">&#125;;</span><br><span class="line">NOIp NOIp2018;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        NOIp2018.RP++;</span><br><span class="line">        NOIp2018.score++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及，明天就是NOIp初赛了，在那之后三周就是复赛，我还不想退役啊<del>但是我实在是太菜了</del>qaq。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P2154&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="https://github.com/Challestend/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="SDOI" scheme="https://github.com/Challestend/tags/SDOI/"/>
    
      <category term="2009" scheme="https://github.com/Challestend/tags/2009/"/>
    
      <category term="离散化" scheme="https://github.com/Challestend/tags/%E7%A6%BB%E6%95%A3%E5%8C%96/"/>
    
      <category term="树状数组" scheme="https://github.com/Challestend/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu-P4900」食堂</title>
    <link href="https://github.com/Challestend/luogu-p4900-solution/"/>
    <id>https://github.com/Challestend/luogu-p4900-solution/</id>
    <published>2018-10-04T04:11:18.000Z</published>
    <updated>2018-12-12T02:04:37.245Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4900" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p><del>闲着没事写篇题解（</del></p><p>简单来说，就是要求</p><script type="math/tex; mode=display">\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\pmod{998244353}</script><p>其中$\lbrace x\rbrace$表示取$x$的小数部分。</p><p>稍加思索，我们不难发现</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}\lbrace\frac{i}{j}\rbrace\\\equiv&\sum\limits_{i=A}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\\\equiv&\sum\limits_{i=1}^{B}\sum\limits_{j=1}^{i}i\%j\times j^{-1}-\sum\limits_{i=1}^{A-1}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}\end{aligned}</script><p>因此，我们只需要关注下式的值</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\pmod{998244353}</script><p>我们可以参考一下<a href="https://www.luogu.org/problemnew/show/P3708" target="_blank" rel="noopener">这道题</a></p><p>在这道题中，我们定义了</p><script type="math/tex; mode=display">f(x)=\sum\limits_{i=1}^{n}x\%i</script><p>首先，如果不考虑$x\%i=0$的情况，我们有</p><script type="math/tex; mode=display">x\%i=(x-1)\%i+1</script><script type="math/tex; mode=display">f(x)=f(x-1)+n</script><p>如果$x\%i=0$，我们需要从$f(x)$中减去$i$，而所有满足该条件的$i$的和就是$x$的约数和，因此</p><script type="math/tex; mode=display">f(x)=f(x-1)+n-\sigma(x)</script><p>我们可以类似地定义</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{n}x\%i\times i^{-1}\pmod{998244353}</script><script type="math/tex; mode=display">h(x)=\sum\limits_{i\mid x}i\times i^{-1}\equiv\sum\limits_{i\mid x}1\equiv d(x)\pmod{998244353}</script><p>从而我们有</p><script type="math/tex; mode=display">g(x)\equiv g(x-1)+\sum\limits_{i=1}^{n}i^{-1}-d(x)\pmod{998244353}</script><p>然而我们需要的是</p><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>其中</p><script type="math/tex; mode=display">ans(x)=\sum\limits_{i=1}^{x}x\%i\times i^{-1}\pmod{998244353}</script><p>不难发现当$i&lt;j$时$i\%j=i$，从而</p><script type="math/tex; mode=display">\begin{aligned}&g(x)-ans(x)\\\equiv&\sum\limits_{i=x+1}^{n}x\%i\times i^{-1}\\\equiv&\sum\limits_{i=x+1}^{n}x\times i^{-1}\pmod{998244353}\end{aligned}</script><p>最终，我们得到</p><script type="math/tex; mode=display">ans(x)\equiv g(x)-x\sum\limits_{i=x+1}^{n}i^{-1}</script><script type="math/tex; mode=display">\sum\limits_{i=1}^{n}\sum\limits_{j=1}^{i}i\%j\times j^{-1}\equiv\sum\limits_{i=1}^{n}ans(i)\pmod{998244353}</script><p>把上面这一坨东西预处理出来，我们就可以$O(1)$地处理所有询问了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4900&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="https://github.com/Challestend/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="洛谷" scheme="https://github.com/Challestend/tags/%E6%B4%9B%E8%B0%B7/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu-P3924」康娜的线段树</title>
    <link href="https://github.com/Challestend/luogu-p3924-solution/"/>
    <id>https://github.com/Challestend/luogu-p3924-solution/</id>
    <published>2018-09-29T08:20:16.000Z</published>
    <updated>2018-12-19T12:01:29.650Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3924" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>读完题目以后，首先一种简单的想法就是建一颗线段树然后模拟，每个节点维护它所管理的区间内所有数的和以及他自身被访问的概率，以及它和它的子树内所有节点的前两个属性的乘积之和。然后你再一看数据范围：</p><blockquote><p>对于$70\%$的数据，保证$1\leqslant n,m\leqslant 10^{5}$。</p><p>对于$100\%$的数据，保证$1\leqslant n,m\leqslant 10^{6}$。</p></blockquote><p><del>也就是说，上述做法<strong>最多</strong>只能拿$70$分。为什么说「最多」呢？因为这道题在中间运算过程中需要使用浮点数，而浮点数是自带大常数的，如果你的程序写得再丑一点常数再大一点，说不定$70$分都拿不到了。</del></p><blockquote><p>Updated on 2018-10-09</p><p>不好意思时间复杂度算错了我太菜了。</p><p>但反正线段树需要卡常才能过（</p></blockquote><p>我们来想办法优化。考虑到，对于线段树的每一个非叶子节点，它所维护的区间和也只是原序列中某一段数字的和，如果我们能把这些节点被访问的概率下推到它的每一个叶子节点，也许就能达到优化的目的。</p><p>定义$E_i$为叶子节点$[i,i]$对答案的贡献，$c_i$为其所有祖先节点被访问的概率之和，不难发现$c_ia_i=E_i$。我们只要预处理出$c_i$，计算出$\prod_{i=1}^{n}c_ia_i$，然后处理出$c_i$的前缀和，每次操作直接查询操作区间内$c_i$的和，再乘以他给的那个数，累加到答案上就可以了。</p><p>稍加分析，我们不难得出如下结论。设根节点深度为$0$，则任意一个节点，就比如说$x$，被访问的概率为$2^{-dep[x]}$，其中$dep[x]$表示$x$的深度。而对于$x$子树内的每一个叶子节点$[i,i]$，我们执行一次$c_i+=2^{-dep[x]}$即可。我们可以用一次类似于树形DP的DFS来完成这一过程。需要注意的是，我们肯定不能暴力枚举所有叶子节点，在DFS时，我们实际上修改的是$c$数组的差分数组，DFS结束后再还原出$c$数组即可。</p><p>以及，最后一句话。</p><p>这道题卡精度。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3924&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="洛谷" scheme="https://github.com/Challestend/tags/%E6%B4%9B%E8%B0%B7/"/>
    
      <category term="差分" scheme="https://github.com/Challestend/tags/%E5%B7%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu-T47720」孤立元</title>
    <link href="https://github.com/Challestend/luogu-t47720-solution/"/>
    <id>https://github.com/Challestend/luogu-t47720-solution/</id>
    <published>2018-09-27T06:29:56.000Z</published>
    <updated>2018-12-29T04:37:49.951Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/T47720" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>自己出的第一道<del>毒瘤</del>数论题。</p><p>对于每一个$i(1&lt;i&lt;n)$，如果它成为了孤立元，那么一定有$i-1\notin B$且$i+1\notin B$，而其他$n-3$个数无论怎样都无法阻止$i$对所有孤立元的和产生贡献，此时，其他$n-3$个数中有且仅有$m-1$个属于$B$，其总方案数为$C_{n-3}^{m-1}$。而对于$1$和$n$来说，它们只有$1$个相邻的元素，因此方案数为$C_{n-2}^{m-1}$。本题答案即为</p><script type="math/tex; mode=display">\frac{\sum_{i=2}^{n-1}iC_{n-3}^{m-1}+(n+1)C_{n-2}^{m-1}}{C_{n}^{m}}</script><p>将这个式子进行一系列惨无人道的化简与整理后，我们得到如下形式</p><script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m-1)}{2n(n-1)}+\frac{m(n+1)(n-m)}{n(n-1)}</script><blockquote><p>Updated on 2018-10-10</p><p>之前公式写错了，分子上的$m$全都漏掉了（</p><p>以及，我们还可以将上式继续整理：</p><script type="math/tex; mode=display">\frac{m(n+1)(n-m)(n-m+1)}{2n(n-1)}</script><p><del>以及，顺便测试了一下新的快读板子，然后发现<code>#ifdef</code>真没用也可能是我太菜了（</del></p><blockquote><p>Updated on 2018-10-16</p><p>好吧我当时并不会用<code>#ifdef</code>（</p></blockquote><p>以及，标程经过一系列<del>丧心病狂的</del>卡常卡到了$1861\text{ms}$，最慢的一个点只跑了$300\text{ms}$不到。截至本日，另外两个切掉这道题的$\text{dalao}$最慢的一个点也只跑了$400\text{ms}$上下。我要不要考虑加强一波数据或者缩一波时限呢？<del>所以说为什么我当初在本地测的时候平均每个点$500\text{ms}$，是我们机房的电脑太菜了吗（</del></p></blockquote><p>于是做法就有了，先$O(n)$预处理一遍，然后单次询问即可$O(1)$解决。</p><p>但是常数好像会很大，我原计划是要将数据范围开到$10^{7}$级别的，然而自己写的标程都跑不过，于是只能一路削到现在的$10^{6}$……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/T47720&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="https://github.com/Challestend/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="组合数学" scheme="https://github.com/Challestend/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="期望" scheme="https://github.com/Challestend/tags/%E6%9C%9F%E6%9C%9B/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/Challestend/hello-world/"/>
    <id>https://github.com/Challestend/hello-world/</id>
    <published>2018-09-27T05:41:19.000Z</published>
    <updated>2018-12-12T02:02:47.401Z</updated>
    
    <content type="html"><![CDATA[<p>总算是搞出来了一个自己觉得海星的blog……</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总算是搞出来了一个自己觉得海星的blog……&lt;/p&gt;

      
    
    </summary>
    
      <category term="其它" scheme="https://github.com/Challestend/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="https://github.com/Challestend/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
  <entry>
    <title>说在前面的话</title>
    <link href="https://github.com/Challestend/announcement/"/>
    <id>https://github.com/Challestend/announcement/</id>
    <published>1899-11-29T16:00:00.000Z</published>
    <updated>2018-12-27T03:46:54.444Z</updated>
    
    <content type="html"><![CDATA[<p>在阅读这个菜鸡的blog之前，您需要知道的一些事情。</p><a id="more"></a><ol><li>在<a href="/poisonous-problems/">有小标题的文章</a>里，侧边栏的网易云外链会出锅。原因不明。</li><li>在撰写评论时，推荐您在「邮箱」一栏如实填写自己用于注册Gravatar的邮箱，使用您Gravatar上的头像。<del>当然，如果您实在是懒得搞什么G啥玩意的，</del>您也可以随便填点什么，我们会基于您填写的内容生成一个随机头像。<strong>但是无论如何不推荐留空。而且一定要保证满足邮箱的格式，即<code>?*@?*.com</code>。其中<code>?*</code>表示这里可以填任意多个字符，但不能是零个，而且不能包含一些奇怪的字符，包括但不限于<code>/</code>、<code>.</code>。</strong></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在阅读这个菜鸡的blog之前，您需要知道的一些事情。&lt;/p&gt;
    
    </summary>
    
      <category term="其它" scheme="https://github.com/Challestend/categories/%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="其它" scheme="https://github.com/Challestend/tags/%E5%85%B6%E5%AE%83/"/>
    
  </entry>
  
</feed>
