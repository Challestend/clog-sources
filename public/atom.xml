<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chromium</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/Challestend/"/>
  <updated>2019-04-14T13:02:53.765Z</updated>
  <id>https://github.com/Challestend/</id>
  
  <author>
    <name>Challestend Rehtorbegnaro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>「NOI2016」循环之美</title>
    <link href="https://github.com/Challestend/luogu-p1587-solution/"/>
    <id>https://github.com/Challestend/luogu-p1587-solution/</id>
    <published>2019-04-14T09:16:32.000Z</published>
    <updated>2019-04-14T13:02:53.765Z</updated>
    
    <content type="html"><![CDATA[<p>突然被wzx安利的一道题。</p><p><a href="https://www.luogu.org/problemnew/show/P1587" target="_blank" rel="noopener">传送门</a></p><p><a href="https://www.cnblogs.com/asuldb/p/10706088.html" target="_blank" rel="noopener">wzx的题解</a></p><a id="more"></a><p><del>通过查阅fuge的题解，</del>我们发现我们要求的式子是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]</script><p>$[i\perp j]$保证了这是一个最简分数从而不会算重，$[j\perp k]$保证了这是一个纯循环小数。</p><p>首先关于$[1,n]$中与某个常数$k$互质的数的数量，我们有一个结论</p><script type="math/tex; mode=display">\sum_{i=1}^{n}[i\perp k]=\sum_{i=1}^{n}\sum_{x|i,x|k}\mu(x)=\sum_{x|k}\lfloor\cfrac{n}{x}\rfloor\mu(x)</script><p>然后大力整理</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=1}^{n}\sum_{j=1}^{m}[i\perp j][j\perp k]&=\sum_{j=1}^{m}[j\perp k]\sum_{i=1}^{n}[i\perp j]\\&=\sum_{j=1}^{m}[j\perp k]\sum_{x|j}\lfloor\cfrac{n}{x}\rfloor\mu(x)\\&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{x|j}[j\perp k]\\&=\sum_{x=1}^{m}\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[jx\perp k]\\&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{j=1}^{\tfrac{m}{x}}[j\perp k]\\&=\sum_{x=1}^{m}[x\perp k]\lfloor\cfrac{n}{x}\rfloor\mu(x)\sum_{y|k}\lfloor\cfrac{m}{xy}\rfloor\mu(y)\end{aligned}</script><p>这道题有一个突破口在于，$k$的范围很小，只有$2000$，从而$d(k)$的范围会更小，这就使得我们能够暴力枚举$k$的约数来计算第二个$\sum$。</p><p>观察第一个$\sum$，我们发现，套上一层整除分块之后，我们需要计算的是</p><script type="math/tex; mode=display">\sum_{i=1}^{n}f(i)</script><p>其中</p><script type="math/tex; mode=display">f(n)=[n\perp k]\mu(n)</script><p>考虑杜教筛，我们再找来一个函数</p><script type="math/tex; mode=display">g(n)=[n\perp k]</script><p>把它们卷积</p><script type="math/tex; mode=display">\begin{aligned}(f\times g)(n)&=\sum_{d|n}f(d)g(\cfrac{n}{d})\\&=\sum_{d|n}[d\perp k][\cfrac{n}{d}\perp k]\mu(d)\\&=[n\perp k]\sum_{d|n}\mu(d)\\&=\epsilon(n)\end{aligned}</script><p>然后就差不多了。</p><p>不过有一个问题，像这种对$n$和$m$同时整除分块的情况，不能用类似min_25的trick（$N\leqslant\sqrt{n}$时存到<code>ans1[N]</code>，否则存到<code>ans2[n/N]</code>），只能通过unordered_map或者Hash来记忆化。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tr1/unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> d[<span class="number">50</span>],f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],mu[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">std</span>::tr1::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">long</span> <span class="keyword">long</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">T</span><span class="params">(re <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d[<span class="number">0</span>];++i)</span><br><span class="line">        res+=<span class="number">1L</span>L*(x/d[i])*mu[d[i]];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> N)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N&lt;=maxn)</span><br><span class="line">        <span class="keyword">return</span> F[N];</span><br><span class="line">    <span class="keyword">if</span>(ans.count(N))</span><br><span class="line">        <span class="keyword">return</span> ans[N];</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">1</span>,lst=T(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">2</span>,r;l&lt;=N;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=N/(N/l);</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> tmp=T(r);</span><br><span class="line">        res-=S(N/l)*(tmp-lst);</span><br><span class="line">        lst=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans[N]=res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    cltstream::read(k);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        <span class="keyword">if</span>(k%i==<span class="number">0</span>)</span><br><span class="line">            d[++d[<span class="number">0</span>]]=i;</span><br><span class="line">    mu[<span class="number">1</span>]=F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">            mu[i]=<span class="number">-1</span>;</span><br><span class="line">            F[i]=-(k%i!=<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%g[j])&#123;</span><br><span class="line">                mu[i*g[j]]=mu[i]*mu[g[j]];</span><br><span class="line">                F[i*g[j]]=F[i]*F[g[j]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=maxn;++i)</span><br><span class="line">        F[i]+=F[i<span class="number">-1</span>];</span><br><span class="line">    re <span class="keyword">long</span> <span class="keyword">long</span> res=<span class="number">0</span>,lst=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n&amp;&amp;l&lt;=m;l=r+<span class="number">1</span>)&#123;</span><br><span class="line">        r=min(n/(n/l),m/(m/l));</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> tmp=S(r);</span><br><span class="line">        res+=(n/l)*T(m/l)*(tmp-lst);</span><br><span class="line">        lst=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::write(res);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;突然被wzx安利的一道题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1587&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/asuldb/p/10706088.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wzx的题解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数论" scheme="https://github.com/Challestend/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>FWT抄袭笔记</title>
    <link href="https://github.com/Challestend/fwt-learning-notes/"/>
    <id>https://github.com/Challestend/fwt-learning-notes/</id>
    <published>2019-04-11T02:28:42.000Z</published>
    <updated>2019-04-12T09:53:06.228Z</updated>
    
    <content type="html"><![CDATA[<p>看到坐在我左边的dalao在学FWT。</p><p>想着二轮前学一些很酷很炫<del>很失败</del>的算法，于是来<del>背一下</del>学一下吧。</p><p><a href="http://www.cnblogs.com/cjyyb/p/9065615.html" target="_blank" rel="noopener">抄袭来源</a>。</p><a id="more"></a><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p>我们利用FFT可以在$O(n\log n)$的时间复杂度内计算</p><script type="math/tex; mode=display">H[k]=(F\times G)[k]=\sum_{i+j=k}F[i]G[j]</script><p>假如说我们把这个式子变一变</p><script type="math/tex; mode=display">H[k]=(F\vee G)[k]=\sum_{i\vee j=k}F[i]G[j]</script><script type="math/tex; mode=display">H[k]=(F\wedge G)[k]=\sum_{i\wedge j=k}F[i]G[j]</script><script type="math/tex; mode=display">H[k]=(F\oplus G)[k]=\sum_{i\oplus j=k}F[i]G[j]</script><p>其中$\vee$指按位或，$\wedge$指按位与，$\oplus$指按位异或。</p><p>我们还是希望能够在$O(n\log n)$的时间复杂度内计算出答案。</p><p>这种时候我们就需要FWT（快速沃尔什变换，Fast Walsh–Hadamard Transformation）了。</p><p>在FFT中，我们先计算出了$F$和$G$的点值多项式，然后将对应位直接相乘得到了$F\times G$的点值多项式，最后还原回了$F\times G$。</p><p>类似地，我们可不可以试着计算出两个多项式$F^{\prime},G^{\prime}$，使得</p><script type="math/tex; mode=display">(F\times G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p><del>当然可以啊不然还怎么会有FWT（</del></p><h3 id="一些约定"><a href="#一些约定" class="headerlink" title="一些约定"></a>一些约定</h3><p>对于两个向量$A$和$B$，我们令</p><script type="math/tex; mode=display">(A,B)=(A[0],A[1],\cdots,B[0],B[1],\cdots)</script><p>设$F$的项数为$2^{t}$。为了方便，我们将其看做一个$2^{t}$维向量</p><script type="math/tex; mode=display">(F[0],F[1],\cdots,F[2^{t}-1])</script><p>然后我们定义</p><script type="math/tex; mode=display">F_{0}=(F[0],F[1],\cdots,F[2^{t-1}-1])</script><script type="math/tex; mode=display">F_{1}=(F[2^{t-1}],F[2^{t-1}+1],\cdots,F[2^{t}-1])</script><h3 id="正变换"><a href="#正变换" class="headerlink" title="正变换"></a>正变换</h3><h4 id="按位或"><a href="#按位或" class="headerlink" title="按位或"></a>按位或</h4><p>定义</p><script type="math/tex; mode=display">F^{\prime}=\begin{cases}&(F_{0}^{\prime},F_{1}^{\prime}+F_{0}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\&F&(t=0)\end{cases}</script><p>我们发现</p><script type="math/tex; mode=display">F^{\prime}[i]=\sum_{j\vee i=i}F[j]</script><p>$t=0$时这十分显然，我们来考虑$t\gt 0$时的情况。</p><p>首先很明显的一点是$j\vee i=i\Leftrightarrow j\subseteq i$，也就是说$j$是$i$的子集。</p><p>对于$F_{1}$中的一个下标$i$，我们在$F_{1}$左边接上$F_{0}$后，这个$i$就多了一个$2^{t-1}$。</p><p>之前$i$的每一个子集$j$，也同样多了一个$2^{t-1}$，它们产生的贡献已经被统计在了$F_{1}^{\prime}[i]$内。</p><p>那么去掉这个$2^{t-1}$，我们还有$j\subseteq i+2^{t-1}$，这部分其实就是$F_{0}^{\prime}[i]$的值。</p><p>据此，我们就有</p><script type="math/tex; mode=display">\begin{aligned}F^{\prime}\cdot G^{\prime}[i]&=\left(\sum_{j\subseteq i}F[j]\right)\left(\sum_{k\subseteq i}G[k]\right)\\&=\sum_{j\vee k\subseteq i}F[j]G[k]\\&=\sum_{l\subseteq i}\sum_{j\vee k=l}F[j]G[k]\\&=\sum_{l\subseteq i}(F\vee G)[l]\\&=(F\vee G)^{\prime}[i]\end{aligned}</script><h4 id="按位与"><a href="#按位与" class="headerlink" title="按位与"></a>按位与</h4><p>定义</p><script type="math/tex; mode=display">F^{\prime}=\begin{cases}&(F_{0}^{\prime}+F_{1}^{\prime},F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\&F&(t=0)\end{cases}</script><p>它具有类似的性质</p><script type="math/tex; mode=display">F^{\prime}[i]=\sum_{j\wedge i=i}F[j]</script><script type="math/tex; mode=display">(F\wedge G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>证明略。</p><h4 id="按位异或"><a href="#按位异或" class="headerlink" title="按位异或"></a>按位异或</h4><p>定义</p><script type="math/tex; mode=display">F^{\prime}=\begin{cases}&(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})\;\;\;\;\;\;\;\;&(t\gt 0)\\&F&(t=0)\end{cases}</script><p>然后我们发现按位异或并没有像上面一样的和子集相关的性质。因此我们需要通过一些其他方式来证明它的正确性。</p><p>首先</p><script type="math/tex; mode=display">(F+G)^{\prime}=F^{\prime}+G^{\prime}</script><p>如果$F$和$G$都只有一项，这十分显然。</p><p>否则</p><script type="math/tex; mode=display">\begin{aligned}F^{\prime}+G^{\prime}&=(F_{0}^{\prime}+F_{1}^{\prime},F_{0}^{\prime}-F_{1}^{\prime})+(G_{0}^{\prime}+G_{1}^{\prime},G_{0}^{\prime}-G_{1}^{\prime})\\&=(F_{0}^{\prime}+G_{0}^{\prime}+F_{1}^{\prime}+G_{1}^{\prime},F_{0}^{\prime}+G_{0}^{\prime}-F_{1}^{\prime}-G_{1}^{\prime})\\&=((F+G)_{0}^{\prime}+(F+G)_{1}^{\prime},(F+G)_{0}^{\prime}-(F+G)_{1}^{\prime})\\&=(F+G)^{\prime}\end{aligned}</script><script type="math/tex; mode=display">(F\oplus G)^{\prime}=F^{\prime}\cdot G^{\prime}</script><p>这个不会证，告辞。</p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p>就是把刚刚算出来的$F^{\prime}$变回$F$。</p><script type="math/tex; mode=display">F=\begin{cases}&F^{\prime}&(t=0)\\&\begin{cases}&(F_{0},F_{1}-F_{0})&(\vee)\\&(F_{0}-F_{1},F_{1})&(\wedge)\\&(\cfrac{F_{0}+F_{1}}{2},\cfrac{F_{0}-F_{1}}{2})\;\;\;\;\;\;\;\;&(\oplus)\end{cases}\;\;\;\;\;\;\;\;&(t\gt 0)\end{cases}</script><p><del>啥意思啊看不懂啊（</del></p><p>然后您就可以切掉这道<a href="https://www.luogu.org/problemnew/show/P4717" target="_blank" rel="noopener">板子题</a>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> F[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>],G[<span class="number">1</span>&lt;&lt;maxn][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FWT(F,tp) &#123;\</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;n;p&lt;&lt;=<span class="number">1</span>)\</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)\</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)&#123;\</span><br><span class="line">                F[j+p][<span class="number">0</span>]=!tp?(F[j+p][<span class="number">0</span>]+F[j][<span class="number">0</span>])%mod:(F[j+p][<span class="number">0</span>]-F[j][<span class="number">0</span>]+mod)%mod;\</span><br><span class="line">                F[j][<span class="number">1</span>]=!tp?(F[j][<span class="number">1</span>]+F[j+p][<span class="number">1</span>])%mod:(F[j][<span class="number">1</span>]-F[j+p][<span class="number">1</span>]+mod)%mod;\</span><br><span class="line">                re <span class="keyword">int</span> x=F[j][<span class="number">2</span>],y=F[j+p][<span class="number">2</span>];\</span><br><span class="line">                F[j][<span class="number">2</span>]=(x+y)%mod;\</span><br><span class="line">                F[j+p][<span class="number">2</span>]=(x-y+mod)%mod;\</span><br><span class="line">                <span class="keyword">if</span>(tp)&#123;\</span><br><span class="line">                    F[j][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j][<span class="number">2</span>]%mod;\</span><br><span class="line">                    F[j+p][<span class="number">2</span>]=<span class="number">499122177L</span>L*F[j+p][<span class="number">2</span>]%mod;\</span><br><span class="line">                &#125;\</span><br><span class="line">            &#125;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    n=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(F[i][<span class="number">0</span>]);</span><br><span class="line">        F[i][<span class="number">1</span>]=F[i][<span class="number">2</span>]=F[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(G[i][<span class="number">0</span>]);</span><br><span class="line">        G[i][<span class="number">1</span>]=G[i][<span class="number">2</span>]=G[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    FWT(F,<span class="number">0</span>);</span><br><span class="line">    FWT(G,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            F[i][j]=<span class="number">1L</span>L*F[i][j]*G[i][j]%mod;</span><br><span class="line">    FWT(F,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">            cltstream::write(F[i][j],i&lt;n<span class="number">-1</span>?<span class="number">32</span>:<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单位元"><a href="#单位元" class="headerlink" title="单位元"></a>单位元</h3><p>我们知道FFT中的单位元多项式是$F(x)=1$，类似地，FWT是否也拥有这样的一个单位元呢？</p><p>当然是有的。</p><p>对于按位或和按位异或来说，它们的单位元是</p><script type="math/tex; mode=display">(1,0,\cdots,0,0)</script><p>对于按位与来说，它的单位元是</p><script type="math/tex; mode=display">(0,0,\cdots,0,1)</script><h3 id="求逆"><a href="#求逆" class="headerlink" title="求逆"></a>求逆</h3><p>既然有了单位元，我们就不禁会想……这东西能求逆吗？</p><p>大概……能吧。</p><p>以下所有运算在模$998244353$意义下进行。</p><h4 id="按位或-1"><a href="#按位或-1" class="headerlink" title="按位或"></a>按位或</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p><script type="math/tex; mode=display">F\vee G=(1,0,\cdots,0,0)</script><p>首先我们需要知道</p><script type="math/tex; mode=display">F\vee G=(F_{0}\vee G_{0},F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1})</script><p>注意到左半部分和右半部分的下标有一个重要区别就是从右往左第$t$位是否为$1$。</p><p>如果某个下标和右半部分的某个下标进行了按位或，它的第$t$位一定是$1$，那么它就跑到右半部分去了。</p><p>否则，即两个左半部分的下标进行了按位或，这种情况结果还是在左半部分。</p><p>然后我们就可以往下推了</p><script type="math/tex; mode=display">\begin{aligned}F_{0}\vee G_{1}+F_{1}\vee G_{0}+F_{1}\vee G_{1}&=0\\(F_{0}+F_{1})\vee G_{1}&=-F_{1}\vee G_{0}\\G_{1}&=-F_{1}\vee G_{0}\vee (F_{0}+F_{1})^{-1}\end{aligned}</script><p>边界条件$G[0]=F[0]^{-1}$。</p><p>大致代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1[<span class="number">1</span>&lt;&lt;maxn],tmp2[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line">        Inv(F,G,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            tmp1[i]=F[i]+F[(n&gt;&gt;<span class="number">1</span>)+i];</span><br><span class="line">        Inv(tmp1,tmp2,n&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            tmp2[i]=<span class="number">1L</span>L*F[(n&gt;&gt;<span class="number">1</span>)+i]*G[i]%mod*tmp2[i]%mod;</span><br><span class="line">        FWT(F+(n&gt;&gt;<span class="number">1</span>),n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        FWT(G,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        FWT(tmp2,n&gt;&gt;<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&gt;&gt;<span class="number">1</span>);++i)</span><br><span class="line">            G[(n&gt;&gt;<span class="number">1</span>)+i]=(mod-tmp2[i])%mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度非常显然是$O(n^{2}2^{n})$。</p><h4 id="按位与-1"><a href="#按位与-1" class="headerlink" title="按位与"></a>按位与</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p><script type="math/tex; mode=display">F\wedge G=(0,0,\cdots,0,1)</script><p>我们可以用类似的过程得到如下结论</p><script type="math/tex; mode=display">F\wedge G=(F_{0}\wedge G_{0}+F_{0}\wedge G_{1}+F_{1}\wedge G_{0},F_{1}\wedge G_{1})</script><script type="math/tex; mode=display">G_{0}=-F_{0}\wedge G_{1}\wedge (F_{0}+F_{1})^{-1}</script><h4 id="按位异或-1"><a href="#按位异或-1" class="headerlink" title="按位异或"></a>按位异或</h4><p>给定一个多项式$F$，让你求出一个多项式$G$，使得</p><script type="math/tex; mode=display">F\oplus G=(1,0,\cdots,0,0)</script><p>首先我们有</p><script type="math/tex; mode=display">F\oplus G=(F_{0}\oplus G_{0}+F_{1}\oplus G_{1},F_{0}\oplus G_{1}+F_{1}\oplus G_{0})</script><p>也就是说</p><script type="math/tex; mode=display">F_{0}\oplus G_{0}+F_{1}\oplus G_{1}=\epsilon</script><script type="math/tex; mode=display">F_{0}\oplus G_{1}+F_{1}\oplus G_{0}=0</script><p>将上面两个式子相加、相减，得到</p><script type="math/tex; mode=display">(F_{0}+F_{1})\oplus(G_{0}+G_{1})=\epsilon</script><script type="math/tex; mode=display">(F_{0}-F_{1})\oplus(G_{0}-G_{1})=\epsilon</script><p>于是</p><script type="math/tex; mode=display">G_{0}=\cfrac{(F_{0}+F_{1})^{-1}+(F_{0}-F_{1})^{-1}}{2}</script><script type="math/tex; mode=display">G_{1}=\cfrac{(F_{0}+F_{1})^{-1}-(F_{0}-F_{1})^{-1}}{2}</script><p>时间复杂度$O(n2^{n})$。</p><p>这就没了？并不是。</p><p>如果您按照上面的式子写好程序，然后往里面输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><p>这样一组数据，您会发现您的程序给出的结果并不正确。</p><p>那么原因是什么呢？是我们式子推错了吗？</p><p>输出一下中间的运算过程，我们发现，在中间有一步，我们计算$(2,2)^{-1}$时，需要用到$(0)^{-1}$。</p><p>显然它不存在，但是同样显然的是，如果$(2,2)^{-1}$存在，那么这个过程不应该出现这样的问题。</p><p>所以说原因就是，$(2,2)^{-1}$，或者更进一步地，$(1,2,3,4)^{-1}$<strong>不存在</strong>。</p><h3 id="子集卷积"><a href="#子集卷积" class="headerlink" title="子集卷积"></a><a href="https://loj.ac/problem/152" target="_blank" rel="noopener">子集卷积</a></h3><p><del>让我来看看有没有点进去看完题面一脸懵逼地关闭标签页的。</del></p><p>这道题是让我们求这个东西</p><script type="math/tex; mode=display">h_{R}=\sum_{S\vee T=R,S\wedge T=\varnothing}f_{S}g_{T}</script><p>这比我们之前看到的卷积拥有更加严格的要求，$S\wedge T=\varnothing$，很明显，这是在提示我们抄题解。</p><p>我们定义</p><script type="math/tex; mode=display">F_{i,S}=\begin{cases}&f_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\&0&(|S|\neq i)\end{cases}</script><script type="math/tex; mode=display">G_{i,S}=\begin{cases}&g_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\&0&(|S|\neq i)\end{cases}</script><script type="math/tex; mode=display">H_{i,S}=\begin{cases}&h_{S}\;\;\;\;\;\;\;\;&(|S|=i)\\&0&(|S|\neq i)\end{cases}</script><p>然后我们从小到大枚举$i$，计算</p><script type="math/tex; mode=display">H_{i}=\sum_{j=0}^{i}F_{j}\vee G_{i-j}</script><p>为了理解这个式子，我们先将其展开</p><script type="math/tex; mode=display">H_{i,R}=\sum_{j=0}^{i}\sum_{S\vee T=R}F_{j,S}G_{i-j,T}</script><p>根据定义，$F_{i,S}$和$G_{i,S}$有值当且仅当$|S|=i$，因此这就相当于</p><script type="math/tex; mode=display">H_{i,R}=\sum_{S\vee T=R,|S|+|T|=i}F_{|S|,S}G_{|T|,T}</script><p>因为$S$和$T$可能会有交集，从而$i\gt |R|$时$H_{i,R}$也可能有值，这是不符合定义的，因此（如果有必要的话）我们需要手动清空。</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000009</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,N;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1</span>&lt;&lt;maxn],F[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],G[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn],H[maxn+<span class="number">1</span>][<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> p=<span class="number">1</span>;p&lt;N;p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i;j&lt;i+p;++j)</span><br><span class="line">                F[j+p]=!tp?(F[j+p]+F[j])%mod:(F[j+p]-F[j]+mod)%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    N=<span class="number">1</span>&lt;&lt;n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        cnt[i]=cnt[i&gt;&gt;<span class="number">1</span>]+(i&amp;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::read(F[cnt[i]][i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::read(G[cnt[i]][i]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        FWT(F[i],<span class="number">0</span>);</span><br><span class="line">        FWT(G[i],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=i;++j)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">                H[i][S]=(H[i][S]+<span class="number">1L</span>L*F[j][S]*G[i-j][S]%mod)%mod;</span><br><span class="line">        FWT(H[i],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> S=<span class="number">0</span>;S&lt;N;++S)</span><br><span class="line">            cnt[S]==i||(H[i][S]=<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        cltstream::write(H[cnt[i]][i],<span class="number">32</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><img src="/images/TIM图片20181011211750.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到坐在我左边的dalao在学FWT。&lt;/p&gt;
&lt;p&gt;想着二轮前学一些很酷很炫&lt;del&gt;很失败&lt;/del&gt;的算法，于是来&lt;del&gt;背一下&lt;/del&gt;学一下吧。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/cjyyb/p/9065615.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;抄袭来源&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="FWT" scheme="https://github.com/Challestend/tags/FWT/"/>
    
  </entry>
  
  <entry>
    <title>「SDOI2019R1游记」僕らは泥を這いつくばるもの</title>
    <link href="https://github.com/Challestend/sdoi2019r1-notes/"/>
    <id>https://github.com/Challestend/sdoi2019r1-notes/</id>
    <published>2019-04-09T00:31:53.000Z</published>
    <updated>2019-04-11T07:28:12.573Z</updated>
    
    <content type="html"><![CDATA[<p>被强大无比且随手吊打我的shzr催更了，于是诚惶诚恐赶来写这篇游记。</p><a id="more"></a><h3 id="Day-X"><a href="#Day-X" class="headerlink" title="Day -X"></a>Day -X</h3><p>经过讨论，我们机房研究出了以下两个堪称完美的战术，若能施加实际行动，定能令SLYZ省选大获全胜：</p><ol><li>让潮子分身，在每一位dalao（如rqy、ckw等）身边分别派一个，然后潮他们，他们就炸了。</li><li>让潮子在厕所蹲着，每看到有选手上厕所，等他上到一半跑到他背后，潮之曰「你稳了」，他就炸了。</li></ol><p><del>这都什么鬼东西（</del></p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day -2"></a>Day -2</h3><p>「省选快到了，我想回家休息休息。」</p><p>像这样理直气壮地请假回家颓废了。</p><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><h4 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h4><p>12：30从学校坐车走，等到了济南已经是大概16：00了。</p><p>到了宾馆loli让我们自由组合。然后mhr学长主动邀请我住一个房间。</p><p>我直接就答应了。</p><h4 id="晚上"><a href="#晚上" class="headerlink" title="晚上"></a>晚上</h4><p>晚上出去吃饭的时候，潮子一直在潮。</p><p>就比如说钦定wzx的SAM没有了A，只剩下了一些奇怪的东西一道题都A不动了。</p><p>可惜绝大部分名言已经失传了。</p><p>这可真是糟糕，OI文学界的一大损失啊。</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>就算没有解压密码也是可以看压缩包内部的文件有哪些的。</p><p>然后就看到了T3有16个样例有点方。</p><p>解压密码直接一坨乱码。龙虾选手表示解压体验(?)极差。</p><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5283" target="_blank" rel="noopener">T1</a></h4><p>诶怎么感觉有点像超级钢琴啊。</p><p>但是因为我超级钢琴只会ST表+堆，想了想发现这题不能这么做。</p><p>好吧，暴力60分先安排上。</p><p>出了考场发现人均A掉T1。</p><h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5284" target="_blank" rel="noopener">T2</a></h4><p>字符串（</p><p>不难想到这么一个做法：对于这$n_{a}+n_{b}$个串每一个建一个点，如果$A$类串$x$支配$B$类串$y$，或者$B$类串$x$是$A$类串$y$的前缀，从$x$向$y$连边。最后整张图有环就是$-1$，没有D个P就出来了。</p><p>然后暴力建图。莫名其妙能有60分。</p><h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5285" target="_blank" rel="noopener">T3</a></h4><p>写作传统题读作提交答案题。</p><p>考场上只想出来了<code>1_998244353</code>的12分。</p><p>然后出考场被各路dalao吊打。</p><p>关于测试点8-16，一开始我的想法是给出两个数$x,y$，有一个长度为$x$的区间从左向右扫过$[1,y]$这个区间。</p><p>但实际上是$[x,y]$这个区间内每个数的性质。想到这一点后面的一些数据范围比较小的点就没啥问题了。</p><p>但是数据范围比较大的点怎么办？</p><p>打一些比较小的表（</p><p>标程70KB了一下。</p><h4 id="下午-1"><a href="#下午-1" class="headerlink" title="下午"></a>下午</h4><p>首先是讲评。</p><p>没有抢到座位于是只能站着。</p><p>因为非常吵什么也听不清。</p><p>印象比较深的是讲到T3突然一阵掌声。</p><p>然后回到宾馆快乐地颓废。</p><h4 id="晚上-1"><a href="#晚上-1" class="headerlink" title="晚上"></a>晚上</h4><p>集体不想出去吃于是点了肯德基，然后……诶诶诶你们什么时候吃完的太快了吧（</p><h3 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h3><h4 id="T1-1"><a href="#T1-1" class="headerlink" title="T1"></a><a href="https://www.luogu.org/problemnew/show/P5289" target="_blank" rel="noopener">T1</a></h4><p>看到题目名我还以为是网络流。</p><p>然后我就在想有没有网络流计数这种操作。</p><p>大概是没有吧。</p><p>打了个爆搜结果还炸了。</p><h4 id="T2-1"><a href="#T2-1" class="headerlink" title="T2"></a><a href="https://www.luogu.org/problemnew/show/P5290" target="_blank" rel="noopener">T2</a></h4><p>看上去好神仙啊。</p><p>考场上写了45分的状压枚举子集。</p><p>结果一出考场听说人均75，就我不会链的贪心和$O(n^{2})$的做法，自毙了。</p><h4 id="T3-1"><a href="#T3-1" class="headerlink" title="T3"></a><a href="https://www.luogu.org/problemnew/show/P5291" target="_blank" rel="noopener">T3</a></h4><p>想写一写$L=n$或$k=1$的情况。</p><p>到最后发现什么也不会，只想到了$L=n$<strong>且</strong>$k=1$的情况。喜提8分。</p><p>但是最后测出来好像是12分来着？没仔细看。</p><h4 id="下午-2"><a href="#下午-2" class="headerlink" title="下午"></a>下午</h4><p>因为有人要回去所以讲评提前了半小时。</p><p>虽然说抢到了一个座位可是今天比昨天还吵真的什么也听不见了。</p><p>T3标程887行了解一下（</p><p><img src="/images/TIM图片20190409113807.jpg" alt></p><p>结果接我们回东营的车咕了大概有一个多小时吧，最后得有20：30才到家。</p><h4 id="晚上-2"><a href="#晚上-2" class="headerlink" title="晚上"></a>晚上</h4><p>当然是回家……啊什么明天就正常上课啦？咕了！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>最后60+60+12+0+45+12=189。</p><p>随便抓只猴子就比我考的高/kk</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;被强大无比且随手吊打我的shzr催更了，于是诚惶诚恐赶来写这篇游记。&lt;/p&gt;
    
    </summary>
    
      <category term="游记" scheme="https://github.com/Challestend/categories/%E6%B8%B8%E8%AE%B0/"/>
    
    
      <category term="SDOI" scheme="https://github.com/Challestend/tags/SDOI/"/>
    
      <category term="2019" scheme="https://github.com/Challestend/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>伯努利数失败笔记</title>
    <link href="https://github.com/Challestend/bernoulli-number-learning-notes/"/>
    <id>https://github.com/Challestend/bernoulli-number-learning-notes/</id>
    <published>2019-03-31T01:33:49.000Z</published>
    <updated>2019-04-01T02:20:42.790Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>「クールでまばゆいばかりのアルゴリズムを学ばないでください、それはうまく検索することが最も重要です。」</p><p>——loli</p></blockquote><p><del>以上，我失败了（</del></p><p><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/guan-yu-bo-nu-li-shuo-zhuai-hua-zi-ran-shuo-mi-hu-gong-shi-di-zheng-mi" target="_blank" rel="noopener">前半部分的抄袭来源</a>。</p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>伯努利数$B_{n}$具有如下性质：</p><script type="math/tex; mode=display">\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><h3 id="自然数幂和"><a href="#自然数幂和" class="headerlink" title="自然数幂和"></a>自然数幂和</h3><p>我们定义</p><script type="math/tex; mode=display">S(n,k)=\sum_{i=0}^{n-1}i^{k}</script><script type="math/tex; mode=display">T(n,k)=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><p>我们希望证明$S(n,k)=T(n,k)$。</p><p>在这里，我们采用一种名为「强归纳法」（或者「完全归纳法」）的方法。具体来说，假设我们已经对于任意的$0\leqslant j\lt k$，证明了$S(n,j)=T(n,j)$成立，利用这个结论推出$S(n,k)=T(n,k)$成立。</p><p>当$k=0$时</p><script type="math/tex; mode=display">S(n,k)=n</script><script type="math/tex; mode=display">T(n,k)=C_{1}^{0}B_{0}n</script><p>因为我们有</p><script type="math/tex; mode=display">C_{1}^{0}B_{0}=[0=0]=1</script><p>从而$S(n,k)=T(n,k)$成立。</p><p>当$k\gt 0$时</p><script type="math/tex; mode=display">S(n,k+1)=\sum_{i=0}^{n-1}i^{k+1}</script><script type="math/tex; mode=display">\begin{aligned}S(n,k+1)+n^{k+1}&=\sum_{i=0}^{n-1}(i+1)^{k+1}\\&=\sum_{i=0}^{n-1}\sum_{j=0}^{k+1}C_{k+1}^{j}i^{j}\\&=\sum_{j=0}^{k+1}C_{k+1}^{j}\sum_{i=0}^{n-1}i^{j}\\&=\sum_{j=0}^{k+1}C_{k+1}^{j}S(n,j)\\&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)+C_{k+1}^{k+1}S(n,k+1)\end{aligned}</script><p>注意到$C_{k+1}^{k+1}=1$，我们就能得到</p><script type="math/tex; mode=display">n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)</script><p>因为我们已经对于任意的$0\leqslant j\lt k$，证明了$S(n,j)=T(n,j)$成立，我们就可以将上式进一步变形</p><script type="math/tex; mode=display">\begin{aligned}n^{k+1}&=\sum_{j=0}^{k}C_{k+1}^{j}S(n,j)\\&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)\\&=\sum_{j=0}^{k-1}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)+C_{k+1}^{k}T(n,k)-C_{k+1}^{k}T(n,k)\\&=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)+C_{k+1}^{k}S(n,k)-C_{k+1}^{k}T(n,k)\end{aligned}</script><p>接下来，如果我们能够证明</p><script type="math/tex; mode=display">n^{k+1}=\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)</script><p>自然就能得出$S(n,k)=T(n,k)$。</p><p>愉快地推式子</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i}B_{i}n^{j-i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{j-i}B_{j-i}n^{i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}C_{j+1}^{i+1}B_{j-i}n^{i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\cfrac{1}{j+1}\sum_{i=0}^{j}\cfrac{j+1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\&=\sum_{j=0}^{k}C_{k+1}^{j}\sum_{i=0}^{j}\cfrac{1}{i+1}C_{j}^{i}B_{j-i}n^{i+1}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{j}C_{j}^{i}B_{j-i}n^{i+1}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}\sum_{j=i}^{k}C_{k+1}^{i}C_{k-i+1}^{j-i}B_{j-i}n^{i+1}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\end{aligned}</script><p>上面的第二个等号是将后面的那个$\sum$倒过来（$i\rightarrow j-i$）求和。</p><p><del>返回本页面最上端之后，</del>我们回想起伯努利数还有个这么个性质</p><script type="math/tex; mode=display">\sum_{i=0}^{n}C_{n+1}^{i}B_{i}=[n=0]</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{k}C_{k+1}^{j}T(n,j)&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}\sum_{j=0}^{k-i}C_{k-i+1}^{j}B_{j}\\&=\sum_{i=0}^{j}\cfrac{1}{i+1}C_{k+1}^{i}n^{i+1}[i=k]\\&=\cfrac{1}{k+1}C_{k+1}^{k}n^{k+1}\\&=n^{k+1}\end{aligned}</script><script type="math/tex; mode=display">\text{QED}</script><h3 id="诶刚才我干了些什么来着"><a href="#诶刚才我干了些什么来着" class="headerlink" title="诶刚才我干了些什么来着"></a>诶刚才我干了些什么来着</h3><p>哦我好像是证明了这么一个东西</p><script type="math/tex; mode=display">\sum_{i=0}^{n-1}i^{k}=\cfrac{1}{k+1}\sum_{i=0}^{k}C_{k+1}^{i}B_{i}n^{k-i+1}</script><h3 id="如何求伯努利数"><a href="#如何求伯努利数" class="headerlink" title="如何求伯努利数"></a>如何求伯努利数</h3><p><del>根据题解，</del>我们知道伯努利数的生成函数是</p><script type="math/tex; mode=display">\cfrac{x}{e^{x}-1}=\cfrac{x}{\sum\limits_{i=1}^{+\infty}\cfrac{x^{i}}{i!}}=\cfrac{1}{\sum\limits_{i=0}^{+\infty}\cfrac{x^{i}}{(i+1)!}}</script><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「Luogu-P3711」仓鼠的数学题"><a href="#「Luogu-P3711」仓鼠的数学题" class="headerlink" title="「Luogu-P3711」仓鼠的数学题"></a><a href="https://www.luogu.org/problemnew/show/P3711" target="_blank" rel="noopener">「Luogu-P3711」仓鼠的数学题</a></h4><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x-1}j^{i}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{j}B_{j}x^{i-j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}C_{i+1}^{i-j}B_{i-j}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}\cfrac{a_{i}}{i+1}\sum_{j=0}^{i}\cfrac{(i+1)!}{(i-j)!(j+1)!}B_{i-j}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{i=0}^{n}i!a_{i}\sum_{j=0}^{i}\cfrac{1}{(j+1)!}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\end{aligned}</script><p>定义</p><script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n}(n-i)!a_{n-i}x^{i}</script><script type="math/tex; mode=display">B(x)=\sum_{i=0}^{n}\cfrac{B_{i}}{i!}x^{i}</script><p>那么</p><script type="math/tex; mode=display">\begin{aligned}\sum_{i=0}^{n}a_{i}\sum_{j=0}^{x}j^{i}&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{1}{(j+1)!}\sum_{i=j}^{n}i!a_{i}\cfrac{B_{i-j}}{(i-j)!}x^{j+1}\\&=\sum_{i=0}^{n}a_{i}x^{i}+\sum_{j=0}^{n}\cfrac{FB[n-j]}{(j+1)!}x^{j+1}\end{aligned}</script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;「クールでまばゆいばかりのアルゴリズムを学ばないでください、それはうまく検索することが最も重要です。」&lt;/p&gt;
&lt;p&gt;——loli&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;del&gt;以上，我失败了（&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/blog/ShadowassIIXVIIIIV/guan-yu-bo-nu-li-shuo-zhuai-hua-zi-ran-shuo-mi-hu-gong-shi-di-zheng-mi&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;前半部分的抄袭来源&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="https://github.com/Challestend/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="伯努利数" scheme="https://github.com/Challestend/tags/%E4%BC%AF%E5%8A%AA%E5%88%A9%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「AT987」高橋君</title>
    <link href="https://github.com/Challestend/at987-solution/"/>
    <id>https://github.com/Challestend/at987-solution/</id>
    <published>2019-03-29T10:47:10.000Z</published>
    <updated>2019-03-29T10:58:55.974Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://tenka1-2014-final.contest.atcoder.jp/tasks/tenka1_2014_final_d" target="_blank" rel="noopener">传送门</a></p><p><a href="https://www.luogu.org/problemnew/show/AT987" target="_blank" rel="noopener">Luogu</a></p><p>第一道AtCoder的题解。</p><p>联动一波<a href="https://www.cnblogs.com/asuldb/p/10623281.html" target="_blank" rel="noopener">asuldb</a>。</p><a id="more"></a><p>「啊这题怎么做啊。看起来好难啊。不会啊。」</p><p>「我们来蒙一个做法吧。比如说就莫队了！」</p><script type="math/tex; mode=display">\sum_{i=0}^{m+1}C_{n}^{i}=\sum_{i=0}^{m}C_{n}^{i}+C_{n}^{m+1}</script><script type="math/tex; mode=display">\sum_{i=0}^{m}C_{n+1}^{i}=\sum_{i=0}^{m}(C_{n}^{i}+C_{n}^{i-1})=\sum_{i=0}^{m}C_{n}^{i}+\sum_{i=0}^{m-1}C_{n}^{i-1}=2\sum_{i=0}^{m}C_{n}^{i}-C_{n}^{m}</script><p>这是左右端点向右移动的情况。向左移动就反过来。</p><p>就这样。</p><p>但是不知道为什么奇偶性排序会WA。</p><p>好短啊QAQ</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 1000000007</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> id(a) (a/sq+1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C(n,m) (1LL*fac[n]*inv[m]%mod*inv[n-m]%mod)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,sq;</span><br><span class="line"><span class="keyword">int</span> fac[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> t,l,r;</span><br><span class="line">&#125;;</span><br><span class="line">Query q[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re Query p1,re Query p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> id(p1.l)==id(p2.l)?p1.r&lt;p2.r:p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>]=inv[<span class="number">0</span>]=fac[<span class="number">1</span>]=inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        fac[i]=<span class="number">1L</span>L*fac[i<span class="number">-1</span>]*i%mod;</span><br><span class="line">        inv[i]=<span class="number">1L</span>L*inv[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    sq=maxn/<span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        q[i].t=i;</span><br><span class="line">        cltstream::read(q[i].r);</span><br><span class="line">        cltstream::read(q[i].l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::sort(q+<span class="number">1</span>,q+n+<span class="number">1</span>);</span><br><span class="line">    re <span class="keyword">int</span> L=<span class="number">0</span>,R=<span class="number">0</span>,res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;R&lt;q[i].r;res=(<span class="number">2</span>*res-C(R,L)+mod)%mod,++R);</span><br><span class="line">        <span class="keyword">for</span>(;R&gt;q[i].r;--R,res=inv[<span class="number">2</span>]*(res+C(R,L))%mod);</span><br><span class="line">        <span class="keyword">for</span>(;L&lt;q[i].l;++L,res=(res+C(R,L))%mod);</span><br><span class="line">        <span class="keyword">for</span>(;L&gt;q[i].l;res=(res-C(R,L)+mod)%mod,--L);</span><br><span class="line">        ans[q[i].t]=res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::write(ans[i],<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://tenka1-2014-final.contest.atcoder.jp/tasks/tenka1_2014_final_d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/AT987&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Luogu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一道AtCoder的题解。&lt;/p&gt;
&lt;p&gt;联动一波&lt;a href=&quot;https://www.cnblogs.com/asuldb/p/10623281.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;asuldb&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="组合数学" scheme="https://github.com/Challestend/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫队" scheme="https://github.com/Challestend/tags/%E8%8E%AB%E9%98%9F/"/>
    
      <category term="玄学" scheme="https://github.com/Challestend/tags/%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>后缀数组自闭笔记</title>
    <link href="https://github.com/Challestend/suffix-array-learning-notes/"/>
    <id>https://github.com/Challestend/suffix-array-learning-notes/</id>
    <published>2019-03-25T09:34:10.000Z</published>
    <updated>2019-03-26T11:03:37.481Z</updated>
    
    <content type="html"><![CDATA[<p>省选前最后两周。同时也是退役前最后两周。</p><p><del>在wzx的鼓动下</del>开了字符串。</p><p>然后自闭了。</p><a id="more"></a><p>以下，我们约定，$S_{l,r}$表示字符串$S$下标为$[l,r]$的子串，下标从$1$开始。超过串长的部分用小于其他所有字符的空字符填充。</p><h3 id="后缀排序"><a href="#后缀排序" class="headerlink" title="后缀排序"></a><a href="https://www.luogu.org/problemnew/show/P3809" target="_blank" rel="noopener">后缀排序</a></h3><p><del><code>std::sort</code>（光速逃</del></p><p>不过<code>std::sort</code>也是可以做的（</p><p>我们发现，这种做法的瓶颈在于比较两个后缀的大小。我们可以二分+Hash求出它们的最长公共前缀的长度，然后比较这个前缀后一个字符的大小。这么做的时间复杂度是$O(n\log^{2}n)$的。</p><p><del>但是没什么用（</del></p><p>然后我们就需要用到后缀数组（Suffix Array）了。</p><p>SA一共有四种构建方式，分别是$O(n\log n)$的倍增，$O(n)$的DC3和SA-IS，以及$O(1)$的潮爷排序。<del>但是后三种太高端了我都不会（</del></p><p>假设对于每一个位置$i$，我们已经按照$S_{i,i+k-1}$的大小排好了序，并且有了一个排名。我们以$i$的排名为第一关键字，$i+k$的排名为第二关键字，排一遍序，整个字符串就被按照$S_{i,i+2k-1}$的大小排好了序。当所有位置的排名都不同时，说明整个过程可以结束了。</p><p><del>但是问题来了，排一遍序不是$O(n\log n)$的吗（</del></p><p><del>我们有基数排序啊（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s[i]：原字符串</span></span><br><span class="line"><span class="comment">// fst[i]：后缀i的第一关键字</span></span><br><span class="line"><span class="comment">// snd[i]：第二关键字排名为i的后缀</span></span><br><span class="line"><span class="comment">// tak[i]：桶</span></span><br><span class="line"><span class="comment">// sa[i]：排名为i的后缀</span></span><br><span class="line"><span class="comment">// 一开始时以首字符为第一关键字，位置为第二关键字排序</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    ++tak[fst[i]=s[i]];</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">122</span>;++i)</span><br><span class="line">    tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 处理桶内前缀和，用来求出第一关键字为i的后缀的最大可能排名</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">    sa[tak[fst[i]]--]=i;</span><br><span class="line">    <span class="comment">// 第一关键字相同时，第二关键字排名越大总排名越大，因此倒序枚举</span></span><br><span class="line">    <span class="comment">// 因为第二关键字是位置，所以snd[i]=i</span></span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> mx=<span class="number">122</span>,k=<span class="number">1</span>;;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">    re <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n-k+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        snd[++cnt]=i;</span><br><span class="line">        <span class="comment">// (n-k,n]的这些后缀没有第二关键字，因此排名最靠前</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(sa[i]&gt;k)</span><br><span class="line">            snd[++cnt]=sa[i]-k;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">        tak[i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ++tak[fst[i]];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mx;++i)</span><br><span class="line">        tak[i]+=tak[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        sa[tak[fst[snd[i]]]--]=snd[i];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        snd[i]=fst[i];</span><br><span class="line">        <span class="comment">// 因为要生成下一轮排序时的第一关键字，把fst里的信息先扔到snd里</span></span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        fst[sa[i]]=fst[sa[i<span class="number">-1</span>]]+(snd[sa[i]]!=snd[sa[i<span class="number">-1</span>]]||snd[sa[i]+k]!=snd[sa[i<span class="number">-1</span>]+k]);</span><br><span class="line">        <span class="comment">// 如果当前后缀与前一个后缀相同则共用排名，否则+1</span></span><br><span class="line">    <span class="keyword">if</span>(fst[sa[n]]==n)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        mx=fst[sa[n]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看上去非常的绕（</p><p>最后直接输出<code>sa</code>数组即可。</p><h3 id="rnk数组"><a href="#rnk数组" class="headerlink" title="rnk数组"></a><code>rnk</code>数组</h3><p><code>rnk[i]</code>表示排名为$i$的后缀。</p><p>不难发现<code>rnk[sa[i]]=sa[rnk[i]]=i</code>。</p><h3 id="het数组"><a href="#het数组" class="headerlink" title="het数组"></a><code>het</code>数组</h3><p>大概算是SA的重点。</p><p>令<code>lcp(x,y)</code>表示$x,y$两个后缀的最长公共前缀（Longest Common Prefix）的长度。</p><p><code>het[i]</code>就被定义为<code>lcp(sa[i],sa[i-1])</code>。<code>het[1]=0</code>。</p><p>不难发现<code>lcp(x,z)=min(lcp(x,y),lcp(y,z))(x&lt;y&lt;z)</code>，<code>lcp(x,y)=min{lcp(i,i-1)}=min{het[i]}(rnk[x]&lt;i&lt;=rnk[y])</code>。</p><p><del>那么问题来了，怎么求呢（</del></p><p>首先我们是肯定不能暴力枚举的。</p><p>二分+Hash？太麻烦而且复杂度不够优秀（</p><p>SA的<code>het</code>数组有一个性质，就是<code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p><p>我们只考虑<code>het[rnk[i-1]]&gt;0</code>时的情况。</p><p>令<code>k=sa[rnk[i-1]-1]</code>，<code>lcp(i-1,k)=het[rnk[i-1]]</code>，又因为后缀$i$是后缀$i-1$删去首字符得到的，后缀$k+1$是后缀$k$删去首字符得到的，从而<code>lcp(i,k+1)=het[rnk[i-1]]-1</code>。</p><p>后缀$i-1$比后缀$k$大，删去首字符后，后缀$i$肯定也比后缀$k+1$大。根据<code>lcp</code>的性质我们有<code>lcp(i,sa[rnk[i]-1])&gt;=lcp(i,k+1)</code>，也即<code>het[rnk[i]]&gt;=het[rnk[i-1]]-1</code>。</p><p>利用这个性质，我们就可以在$O(n)$的时间复杂度内求出<code>het</code>数组了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">    <span class="keyword">if</span>(rnk[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        j-=!!j;</span><br><span class="line">        re <span class="keyword">int</span> pos=sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(;i+j&lt;=n&amp;&amp;pos+j&lt;=n&amp;&amp;s[i+j]==s[pos+j];++j);</span><br><span class="line">        het[rnk[i]]=j;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后SA就彻底建好了。没错就这么点东西（</p><h3 id="板子应用"><a href="#板子应用" class="headerlink" title="板子应用"></a><del>板子</del>应用</h3><h4 id="不同子串个数"><a href="#不同子串个数" class="headerlink" title="不同子串个数"></a>不同子串个数</h4><p>给定一个长度为$n$的字符串$S$，求其本质不同的子串的数量。</p><p>首先有一个很显然的结论是，如果一个字符串是$S$的子串，那么它一定是$S$的若干个排名连续的后缀的公共前缀。</p><p>对于排名为$1$和排名为$2$的两个后缀来说，它们一共有<code>het[2]</code>个公共前缀；排名为$2$和排名为$3$的两个后缀一共有<code>het[3]</code>个公共前缀……</p><p>因此，$S$的不同子串个数就是它的所有子串个数，$\cfrac{n(n+1)}{2}$，减去所有<code>het</code>的和。</p><h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>给定$n$个字符串$S_{1},S_{2},\cdots,S_{n}$，求它们的最长公共子串。</p><p>我们首先将这$n$个串拼在一起，中间插入特殊字符将相邻的两个串隔开。然后我们将每个串内部的字符染色，第$1$个串染成颜色$1$，第$2$个串染成颜色$2$，用尺取法找出<code>sa[l],sa[l+1],...,sa[r]</code>覆盖全部$n$种颜色的区间$[l,r]$，求出其中<code>min{het[i]}(l&lt;i&lt;=r)</code>的最大值即可。</p><h4 id="模式串出现次数"><a href="#模式串出现次数" class="headerlink" title="模式串出现次数"></a>模式串出现次数</h4><p>给定$n$个文本串和$m$个模式串，询问每个模式串在$n$个文本串中一共出现了多少次。</p><p>首先将所有文本串拼在一起。对于每一个模式串，如果我们能够找到这个长串的任意一个后缀$x$，使得其拥有这个模式串作为前缀，然后找到一个最小的$l$和一个最大的$r$，使得<code>min{het[i]}(l&lt;i&lt;=rnk[x])</code>和<code>min{het[i]}(rnk[x]&lt;i&lt;=r)</code>均大于等于该模式串长度，$r-l+1$就是答案。不难看出向两边取$\min$这个操作具有单调性，因此我们可以二分。</p><p>但是问题来了，我们该怎么找到这个后缀啊。</p><p>一想，把模式串也接到文本串后就可以了。</p><p>那如果说模式串出现了互相包含的情况呢？</p><p>我们可以再开一个数组<code>col</code>，<code>col[i]</code>表示<code>sa[i]</code>的首字符是否属于一个文本串。因为这个是静态的，直接一遍前缀和就行。</p><h4 id="母串数量"><a href="#母串数量" class="headerlink" title="母串数量"></a>母串数量</h4><p>给定$n$个文本串和$m$个模式串，询问每个模式串在多少个文本串中出现过。也就是说，在同一个文本串中出现多次只记一次。</p><p>和上面一样，只不过是最后一步<code>col[i]</code>表示<code>sa[i]</code>的首字符所属的文本串的编号，对于每一个模式串，二分出区间后数一下颜色种类数。</p><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><p>自己找去吧（</p><p>然后您就会发现字符串的题一道比一道神仙（</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;省选前最后两周。同时也是退役前最后两周。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;在wzx的鼓动下&lt;/del&gt;开了字符串。&lt;/p&gt;
&lt;p&gt;然后自闭了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="字符串" scheme="https://github.com/Challestend/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="SA" scheme="https://github.com/Challestend/tags/SA/"/>
    
  </entry>
  
  <entry>
    <title>「Ynoi2014D2T2」人人本着正义之名</title>
    <link href="https://github.com/Challestend/luogu-p5066-solution-not/"/>
    <id>https://github.com/Challestend/luogu-p5066-solution-not/</id>
    <published>2019-03-19T07:57:35.000Z</published>
    <updated>2019-03-25T11:06:01.310Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P5066" target="_blank" rel="noopener">传送门</a></p><p><del>一人血书放大常数Splay一条生路。</del></p><a id="more"></a><p>之前Ynoi2014唯一一道没公开的题。</p><p>写个$O(nm)$的暴力就有30了。</p><p>我们来分析一下操作$3,4,5,6$都在干些啥。</p><p>以操作$3$为例，如果在操作前，有一个位置的数字是$1$，它左边是一个$0$，操作完之后那个$0$就会变成$1$。除此之外不会再有其它改变。</p><p>仔细想象一下这个过程，我们发现这实际上是将操作区间内所有极长连续$1$的左端点向左扩展了$1$位，所有极长连续$0$的右端点向左收缩了$1$位。</p><p>操作$4,5,6$也是类似的。</p><p>那么我们写一棵珂朵莉树就可以获得50分了。</p><p>但实际上emmmmm……我的珂朵莉树可能和别人不一样（</p><p>别人的珂朵莉树：</p><p><img src="/images/TIM截图20190319161404.png" alt></p><p>我的珂朵莉树：</p><p><img src="/images/TIM截图20190319161900.png" alt></p><p>那么满分做法？</p><p>手写平衡树。没了。</p><p><del>虽然这么说，但是lxl都写了将近10KB（</del></p><p>总体思路就是，手写平衡树维护所有极长连续段的长度，并不需要维护端点因为可以算出来，单独维护还麻烦。每个节点维护子树内极长连续$0$和$1$的数量、长度最小值，以及连续段的长度变化量（标记）。修改时判断一下如果最小值变成了$0$，那么就暴力重构。<del>反正lxl说因为有前两个操作的存在这么做时间复杂度是对的。</del></p><p>首先有一个问题就是，这样做每个节点维护的必须要是<strong>极长连续段</strong>。想象一下，如果有两个相邻的节点值都是$1$，我们进行一次操作$3$或$4$，会发生什么？</p><p>两个节点的长度都加了$1$。然后整个序列莫名其妙多出来$1$个数。再然后您就WA了。</p><p>然后就是各种各样乱七八糟的细节。虽然这么说但好像没什么可列举的了。</p><p>然后您按照上面的思路打完四五百行的代码之后交上去一看：</p><p><img src="/images/TIM截图20190319171721.png" alt></p><p>虽然说暴力重构的时间复杂度<del>应该</del>是对的，但是不难发现它常数大啊。</p><p>但是如果不重构，合并相邻的连续段就会变得非常麻烦。</p><p>结论就是这题不可写，散了吧散了吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P5066&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;del&gt;一人血书放大常数Splay一条生路。&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="珂朵莉树" scheme="https://github.com/Challestend/tags/%E7%8F%82%E6%9C%B5%E8%8E%89%E6%A0%91/"/>
    
      <category term="平衡树" scheme="https://github.com/Challestend/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
      <category term="毒瘤" scheme="https://github.com/Challestend/tags/%E6%AF%92%E7%98%A4/"/>
    
  </entry>
  
  <entry>
    <title>来扯点多项式？</title>
    <link href="https://github.com/Challestend/polynomial-triangle-function/"/>
    <id>https://github.com/Challestend/polynomial-triangle-function/</id>
    <published>2019-03-17T03:06:25.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>在luogu上看到了多项式三角函数/反三角函数的板子。</p><p>不过还没加进公共题库，没人交，于是不敢交（</p><p>于是来口胡一波吧。</p><a id="more"></a><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>总之就是求$\sin F(x)$，$\cos F(x)$，其他的三角函数都可以用这两个凑出来因此不需要单独讨论。</p><p>虽然说我们也有$\cos x=\sin(x+\cfrac{\pi}{2})$，但是问题来了，模意义下怎么表示$\pi$（</p><p>首先我们有欧拉公式</p><script type="math/tex; mode=display">e^{ix}=\cos x+i\sin x</script><p>于是</p><script type="math/tex; mode=display">e^{iF}=\cos F+i\sin F</script><p>根据定义，$i^{2}\equiv -1\equiv 998244352\pmod{998244353}$。而$998244352$是模$998244353$的二次剩余，说人话就是这样的$i$是存在的。</p><p>但是问题来了，我们该怎么分离$\sin$和$\cos$？</p><p>我们还需要有</p><script type="math/tex; mode=display">e^{i(-F)}=\cos F-i\sin F</script><p>很明显地</p><script type="math/tex; mode=display">\sin F=\cfrac{e^{iF}-e^{i(-F)}}{2i}</script><script type="math/tex; mode=display">\cos F=\cfrac{e^{iF}+e^{i(-F)}}{2}</script><h3 id="反三角函数"><a href="#反三角函数" class="headerlink" title="反三角函数"></a>反三角函数</h3><p>求$\arcsin F(x)$，$\arccos F(x)$。</p><p>我们令答案的多项式为$G(x)$。</p><p>我们都知道</p><script type="math/tex; mode=display">\sin^{2}x+\cos^{2}x=1</script><p>于是知道了$\sin G$或者是$\cos G$，我们就可以推出另一项，然后再根据</p><script type="math/tex; mode=display">e^{iG}=\cos G+i\sin G</script><script type="math/tex; mode=display">G=\cfrac{\ln(\cos G+i\sin G)}{i}</script><p>就可以算出$G$了。</p><p>那么$\arctan F(x)$？</p><script type="math/tex; mode=display">\sin^{2}G+\cos^{2}G=1</script><p>因为$\tan G$有意义，所以$\cos G\neq0$。</p><script type="math/tex; mode=display">\tan^{2}G+1=\sec^{2}G</script><script type="math/tex; mode=display">\cos G=\cfrac{1}{\sqrt{\tan^{2}G+1}}</script><p>但是看着就麻烦（</p><blockquote><p>Updated on 2019-03-18</p><p>上面这种做法大概不是正解，因为这样需要对一个常数项不是$1$，最低次非零系数也不是$1$的多项式求平方根，很明显这需要二次剩余<del>，而且我不会</del>。</p><p>考虑倍增。</p><script type="math/tex; mode=display">\sin G_{0}-F\equiv 0\pmod{x^{t}}</script><script type="math/tex; mode=display">\sin G-F\equiv 0\pmod{x^{2t}}</script><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\sin G_{0}-F}{(\sin G_{0}-F)^{\prime}}\equiv G_{0}-\cfrac{\sin G_{0}-F}{\cos G_{0}}\pmod{x^{2t}}</script><p>然后是$\arccos$。</p><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\cos G_{0}-F}{(\cos G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\cos G_{0}-F}{\sin G_{0}}\pmod{x^{2t}}</script><p>然后是$\arctan$。不过我不怎么会求导$\tan$（</p><script type="math/tex; mode=display">\begin{aligned}(\tan x)^{\prime}&=(\cfrac{\sin x}{\cos x})^{\prime}\\&=\cfrac{(\sin x)^{\prime}}{\cos x}+\sin x(\cfrac{1}{\cos x})^{\prime}\\&=1+\tan^{2}x\end{aligned}</script><script type="math/tex; mode=display">G\equiv G_{0}-\cfrac{\tan G_{0}-F}{(\tan G_{0}-F)^{\prime}}\equiv G_{0}+\cfrac{\tan G_{0}-F}{1+\tan^{2} G_{0}}\pmod{x^{2t}}</script><p>这大概不能写（</p></blockquote><h3 id="多项式GCD-LCM"><a href="#多项式GCD-LCM" class="headerlink" title="多项式GCD/LCM"></a>多项式GCD/LCM</h3><p>既然多项式能够整除和取模，那么GCD和LCM一定也是可以算的吧！</p><p>……应该可以吧（</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在luogu上看到了多项式三角函数/反三角函数的板子。&lt;/p&gt;
&lt;p&gt;不过还没加进公共题库，没人交，于是不敢交（&lt;/p&gt;
&lt;p&gt;于是来口胡一波吧。&lt;/p&gt;
    
    </summary>
    
      <category term="瞎扯" scheme="https://github.com/Challestend/categories/%E7%9E%8E%E6%89%AF/"/>
    
    
      <category term="多项式" scheme="https://github.com/Challestend/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/"/>
    
      <category term="三角函数" scheme="https://github.com/Challestend/tags/%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>生成函数学习笔记</title>
    <link href="https://github.com/Challestend/generating-function-learning-notes/"/>
    <id>https://github.com/Challestend/generating-function-learning-notes/</id>
    <published>2019-03-15T03:34:27.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>又被wzx吊打了QAQ</p><p>来写一篇生成函数吧QAQ</p><p><del>本文全部内容抄袭自<a href="https://www.cnblogs.com/asuldb/p/10533453.html" target="_blank" rel="noopener">这篇blog</a>和<a href="https://www.cnblogs.com/asuldb/p/10534860.html" target="_blank" rel="noopener">这篇blog</a></del></p><a id="more"></a><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数列$\{a_{0},a_{1},\cdots,a_{n}\}$的生成函数$f(x)$被定义为</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^{n}a_{i}x^{i}</script><p>就这样（</p><h3 id="封闭表达式"><a href="#封闭表达式" class="headerlink" title="封闭表达式"></a>封闭表达式</h3><p>但是这个形式比较玄乎，不便于我们推式子。特别是当我们需要求一个无穷数列的生成函数时。于是我们希望能够进一步化简。</p><p>比如说，当$a_{n}=c^{n}$，即这个数列是$\{1,c,c^{2},\cdots\}$时，它的生成函数是</p><script type="math/tex; mode=display">f(x)=\sum_{i=0}^{n}c^{i}x^{i}=\cfrac{1-(cx)^{n+1}}{1-cx}</script><p>就是一个简单地等比数列求和。很明显，当$x\in(-1,1)$时，如果$n$趋向于正无穷大，则上式等于$\cfrac{1}{1-cx}$。</p><p>我们现在来分析一下斐波那契数列的生成函数。</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\end{aligned}</script><p>为了方便，我们定义当$n\lt 0$时，$F_{n}=0$。</p><p>然后我们发现$F_{1}=F_{0}+F_{-1}=0+0=0$，于是我们再加上一项$[i=1]$。</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}(F_{i-1}+F_{i-2}+[i=1])x^{i}\\&=x+\sum_{i=0}^{n}(F_{i-1}+F_{i-2})x^{i}\\&=x+x\sum_{i=0}^{n}F_{i-1}x^{i-1}+x^{2}\sum_{i=0}^{n}F_{i-2}x^{i-2}\\&=x+xF(x)+x^{2}F(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">F(x)=\cfrac{x}{1-x-x^{2}}</script><h3 id="通项公式"><a href="#通项公式" class="headerlink" title="通项公式"></a>通项公式</h3><h4 id="斐波那契数"><a href="#斐波那契数" class="headerlink" title="斐波那契数"></a>斐波那契数</h4><p>那么问题来了，我们闲着没事求这个生成函数有什么用啊。</p><p>求通项公式。</p><p>我们知道形如$a_{n}=c^{n}$的数列的生成函数等于$\cfrac{1}{1-cx}$，我们可以试着将$\cfrac{x}{1-x-x^{2}}$分解成两个类似形式的分式的和。</p><p>设</p><script type="math/tex; mode=display">1-x-x^{2}=(1-ax)(1-bx)</script><script type="math/tex; mode=display">\begin{cases}&a+b=1\\&ab=-1\end{cases}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\begin{cases}&a=\cfrac{1+\sqrt{5}}{2}\\&b=\cfrac{1-\sqrt{5}}{2}\end{cases}</script><p>再设</p><script type="math/tex; mode=display">\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{x}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><script type="math/tex; mode=display">\cfrac{c}{1-\cfrac{1+\sqrt{5}}{2}x}+\cfrac{d}{1-\cfrac{1-\sqrt{5}}{2}x}=\cfrac{c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx}{(1-\cfrac{1+\sqrt{5}}{2}x)(1-\cfrac{1-\sqrt{5}}{2}x)}</script><p>于是</p><script type="math/tex; mode=display">c-\cfrac{1-\sqrt{5}}{2}cx+d-\cfrac{1+\sqrt{5}}{2}dx=x</script><p>等式右边没有常数项，因此$c+d$应当是$0$。再继续接下去，我们得到</p><script type="math/tex; mode=display">\begin{cases}&c=\cfrac{1}{\sqrt{5}}\\&d=-\cfrac{1}{\sqrt{5}}\end{cases}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1+\sqrt{5}}{2}x}-\cfrac{1}{\sqrt{5}}\cfrac{1}{1-\cfrac{1-\sqrt{5}}{2}x}\\&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}x^{i}-\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}x^{i}\\&=\sum_{i=0}^{n}\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{i}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{i}\right)x^{i}\end{aligned}</script><p>结论就是</p><script type="math/tex; mode=display">F_{n}=\cfrac{1}{\sqrt{5}}\left(\left(\cfrac{1+\sqrt{5}}{2}\right)^{n}-\left(\cfrac{1-\sqrt{5}}{2}\right)^{n}\right)</script><h4 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h4><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}C_{i}x^{i}\\&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}+[i=0]\right)x^{i}\\&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i}\\&=1+x\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}C_{i-j-1}\right)x^{i-1}\\&=1+xF^{2}(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">xF^{2}(x)-F(x)+1=0</script><script type="math/tex; mode=display">F(x)=\cfrac{1\pm\sqrt{1-4x}}{2x}</script><script type="math/tex; mode=display">2xF(x)=1\pm\sqrt{1-4x}</script><p>当$x=0$时</p><script type="math/tex; mode=display">2\times 0\times 1=1\pm1</script><p>因此根号前应该取负。至此我们得到</p><script type="math/tex; mode=display">F(x)=\cfrac{1-\sqrt{1-4x}}{2x}</script><p>那么通项公式呢？</p><p>根据<del>一个我抄过来的</del>广义二项式定理，我们有</p><script type="math/tex; mode=display">\begin{aligned}\sqrt{1-4x}&=1+\sum_{i=1}^{n}\cfrac{(-1)^{i-1}}{i2^{2i-1}}C_{2i-2}^{i-1}(-4x)^{i}\\&=1+2\sum_{i=1}^{n}\cfrac{(-1)^{2i-1}}{i}C_{2i-2}^{i-1}x^{i}\\&=1-2\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i}\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}F(x)&=\cfrac{1-\sqrt{1-4x}}{2x}\\&=\sum_{i=1}^{n}\cfrac{1}{i}C_{2i-2}^{i-1}x^{i-1}\\&=\sum_{i=0}^{n}\cfrac{1}{i+1}C_{2i}^{i}x^{i}\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">C_{n}=\cfrac{1}{n+1}C_{2n}^{n}</script><h4 id="默慈金数"><a href="#默慈金数" class="headerlink" title="默慈金数"></a>默慈金数</h4><p><del>等会默慈金数是个什么鬼？（</del></p><p>默慈金数一般记为$M_{n}$，被定义为在均匀分布在一个圆上的$n$个有编号的点之间连出彼此不相交的弦的方案数。一根弦也不连也是一种方案。</p><script type="math/tex; mode=display">M_{0}=1</script><script type="math/tex; mode=display">M_{n}=M_{n-1}+\sum_{i=0}^{n-2}M_{i}M_{n-i-2}</script><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}M_{i}x^{i}\\&=\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}+[i=0]\right)x^{i}\\&=1+\sum_{i=0}^{n}\left(M_{i-1}+\sum_{j=0}^{i-2}M_{j}M_{i-j-2}\right)x^{i}\\&=1+xF(x)+x^{2}F^{2}(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">x^{2}F^{2}(x)+(x-1)F(x)+1=0</script><script type="math/tex; mode=display">F(x)=\cfrac{1-x\pm\sqrt{1-2x-3x^{2}}}{2x^{2}}</script><p>总之根号前应该取负（</p><script type="math/tex; mode=display">\begin{aligned}F(x)&=\cfrac{1-x-\sqrt{1-2x-3x^{2}}}{2x^{2}}\\&=\cfrac{2-2x-2\sqrt{1-2x-3x^{2}}}{4x^{2}}\\&=\cfrac{(1+x)-2\sqrt{(1+x)(1-3x)}+(1-3x)}{4x^{2}}\\&=\cfrac{(\sqrt{1+x}-\sqrt{1-3x})^{2}}{4x^{2}}\end{aligned}</script><p>woc这什么鬼东西溜了溜了。</p><p><del>留作课后习题，哪位dalao推出来了让我%一%（</del></p><h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><h4 id="「TJOI2015」概率论"><a href="#「TJOI2015」概率论" class="headerlink" title="「TJOI2015」概率论"></a><a href="https://www.luogu.org/problemnew/show/P3978" target="_blank" rel="noopener">「TJOI2015」概率论</a></h4><p>首先很明显，互不同构的二叉树一共$C_{n}$棵，其中$C_{n}$是卡特兰数。现在我们希望求出这些二叉树的叶子结点总数，我们记为$F_{n}$。不难发现</p><script type="math/tex; mode=display">F_{0}=0</script><script type="math/tex; mode=display">F_{1}=1</script><script type="math/tex; mode=display">F_{n}=2\sum_{i=0}^{n-1}C_{i}F_{n-i-1}+[i=1]</script><script type="math/tex; mode=display">\begin{aligned}F(x)&=\sum_{i=0}^{n}F_{i}x^{i}\\&=\sum_{i=0}^{n}\left(2\sum_{j=0}^{i-1}C_{j}F_{i-j-1}+[i=1]\right)x^{i}\\&=x+2\sum_{i=0}^{n}\left(\sum_{j=0}^{i-1}C_{j}F_{i-j-1}\right)x^{i}\\&=x+2xCF(x)\end{aligned}</script><p>于是</p><script type="math/tex; mode=display">F(x)=\cfrac{x}{1-2xC(x)}</script><p>其中$C(x)$是卡特兰数的生成函数，我们知道它的值是$\cfrac{1-\sqrt{1-4x}}{2x}$，所以说</p><script type="math/tex; mode=display">F(x)=\cfrac{x}{\sqrt{1-4x}}</script><p><del>然后我又不会了（</del></p><script type="math/tex; mode=display">(xC(x))^{\prime}=\cfrac{1}{\sqrt{1-4x}}=\cfrac{F(x)}{x}</script><script type="math/tex; mode=display">(xC(x))^{\prime}=\sum_{i=0}^{n}(i+1)C_{i}x^{i}</script><script type="math/tex; mode=display">\cfrac{F(x)}{x}=\sum_{i=0}^{n}F_{i}x^{i-1}=\sum_{i=-1}^{n}F_{i+1}x^{i}</script><p>我们就得到</p><script type="math/tex; mode=display">iC_{i-1}=F_{i}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}\text{Ans}&=\cfrac{F_{n}}{C_{n}}\\&=\cfrac{nC_{n-1}}{C_{n}}\\&=\cfrac{C_{2n-2}^{n-1}}{\cfrac{1}{n+1}C_{2n}^{n}}\\&=\cfrac{\cfrac{(2n-2)!}{(n-1)!(n-1)!}}{\cfrac{(2n)!}{n!(n+1)!}}\\&=\cfrac{(2n-2)!n!(n+1)!}{(n-1)!(n-1)!(2n)!}\\&=\cfrac{n(n+1)}{2(2n-1)}\end{aligned}</script><h4 id="「国家集训队」整数的lqp拆分"><a href="#「国家集训队」整数的lqp拆分" class="headerlink" title="「国家集训队」整数的lqp拆分"></a><a href="https://www.luogu.org/problemnew/show/P4451" target="_blank" rel="noopener">「国家集训队」整数的lqp拆分</a></h4><p>其实这道题我几个月前推出来了一个$O(n^{2})$的式子（</p><p>如果记答案为$G_{n}$，我们有</p><script type="math/tex; mode=display">G_{n}=\sum_{i=0}^{n}F_{i}G_{n-i}</script><p>其中$F_{n}$是斐波那契数。为了方便，我们强行定义$G_{0}=1$。</p><script type="math/tex; mode=display">\begin{aligned}G(x)&=\sum_{i=0}^{n}G_{i}x^{i}\\&=\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}+[i=0]\right)x^{i}\\&=1+\sum_{i=0}^{n}\left(\sum_{j=0}^{i}F_{j}G_{i-j}\right)x^{i}\\&=1+FG(x)\end{aligned}</script><p>其中$F(x)$是斐波那契数的生成函数。于是</p><script type="math/tex; mode=display">G(x)=\cfrac{1}{1-F(x)}=\cfrac{1-x-x^{2}}{1-2x-x^{2}}=1+\cfrac{x}{1-2x-x^{2}}</script><p>多出来的那个$1$是$G_{0}$，可以无视掉。</p><p>设</p><script type="math/tex; mode=display">(1-ax)(1-bx)=1-2x-x^{2}</script><p>（中间过程略）</p><script type="math/tex; mode=display">\begin{cases}&a=1+\sqrt{2}\\&b=1-\sqrt{2}\end{cases}</script><p>再设</p><script type="math/tex; mode=display">\cfrac{c}{1-(1+\sqrt{2})x}+\cfrac{d}{1-(1-\sqrt{2})x}=\cfrac{x}{1-2x-x^{2}}</script><p>（中间过程略$\times 2$）</p><script type="math/tex; mode=display">\begin{cases}&c=\cfrac{1}{2\sqrt{2}}\\&d=-\cfrac{1}{2\sqrt{2}}\end{cases}</script><p>于是</p><script type="math/tex; mode=display">\begin{aligned}G(x)&=1+\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1+\sqrt{2})x}-\cfrac{1}{2\sqrt{2}}\cfrac{1}{1-(1-\sqrt{2})x}\\&=1+\sum_{i=0}^{n}\cfrac{1}{2\sqrt{2}}\left((1+\sqrt{2})^{i}-(1-\sqrt{2})^{i}\right)x^{i}\end{aligned}</script><p>最终结论就是</p><script type="math/tex; mode=display">G_{n}=\cfrac{(1+\sqrt{2})^{n}-(1-\sqrt{2})^{n}}{2\sqrt{2}}</script><p>根据暴力枚举，我们得出$\sqrt{2}\equiv 59713600\pmod{10^{9}+7}$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又被wzx吊打了QAQ&lt;/p&gt;
&lt;p&gt;来写一篇生成函数吧QAQ&lt;/p&gt;
&lt;p&gt;&lt;del&gt;本文全部内容抄袭自&lt;a href=&quot;https://www.cnblogs.com/asuldb/p/10533453.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇blog&lt;/a&gt;和&lt;a href=&quot;https://www.cnblogs.com/asuldb/p/10534860.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇blog&lt;/a&gt;&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="生成函数" scheme="https://github.com/Challestend/tags/%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu-P4705」Van♂游戏</title>
    <link href="https://github.com/Challestend/luogu-p4705-solution/"/>
    <id>https://github.com/Challestend/luogu-p4705-solution/</id>
    <published>2019-03-12T11:49:47.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>下个月就要省选了我还在颓怕不是要凉</p><p>然后再一翻wzx的blog发现他更新频率快到爆炸</p><p>大概这就是神吧</p><p>啊啊我好菜啊，不过还是来抄篇题解吧</p><p><a href="https://www.luogu.org/problemnew/show/P4705" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>令$\text{Ans}[t]$表示$t$次价值：</p><script type="math/tex; mode=display">\begin{aligned}\text{Ans}[t]&=\sum_{i=1}^{n}\sum_{j=1}^{m}(a_{i}+b_{j})^{t}\\&=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=0}^{t}C_{t}^{k}a_{i}^{k}b_{j}^{t-k}\\&=t!\sum_{k=0}^{t}\cfrac{\sum a_{i}^{k}}{k!}\cfrac{\sum b_{j}^{t-k}}{(t-k)!}\end{aligned}</script><p>然后我们看到了$\sum a_{i}^{k}$这种东西，要算的话时间复杂度至少要是$O(nt)$的（</p><p>从这里往下是抄的题解。</p><p>定义</p><script type="math/tex; mode=display">F(x)=\prod_{i=1}^{n}(a_{i}x+1)</script><script type="math/tex; mode=display">\begin{aligned}G(x)&=\ln F(x)\\&=\ln\prod_{i=1}^{n}(a_{i}x+1)\\&=\sum_{i=1}^{n}\ln(a_{i}x+1)\end{aligned}</script><p>我们先来考虑如何求出$F$。定义$Q_{i}$为从$\{a_{n}\}$中选出$i$个数相乘，这样的所有方案结果的总和，且$Q_{0}=1$。我们有</p><script type="math/tex; mode=display">F(x)=\sum_{i=0}^{n}Q_{i}x^{i}</script><p>然后分治。假设我们现在已经求出了$[l,mid]$上的$Q_{L,0},Q_{L,1},\cdots,Q_{L,mid-l+1}$和$(mid,r]$上的$Q_{R,0},Q_{R,1},\cdots,Q_{R,r-mid}$，不难发现</p><script type="math/tex; mode=display">Q_{i}=\sum_{j=0}^{i}Q_{L,j}Q_{R,i-j}</script><p>这部分的时间复杂度为$O(n\log^{2}n)$。</p><p>然后我们将$G$在$1$这个位置泰勒展开。先回忆一下<a href="/polynomial-learning-notes-pt2/">泰勒展开</a>的式子</p><script type="math/tex; mode=display">g(x)=\sum\limits_{i=1}^{+\infty}\cfrac{f^{(i)}(x_{0})}{i!}(x-x_{0})^i</script><script type="math/tex; mode=display">\ln^{(n)}(x)=(-1)^{n-1}(n-1)!x^{-n}</script><script type="math/tex; mode=display">\begin{aligned}G(x)&=\sum_{i=1}^{n}\ln(a_{i}x+1)\\&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{\ln^{(j)}(1)}{j!}a_{i}^{j}x^{j}\\&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}(j-1)!1^{-j}}{j!}a_{i}^{j}x^{j}\\&=\sum_{i=1}^{n}\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}a_{i}^{j}x^{j}\\&=\sum_{j=1}^{+\infty}\cfrac{(-1)^{j-1}}{j}\left(\sum_{i=1}^{n}a_{i}^{j}\right)x^{j}\end{aligned}</script><p><img src="/images/TIM图片20190123161752.jpg" alt></p><p>令人窒息（</p><p>然后这道题就做出来了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 524288</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,t;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],inv[maxn+<span class="number">1</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],F[maxn+<span class="number">1</span>],G[maxn+<span class="number">1</span>],tmp1[maxn+<span class="number">1</span>],tmp2[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;(rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(n&gt;&gt;<span class="number">1</span>):<span class="number">0</span>)))</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Inv</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    G[<span class="number">0</span>]=cltpow(F[<span class="number">0</span>],mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">4</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,j&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        NTT(G,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(i&lt;&lt;<span class="number">1</span>);++k)</span><br><span class="line">            tmp1[k]=F[k];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            tmp1[k]=<span class="number">0</span>;</span><br><span class="line">        NTT(tmp1,j,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">0</span>;k&lt;j;++k)</span><br><span class="line">            G[k]=(<span class="number">2</span><span class="number">-1L</span>L*tmp1[k]*G[k]%mod+mod)*G[k]%mod;</span><br><span class="line">        NTT(G,j,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> k=(i&lt;&lt;<span class="number">1</span>);k&lt;j;++k)</span><br><span class="line">            G[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Ln</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span>* G,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;n;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    N&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        G[i<span class="number">-1</span>]=<span class="number">1L</span>L*F[i]*i%mod;</span><br><span class="line">    G[n<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    Inv(F,tmp2,n);</span><br><span class="line">    NTT(tmp2,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*tmp2[i]%mod;</span><br><span class="line">    NTT(G,N,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;--i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i<span class="number">-1</span>]*inv[i]%mod;</span><br><span class="line">    G[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=n;i&lt;N;++i)</span><br><span class="line">        G[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(re <span class="keyword">int</span>* P,re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;r)&#123;</span><br><span class="line">        re <span class="keyword">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>,N=<span class="number">1</span>;</span><br><span class="line">        calc(P,l,mid);</span><br><span class="line">        calc(P,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">for</span>(;N&lt;r-l+<span class="number">2</span>;N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">        F[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mid-l+<span class="number">1</span>;++i)</span><br><span class="line">            F[i]=P[l+i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=mid-l+<span class="number">2</span>;i&lt;N;++i)</span><br><span class="line">            F[i]=<span class="number">0</span>;</span><br><span class="line">        NTT(F,N,<span class="number">0</span>);</span><br><span class="line">        G[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-mid;++i)</span><br><span class="line">            G[i]=P[mid+i];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=r-mid+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">            G[i]=<span class="number">0</span>;</span><br><span class="line">        NTT(G,N,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">            F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">        NTT(F,N,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=r-l+<span class="number">1</span>;++i)</span><br><span class="line">            P[l+i<span class="number">-1</span>]=F[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)</span><br><span class="line">        inv[i]=(mod<span class="number">-1L</span>L*mod/i*inv[mod%i]%mod)%mod;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cltstream::read(A[i]);</span><br><span class="line">    B[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        cltstream::read(B[i]);</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    calc(A,<span class="number">1</span>,n);</span><br><span class="line">    calc(B,<span class="number">1</span>,m);</span><br><span class="line">    Ln(A,F,t+<span class="number">1</span>);</span><br><span class="line">    Ln(B,G,t+<span class="number">1</span>);</span><br><span class="line">    F[<span class="number">0</span>]=n;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*j%mod;</span><br><span class="line">    G[<span class="number">0</span>]=m;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=<span class="number">1</span>;i&lt;=t;j=<span class="number">1L</span>L*j*(mod-inv[i])%mod,++i)</span><br><span class="line">        G[i]=<span class="number">1L</span>L*G[i]*j%mod;</span><br><span class="line">    re <span class="keyword">int</span> N=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;N&lt;(t&lt;&lt;<span class="number">1</span>|<span class="number">1</span>);N&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=t+<span class="number">1</span>;i&lt;N;++i)</span><br><span class="line">        F[i]=G[i]=<span class="number">0</span>;</span><br><span class="line">    NTT(F,N,<span class="number">0</span>);</span><br><span class="line">    NTT(G,N,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*G[i]%mod;</span><br><span class="line">    NTT(F,N,<span class="number">1</span>);</span><br><span class="line">    N=cltpow(<span class="number">1L</span>L*n*m%mod,mod<span class="number">-2</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>,j=N;i&lt;=t;++i,j=<span class="number">1L</span>L*j*i%mod)</span><br><span class="line">        cltstream::write(<span class="number">1L</span>L*F[i]*j%mod,<span class="number">10</span>);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下个月就要省选了我还在颓怕不是要凉&lt;/p&gt;
&lt;p&gt;然后再一翻wzx的blog发现他更新频率快到爆炸&lt;/p&gt;
&lt;p&gt;大概这就是神吧&lt;/p&gt;
&lt;p&gt;啊啊我好菜啊，不过还是来抄篇题解吧&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4705&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="NTT" scheme="https://github.com/Challestend/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>「网络流学习笔记Part II」总之XJB写点啥（</title>
    <link href="https://github.com/Challestend/network-flow-learning-notes-pt2/"/>
    <id>https://github.com/Challestend/network-flow-learning-notes-pt2/</id>
    <published>2019-02-21T09:37:23.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>Part I大概是<a href="/something-about-network-flow-learning-notes/">这篇</a>。</p><p>去郑州的时候讲的网络流部分。</p><p>什么你说游记？咕咕咕。</p><a id="more"></a><h3 id="一种似乎没有名字的二元组模型"><a href="#一种似乎没有名字的二元组模型" class="headerlink" title="一种似乎没有名字的二元组模型"></a>一种似乎没有名字的二元组模型</h3><h4 id="简化版"><a href="#简化版" class="headerlink" title="简化版"></a>简化版</h4><p>你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个三元组<del>（虽然说不是标题说的二元组不过不要在意这些细节）</del>，每一个三元组形如$(x,y,c)$，意思是如果$x$和$y$两个任务在不同的机器上完成需要额外付出$c$的代价。你需要完成这$n$个任务，并最小化代价和。</p><p>我们都知道最小割=最大流。因此在一些题目中，如果无法将问题抽象成最大流问题，我们可以试着抽象成最小割问题。</p><p>对于任务$i$，连边$(S,i,a_{i}),(i,T,b_{i})$。对于一个三元组$(x,y,c)$，连边$(x,y,c),(y,x,c)$。</p><p>割断$(S,i,a_{i})$意味着任务$i$在第一台机器上完成，割断$(i,T,b_{i})$意味着任务$i$在第二台机器上完成。</p><p>首先很明显的是，同时割断$(S,i,a_{i})$和$(i,T,b_{i})$一定不是最优的决策。因此一个任务只会在一台机器上被完成。</p><p>对于一个三元组$(x,y,c)$，如果我们同时割断$(S,x,a_{x})$和$(S,y,a_{y})$，$S$与$T$直接就断开了，这样我们的代价是$a_{x}+a_{y}$。同时割断$(x,T,b_{x})$和$(y,T,b_{y})$也是类似的。</p><p>如果说我们同时割断$(S,x,a_{x})$和$(y,T,b_{y})$，图上仍存在$\{(S,y,a_{y}),(y,x,c),(x,T,b_{x})\}$这样一条路径，我们还需要割断$(y,x,c)$，这样我们的代价是$a_{x}+b_{y}+c$。同时割断$(x,T,b_{x})$和$(S,y,a_{y})$也是类似的。</p><h4 id="一般化"><a href="#一般化" class="headerlink" title="一般化"></a>一般化</h4><p>你有两台机器和$n$个任务。用第一台机器完成第$i$个任务需要付出$a_{i}$的代价，用第二台完成需要$b_{i}$的代价。你有$m$个六元组，每一个六元组形如$(x,y,c_{1},c_{2},c_{3},c_{4})$，意思是你需要为$x$和$y$这两个任务付出一些额外代价：</p><ul><li>如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{1}$。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{2}$。</li><li>如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，这个额外代价是$c_{3}$。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，这个额外代价是$c_{4}$。</li></ul><p>你需要完成这$n$个任务，并最小化代价和。</p><p>首先仍然是连边$(S,i,a_{i}),(i,T,b_{i})$。对于每一个六元组，连边$(S,x,A),(S,y,B),(x,T,C),(y,T,D),(x,y,E),(y,x,F)$。我们发现</p><ul><li>如果任务$x$在第一台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,x,A),(S,y,B)$，付出$A+B$的代价。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(x,T,C),(y,T,D)$，付出$C+D$的代价。</li><li>如果任务$x$在第一台机器上完成，任务$y$在第二台机器上完成，我们需要割断$(S,x,A),(y,T,D),(y,x,F)$，付出$A+D+F$的代价。</li><li>如果任务$x$在第二台机器上完成，任务$y$在第一台机器上完成，我们需要割断$(S,y,B),(x,T,C),(x,y,E)$，付出$B+C+E$的代价。</li></ul><p>因此我们列出如下的方程组</p><script type="math/tex; mode=display">\begin{cases}&A+B=c_{1}&(1)\\&C+D=c_{2}&(2)\\&A+D+F=c_{3}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;&(3)\\&B+C+E=c_{4}&(4)\end{cases}</script><p>因为我们要将问题转化成最大流问题，首先想到，我们要有$A,B,C,D,E,F\geqslant 0$。注意到，$(S,x,A)$和$(x,T,C)$中有且仅有一条边会出现在最小割集中，因此我们可以将$A$和$C$同时加上一个数，求出最小割后在答案中减去。$B$和$D$也可以类似处理。</p><p>需要注意的是，$E$和$F$不能被这样处理，因为我们不能确定它们在答案中产生了几次贡献。</p><p>$(3)+(4)-(1)-(2)$，我们得到</p><script type="math/tex; mode=display">E+F=c_{3}+c_{4}-c_{1}-c_{2}</script><p>定义$K=c_{3}+c_{4}-c_{1}-c_{2}$，当$K\geqslant 0$时它有意义，我们直接令$E=F=\cfrac{K}{2}$即可。</p><p>剩下的四个量随便给几个值，好算就行。</p><p>其实就算$K\lt 0$有时也是可以做的，但是我太菜了不会（</p><p>因为太菜了所以没有图（</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><h5 id="「国家集训队」happiness"><a href="#「国家集训队」happiness" class="headerlink" title="「国家集训队」happiness"></a><a href="https://www.luogu.org/problemnew/show/P1646" target="_blank" rel="noopener">「国家集训队」happiness</a></h5><p>题目要求最大化总收益，我们可以先将所有数取相反数，然后最小化总代价。</p><p>令位置$i$选文的单独收益是$a_{i}$，选理的单独收益是$b_{i}$，连边$(S,i,-a_{i}),(i,T,-b_{i})$。</p><p>考虑一对相邻的位置，他们都选文的额外收益是$v_{1}$，都选理的额外收益是$v_{2}$，列出方程组</p><script type="math/tex; mode=display">\begin{cases}&A+B=-v_{1}\\&C+D=-v_{2}\\&A+D+E=0\\&B+C+E=0\end{cases}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\begin{cases}&A=-\cfrac{v_{1}}{2}\\&B=-\cfrac{v_{1}}{2}\\&C=-\cfrac{v_{2}}{2}\\&D=-\cfrac{v_{2}}{2}\\&E=\cfrac{v_{1}+v_{2}}{2}\end{cases}</script><p>为了避免浮点数，我们把上面所有边的容量乘以$2$，包括$(S,i,-a_{i}),(i,T,-b_{i})$，最后再除回来。</p><p>然后，为了避免负数，我们将$A,B,C,D$加上$v_{1}+v_{2}$，把边$(S,i,-2a_{i}),(i,T,-2b_{i})$的容量加上$2a_{i}+2b_{i}$，最后再减回来。</p><p>总结一下就是，对于一个位置$i$，连边$(S,i,2b_{i}),(i,T,2a_{i})$。对于一对相邻位置$x,y$，连边$(S,x,v_{2}),(S,y,v_{2}),(x,T,v_{1}),(y,T,v_{1}),(x,y,v_{1}+v_{2}),(y,x,v_{1}+v_{2})$。</p><script type="math/tex; mode=display">\text{Ans}=\sum(a_{i}+b_{i})+\sum(v_{1}+v_{2})-\cfrac{\text{MinCut}(S,T)}{2}</script><p>但是我的<a href="https://www.luogu.org/recordnew/show/16563258" target="_blank" rel="noopener">代码</a>不知道为什么写炸了（</p><p>反正这个式子应该是没问题的（</p><p>那么告辞吧（</p><h3 id="闭合子图"><a href="#闭合子图" class="headerlink" title="闭合子图"></a>闭合子图</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于一个有向图$G$，它的一个闭合子图指的是一个顶点集合$V$，满足$V\subset G$，且</p><script type="math/tex; mode=display">\forall u\in V\wedge(u,v)\in G,v\in V</script><p>其中$|V|$最大的$V$被称为$G$的最大闭合子图。</p><p>如果$G$中的点有点权，$\sum_{u\in V}w(u)$最大的$V$被称为$G$的最大权闭合子图。</p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>首先，我们还是需要将所有点权取相反数，转为求最小权闭合子图。</p><p>对于$G$中的一个点$x$，割断与$S$之间的边表示$x\notin V$，割断与$T$之间的边表示$x\in V$。对于$G$中的一条边$(x,y)$，如果$x\in V$，那么一定有$y\in V$。我们可以认为，如果令$x\in V$，$y\notin V$，需要付出$+\infty$的代价。由此列出方程组</p><script type="math/tex; mode=display">\begin{cases}&A+B=0\\&C+D=-w(x)-w(y)\\&A+D+F=-w(x)\\&B+C+E=-w(y)+\infty\end{cases}\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\;\begin{cases}&A=0\\&B=0\\&C=-w(x)\\&D=-w(y)\\&E=+\infty\\&F=0\end{cases}</script><p>于是，去掉所有容量为$0$的边，我们得到$(x,T,-w(x)),(y,T,-w(y)),(x,y,+\infty)$这三条边。如果$w(x)\geqslant 0$，我们需要把边$(S,x,0),(x,T,-w(x))$的容量都加上$w(x)$，相当于是把$(x,T,-w(x))$换成了$(S,x,w(x))$。</p><p>总结一下就是，对于原图中的一个正权点$x$，连边$(S,x,w(x))$，对于原图中的一个负权点$x$，连边$(x,T,-w(x))$。对于原图中的一条边$(x,y)$，连边$(x,y,+\infty)$。</p><script type="math/tex; mode=display">\text{Ans}=\sum_{w(x)\geqslant 0}w(x)-\text{MinCut}(S,T)</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Part I大概是&lt;a href=&quot;/something-about-network-flow-learning-notes/&quot;&gt;这篇&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;去郑州的时候讲的网络流部分。&lt;/p&gt;
&lt;p&gt;什么你说游记？咕咕咕。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络流" scheme="https://github.com/Challestend/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>「Luogu-P3613」睡觉困难综合征</title>
    <link href="https://github.com/Challestend/luogu-p3613-solution/"/>
    <id>https://github.com/Challestend/luogu-p3613-solution/</id>
    <published>2019-02-15T11:25:37.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3613" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><h3 id="xjb扯"><a href="#xjb扯" class="headerlink" title="xjb扯"></a>xjb扯</h3><p>以前刚学树剖时看到这题感觉好神仙啊没法做啊。</p><p>然后现在学了LCT过来一看<del>，这不就一水题（</del></p><p>xjb写了棵LCT一交。</p><p><img src="/images/TIM截图20190215193107.png" alt></p><p>emmmmmm……</p><p>然后改的时候才发现全是细节错误，LCT的部分动都没动一下（</p><p>就比如说，下面是我第一次交的程序的主程序部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">    <span class="keyword">int</span> opt,x,y;</span><br><span class="line">    cltstream::read(opt);</span><br><span class="line">    cltstream::read(x);</span><br><span class="line">    cltstream::read(y);</span><br><span class="line">    <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> z;</span><br><span class="line">        <span class="comment">//我都不知道我当时是怎么想的（</span></span><br><span class="line">        cltstream::read(z);</span><br><span class="line">        split(mempool+x,mempool+y);</span><br><span class="line">        re <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ans0=(mempool+y)-&gt;ans0,ans1=(mempool+y)-&gt;ans1,ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=k<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            <span class="keyword">if</span>(((ans0&gt;&gt;j)&amp;<span class="number">1</span>)&gt;=((ans1&gt;&gt;j)&amp;<span class="number">1</span>)||z&lt;(<span class="number">1</span>&lt;&lt;j))</span><br><span class="line">            <span class="comment">//甚至忘了用1ULL（</span></span><br><span class="line">                ans^=ans0&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                z-=<span class="number">1</span>&lt;&lt;j;</span><br><span class="line">                ans^=ans1&amp;(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">            &#125;</span><br><span class="line">        cltstream::write(ans,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> z;</span><br><span class="line">        cltstream::read(z);</span><br><span class="line">        access(mempool+x);</span><br><span class="line">        (mempool+x)-&gt;tp=y;</span><br><span class="line">        (mempool+x)-&gt;val=z;</span><br><span class="line">        (mempool+y)-&gt;pushUp();</span><br><span class="line">        <span class="comment">//？？？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我Splay节点的内部信息甚至开成了<code>unsigned</code>，excuse me？？？</p><p><del>不这个东西这不是我写的（</del></p><h3 id="真正的题解"><a href="#真正的题解" class="headerlink" title="真正的题解"></a>真正的题解</h3><p>首先LCT。</p><p>不过首先的首先您还是要先做了<a href="https://www.luogu.org/problemnew/show/P2114" target="_blank" rel="noopener">这道题</a>。</p><p>每个Splay节点维护两个值，分别是把$0$和$-1$在它所在的实链的一部分中按照深度递增的方向跑一遍得到的结果。</p><p>我们记这两个值为<code>ans0</code>和<code>ans1</code>。</p><p>左子树和节点本身的信息很好维护。</p><p>而关于右子树，看上去我们没办法迅速求出把到现在为止的<code>ans0</code>和<code>ans1</code>扔进去跑一遍的结果。</p><p>但是注意到这些都是按位运算，位与位之间不互相影响。</p><p>我们可以对于<code>ans0</code>中是$1$的那些位，提取出<code>rc-&gt;ans1</code>的对应位，对于<code>ans0</code>中是$0$的那些位，提取出<code>rc-&gt;ans0</code>的对应位。</p><p>然后<code>ans1</code>也类似处理就行了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    SplayNode *ftr,*lc,*rc;</span><br><span class="line">    <span class="keyword">int</span> tp,rev;</span><br><span class="line">    <span class="keyword">unsigned</span> val,ans0,ans1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">apply</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tp==<span class="number">1</span>?(x&amp;val):tp==<span class="number">2</span>?(x|val):(x^val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ans0=<span class="number">0</span>,ans1=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(lc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans0=lc-&gt;ans0;</span><br><span class="line">            ans1=lc-&gt;ans1;</span><br><span class="line">        &#125;</span><br><span class="line">        ans0=apply(ans0),ans1=apply(ans1);</span><br><span class="line">        <span class="keyword">if</span>(rc!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            ans0=(ans0&amp;rc-&gt;ans1)|((~ans0)&amp;rc-&gt;ans0);</span><br><span class="line">            ans1=(ans1&amp;rc-&gt;ans1)|((~ans1)&amp;rc-&gt;ans0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是还有一个问题是，LCT在连边和提取路径时需要<code>makeRoot</code>，也就是说需要区间翻转。</p><p>但是由于不同种类的位运算混在一起没有交换律，我们无法快速地算出翻转后的答案。</p><p>那么提前维护好就行了。提前维护好<code>sna0</code>和<code>sna1</code>，表示把$0$和$-1$反过来跑一遍的结果。</p><p>然后就没了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3613&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树链剖分" scheme="https://github.com/Challestend/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
      <category term="LCT" scheme="https://github.com/Challestend/tags/LCT/"/>
    
  </entry>
  
  <entry>
    <title>「年轻人，你渴望力量吗？」</title>
    <link href="https://github.com/Challestend/min-25-sieve-learning-notes/"/>
    <id>https://github.com/Challestend/min-25-sieve-learning-notes/</id>
    <published>2019-02-13T13:41:39.000Z</published>
    <updated>2019-04-14T09:49:49.351Z</updated>
    
    <content type="html"><![CDATA[<p>标题来自某学长安利min_25筛的方式（</p><a id="more"></a><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>我们知道，<a href="/number-theory-learning-notes/">杜教筛</a>可以在$O(n^{\tfrac{2}{3}})$的时间复杂度内计算某些给定的积性函数的前缀和。</p><p>但是现在我们希望更快。于是我们有了min_25筛（</p><p>以下，我们约定$p$是一个质数。$\mathbb{P}_{i}$表示第$i$小的质数，$\mathbb{P}_{0}=0$。$\text{minp}(n)$表示$n$最小的质因数，$\text{minp}(1)=0$。</p><p>现在我们要求一个积性函数$f$的前缀和。我们需要它满足以下两条性质：</p><ol><li>$f(p)$是一个<strong>可以快速求前缀和的完全积性函数</strong>，或者能用多个这样的函数运算得到。</li><li>$f(p^{k})$可以快速求，大概$O(k)$以内就可以。</li></ol><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>我们要对每一个$x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，求出</p><script type="math/tex; mode=display">\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>定义</p><script type="math/tex; mode=display">F(x,y)=\sum_{i=1}^{x}[i\in\mathbb{P}\vee\text{minp}(i)\gt\mathbb{P}_{y}]f^{\prime}(i)</script><p>也就是把所有质数和最小质因数大于$\mathbb{P}_y$的合数全部当成质数代入$f^{\prime}$求值并求和。不难发现</p><script type="math/tex; mode=display">F(x,+\infty)=\sum_{i=1}^{x}[i\in\mathbb{P}]f(i)</script><p>我们回忆一下埃式筛法的运行过程。</p><p>筛完$k$次后，我们除去了最小质因数小于等于$\mathbb{P}_{k}$的合数，剩下了质数和最小质因数大于$\mathbb{P}_k$的合数。</p><p>可以看到这和$F(x,y)$的定义十分吻合。$F(x,y)$就是埃式筛法筛完$y$次后，没有被筛掉的数的$f^{\prime}$的值的和。</p><p>首先，第$y$次筛掉的最小的数很明显是$\mathbb{P}_{y}^{2}$，如果$\mathbb{P}_{y}^{2}\gt x$，我们什么也筛不掉，此时$F(x,y)=F(x,y-1)$。</p><p>也因此，筛质数筛到$\sqrt{n}$即可。</p><p>否则，即$\mathbb{P}_{y}^{2}\leqslant x$，我们将所有数除以$\mathbb{P}_{y}$，之前所有最小质因数等于$\mathbb{P}_{y}$的合数一一对应到了现在所有大于等于$\mathbb{P}_{y}$的数。</p><p>又因为$f^{\prime}$是完全积性的，假如我们有一个需要筛掉的数$z$，我们可以通过$f^{\prime}(\cfrac{z}{\mathbb{P}_{y}})f^{\prime}(\mathbb{P}_{y})$计算$f^{\prime}(z)$。</p><p>那么看起来</p><script type="math/tex; mode=display">F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)</script><p>$F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)$包含了三类数的$f^{\prime}$的值：</p><ol><li>大于等于$\mathbb{P}_{y}$的质数。</li><li>最小质因数大于等于$\mathbb{P}_{y}$（大于$\mathbb{P}_{y-1}$）的合数。</li><li>小于$\mathbb{P}_{y}$的质数。</li></ol><p>但是很明显第三类数不能被除去，因此实际上</p><script type="math/tex; mode=display">F(x,y)=F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)</script><p>综上所述</p><script type="math/tex; mode=display">F(x,y)=\begin{cases}&F(x,y-1)-f^{\prime}(\mathbb{P}_{y})\left(F(\lfloor\cfrac{n}{\mathbb{P}_{y}}\rfloor,y-1)-\sum\limits_{i=1}^{y-1}f^{\prime}(\mathbb{P}_{i})\right)\;\;&(\mathbb{P}_{y}^{2}\leqslant x)\\&F(x,y-1)&(\mathbb{P}_{y}^{2}\gt x)\end{cases}</script><p>初值为</p><script type="math/tex; mode=display">F(x,0)=\sum_{i=2}^{x}f^{\prime}(i)</script><p>注意到第二维只与$y-1$有关，我们可以滚掉。</p><p>还有一个问题。这类题目的$n$会很大，我们无法开一个长度为$n$的数组。</p><p>因为$x=\lfloor\cfrac{n}{i}\rfloor(i\in\mathbb{N}\cap[1,n])$，这样的$x$最多只有$2\sqrt{n}$个，我们可以离散化存储。</p><p>具体实现细节我说不清，看代码吧（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">cltstream::read(n);</span><br><span class="line">sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=sq;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">        g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">        fsum[g[<span class="number">0</span>]]=fsum[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="comment">/**/</span>;</span><br><span class="line">        <span class="comment">//注释处应填f`(i)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;i*g[j]&lt;=sq;++j)&#123;</span><br><span class="line">        f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">    w[++m]=n/l;</span><br><span class="line">    <span class="comment">//编号对应的离散化前的值</span></span><br><span class="line">    F[m]=<span class="comment">/**/</span>;</span><br><span class="line">    <span class="comment">//注释处应填\sum_&#123;t=2&#125;^&#123;w[m]&#125;f`(t)</span></span><br><span class="line">    <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">        id1[w[m]]=m;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        id2[n/w[m]]=m;</span><br><span class="line">    <span class="comment">//分段存储值对应的编号，这样数组只需要开到sqrt&#123;n&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=g[j]*g[j];++i)&#123;</span><br><span class="line">    <span class="comment">//w[i]&gt;=g[j]*g[j]，所以w[i]/g[j]&gt;=g[j]</span></span><br><span class="line">        re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">        F[i]-=<span class="comment">/**/</span>*(F[id]-fsum[j<span class="number">-1</span>]);</span><br><span class="line">        <span class="comment">//注释处应填f`(g[j])</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这一部分的时间复杂度已被证明是$O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>然而看上去很奇怪（</del></p><h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>在第一部分中我们求出了所有质数的贡献，现在我们要扩展到全体整数。</p><p>定义</p><script type="math/tex; mode=display">S(x,y)=\sum_{i=1}^{x}[\text{minp}(i)\geqslant\mathbb{P}_{y}]f(i)</script><p>也就是所有最小质因数大于等于$\mathbb{P}_{y}$的数的$f$的值的和。我们最终要求的就是$S(n,1)+f(1)$。</p><p>首先我们需要统计所有质数的贡献，也就是$F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})$。</p><p>关于合数，我们枚举最小的质因数，然后把所有数除以这个数的若干次幂，得到的商的最小质因数应当大于这个数。</p><script type="math/tex; mode=display">\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)</script><p>但是还有一个问题是$S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)$中不包括$f(1)$，因此$f(\mathbb{P}_{i}^{j})$没有被统计，我们需要手动算进来</p><script type="math/tex; mode=display">\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>于是</p><script type="math/tex; mode=display">S(x,y)=F(x,+\infty)-\sum\limits_{i=1}^{y-1}f(\mathbb{P}_{i})+\sum_{i=y}^{\mathbb{P}_{i}^{2}\leqslant n}\sum_{j=1}^{\mathbb{P}_{i}^{j+1}\leqslant n}\left(f(\mathbb{P}_{i}^{j})S(\lfloor\cfrac{x}{\mathbb{P}_{i}^{j}}\rfloor,i+1)+f(\mathbb{P}_{i}^{j+1})\right)</script><p>然后暴力搜，记忆化都不需要，时间复杂度还是$O(\cfrac{n^{\tfrac{3}{4}}}{\log n})$。<del>就很神奇（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">S</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">int</span> res=F[id]-fsum[y<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=<span class="comment">/*1*/</span>*S(x/p,i+<span class="number">1</span>)+<span class="comment">/*2*/</span>;</span><br><span class="line">                <span class="comment">//1处应填f(p)，2处应填f(p*g[i])</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="「Luogu-P4213」「模板」杜教筛（Sum）"><a href="#「Luogu-P4213」「模板」杜教筛（Sum）" class="headerlink" title="「Luogu-P4213」「模板」杜教筛（Sum）"></a><a href="https://www.luogu.org/problemnew/show/P4213" target="_blank" rel="noopener">「Luogu-P4213」「模板」杜教筛（Sum）</a></h3><p>首先我们有</p><script type="math/tex; mode=display">\varphi(p)=\text{id}(p)-1</script><script type="math/tex; mode=display">\mu(p)=-1</script><p>然后$\text{id}$和$1$都是能$O(1)$求前缀和完全积性函数，因此可以用min_25筛搞。</p><p>说起来比较麻烦，min_25筛不结合代码大概也很难理解，所以说直接上代码（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 50000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,n,sq,m;</span><br><span class="line"><span class="keyword">int</span> f[maxn+<span class="number">1</span>],g[maxn+<span class="number">1</span>],w[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>],id1[maxn+<span class="number">1</span>],id2[maxn+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> prmcnt[maxn+<span class="number">1</span>],prmCnt[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> prmsum[maxn+<span class="number">1</span>],prmSum[(maxn&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">getPhi</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> res=(prmSum[id]-prmCnt[id])-(prmsum[y<span class="number">-1</span>]-prmcnt[y<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> p=g[i];<span class="number">1L</span>L*p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=<span class="number">1L</span>L*p/g[i]*(g[i]<span class="number">-1</span>)*getPhi(x/p,i+<span class="number">1</span>)+<span class="number">1L</span>L*p*(g[i]<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMu</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> id=x&lt;=sq?id1[x]:id2[n/x];</span><br><span class="line">        re <span class="keyword">int</span> res=prmcnt[y<span class="number">-1</span>]-prmCnt[id];</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            res-=getMu(x/g[i],i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=maxn;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">            g[++g[<span class="number">0</span>]]=i;</span><br><span class="line">            prmcnt[g[<span class="number">0</span>]]=prmcnt[g[<span class="number">0</span>]<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            prmsum[g[<span class="number">0</span>]]=prmsum[g[<span class="number">0</span>]<span class="number">-1</span>]+i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*i*g[j]&lt;=maxn;++j)&#123;</span><br><span class="line">            f[i*g[j]]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!(i%g[j]))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">        cltstream::read(n);</span><br><span class="line">        sq=<span class="built_in">sqrt</span>(n);</span><br><span class="line">        m=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> l=<span class="number">1</span>,r;l&lt;=n;r=n/(n/l),l=r+<span class="number">1</span>)&#123;</span><br><span class="line">            w[++m]=n/l;</span><br><span class="line">            prmCnt[m]=w[m]<span class="number">-1</span>;</span><br><span class="line">            prmSum[m]=<span class="number">1L</span>L*(w[m]<span class="number">-1</span>)*(w[m]+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(w[m]&lt;=sq)</span><br><span class="line">                id1[w[m]]=m;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                id2[n/w[m]]=m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=g[<span class="number">0</span>];++j)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m&amp;&amp;w[i]&gt;=<span class="number">1L</span>L*g[j]*g[j];++i)&#123;</span><br><span class="line">                re <span class="keyword">int</span> id=w[i]/g[j]&lt;=sq?id1[w[i]/g[j]]:id2[n/(w[i]/g[j])];</span><br><span class="line">                prmCnt[i]-=prmCnt[id]-prmcnt[j<span class="number">-1</span>];</span><br><span class="line">                prmSum[i]-=<span class="number">1L</span>L*g[j]*(prmSum[id]-prmsum[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        cltstream::write(getPhi(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(getMu(n,<span class="number">1</span>)+<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/TIM截图20190214152934.png" alt></p><p>上为min_25筛，下为杜教筛。</p><p>min_25筛的优势不仅在于时间复杂度，它还可以筛一些乱七八糟的东西。就比如说</p><h3 id="「LOJ6053」简单的函数"><a href="#「LOJ6053」简单的函数" class="headerlink" title="「LOJ6053」简单的函数"></a><a href="https://loj.ac/problem/6053" target="_blank" rel="noopener">「LOJ6053」简单的函数</a></h3><p>总结一下这个函数：</p><script type="math/tex; mode=display">f(1)=1</script><script type="math/tex; mode=display">f\left(\prod_{i=1}^{N}p_{i}^{r_{i}}\right)=\prod_{i=1}^{N}(p_{i}\otimes r_{i})</script><p>其中$\otimes$表示按位异或。</p><p><img src="/images/TIM图片20190103092627.png" alt></p><p>按位异或从十进制的角度来看无异于玄学，因此杜教筛就没法做了（</p><p>注意到</p><script type="math/tex; mode=display">f(p)=p\otimes 1=\begin{cases}&p+1\;\;&(p=2)\\&p-1\;\;&(p\gt 2)\end{cases}</script><p>我们可以在算前缀和时将$f(2)$当成$2-1$，然后特判一下加回来。</p><p>然后还是要用min_25筛的前半部分筛出$\text{id}$和$1$，其实和上面的$\varphi$没多大区别就是加了点细节（</p><p><a href="https://loj.ac/submission/336101" target="_blank" rel="noopener">好像这种能随便看代码的OJ可以直接扔个提交记录</a>。</p><h3 id="「UOJ188」Sanrd"><a href="#「UOJ188」Sanrd" class="headerlink" title="「UOJ188」Sanrd"></a><a href="http://uoj.ac/problem/188" target="_blank" rel="noopener">「UOJ188」Sanrd</a></h3><p>次大质因数和。</p><p>其实这个题面有点考阅读的。</p><p>但是我们发现次大质因数这个函数和质数并没有什么关系，而且不积性。<del>说好的只能筛积性函数呢（</del></p><p>我们来分析一下min_25筛的运行过程。</p><p>调用到$S(x,y)$时，剩下的最小质因数大于等于$\mathbb{P}_{y}$的数中，只有质数与$\mathbb{P}_{y-1}$相乘之后能够得到次大质因数为$\mathbb{P}_{y-1}$的数。这部分可以直接算。</p><p>关于次大质因数大于$\mathbb{P}_{y-1}$的，还是枚举递归暴力搜。然后还是没有算$f(\mathbb{P}_{i}^{j})$，手动加。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">S</span><span class="params">(re <span class="keyword">long</span> <span class="keyword">long</span> n,re <span class="keyword">long</span> <span class="keyword">long</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=<span class="number">1</span>||g[y]&gt;x)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> k=id[x&lt;=sq?x:n/x+sq];</span><br><span class="line">        re <span class="keyword">long</span> <span class="keyword">long</span> res=(y&gt;<span class="number">1</span>?g[y<span class="number">-1</span>]:<span class="number">0</span>)*(prmCnt[k]-y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=y;i&lt;=g[<span class="number">0</span>]&amp;&amp;<span class="number">1L</span>L*g[i]*g[i]&lt;=x;++i)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">long</span> <span class="keyword">long</span> p=g[i];p*g[i]&lt;=x;p*=g[i])</span><br><span class="line">                res+=S(n,x/p,i+<span class="number">1</span>)+g[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://uoj.ac/submission/324057" target="_blank" rel="noopener">提交记录</a>。</p><p><del>一道比一道神仙，像我这种菜鸡只能抄题解了（</del></p><h3 id="课后习题"><a href="#课后习题" class="headerlink" title="课后习题"></a>课后习题</h3><ul><li><a href="https://loj.ac/problem/572" target="_blank" rel="noopener">「LOJ572」「LibreOJ Round #11」Misaka Network与求和</a></li><li><a href="https://www.spoj.com/problems/DIVCNTK/" target="_blank" rel="noopener">「SP34096」DIVCNTK - Counting Divisors (general)</a></li><li><a href="https://www.spoj.com/problems/GCDEX2/" target="_blank" rel="noopener">「SP19985」GCDEX2 - GCD Extreme (hard)</a></li><li><a href="https://www.spoj.com/problems/APS2/" target="_blank" rel="noopener">「SP19975」APS2 - Amazing Prime Sequence (hard)</a></li></ul><h3 id="其它文献"><a href="#其它文献" class="headerlink" title="其它文献"></a>其它文献</h3><ul><li><a href="https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096" target="_blank" rel="noopener">https://www.luogu.org/blog/ShadowassIIXVIIIIV/solution-sp34096</a></li><li><a href="https://www.cnblogs.com/zhoushuyu/p/9187319.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoushuyu/p/9187319.html</a></li><li><a href="https://www.cnblogs.com/cjyyb/p/10169190.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjyyb/p/10169190.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;标题来自某学长安利min_25筛的方式（&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="min_25筛" scheme="https://github.com/Challestend/tags/min-25%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>动态树学习笔记</title>
    <link href="https://github.com/Challestend/link-cut-tree-learning-notes/"/>
    <id>https://github.com/Challestend/link-cut-tree-learning-notes/</id>
    <published>2019-01-21T02:57:11.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>24号要出去学习，趁现在先自己xjb学点啥。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>首先我们有一道<a href="https://www.luogu.org/problemnew/show/P3690" target="_blank" rel="noopener">模板题</a>。</p><p>我们所熟悉的树链剖分指的是重链剖分。也就是定义一个节点的子树大小最大的儿子为它的重儿子，连接重儿子的边叫做重边，若干条重边连在一起形成重链。除了重儿子以外的儿子被称为轻儿子，连接轻儿子的边叫做轻边。</p><p>这样一来，我们给原树的节点重新标号，使得一条重链上的所有节点的新标号是连续的，然后通过线段树或者树状数组等能够处理区间的数据结构进行维护，通过轻边合并两条重链上的信息。时间复杂度一般是$O(n\log^{2}n)$。</p><p>但是这样有一个问题，因为线段树，又或者是树状数组，都是静态的数据结构，它们不能支持我们在上面xjb捣鼓。反映到原树上，这就意味着我们边的轻重只能也是静态的。这会带来很多不便。就比如说，我们现在要维护一片森林，要求支持动态连边、删边，同时需要查询某条链上的信息。</p><p>很明显这是重链剖分无法胜任的。为了解决这个问题，我们需要一种能够动态修改边的轻重的算法，也就是实链剖分。</p><p>实链剖分一般被称为LCT，全称<del>Link-Cat Tree</del> <del>Linear Challestend Transformation</del> Link-Cut Tree，也就是动态树。</p><p>与重链剖分类似地，我们根据实际情况，随便钦定一个节点的某个儿子为它的实儿子，连接实儿子的边叫做实边，若干条实边连在一起形成实链。除了实儿子以外的儿子被称为虚儿子，连接虚儿子的边叫做虚边。</p><p>为了实现它，我们需要通过更加灵活的Splay来维护每一条实链。它具有如下性质：</p><ol><li>每棵Splay维护的是一条原森林中深度严格递增的路径，也就是一条实链。</li><li>每个节点属于且仅属于一棵Splay。</li><li>如果一个节点在原森林中有多个儿子，只有一个与它在同一颗Splay中，也就是实儿子。其他儿子所在的Splay的根节点有一根父指针指向这个节点，但是从这个节点访问不到它们。</li><li>不同于重链剖分，就算一个节点有至少一个儿子，也可以没有实儿子。</li></ol><p>以下图片来自<a href="https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。" target="_blank" rel="noopener">https://wenku.baidu.com/view/75906f160b4e767f5acfcedb。</a></p><p>我们来看这样一棵树</p><p><img src="/images/1309909-20180123095924037-1618037447.png" alt></p><p>其中粗线表示实边，虚线表示虚边。</p><p>它所对应的Splay森林可能长下面这样，每一个绿框内都是一棵Splay。</p><p><img src="/images/1309909-20180123095955350-1680422636.png" alt></p><p>当然这并不是唯一的。</p><p>为了方便，我先放出我Splay的代码实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">    SplayNode *ftr,*ls,*rs;</span><br><span class="line">    <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//判断一个节点是否是原森林中的一棵树的树根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">        rev^=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                ls-&gt;reverse();</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                rs-&gt;reverse();</span><br><span class="line">            rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sum=val;</span><br><span class="line">        <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">            sum^=ls-&gt;sum;</span><br><span class="line">        <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">            sum^=rs-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    re SplayNode* q=p-&gt;ftr;</span><br><span class="line">    q-&gt;pushDown();</span><br><span class="line">    p-&gt;pushDown();</span><br><span class="line">    p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">            p-&gt;ftr-&gt;ls=p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">            p-&gt;ftr-&gt;rs=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">        q-&gt;rs=p-&gt;ls;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;rs-&gt;ftr=q;</span><br><span class="line">        p-&gt;ls=q;</span><br><span class="line">        q-&gt;ftr=p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;ls=p-&gt;rs;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">            q-&gt;ls-&gt;ftr=q;</span><br><span class="line">        p-&gt;rs=q;</span><br><span class="line">        q-&gt;ftr=p;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;pushUp();</span><br><span class="line">    p-&gt;pushUp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line"><span class="comment">//不同于我们以前写的Splay，现在我们只需要将一个节点旋转到根即可</span></span><br><span class="line">    <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">            rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="access"><a href="#access" class="headerlink" title="access"></a>access</h3><p>首先我们有一个基本操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>首先有一个问题是，这个单词怎么读？</p><p><code>/ək&#39;ses/</code>？不不不应该是<code>/&#39;ækses/</code>。</p><p>如果您有兴趣，可以在<a href="https://github.com/shimohq/chinese-programmer-wrong-pronunciation">这里</a>看看自己以前都读错了多少单词（</p><p>这个函数的作用是打通指定节点到根节点的路径，将这条路径修改成实链，并抛弃指定节点自身的实儿子。</p><p>我们来看看这个函数的具体过程。还是上面的例子，现在我们调用<code>access(N)</code>，整棵树会变成这样</p><p><img src="/images/1309909-20180123101901740-2118178734.png" alt></p><p><del>虽然说好像图上用的还是轻重……不过这些细节就不要在意啦（</del></p><p>首先我们调用<code>splay(N)</code>，令$\text{N}$成为它所在的Splay的根节点，然后它所在的实链中再往下的部分就到了它的右子树中，我们直接回收它的右儿子指针即可。需要注意的是，我们并没有切断这条边，只是让它变虚，因此它的右儿子的父指针不应该被修改。</p><p><img src="/images/1309909-20180123110136115-1112016464.png" alt></p><p>向上找到$\text{N}$的父亲$\text{I}$，调用<code>splay(I)</code>，回收$\text{I}$的右儿子指针。不过这一次，我们需要再令其指向$\text{N}$，然后$\text{N}$就成了$\text{I}$的实儿子了。</p><p><img src="/images/1309909-20180123110156272-1242463729.png" alt></p><p>然后继续向上，找到$\text{I}$的父亲$\text{H}$，调用<code>splay(H)</code>，并令$\text{H}$的右儿子指针指向$\text{I}$。</p><p><img src="/images/1309909-20180123110209772-2057141058.png" alt></p><p>最后一步，找到$\text{H}$的父亲$\text{A}$，调用<code>splay(A)</code>，并令$\text{A}$的右儿子指针指向$\text{H}$。</p><p><img src="/images/1309909-20180123110213709-49169640.png" alt></p><p>然后我们看到，$\text{N}$和$\text{A}$到了同一颗Splay中，完成任务，返回。</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    splay(p);</span><br><span class="line">    p-&gt;pushDown();</span><br><span class="line">    p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;pushUp();</span><br><span class="line">    <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">        splay(q-&gt;ftr);</span><br><span class="line">        q-&gt;ftr-&gt;pushDown();</span><br><span class="line">        q-&gt;ftr-&gt;rs=q;</span><br><span class="line">        q-&gt;ftr-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p);</span><br><span class="line">    <span class="comment">//据说闲着没事瞎转转有利于摊开时间复杂度（</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="findRoot"><a href="#findRoot" class="headerlink" title="findRoot"></a>findRoot</h3><p>有了<code>access</code>，我们就可以随心所欲的瞎搞了。比如说</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SplayNode* <span class="title">findRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>返回给定节点所在的树的树根，也就是调用完<code>access</code>后它所在的实链上深度最小的节点。</p><p>因为<code>access</code>的最后自带了一个<code>splay</code>，这个时候给定节点已经是Splay的根节点了，我们直接循环跳左儿子指针即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">    splay(p);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="makeRoot-amp-amp-split"><a href="#makeRoot-amp-amp-split" class="headerlink" title="makeRoot &amp;&amp; split"></a>makeRoot &amp;&amp; split</h3><p>现在我们要提取出树上两个给定节点之间的路径。但是我们知道，这样的路径不一定满足深度严格递增，也就是说，它可能不能够出现在一棵Splay中。</p><p>不过办法总是有的。比如说我们指定了两个节点$x$和$y$，我们先调用<code>access(x)</code>，然后考虑翻转$x$的子树之后会发生什么。</p><p><code>access</code>结束后，$x$没有右子树，翻转之后就没有了左子树，也就是说，现在没有比$x$的深度更小的节点了。换句话说就是，$x$现在成为了树根。</p><p>那么这样一来，$x$到$y$的路径就一定满足深度严格递增了，我们只需调用一次<code>access(y)</code>就可以把它抽出来。</p><p>我们实现下面两个函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>令给定节点成为树根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>抽出给定的两个节点之间的路径。不过虽然说模板题保证联通，还是有必要稍微考虑一下不连通的情况的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">    access(p);</span><br><span class="line">    p-&gt;reverse();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    access(q);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3><p>我们需要实现函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>在给定的两个节点间连一条边。特殊地，如果说给定的两个节点已经联通，什么都不做直接返回。不过这是模板题的要求，有些题可能会让你输出操作失败，这种情况下改一下返回值就行。</p><p>思路很简单。假设我们指定$x$和$y$两个节点，首先调用<code>makeRoot(x)</code>，然后检查<code>findRoot(y)</code>的返回值。如果不是$x$，说明两个节点不连通，将$x$的父指针指向$y$；否则，即<code>findRoot(y)==x</code>，说明两个节点联通，直接返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">        p-&gt;ftr=q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>我们需要实现函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(SplayNode*,SplayNode*)</span></span></span><br></pre></td></tr></table></figure><p>切断给定的两个节点之间的边。不存在就什么也不做。</p><p>需要注意的是，两个节点$x$和$y$之间直接有边相连，不仅要求$x$与$y$联通，还要求它们在Splay中是相邻的两个节点。为了避免讨论深度的大小关系，我们先调用<code>makeRoot(x)</code>，此时$y$应该是$x$的右儿子，并且它不能有左儿子。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">    makeRoot(p);</span><br><span class="line">    <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把上面这么一些东西写好之后，再根据题目要求搞一搞，您就可以切掉模板题了。</p><p>完整板子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 300000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(_tp&amp; x,_tp&amp; y)</span></span>&#123;</span><br><span class="line">        _tp z=x;</span><br><span class="line">        x=y;</span><br><span class="line">        y=z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span>&#123;</span></span><br><span class="line">        SplayNode *ftr,*ls,*rs;</span><br><span class="line">        <span class="keyword">int</span> val,sum,rev;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">isRoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ftr==<span class="literal">NULL</span>||(ftr-&gt;ls!=<span class="keyword">this</span>&amp;&amp;ftr-&gt;rs!=<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">std</span>::swap(ls,rs);</span><br><span class="line">            rev^=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushDown</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(rev)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                    ls-&gt;reverse();</span><br><span class="line">                <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                    rs-&gt;reverse();</span><br><span class="line">                rev=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pushUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            sum=val;</span><br><span class="line">            <span class="keyword">if</span>(ls!=<span class="literal">NULL</span>)</span><br><span class="line">                sum^=ls-&gt;sum;</span><br><span class="line">            <span class="keyword">if</span>(rs!=<span class="literal">NULL</span>)</span><br><span class="line">                sum^=rs-&gt;sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    SplayNode mempool[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        re SplayNode* q=p-&gt;ftr;</span><br><span class="line">        q-&gt;pushDown();</span><br><span class="line">        p-&gt;pushDown();</span><br><span class="line">        p-&gt;ftr=q-&gt;ftr;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;ftr!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ftr-&gt;ls==q)</span><br><span class="line">                p-&gt;ftr-&gt;ls=p;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;ftr-&gt;rs==q)</span><br><span class="line">                p-&gt;ftr-&gt;rs=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rs==p)&#123;</span><br><span class="line">            q-&gt;rs=p-&gt;ls;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;rs!=<span class="literal">NULL</span>)</span><br><span class="line">                q-&gt;rs-&gt;ftr=q;</span><br><span class="line">            p-&gt;ls=q;</span><br><span class="line">            q-&gt;ftr=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            q-&gt;ls=p-&gt;rs;</span><br><span class="line">            <span class="keyword">if</span>(q-&gt;ls!=<span class="literal">NULL</span>)</span><br><span class="line">                q-&gt;ls-&gt;ftr=q;</span><br><span class="line">            p-&gt;rs=q;</span><br><span class="line">            q-&gt;ftr=p;</span><br><span class="line">        &#125;</span><br><span class="line">        q-&gt;pushUp();</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(;!p-&gt;isRoot();rotate(p))</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;ftr-&gt;isRoot())</span><br><span class="line">                rotate((p-&gt;ftr-&gt;ftr-&gt;ls==p-&gt;ftr)==(p-&gt;ftr-&gt;ls==p)?p-&gt;ftr:p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">(re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            re SplayNode* p=mempool+i;</span><br><span class="line">            p-&gt;ftr=p-&gt;ls=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">            cltstream::read(p-&gt;val);</span><br><span class="line">            p-&gt;sum=p-&gt;val;</span><br><span class="line">            p-&gt;rev=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        splay(p);</span><br><span class="line">        p-&gt;pushDown();</span><br><span class="line">        p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;pushUp();</span><br><span class="line">        <span class="keyword">for</span>(re SplayNode* q=p;q-&gt;ftr!=<span class="literal">NULL</span>;q=q-&gt;ftr)&#123;</span><br><span class="line">            splay(q-&gt;ftr);</span><br><span class="line">            q-&gt;ftr-&gt;pushDown();</span><br><span class="line">            q-&gt;ftr-&gt;rs=q;</span><br><span class="line">            q-&gt;ftr-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> SplayNode* <span class="title">findRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        access(p);</span><br><span class="line">        <span class="keyword">for</span>(;p-&gt;ls!=<span class="literal">NULL</span>;p=p-&gt;ls);</span><br><span class="line">        splay(p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">makeRoot</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        access(p);</span><br><span class="line">        p-&gt;reverse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        access(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        <span class="keyword">if</span>(findRoot(q)!=p)</span><br><span class="line">            p-&gt;ftr=q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(re SplayNode* p,re SplayNode* q)</span></span>&#123;</span><br><span class="line">        makeRoot(p);</span><br><span class="line">        <span class="keyword">if</span>(findRoot(q)==p&amp;&amp;q-&gt;ftr==p&amp;&amp;q-&gt;ls==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            q-&gt;ftr=p-&gt;rs=<span class="literal">NULL</span>;</span><br><span class="line">            p-&gt;pushUp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryPathXorSum</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        split(mempool+x,mempool+y);</span><br><span class="line">        <span class="keyword">return</span> (mempool+y)-&gt;sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">createEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        link(mempool+x,mempool+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destoryEdge</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        cut(mempool+x,mempool+y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyVertice</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        splay(mempool+x);</span><br><span class="line">        (mempool+x)-&gt;val=y;</span><br><span class="line">        (mempool+x)-&gt;pushUp();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(re SplayNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;pushDown();</span><br><span class="line">            printTree(p-&gt;ls);</span><br><span class="line">            <span class="built_in">printf</span>(</span><br><span class="line">                <span class="string">"%d(%d,%d,%d)\n"</span>,</span><br><span class="line">                p-mempool,</span><br><span class="line">                p-&gt;ftr!=<span class="literal">NULL</span>?p-&gt;ftr-mempool:<span class="number">-1</span>,</span><br><span class="line">                p-&gt;ls!=<span class="literal">NULL</span>?p-&gt;ls-mempool:<span class="number">-1</span>,</span><br><span class="line">                p-&gt;rs!=<span class="literal">NULL</span>?p-&gt;rs-mempool:<span class="number">-1</span></span><br><span class="line">            );</span><br><span class="line">            printTree(p-&gt;rs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">LinkCutTree QAQ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;\</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    QAQ.build(n);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> opt,x,y;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(x);</span><br><span class="line">        cltstream::read(y);</span><br><span class="line">        <span class="keyword">switch</span>(opt)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                cltstream::write(QAQ.queryPathXorSum(x,y),<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                QAQ.createEdge(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                QAQ.destoryEdge(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                QAQ.modifyVertice(x,y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>是不是感觉很好写呢（</del></p><h3 id="用LCT维护子树信息"><a href="#用LCT维护子树信息" class="headerlink" title="用LCT维护子树信息"></a>用LCT维护子树信息</h3><p>咕咕咕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;24号要出去学习，趁现在先自己xjb学点啥。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="LCT" scheme="https://github.com/Challestend/tags/LCT/"/>
    
      <category term="Splay" scheme="https://github.com/Challestend/tags/Splay/"/>
    
  </entry>
  
  <entry>
    <title>2019-01-20：loli的两场模拟赛的题解</title>
    <link href="https://github.com/Challestend/lolioi-2019-01-20-solutions/"/>
    <id>https://github.com/Challestend/lolioi-2019-01-20-solutions/</id>
    <published>2019-01-20T09:43:14.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。</p><p>上午记为D1，下午记为D2。</p><a id="more"></a><h3 id="D1"><a href="#D1" class="headerlink" title="D1"></a>D1</h3><h4 id="T1-简-simple"><a href="#T1-简-simple" class="headerlink" title="T1 简 - simple"></a>T1 简 - simple</h4><p>给你$2n$个数，让你配成$n$对数，每个数恰属于一对数，一对数的得分是其中的较小值，让你最大化得分和。</p><p>$n\leqslant 100000$。</p><p>不予置评。</p><h4 id="T2-单-single"><a href="#T2-单-single" class="headerlink" title="T2 单 - single"></a>T2 单 - single</h4><p>给你一棵树，每个点有点权$a_{i}$，$dist(u,v)$表示$u$到$v$的树上路径经过的边数。定义</p><script type="math/tex; mode=display">b_{u}=\sum_{i=1}^{n}dist(u,i)a_{i}</script><p>还会给你一个$\text{tp}$，$\text{tp}=0$时给你$\{a_{n}\}$让你求$\{b_{n}\}$，$\text{tp}=1$时给你$\{b_{n}\}$让你求$\{a_{n}\}$。多组数据。</p><p>$n\leqslant 100000,T\leqslant 5$。</p><p>$\text{tp}=0$时就是一个简单的树形DP。</p><p>$\text{tp}=1$……高斯消元？不是很会写而且$O(n^{3})$会T飞啊（</p><p>他给的题解我也没看懂（</p><p>我就打了$\text{tp}=0$的$30$分。</p><h4 id="T3-题-problem"><a href="#T3-题-problem" class="headerlink" title="T3 题 - problem"></a>T3 题 - problem</h4><p>有一个平面直角坐标系。一开始你在原点，每次移动可以从$(x,y)$移动到$(x+1,y)$，$(x-1,y)$，$(x,y+1)$，$(x,y-1)$。再给你一个无穷点集$S$，你只能停留在这个点集内的点上，问你恰好$n$步后回到原点的方案数。对$10^{9}+7$取模。</p><p>关于$S$，首先会给你一个$\text{tp}$，然后$S$如下定义</p><script type="math/tex; mode=display">S=\begin{cases}&\{(x,y)\mid x,y\in\mathbb{Z}\}\;\;&(\text{tp}=0)\\&\{(x,y)\mid x\in\mathbb{N},y=0\}&(\text{tp}=1)\\&\{(x,y)\mid xy=0\}&(\text{tp}=2)\\&\{(x,y)\mid x,y\in\mathbb{N}\}&(\text{tp}=3)\end{cases}</script><p>$n\leqslant 100000$，$n\equiv 0\pmod{2}$，$\text{tp}\in\{0,1,2,3\}$。特殊地，当$\text{tp}=2$时$n\leqslant 1000$。</p><p>四合一数论提答（</p><p>很明显，无论是$x$坐标上还是$y$坐标上，我们都需要移动偶数次。再加上$n$保证是偶数，我们可以将$n$除以$2$，然后走$2n$步。</p><p>$\text{tp}=0$时，我们枚举$2i$步沿$x$轴方向走，$2(n-i)$步沿$y$轴方向走。<br>我们可以将这抽象成一个序列，其中有$i$个$x+1/x-1$，$n-i$个$y+1/y-1$，总排列方案数就是$\cfrac{(2n)!}{i!i!(n-i)!(n-i)!}$。因此</p><script type="math/tex; mode=display">\text{Ans}=(2n)!\sum_{i=0}^{n}\cfrac{1}{i!i!(n-i)!(n-i)!}</script><p>$\text{tp}=1$直接卡特兰数。</p><p>$\text{tp}=2$比较特殊。因为我们不能离开坐标系，一旦我们离开了原点，我们必须要先走回原点，才能沿着另一个坐标轴的方向继续走。我们可以考虑两种不同的括号，不同种括号之间不能嵌套，然后问有多少个长度为$2n$的序列是匹配的。</p><p>如果说我们有连续一段一共$i$对同种括号，不难发现排列方案数是$\cfrac{(2i)!}{i!i!}$，于是我们就有了一个$O(n^{2})$的DP</p><script type="math/tex; mode=display">f[x]=\sum_{i=1}^{x}f[x-i]\cfrac{(2i)!}{i!i!}</script><p>其实如果改一下模数的话这个东西可以用NTT优化到$O(n\log n)$的。虽然现在这个样子MTT也能搞……但是我不会写（</p><p>$\text{tp}=3$大概是$\text{tp}=0$与$\text{tp}=1$的结合。枚举沿$x$轴方向走多少步，然后两个方向分别卡特兰，然后把两个序列合并起来。于是</p><script type="math/tex; mode=display">\begin{aligned}\text{Ans}&=\sum_{i=0}^{n}C_{2n}^{2i}C_{i}C_{n-i}\\&=\sum_{i=0}^{n}\cfrac{(2n)!}{(2i)!(2(n-i))!}\left(\cfrac{(2i)!}{i!i!}-\cfrac{(2i)!}{(i+1)!(i-1)!}\right)\left(\cfrac{(2(n-i))!}{(n-i)!(n-i)!}-\cfrac{(2(n-i))!}{(n-i+1)!(n-i-1)!}\right)\\&=(2n)!\sum_{i=0}^{n}\left(\cfrac{1}{i!i!}-\cfrac{1}{(i+1)!(i-1)!}\right)\left(\cfrac{1}{(n-i)!(n-i)!}-\cfrac{1}{(n-i+1)!(n-i-1)!}\right)\end{aligned}</script><p>于是愉快地$230$直接rank1（</p><p>话说wzx打了$240$分的啊……然而炸成$210$（</p><h3 id="D2"><a href="#D2" class="headerlink" title="D2"></a>D2</h3><h4 id="T1-印章-seal"><a href="#T1-印章-seal" class="headerlink" title="T1 印章 - seal"></a>T1 印章 - seal</h4><p>给你一张$n\times m$的纸，上面有些格子要印墨水。你有一个$r\times c$的印章，上面有些格子是凸起的可以印。纸和印章不可以旋转，不可以重复印同一个格子，不可以把墨水印到纸外面去。问是否可行。多组数据。</p><p>$n,m,r,c\leqslant 1000,T\leqslant 10$。</p><p>首先我们不难想出一个$O((n-r)(m-c)rc)$也就是差不多$O(n^{4})$的暴力。不过这样只有$60$分。当时我用了一个<code>bitset</code>瞎搞了一波把复杂度降到了$O(n^{3})$，然而……并没有什么用（</p><p>拿了$60$就跑（</p><h4 id="T2-多边形-polygon"><a href="#T2-多边形-polygon" class="headerlink" title="T2 多边形 - polygon"></a>T2 多边形 - polygon</h4><p>一个$0-n$边形被定义为一个正常的$n$边形。对于一个$k-n$边形，对于它最外层的每一条边，我们向外做$n$边形，得到一个$(k+1)-n$边形。</p><p>这是一个$0-4$边形</p><p><img src="/images/图片1.png" alt></p><p>这是一个$1-4$边形</p><p><img src="/images/图片2.png" alt></p><p>这是一个$2-4$边形</p><p><img src="/images/图片3.png" alt></p><p>给你一个$k-n$边形，问你它的生成树数量。对$998244353$取模。</p><p>$0\leqslant k\leqslant 10^{6},3\leqslant n\leqslant 10^{9}$。</p><p><img src="/images/TIM图片20181023195537.jpg" alt></p><p>告辞（</p><p>彻底放弃治疗（</p><h4 id="T3-扔球-ball"><a href="#T3-扔球-ball" class="headerlink" title="T3 扔球 - ball"></a>T3 扔球 - ball</h4><p>给你$n$个球和$n$个瓶子，编号从$1$到$n$。每个球只能扔到指定集合的瓶子里。对于每个球，把它指定集合里的瓶子按编号从小到大排序，然后依次往里面扔球。每次扔进去的概率是$p$，扔不进去就试下一个瓶子，试完所有瓶子一遍还是没扔进去就从头再来一遍直到扔进去为止。指定集合为空就跳过这个球。</p><p>所有球扔完之后，记$i$号球被扔进了$a_{i}$号瓶子，问你$\{a_{n}\}$的期望逆序对数量。四舍五入保留两位小数。</p><p>如果扔球时跳过了$i$号球，那么当做$a_{i}$不存在。</p><p>$n\leqslant 500000,0.4\leqslant p\leqslant 0.6$。记$i$号球的指定集合为$S_{i}$，$\Sigma|S_{i}|\leqslant 500000$。</p><p>从后往前扫，扫到$x$时枚举$a_{x}$的可能取值$y$，将答案累加上$a_{x}=y$的概率与$a_{x+1}$到$a_{n}$中小于$y$的数的数量的期望值的乘积。然后$a_{x}$到$a_{n}$中$y$的出现次数的期望值就是$a_{x+1}$到$a_{n}$中$y$的出现次数的期望值再加上$a_{x}=y$的概率。</p><p>套个树状数组就行。</p><p>但是等会，$a_{x}=y$的概率怎么算啊。</p><p>首先我们考虑集合中最小的那个数，把球扔进那个瓶子的概率应该是</p><script type="math/tex; mode=display">\begin{aligned}\lim_{n\rightarrow+\infty}\sum_{i=0}^{n}(1-p)^{i|S_{x}|}p&=p\cfrac{(1-p)^{(n+1)|S_{x}|}-1}{(1-p)^{|S_{x}|}-1}\\&=\cfrac{p}{1-(1-p)^{|S_{x}|}}\end{aligned}</script><p>那么第$2$小呢？首先我们第一次扔不能扔进去，所以首先需要乘个$1-p$，然后就和上面一样了。依次类推，扔进编号第$i$小的瓶子的概率为</p><script type="math/tex; mode=display">\cfrac{p(1-p)^{i-1}}{1-(1-p)^{|S_{x}|}}</script><p>最后总分只有$160$，被$190$分的wzx吊着打（</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天loli搞了上午下午连续两场模拟赛，于是来写一篇题解。&lt;/p&gt;
&lt;p&gt;上午记为D1，下午记为D2。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="loli" scheme="https://github.com/Challestend/tags/loli/"/>
    
      <category term="模拟赛" scheme="https://github.com/Challestend/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>「HEOI2016/TJOI2016」求和</title>
    <link href="https://github.com/Challestend/luogu-p4091-solution/"/>
    <id>https://github.com/Challestend/luogu-p4091-solution/</id>
    <published>2019-01-17T03:28:06.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4091" target="_blank" rel="noopener">传送门</a></p><p>感觉最近意志消沉啥也不想干，于是继续来颓blog（</p><a id="more"></a><p>仔细一推发现也不是什么很难的题，感觉几天前的自己就是个傻子（</p><p>首先我们知道如果$n\gt m$，$S(n,m)=0$。于是我们将原式写成</p><script type="math/tex; mode=display">\sum_{i=0}^{n}\sum_{j=0}^{n}2^{j}j!S(i,j)=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)</script><p>第二类斯特林数有一个通项公式，它长这样</p><script type="math/tex; mode=display">S(n,m)=\cfrac{1}{m!}\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>直观理解一下，$S(n,m)$说的是将$n$个有标号的小球放进$m$个无标号的盒子，且不允许空盒的方案数。我们令$F(n,m,k)$表示将$n$个有标号的小球放进$m$个有标号的盒子，且其中至少有$k$个空盒的方案数。不难发现</p><script type="math/tex; mode=display">F(n,m,k)=C(m,k)(m-k)^{n}</script><p>然后我们容斥一下，得到将$n$个有标号的小球放进$m$个有标号的盒子，且不允许空盒的方案数$G(n,m)$。不难发现</p><script type="math/tex; mode=display">G(n,m)=\sum_{i=0}^{m}(-1)^{i}F(n,m,i)=\sum_{i=0}^{m}(-1)^{i}C(m,i)(m-i)^{n}</script><p>因为$S(n,m)$的定义中要求盒子无标号，我们再除以盒子的排列方案$m!$即可。</p><p>然后我们继续推式子</p><script type="math/tex; mode=display">\begin{aligned}\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}S(i,j)&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}C(j,k)(j-k)^{i}\\&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\cfrac{1}{j!}\sum_{k=0}^{j}(-1)^{k}\cfrac{j!}{k!(j-k)!}(j-k)^{i}\\&=\sum_{j=0}^{n}2^{j}j!\sum_{i=0}^{n}\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}(j-k)^{i}\\&=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}\end{aligned}</script><p>我们看到右边就是一个等比数列求和，于是</p><script type="math/tex; mode=display">\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!(j-k)!}\sum_{i=0}^{n}(j-k)^{i}=\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}</script><p>定义</p><script type="math/tex; mode=display">F[i]=\cfrac{(-1)^{i}}{i!}</script><p>右边的等比数列求和比较麻烦，我们需要一些特判。</p><script type="math/tex; mode=display">G[i]=\begin{cases}&1&(i=0)\\&n+1&(i=1)\\&\cfrac{i^{n+1}-1}{i!(i-1)}\;\;&(i>1)\end{cases}</script><p>然后我们就有</p><script type="math/tex; mode=display">\sum_{j=0}^{n}2^{j}j!\sum_{k=0}^{j}\cfrac{(-1)^{k}}{k!}\cfrac{(j-k)^{n+1}-1}{(j-k)!(j-k-1)}=\sum_{j=0}^{n}2^{j}j!(F\times G)[j]</script><p>这么一想前几天的我还只会暴力二项式定理展开（</p><p><img src="/images/TIM图片20181209192946.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4091&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感觉最近意志消沉啥也不想干，于是继续来颓blog（&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="HEOI" scheme="https://github.com/Challestend/tags/HEOI/"/>
    
      <category term="NTT" scheme="https://github.com/Challestend/tags/NTT/"/>
    
      <category term="TJOI" scheme="https://github.com/Challestend/tags/TJOI/"/>
    
      <category term="2016" scheme="https://github.com/Challestend/tags/2016/"/>
    
  </entry>
  
  <entry>
    <title>有上下界的网络流问题与预留推进学习笔记</title>
    <link href="https://github.com/Challestend/something-about-network-flow-learning-notes/"/>
    <id>https://github.com/Challestend/something-about-network-flow-learning-notes/</id>
    <published>2019-01-14T13:18:08.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>感觉最近好颓啊（</p><p>这是一篇正在咕咕咕的blog。<br><a id="more"></a></p><h3 id="无源汇有上下界可行流"><a href="#无源汇有上下界可行流" class="headerlink" title="无源汇有上下界可行流"></a><a href="https://loj.ac/problem/115" target="_blank" rel="noopener">无源汇有上下界可行流</a></h3><p>我们发现，这道题中每条边的流量有一个下界。相比起我们以前做过的网络流题目，我们发现它们并不对流量下界作出要求，也就是说，下界都是$0$。一种简单的想法就是，将每条边的流量上界置为$\text{upper}(e)-\text{lower}(e)$，下界置为$0$。然后我们发现，这样做可能会导致流量不平衡，我们需要调整。令</p><script type="math/tex; mode=display">w(u)=\sum_{v\in V,(v,u)\in E}\text{lower}((v,u))-\sum_{v\in V,(u,v)\in E}\text{lower}((u,v))</script><ul><li>如果$w(u)=0$，说明我们不需要对点$u$做出调整。</li><li>如果$w(u)\gt 0$，说明调整上下界后，流入$u$的流量减少地要比流出$u$的流量多，我们就建立一个源点，从其向点$u$连一条流量上界为$w(u)$的边。</li><li>如果$w(u)\lt 0$，说明调整上下界后，流出$u$的流量减少地要比流入$u$的流量多，我们就建立一个汇点，从点$u$向其连一条流量上界为$-w(u)$的边。</li></ul><p>然后直接跑一边从源点到汇点的最大流即可。</p><p>需要注意的是我们额外向图中加入的边，加入它们的目的是为了平衡流量，易知，如果它们没有完全满载，就一定不能完全平衡原图的流量，此时问题无解。</p><p>否则，我们就已经构造出了一组可行解。</p><h3 id="有源汇有上下界最大流"><a href="#有源汇有上下界最大流" class="headerlink" title="有源汇有上下界最大流"></a><a href="https://loj.ac/problem/116" target="_blank" rel="noopener">有源汇有上下界最大流</a></h3><p>这道题与上面的区别在于限制了源点和汇点，并且要求求出最大流。</p><p>我们可以从汇点到源点连一条流量上界为$+\infty$的边，然后这整个网络就循环了，然后我们跑一遍无源汇有上下界可行流。</p><p>需要注意的是，我们毕竟只是求出了可行流，原图可能还并没有满载。因此，我们删去之前求解可行流时创建的超源和超汇，在原图的残余网络上再跑一边最大流，两次的流量之和就是问题的解。</p><p>当然，求解可行流时无解的话，整个问题无解。</p><h3 id="有源汇有上下界最小流"><a href="#有源汇有上下界最小流" class="headerlink" title="有源汇有上下界最小流"></a><a href="https://loj.ac/problem/117" target="_blank" rel="noopener">有源汇有上下界最小流</a></h3><p>还没看懂，先咕着。</p><h3 id="最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）"><a href="#最高标号预流推进（HLPP-Highest-Label-Preflow-Pushing？）" class="headerlink" title="最高标号预流推进（HLPP-Highest Label Preflow Pushing？）"></a><a href="https://loj.ac/problem/127" target="_blank" rel="noopener">最高标号预流推进（HLPP-Highest Label Preflow Pushing？）</a></h3><p>还没看懂，先咕着。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;感觉最近好颓啊（&lt;/p&gt;
&lt;p&gt;这是一篇正在咕咕咕的blog。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络流" scheme="https://github.com/Challestend/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最大流" scheme="https://github.com/Challestend/tags/%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
    
      <category term="预留推进" scheme="https://github.com/Challestend/tags/%E9%A2%84%E7%95%99%E6%8E%A8%E8%BF%9B/"/>
    
  </entry>
  
  <entry>
    <title>类欧几里得算法学习笔记</title>
    <link href="https://github.com/Challestend/similar-euclid-algorithm-learning-notes/"/>
    <id>https://github.com/Challestend/similar-euclid-algorithm-learning-notes/</id>
    <published>2019-01-10T05:37:33.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p>其实我也不知道这个算法的英文名是啥（</p><p>我就yy出来一个「Similar Euclid Algorithm」（</p><a id="more"></a><p>给你六个非负整数$n,a,b,c,k_{1},k_{2}$，你需要求出</p><script type="math/tex; mode=display">\sum_{i=0}^{n}i^{k_{1}}\lfloor\cfrac{ai+b}{c}\rfloor^{k_{2}}\pmod{1000000007}</script><p>$n,a,b,c\leqslant 10^{9}$，$k_{1}+k_{2}\leqslant 10$。</p><p><img src="https://i.loli.net/2019/01/10/5c36dbda14c92.jpg" alt></p><p>太难了，告辞（</p><p>所以我们现在来研究简单一点的。</p><p>给你四个非负整数$n,a,b,c$，你需要求出</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\g(n,a,b,c)&\equiv\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\pmod{998244353}\\h(n,a,b,c)&\equiv\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\pmod{998244353}\end{aligned}</script><p>$n,a,b,c\leqslant 10^{9}$，$10^{5}$组询问。</p><p><a href="https://www.luogu.org/problemnew/show/P5170" target="_blank" rel="noopener">传送门</a></p><p>于是我们开始愉快地推式子。首先我们暂不考虑取模，也就是下文中先用等号代替同余。</p><p>首先考虑$f(n,a,b,c)$，假设$a\geqslant c\vee b\geqslant c$</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)\\&=\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\\&=f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\end{aligned}</script><p>也就是说，我们只需要重点关注$a\lt c\wedge b\lt c$时的情况即可。我们令$m=\lfloor\cfrac{an+b}{c}\rfloor$，然后继续往下推</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\sum_{j=1}^{m}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\leqslant ai+b\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\geqslant cj+c-b\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\geqslant\cfrac{cj+c-b}{a}\right]\\\end{aligned}</script><p>然后我们发现，我们可能需要在$\cfrac{cj+c-b}{a}$周围来一个上取整，然而上取整并没有什么比较好的性质。</p><p>考虑转换一下思路。既然$cj+c\leqslant ai+b$，我们就有$cj+c\lt ai+b+1$，然后再往下</p><script type="math/tex; mode=display">\begin{aligned}f(n,a,b,c)&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[cj+c\lt ai+b+1\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[ai\gt cj+c-b-1\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]\\&=\sum_{j=0}^{m-1}\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\&=mn-\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\&=mn-f(m-1,c,c-b-1,a)\end{aligned}</script><p>然后我们看到，这个函数它递归了！</p><p>注意到$(a,b,c)$变成了$(c,c-b-1,a)$，虽然我不是很能理解，反正这个东西最多递归$\log a$次，时间复杂度就是$O(\log a)$了。</p><p>然后考虑$g(n,a,b,c)$。</p><p>$a\geqslant c\vee b\geqslant c$：</p><script type="math/tex; mode=display">\begin{aligned}g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\left(i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i^{2}\lfloor\cfrac{a}{c}\rfloor+i\lfloor\cfrac{b}{c}\rfloor\right)\\&=\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\\&=g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\end{aligned}</script><p>$a\lt c\wedge b\lt c$，当然$m$还是$\lfloor\cfrac{an+b}{c}\rfloor$：</p><script type="math/tex; mode=display">\begin{aligned}g(n,a,b,c)&=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor\\&=\sum_{i=0}^{n}\sum_{j=1}^{m}i\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m-1}i\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]\end{aligned}</script><p>我们可以把上面这个式子理解成$\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor$且$\leqslant n$的所有自然数之和，于是差分一下我们得到</p><script type="math/tex; mode=display">\begin{aligned}g(n,a,b,c)&=\sum_{j=0}^{m-1}\left(\cfrac{n(n+1)}{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)\\&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor^{2}-\cfrac{1}{2}\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor\\&=\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)\end{aligned}</script><p>我们看到这个函数调用了$h(n,a,b,c)$，我们接下来就来研究一下这个函数。</p><p>$a\geqslant c\vee b\geqslant c$：</p><script type="math/tex; mode=display">\begin{aligned}h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+i\lfloor\cfrac{a}{c}\rfloor+\lfloor\cfrac{b}{c}\rfloor\right)^{2}\\&=\sum_{i=0}^{n}\left(\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}+i^{2}\lfloor\cfrac{a}{c}\rfloor^{2}+\lfloor\cfrac{b}{c}\rfloor^{2}+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+2\lfloor\cfrac{b}{c}\rfloor\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+2i\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\right)\\&=\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor^{2}+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}\\&+2\lfloor\cfrac{a}{c}\rfloor\sum_{i=0}^{n}i\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+2\lfloor\cfrac{b}{c}\rfloor\sum_{i=0}^{n}\lfloor\cfrac{(a\operatorname{mod}c)i+(b\operatorname{mod}c)}{c}\rfloor+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\\&=h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\end{aligned}</script><p>您绝对想象不到上面这一坨子东西的$\TeX$源码长什么样（</p><p>$a\lt c\wedge b\lt c$：</p><script type="math/tex; mode=display">\begin{aligned}h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\&=\sum_{i=0}^{n}\sum_{j=1}^{m^{2}}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor^{2}\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[c^{2}j+c^{2}\lt a^{2}i^{2}+2abi+b^{2}+1\right]\\&=\sum_{i=0}^{n}\sum_{j=0}^{m^{2}-1}\left[i\gt\sqrt{\lfloor\cfrac{c^{2}j+c^{2}-2abi-b^{2}-1}{a^{2}}\rfloor}\right]\end{aligned}</script><p><img src="https://i.loli.net/2019/01/10/5c36e7ca7de6a.jpg" alt></p><p>然后我们发现推不下去了。</p><p>不过办法总是有的。首先我们有一个看起来没啥用的式子</p><script type="math/tex; mode=display">x^{2}=2\sum_{i=1}^{n}i-x</script><p>套进去</p><script type="math/tex; mode=display">\begin{aligned}h(n,a,b,c)&=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}\\&=\sum_{i=0}^{n}\left(2\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\lfloor\cfrac{ai+b}{c}\rfloor\right)\\&=2\sum_{i=0}^{n}\sum_{j=1}^{\lfloor\tfrac{ai+b}{c}\rfloor}j-\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor\\&=2\sum_{j=1}^{m}j\sum_{i=0}^{n}\left[j\leqslant\lfloor\cfrac{ai+b}{c}\rfloor\right]-f(n,a,b,c)\\&=2\sum_{j=0}^{m-1}(j+1)\sum_{i=0}^{n}\left[i\gt\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right]-f(n,a,b,c)\\&=2\sum_{j=0}^{m-1}(j+1)\left(n-\lfloor\cfrac{cj+c-b-1}{a}\rfloor\right)-f(n,a,b,c)\\&=m(m+1)n-2\sum_{j=0}^{m-1}j\lfloor\cfrac{cj+c-b-1}{a}\rfloor-2\sum_{j=0}^{m-1}\lfloor\cfrac{cj+c-b-1}{a}\rfloor-f(n,a,b,c)\\&=m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)\\\end{aligned}</script><p>然后我们看到它奇迹般地递归了！</p><p>我们来总结一下。</p><script type="math/tex; mode=display">f(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}&f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)}{2}\lfloor\cfrac{a}{c}\rfloor+(n+1)\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\&mn-f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)\end{cases}</script><script type="math/tex; mode=display">g(n,a,b,c)=\sum_{i=0}^{n}i\lfloor\cfrac{ai+b}{c}\rfloor=\begin{cases}&g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor+\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\&\cfrac{mn(n+1)}{2}-\cfrac{1}{2}h(m-1,c,c-b-1,a)-\cfrac{1}{2}f(m-1,c,c-b-1,a)&(a\lt c\wedge b\lt c)\end{cases}</script><script type="math/tex; mode=display">h(n,a,b,c)=\sum_{i=0}^{n}\lfloor\cfrac{ai+b}{c}\rfloor^{2}=\begin{cases}&h(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{a}{c}\rfloor g(n,a\operatorname{mod}c,b\operatorname{mod}c,c)+2\lfloor\cfrac{b}{c}\rfloor f(n,a\operatorname{mod}c,b\operatorname{mod}c,c)\\&+\cfrac{n(n+1)(2n+1)}{6}\lfloor\cfrac{a}{c}\rfloor^{2}+(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}+n(n+1)\lfloor\cfrac{a}{c}\rfloor\lfloor\cfrac{b}{c}\rfloor\;\;&(a\geqslant c\vee b\geqslant c)\\&m(m+1)n-2g(m-1,c,c-b-1,a)-2f(m-1,c,c-b-1,a)-f(n,a,b,c)&(a\lt c\wedge b\lt c)\end{cases}</script><p>但是还有一个细节，如果说$n=0$或$a=0$，我们需要直接特判，大概像这样：</p><script type="math/tex; mode=display">f(n,a,b,c)=\begin{cases}&\lfloor\cfrac{b}{c}\rfloor\;\;&(n=0)\\&(n+1)\lfloor\cfrac{b}{c}\rfloor&(a=0)\end{cases}</script><script type="math/tex; mode=display">g(n,a,b,c)=\begin{cases}&0\;\;&(n=0)\\&\cfrac{n(n+1)}{2}\lfloor\cfrac{b}{c}\rfloor&(a=0)\end{cases}</script><script type="math/tex; mode=display">h(n,a,b,c)=\begin{cases}&\lfloor\cfrac{b}{c}\rfloor^{2}&(n=0)\\&(n+1)\lfloor\cfrac{b}{c}\rfloor^{2}&(a=0)\end{cases}</script><p>另外写的时候注意三个函数值要套在结构体里一起算，不然还是会T。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,a,b,c,n,I2=<span class="number">499122177</span>,I6=<span class="number">166374059</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Query</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> f,g,h;</span><br><span class="line"></span><br><span class="line">    Query(re <span class="keyword">int</span> _f,re <span class="keyword">int</span> _g,re <span class="keyword">int</span> _h)&#123;</span><br><span class="line">        f=_f;</span><br><span class="line">        g=_g;</span><br><span class="line">        h=_h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Query <span class="title">query</span><span class="params">(re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c,re <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)&#123;</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(b,<span class="number">0</span>,<span class="number">1L</span>L*b*b%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a)&#123;</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod,<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod,<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">        re Query res=query(a%c,b%c,c,n);</span><br><span class="line">        a/=c,</span><br><span class="line">        b/=c;</span><br><span class="line">        <span class="keyword">return</span> Query(</span><br><span class="line">            (res.f+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*a%mod+<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod)%mod,</span><br><span class="line">            (res.g+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*I2%mod*b%mod)%mod,</span><br><span class="line">            (res.h+<span class="number">2L</span>L*a*res.g%mod+<span class="number">2L</span>L*b*res.f%mod</span><br><span class="line">                  +<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*(<span class="number">2</span>*n+<span class="number">1</span>)%mod*I6%mod*a%mod*a%mod</span><br><span class="line">                  +<span class="number">1L</span>L*(n+<span class="number">1</span>)*b%mod*b%mod+<span class="number">1L</span>L*n*(n+<span class="number">1</span>)%mod*a%mod*b%mod)%mod</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> m=(<span class="number">1L</span>L*a*n+b)/c;</span><br><span class="line">        re Query res=query(c,c-b<span class="number">-1</span>,a,m<span class="number">-1</span>);</span><br><span class="line">        re <span class="keyword">int</span> tmp=((<span class="number">1L</span>L*m*n%mod-res.f)%mod+mod)%mod;</span><br><span class="line">        <span class="keyword">return</span> Query(</span><br><span class="line">            tmp,</span><br><span class="line">            ((<span class="number">1L</span>L*m*n%mod*(n+<span class="number">1</span>)%mod-res.h-res.f)%mod+mod)*I2%mod,</span><br><span class="line">            ((<span class="number">1L</span>L*m*(m+<span class="number">1</span>)%mod*n%mod<span class="number">-2L</span>L*res.g%mod<span class="number">-2L</span>L*res.f%mod-tmp)%mod+mod)%mod</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(t);</span><br><span class="line">    <span class="keyword">for</span>(;t;--t)&#123;</span><br><span class="line">        cltstream::read(n);</span><br><span class="line">        cltstream::read(a);</span><br><span class="line">        cltstream::read(b);</span><br><span class="line">        cltstream::read(c);</span><br><span class="line">        Query ans=query(a,b,c,n);</span><br><span class="line">        cltstream::write(ans.f,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(ans.h,<span class="number">32</span>);</span><br><span class="line">        cltstream::write(ans.g,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，这个东西有什么用啊。</p><p><del>没啥用（</del></p><p>其他的模板题我就不举了，我们来看一下<a href="https://www.luogu.org/problemnew/show/P4433" target="_blank" rel="noopener">这样一道题</a>。</p><p>看到推平操作我们可以直接往珂朵莉树上想了。</p><p>那么对于被推平的一段区间，我们将其压成一个节点丢到珂朵莉树上，然后维护六个信息<code>l,r,L,R,a,b</code>，表示其对应原序列中的$[l,r]$这段区间，里面一共有$\sum_{i=L}^{R}ai\operatorname{mod}b$颗石头。注意这里的<code>l,r,L,R</code>一定不要搞混<del>，我就是因为这样WA了整整四遍（</del>。</p><p><del>这三个样例一定是故意的。</del></p><p>然后每次我们初始化一个节点的时候直接算出节点内的石头总数，像下面这样：</p><script type="math/tex; mode=display">\sum_{i=L}^{R}ai\operatorname{mod}b=\sum_{i=L}^{R}\left(ai-\lfloor\cfrac{ai}{b}\rfloor b\right)=\cfrac{(R+L)(R-L+1)}{2}-\sum_{i=0}^{R}\lfloor\cfrac{ai}{b}\rfloor b+\sum_{i=0}^{L-1}\lfloor\cfrac{ai}{b}\rfloor b</script><p>直接一波板子套上去。</p><p>还有就是，这么算的话中间量会爆<code>long long</code>，我们可以考虑用<code>__int128_t</code>来存。不过这个类型在本地一般是编译不了的，虽然说交到OJ上基本没问题。我们可以</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>然后把一些没必要用或者是不能用<code>__int128_t</code>的改成<code>signed</code>即可。</p><p>代码还是有必要贴一下的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _it std::set<span class="meta-string">&lt;node&gt;::iterator</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> int __int128_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">signed</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">signed</span> digit[<span class="number">50</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">simEuc</span><span class="params">(re <span class="keyword">int</span> n,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b,re <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n)</span><br><span class="line">        <span class="keyword">return</span> b/c;</span><br><span class="line">    <span class="keyword">if</span>(!a)</span><br><span class="line">        <span class="keyword">return</span> (n+<span class="number">1</span>)*(b/c);</span><br><span class="line">    <span class="keyword">if</span>(a&gt;=c||b&gt;=c)&#123;</span><br><span class="line">        re <span class="keyword">int</span> res=simEuc(n,a%c,b%c,c);</span><br><span class="line">        <span class="keyword">return</span> res+n*(n+<span class="number">1</span>)*(a/c)/<span class="number">2</span>+(n+<span class="number">1</span>)*(b/c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        re <span class="keyword">int</span> m=(a*n+b)/c;</span><br><span class="line">        <span class="keyword">return</span> m*n-simEuc(m<span class="number">-1</span>,c,c-b<span class="number">-1</span>,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,L,R,a,b,sum;</span><br><span class="line"></span><br><span class="line">    node(re <span class="keyword">int</span> _l,re <span class="keyword">int</span> _r,re <span class="keyword">int</span> _L,re <span class="keyword">int</span> _R,re <span class="keyword">int</span> _a,re <span class="keyword">int</span> _b)&#123;</span><br><span class="line">        l=_l;</span><br><span class="line">        r=_r;</span><br><span class="line">        L=_L;</span><br><span class="line">        R=_R;</span><br><span class="line">        a=_a;</span><br><span class="line">        b=_b;</span><br><span class="line">        sum=(R+L)*(R-L+<span class="number">1</span>)*a/<span class="number">2</span>-simEuc(R,a,<span class="number">0</span>,b)*b+simEuc(L<span class="number">-1</span>,a,<span class="number">0</span>,b)*b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;node&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(re node p1,re node p2)&#123;</span><br><span class="line">    <span class="keyword">return</span> p1.l&lt;p2.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> _<span class="function">it <span class="title">split</span><span class="params">(re <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    re _it it=s.lower_bound(node(pos,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span>(it!=s.end()&amp;&amp;it-&gt;l==pos)</span><br><span class="line">        <span class="keyword">return</span> it;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        --it;</span><br><span class="line">        re <span class="keyword">int</span> l=it-&gt;l,r=it-&gt;r,L=it-&gt;L,R=it-&gt;R,a=it-&gt;a,b=it-&gt;b;</span><br><span class="line">        s.erase(it);</span><br><span class="line">        s.insert(node(l,pos<span class="number">-1</span>,L,L+pos-l<span class="number">-1</span>,a,b));</span><br><span class="line">        <span class="keyword">return</span> s.insert(node(pos,r,L+pos-l,R,a,b)).first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">modifyStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r,re <span class="keyword">int</span> a,re <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    s.erase(itl,itr);</span><br><span class="line">    s.insert(node(l,r,<span class="number">1</span>,r-l+<span class="number">1</span>,a,b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">queryStone</span><span class="params">(re <span class="keyword">int</span> l,re <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    re _it itr=split(r+<span class="number">1</span>),itl=split(l);</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;itl!=itr;res+=itl-&gt;sum,++itl);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    s.insert(node(<span class="number">1</span>,n,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)&#123;</span><br><span class="line">        re <span class="keyword">int</span> opt,l,r,a,b;</span><br><span class="line">        cltstream::read(opt);</span><br><span class="line">        cltstream::read(l);</span><br><span class="line">        cltstream::read(r);</span><br><span class="line">        <span class="keyword">if</span>(opt==<span class="number">1</span>)&#123;</span><br><span class="line">            cltstream::read(a);</span><br><span class="line">            cltstream::read(b);</span><br><span class="line">            modifyStone(l,r,a,b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cltstream::write(queryStone(l,r),<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实我也不知道这个算法的英文名是啥（&lt;/p&gt;
&lt;p&gt;我就yy出来一个「Similar Euclid Algorithm」（&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://github.com/Challestend/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数论" scheme="https://github.com/Challestend/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="类欧几里得" scheme="https://github.com/Challestend/tags/%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>「HEOI2012」采花</title>
    <link href="https://github.com/Challestend/luogu-p4113-solution/"/>
    <id>https://github.com/Challestend/luogu-p4113-solution/</id>
    <published>2019-01-07T11:05:03.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4113" target="_blank" rel="noopener">传送门</a></p><p><a href="https://dftyem.github.io/2019/01/07/HEOI2012-采花/" target="_blank" rel="noopener">Taduro的题解</a></p><p>sto <strong>Taduro</strong> orz</p><a id="more"></a><p>首先，读完题一定有人要跳出来喊「莫队！」。</p><p><del>莫队！</del></p><p>然后再一看数据范围</p><blockquote><p>对于$100\%$的数据，$1\leqslant c\leqslant n,m\leqslant 2\times 10^{6}$。</p></blockquote><p><del>笑容逐渐消失。</del></p><p>然后根据数据范围，我们不难猜出正解是树状数组。然后问题来了<del>，树状数组什么时候有这种操作了</del>。</p><p>首先这个样例比较菜，我们手造一个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 6 2 4 2 3 6 2</span><br></pre></td></tr></table></figure><p>首先我们维护一个<code>nxt</code>数组，表示当前颜色下一次出现的位置，不存在的话就是$0$。上面的样例对应的<code>nxt</code>差不多长这样：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>nxt[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$7$</td><td style="text-align:center">$5$</td><td style="text-align:center">$0$</td><td style="text-align:center">$8$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><p>然后我们把所有询问离线下来，以左端点为第一关键字，右端点为第二关键字排一下序。维护一个指针，让它一直跟着当前询问的左端点走。一开始它在$1$。</p><p>然后我们还需要一个数组<code>ans</code>，对于每一种颜色，我们令<strong>其在指针所在位置及其之后的部分中第二次出现的位置</strong>的<code>ans</code>为$1$。</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><p>因为一种颜色第一次出现不会被统计，第二次出现才会被统计，在这之后就算再出现也不会多统计了。</p><p>不难发现，此时$\sum_{i=1}^{x}ans[i]$就是询问<code>1 x</code>的答案。</p><p>需要移动指针时，我们每次只移动一个位置。移动完之后，移动前指针所在位置的颜色第二次出现的位置就变成了第一次出现，因此我们需要将这个位置上的<code>ans</code>置为$0$。同理，第三次就变成了第二次，因此我们需要将其置为$1$。因为我们每次只移动一个位置，所以说只有一个颜色的状态会发生变化。</p><p>这个时候<code>nxt</code>数组就派上用场了，我们可以通过它块速地定位到当前颜色后面的出现位置。</p><p>让我们以上面的样例为例，稍微模拟一下指针的移动（下划线表示指针当前位置）：</p><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$\underline{1}$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$\underline{2}$</th><th style="text-align:center">$3$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$\underline{3}$</th><th style="text-align:center">$4$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">${\color{red}6}$</td><td style="text-align:center">$2$</td><td style="text-align:center">$4$</td><td style="text-align:center">$2$</td><td style="text-align:center">$3$</td><td style="text-align:center">${\color{red}6}$</td><td style="text-align:center">$2$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$1$</td><td style="text-align:center">$0$</td><td style="text-align:center">${\color{red}0}$</td><td style="text-align:center">$0$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center"><code>i</code></th><th style="text-align:center">$1$</th><th style="text-align:center">$2$</th><th style="text-align:center">$3$</th><th style="text-align:center">$\underline{4}$</th><th style="text-align:center">$5$</th><th style="text-align:center">$6$</th><th style="text-align:center">$7$</th><th style="text-align:center">$8$</th></tr></thead><tbody><tr><td style="text-align:center"><code>c[i]</code></td><td style="text-align:center">$1$</td><td style="text-align:center">$6$</td><td style="text-align:center">${\color{red}2}$</td><td style="text-align:center">$4$</td><td style="text-align:center">${\color{red}2}$</td><td style="text-align:center">$3$</td><td style="text-align:center">$6$</td><td style="text-align:center">${\color{red}2}$</td></tr><tr><td style="text-align:center"><code>ans[i]</code></td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">${\color{red}0}$</td><td style="text-align:center">$0$</td><td style="text-align:center">$0$</td><td style="text-align:center">${\color{red}1}$</td></tr></tbody></table></div><p>对于一次询问<code>l r</code>，我们将指针移动到<code>l</code>这个位置之后查询$\sum_{i=l}^{r}ans[i]$即可。</p><p>代码就不贴了<del>，其实我还没写（</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P4113&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dftyem.github.io/2019/01/07/HEOI2012-采花/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Taduro的题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;sto &lt;strong&gt;Taduro&lt;/strong&gt; orz&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="树状数组" scheme="https://github.com/Challestend/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="分块" scheme="https://github.com/Challestend/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="HEOI" scheme="https://github.com/Challestend/tags/HEOI/"/>
    
      <category term="2012" scheme="https://github.com/Challestend/tags/2012/"/>
    
      <category term="莫队" scheme="https://github.com/Challestend/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>「AHOI2017/HNOI2017」礼物</title>
    <link href="https://github.com/Challestend/luogu-p3723-solution/"/>
    <id>https://github.com/Challestend/luogu-p3723-solution/</id>
    <published>2019-01-04T03:14:12.000Z</published>
    <updated>2019-03-25T11:06:01.295Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3723" target="_blank" rel="noopener">传送门</a></p><a id="more"></a><p>首先我们要有一个简单粗暴的暴力。</p><script type="math/tex; mode=display">\min\limits_{x=0}^{n-1}\min\limits_{c_{1}=0,c_{2}=0}^{m}\sum\limits_{i=0}^{n-1}(A_{i}+c_{1}-B_{(i+x)\%n}-c_{2})^{2}</script><p>因为我们关心的只是两个数的差的平方，我们完全可以将$c_{1}$和$c_{2}$这两个非负整数合并成一个整数$c$。</p><script type="math/tex; mode=display">\min\limits_{x=0}^{n-1}\min\limits_{c=-m}^{m}\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}</script><p>我们仔细观察一下那个$\Sigma$。</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=0}^{n-1}(A_{i}-B_{(i+x)\%n}+c)^{2}\\=&\sum\limits_{i=0}^{n-1}(A_{i}^{2}+B_{(i+x)\%n}^{2}+c^{2}-2A_{i}B_{(i+x)\%n}+2cA_{i}-2cB_{(i+x)\%n})\\=&\sum\limits_{i=0}^{n-1}A_{i}^{2}+\sum\limits_{i=0}^{n-1}B_{i}^{2}+nc^{2}+2c(\sum\limits_{i=0}^{n-1}A_{i}-\sum\limits_{i=0}^{n-1}B_{i})-2\sum\limits_{i=0}^{n-1}A_{i}B_{(i+x)\%n}\end{aligned}</script><p>首先$\Sigma A_{i}^{2}$和$\Sigma B_{i}^{2}$可以看成是常数项。</p><p>$nc^{2}+2c(\Sigma A_{i}-\Sigma B_{i})$可以看成是一个关于$c$的二次函数，令$k=(\Sigma A_{i}-\Sigma B_{i})$，我们知道它在$c=-\cfrac{k}{n}$处取得最小值。但是根据题意，$c$应当是一个整数，因此我们需要将$c=\lfloor -\cfrac{k}{n}\rfloor$和$c=\lceil -\cfrac{k}{n}\rceil$两者都代入原式，然后取较小值。</p><p>然后我们想要求出$\Sigma A_{i}B_{(i+x)\%n}$的最大值，加上上面那两项就是最终答案了。首先这个取模不好搞，我们把它拆开。</p><script type="math/tex; mode=display">\sum\limits_{i=0}^{n-x-1}A_{i}B_{i+x}+\sum\limits_{i=0}^{x-1}A_{i-x+n}B_{i}</script><p>然后我们看到这个东西好像卷积啊，但是卷积要求两个下标加起来是常数，这个下标是加上一个数没办法卷积啊。</p><p>然后一想，我们可以倒过来搞啊。</p><p>定义$F^{R}(x)$是将$F(x)$的系数数组翻转过来得到的新多项式。于是我们可以将上式写成</p><script type="math/tex; mode=display">\begin{aligned}&\sum\limits_{i=0}^{n-x-1}A_{i}B^{R}_{n-x-1-i}+\sum\limits_{i=0}^{x-1}A^{R}_{x-1-i}B_{i}\\=&(AB^{R})_{n-x-1}+(A^{R}B)_{x-1}\end{aligned}</script><p>然后套一波多项式乘法的板子，扫一遍系数求个最大值就行了。需要注意的是当$x=0$的时候就只有$(AB^{R})_{n-1}$一项。</p><p>以下是代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 131072</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mod 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max(a,b) ((a)&gt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(a,b) ((a)&lt;=(b)?(a):(b))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(a,b) a^=b,b^=a,a^=b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cltstream&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> size 1048576</span></span><br><span class="line">    <span class="keyword">char</span> cltin[size+<span class="number">1</span>],*ih=cltin,*it=cltin;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">gc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> ONLINE_JUDGE</span></span><br><span class="line">            <span class="keyword">if</span>(ih==it)&#123;</span><br><span class="line">                it=(ih=cltin)+fread(cltin,<span class="number">1</span>,size,<span class="built_in">stdin</span>);</span><br><span class="line">                <span class="keyword">if</span>(ih==it)</span><br><span class="line">                    <span class="keyword">return</span> EOF;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> *ih++;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">return</span> getchar();</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> cltout[size+<span class="number">1</span>],*oh=cltout,*ot=cltout+size;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pc</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(oh==ot)&#123;</span><br><span class="line">            fwrite(cltout,<span class="number">1</span>,size,<span class="built_in">stdout</span>);</span><br><span class="line">            oh=cltout;</span><br><span class="line">        &#125;</span><br><span class="line">        *oh++=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> clop() fwrite(cltstream::cltout,1,cltstream::oh-cltstream::cltout,stdout),cltstream::oh=cltstream::cltout</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">undef</span> size</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(_tp&amp; x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sn=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span> c=gc();</span><br><span class="line">        <span class="keyword">for</span>(;c!=<span class="number">45</span>&amp;&amp;(c&lt;<span class="number">48</span>||c&gt;<span class="number">57</span>)&amp;&amp;c!=EOF;c=gc());</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="number">45</span>&amp;&amp;c!=EOF)</span><br><span class="line">            sn=<span class="number">-1</span>,c=gc();</span><br><span class="line">        <span class="keyword">for</span>(x=<span class="number">0</span>;c&gt;=<span class="number">48</span>&amp;&amp;c&lt;=<span class="number">57</span>&amp;&amp;c!=EOF;x=(x&lt;&lt;<span class="number">3</span>)+(x&lt;&lt;<span class="number">1</span>)+(c^<span class="number">48</span>),c=gc());</span><br><span class="line">        x*=sn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _tp&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(_tp x,<span class="keyword">char</span> text=<span class="number">-1</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>)</span><br><span class="line">            pc(<span class="number">45</span>),x=-x;</span><br><span class="line">        <span class="keyword">if</span>(!x)</span><br><span class="line">            pc(<span class="number">48</span>);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> digit[<span class="number">22</span>];</span><br><span class="line">            <span class="keyword">for</span>(digit[<span class="number">0</span>]=<span class="number">0</span>;x;digit[++digit[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">for</span>(;digit[<span class="number">0</span>];pc(digit[digit[<span class="number">0</span>]--]^<span class="number">48</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(text&gt;=<span class="number">0</span>)</span><br><span class="line">            pc(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,ans,k,mx;</span><br><span class="line"><span class="keyword">int</span> unit[<span class="number">2</span>][<span class="number">24</span>],rev[maxn+<span class="number">1</span>],A[maxn+<span class="number">1</span>],B[maxn+<span class="number">1</span>],C[maxn+<span class="number">1</span>],D[maxn+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">cltpow</span><span class="params">(re <span class="keyword">int</span> x,re <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    re <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1</span>)</span><br><span class="line">            res=<span class="number">1L</span>L*res*x%mod;</span><br><span class="line">        x=<span class="number">1L</span>L*x*x%mod;</span><br><span class="line">        y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(re <span class="keyword">int</span>* F,re <span class="keyword">int</span> n,re <span class="keyword">int</span> tp)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span>(i&lt;rev[i])</span><br><span class="line">            swap(F[i],F[rev[i]]);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> k=<span class="number">1</span>,p=<span class="number">1</span>;p&lt;n;++k,p&lt;&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i+=p&lt;&lt;<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(re <span class="keyword">int</span> j=i,tmp=<span class="number">1</span>;j&lt;i+p;++j,tmp=<span class="number">1L</span>L*tmp*unit[tp][k]%mod)&#123;</span><br><span class="line">                re <span class="keyword">int</span> x=F[j],y=<span class="number">1L</span>L*F[j+p]*tmp%mod;</span><br><span class="line">                F[j]=(x+y)%mod;</span><br><span class="line">                F[j+p]=(x-y+mod)%mod;</span><br><span class="line">            &#125;</span><br><span class="line">    re <span class="keyword">int</span> v=cltpow(n,tp*(mod<span class="number">-2</span>));</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        F[i]=<span class="number">1L</span>L*F[i]*v%mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cltstream::read(n);</span><br><span class="line">    cltstream::read(m);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(A[i]);</span><br><span class="line">        ans+=A[i]*A[i];</span><br><span class="line">        k+=A[i];</span><br><span class="line">        C[n<span class="number">-1</span>-i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">        cltstream::read(B[i]);</span><br><span class="line">        ans+=B[i]*B[i];</span><br><span class="line">        k-=B[i];</span><br><span class="line">        D[n<span class="number">-1</span>-i]=B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=min(n*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">floor</span>(<span class="number">1.0</span>*k/n),n*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n)<span class="number">-2</span>*k*<span class="built_in">ceil</span>(<span class="number">1.0</span>*k/n));</span><br><span class="line">    unit[<span class="number">0</span>][<span class="number">23</span>]=cltpow(<span class="number">3</span>,<span class="number">119</span>);</span><br><span class="line">    unit[<span class="number">1</span>][<span class="number">23</span>]=cltpow(<span class="number">332748118</span>,<span class="number">119</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;++i)</span><br><span class="line">        <span class="keyword">for</span>(re <span class="keyword">int</span> j=<span class="number">22</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            unit[i][j]=<span class="number">1L</span>L*unit[i][j+<span class="number">1</span>]*unit[i][j+<span class="number">1</span>]%mod;</span><br><span class="line">    <span class="keyword">for</span>(m=<span class="number">1</span>;m&lt;n;m&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">    m&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        rev[i]=(rev[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)?(m&gt;&gt;<span class="number">1</span>):<span class="number">0</span>);</span><br><span class="line">    NTT(A,m,<span class="number">0</span>);</span><br><span class="line">    NTT(B,m,<span class="number">0</span>);</span><br><span class="line">    NTT(C,m,<span class="number">0</span>);</span><br><span class="line">    NTT(D,m,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        A[i]=<span class="number">1L</span>L*A[i]*D[i]%mod;</span><br><span class="line">        B[i]=<span class="number">1L</span>L*B[i]*C[i]%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    NTT(A,m,<span class="number">1</span>);</span><br><span class="line">    NTT(B,m,<span class="number">1</span>);</span><br><span class="line">    mx=A[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(re <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        mx=max(mx,A[n<span class="number">-1</span>-i]+B[i<span class="number">-1</span>]);</span><br><span class="line">    cltstream::write(ans-=<span class="number">2</span>*mx);</span><br><span class="line">    clop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.luogu.org/problemnew/show/P3723&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://github.com/Challestend/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="NTT" scheme="https://github.com/Challestend/tags/NTT/"/>
    
      <category term="AHOI" scheme="https://github.com/Challestend/tags/AHOI/"/>
    
      <category term="HNOI" scheme="https://github.com/Challestend/tags/HNOI/"/>
    
      <category term="2017" scheme="https://github.com/Challestend/tags/2017/"/>
    
  </entry>
  
</feed>
